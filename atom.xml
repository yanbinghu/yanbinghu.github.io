<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>守望的个人博客</title>
  
  <subtitle>编程珠玑</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.yanbinghu.com/"/>
  <updated>2020-12-13T08:53:22.134Z</updated>
  <id>https://www.yanbinghu.com/</id>
  
  <author>
    <name>守望</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>scanf高级用法</title>
    <link href="https://www.yanbinghu.com/2020/12/12/46629.html"/>
    <id>https://www.yanbinghu.com/2020/12/12/46629.html</id>
    <published>2020-12-12T09:00:00.000Z</published>
    <updated>2020-12-13T08:53:22.134Z</updated>
    
    <content type="html"><![CDATA[<p>不知道你有没有看到过scanf下面这样的用法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">// 作者：守望先生</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%[0-9]"</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码什么意思呢？试一下几个输入输出：<br><a id="more"></a><br>示例0：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：13579</span><br><span class="line">输出：13579</span><br></pre></td></tr></table></figure></p><p>示例1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入:121abc</span><br><span class="line">输出:121</span><br></pre></td></tr></table></figure><p>示例2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入:shouwang123nb455</span><br><span class="line">输出:</span><br></pre></td></tr></table></figure></p><p>注意：这里输出不是123，如果想要输出123怎么办？请看后面丢弃特定字符部分。</p><p>看到这里，估计你已经看清套路了，没错，[0-9]表示scanf只读取0-9的字符，而如果遇到不在该范围内的字符，则停止，不再继续读取，就是前面我们看到的示例情况了。</p><h2 id="scanf的"><a href="#scanf的" class="headerlink" title="scanf的["></a>scanf的[</h2><p>scanf函数中，还有一个不常被人注意的，就是[了。它用来扫描特定的字符集。如果它以^开头，表示扫描除了字符集以外的所有字符，否则就是前面我们看到的，只扫描读取指定字符。</p><h2 id="scanf读取空字符"><a href="#scanf读取空字符" class="headerlink" title="scanf读取空字符"></a>scanf读取空字符</h2><p>我们都知道，scanf在读取内容的时候，会跳过空字符，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,s);</span><br></pre></td></tr></table></figure><p>假设输入为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bianchengzhuji</span><br></pre></td></tr></table></figure></p><p>那么输出将会是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bianchengzhuji</span><br></pre></td></tr></table></figure></p><p>注意，前面的空字符并没有读入到字符串s中，而是被跳过了。</p><p>那如果要读取空字符怎么办？很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scanf(&quot;%[^\n]&quot;,s);</span><br></pre></td></tr></table></figure></p><p>这里的意思就是说，除了换行符，其他字符都读入，也就是说前面的空字符也会被读取，就达到了我们的目的了。</p><h2 id="忽略开头的换行符"><a href="#忽略开头的换行符" class="headerlink" title="忽略开头的换行符"></a>忽略开头的换行符</h2><p>如果我们一开始就按回车，你会发现，s什么都没有读入，如何忽略开始的换行呢？像下面这样就可以了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">// 作者：守望先生</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%*[\n]%[^\n]"</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入输出示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入:[回车][回车]abc</span><br><span class="line">输出:abc</span><br></pre></td></tr></table></figure></p><p>输入时，按下两次回车，再输入其他字符，则最终会读取其他字符，而忽略开头的回车换行。我们知道，在scanf中，*是跳过相应的字符项，比如，跳过开头的两个数字：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">// 作者：守望先生</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> third = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%*d %*d %d"</span>,&amp;third);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,third);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">111 222 333</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">333</span><br></pre></td></tr></table></figure></p><p>scanf会跳过前面的111和222，则会读取333，<strong>这个功能在读取文件获取特定列内容的时候很有用</strong>。同理，在前面的例子中%*[\n]即表示跳过换行，<sup><a href="#fn_\\n" id="reffn_\\n">\\n</a></sup>则读取任意字符，直到遇到换行。</p><h2 id="丢弃特定字符"><a href="#丢弃特定字符" class="headerlink" title="丢弃特定字符"></a>丢弃特定字符</h2><p>最开始的例子中，如果开头是字母，即便想读取数字，也读取不到，那么如何跳过开头的字母呢？仿照刚刚讲的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">// 作者：守望先生</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%*[a-zA-Z]%[0-9]"</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样，开头的字母就会被丢弃。</p><h2 id="读取指定长度的任意字符"><a href="#读取指定长度的任意字符" class="headerlink" title="读取指定长度的任意字符"></a>读取指定长度的任意字符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char s[8] = &#123;0&#125;;</span><br><span class="line">scanf(&quot;%7s&quot;,s);</span><br></pre></td></tr></table></figure><p>输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcdefghij</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcdefg</span><br></pre></td></tr></table></figure></p><p>这样可以避免缓冲区溢出。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>scanf读取内容会跳过开头的空白字符，遇到换行符或者不是目标字符时结束读取。当然，你不是没有办法，今天所分享的就是办法。当然了，很多时候，你可能会选择使用fgets，getchar之类的函数，无妨。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">// 作者：守望先生</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcd1234</span><br></pre></td></tr></table></figure></p><p>输出会是什么？为什么？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知道你有没有看到过scanf下面这样的用法：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 来源：公众号【编程珠玑】&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 作者：守望先生&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; a[&lt;span class=&quot;number&quot;&gt;128&lt;/span&gt;] = &amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%[0-9]&quot;&lt;/span&gt;,a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%s\n&quot;&lt;/span&gt;,a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面的代码什么意思呢？试一下几个输入输出：&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="https://www.yanbinghu.com/categories/C/"/>
    
    
      <category term="C" scheme="https://www.yanbinghu.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>API设计原则-避免暴露数据成员</title>
    <link href="https://www.yanbinghu.com/2020/11/07/61329.html"/>
    <id>https://www.yanbinghu.com/2020/11/07/61329.html</id>
    <published>2020-11-07T08:00:00.000Z</published>
    <updated>2020-11-07T08:44:53.926Z</updated>
    
    <content type="html"><![CDATA[<p>之前在《<a href="http://www.yanbinghu.com/2020/11/06/3161.html">PIMPL-隐藏接口实现细节</a>》中介绍了一种隐藏类的私有成员的方法，或者说隐藏接口实现细节的方法-PIMPL。<br>假设提供的接口的入参比较复杂，可能有人会考虑使用结构体作为入参。当你考虑这么做的时候，灾难也将会随之而来……<br><a id="more"></a></p><h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">// 作者：守望先生</span></span><br><span class="line"><span class="comment">// api.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Param</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestFun</span><span class="params">(<span class="keyword">const</span> Param &amp;param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// api.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"api.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestFun</span><span class="params">(<span class="keyword">const</span> Param &amp;param)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"num:"</span>&lt;&lt;param.num&lt;&lt;<span class="string">" str:"</span>&lt;&lt;param.str.c_str()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设提供TestFun作为一个对外接口，我们编译并制作为静态库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -c api.cc -I./</span><br><span class="line">$ ar -rcs libapi.a api.o</span><br></pre></td></tr></table></figure></p><p>关于静态库的制作，请参考《<a href="https://www.yanbinghu.com/2019/07/10/23906.html">Linux下如何制作静态库？</a>》。</p><p>另外一个程序main.cc这么使用它：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来源：公众号编程珠玑</span></span><br><span class="line"><span class="comment">// 作者：守望先生</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"api.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Param param;</span><br><span class="line">    param.num = <span class="number">10</span>;</span><br><span class="line">    param.str = <span class="string">"24"</span>; </span><br><span class="line">    TestFun(param);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译链接使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -o main main.cc -L./ -lapi -I ./</span><br><span class="line">$ ./main</span><br></pre></td></tr></table></figure></p><p>看起来并没有什么问题，有新的参数，可以直接在Param中增加即可，扩展性也不错。</p><h2 id="问题来了"><a href="#问题来了" class="headerlink" title="问题来了"></a>问题来了</h2><p>目前来看是没有什么问题的，但是假设，还有另外一个库要使用它，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来源：公众号编程珠玑</span></span><br><span class="line"><span class="comment">// 作者：守望先生</span></span><br><span class="line"><span class="comment">// use_api.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"api.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseApi</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use_api.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"use_api.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseApi</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Param param;</span><br><span class="line">    param.num = <span class="number">10</span>;</span><br><span class="line">    param.str = <span class="string">"24"</span>; </span><br><span class="line">    TestFun(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也将它作为静态库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -c use_api.cc -I./</span><br><span class="line">$ ar -rcs libuse_api.a use_api.o</span><br></pre></td></tr></table></figure></p><p>这个时候同样主程序会用到我们的原始api，但是却使用了不同的版本，比如，新增了Param中新增了一个字段ext：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">// 作者：守望先生</span></span><br><span class="line"><span class="comment">// api.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Param</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> ext;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestFun</span><span class="params">(<span class="keyword">const</span> Param &amp;param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// api.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"api.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestFun</span><span class="params">(<span class="keyword">const</span> Param &amp;param)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"num:"</span>&lt;&lt;param.num&lt;&lt;<span class="string">" str:"</span>&lt;&lt;param.str.c_str()&lt;&lt;<span class="string">" ext:"</span>&lt;&lt;param.ext.c_str()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重新生成静态库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -c api.cc -I./</span><br><span class="line">$ ar -rcs libapi.a api.o</span><br></pre></td></tr></table></figure></p><p>这个时候，通过use_api使用api接口，但是链接新的库：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来源：公众号编程珠玑</span></span><br><span class="line"><span class="comment">// 作者：守望先生</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"use_api.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    UseApi();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个时候，再去编译链接，并运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -o main main.cc -I./ -L./ -luse_api -lapi</span><br><span class="line">$ ./main</span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure></p><p>看到没有，喜闻乐见的core dumped了，分析core还会发现，是由于访问非法地址导致的。</p><p>我们再来梳理一下这个过程：</p><ul><li>提供库libapi.a版本A</li><li>libuse_api使用版本A进行编译，使用A版本的头文件</li><li>libapi.a库升级到B版本，其中头文件中增加了字段，并且实现也引用了新的字段</li><li>主程序使用了use_api，但是链接了版本B的libapi.a库</li></ul><p>这个时候，版本B的实现访问了新的字段，还是use_api中还是使用A版本，并没有传入新字段，因此自然会导致非法访问。</p><h2 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h2><p>很简单，不直接暴露成员，而是提供setter和getter，而提供方式和前面提到的PIMPL方法类似。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// api.h</span></span><br><span class="line"><span class="comment">// 来源：公众号编程珠玑</span></span><br><span class="line"><span class="comment">// 作者：守望先生</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Param</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetNum</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetNum</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetStr</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;str)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GetStr</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetExt</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;str)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GetExt</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    Param();</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ParamImpl</span>;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ParamImpl&gt; param_impl_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestFun</span><span class="params">(<span class="keyword">const</span> Param &amp;param)</span></span>;</span><br></pre></td></tr></table></figure></p><p>在这里头文件中只提供setter和getter，而完全不暴露成员，具体成员的设置在ParamImpl中实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// api.cc</span></span><br><span class="line"><span class="comment">// 来源：公众号编程珠玑</span></span><br><span class="line"><span class="comment">// 作者：守望先生</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"api.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Param</span>:</span>:ParamImpl&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> ext;</span><br><span class="line">&#125;;</span><br><span class="line">Param::Param()&#123;</span><br><span class="line">    param_impl_.reset(<span class="keyword">new</span> ParamImpl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 析构函数必须要</span></span><br><span class="line">Param::~Param() = <span class="keyword">default</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Param::SetNum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    param_impl_-&gt;num = num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Param::GetNum</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  param_impl_-&gt;num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Param::SetStr</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;str)</span></span>&#123;</span><br><span class="line">    param_impl_-&gt;str = str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Param::SetExt</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;ext)</span></span>&#123;</span><br><span class="line">    param_impl_-&gt;ext = ext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">Param::GetStr</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> param_impl_-&gt;str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">Param::GetExt</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> param_impl_-&gt;ext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestFun</span><span class="params">(<span class="keyword">const</span> Param &amp;param)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"num:"</span>&lt;&lt;param.GetNum()&lt;&lt;<span class="string">" str:"</span>&lt;&lt;param.GetStr().c_str()&lt;&lt;<span class="string">"ext:"</span>&lt;&lt;param.GetExt().c_str()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过上面的方式，不会直接暴露成员函数，而是提供接口设置或者获取，而在实现中，即便出现新的版本增加了接口，最多也只是获取到默认值，而不会导致程序崩溃。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文和之前的文章实现方法是一样的，这样不暴露成员的做法，更大程度避免了链接库不一致导致的问题，你学会了吗？</p><p>源码地址：<a href="https://github.com/yanbinghu/examples/tree/main/api_impl" target="_blank" rel="noopener">源代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在《&lt;a href=&quot;http://www.yanbinghu.com/2020/11/06/3161.html&quot;&gt;PIMPL-隐藏接口实现细节&lt;/a&gt;》中介绍了一种隐藏类的私有成员的方法，或者说隐藏接口实现细节的方法-PIMPL。&lt;br&gt;假设提供的接口的入参比较复杂，可能有人会考虑使用结构体作为入参。当你考虑这么做的时候，灾难也将会随之而来……&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://www.yanbinghu.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="CPP" scheme="https://www.yanbinghu.com/tags/CPP/"/>
    
      <category term="设计模式" scheme="https://www.yanbinghu.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="api设计" scheme="https://www.yanbinghu.com/tags/api%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>PIMPL-隐藏接口实现细节</title>
    <link href="https://www.yanbinghu.com/2020/11/06/3161.html"/>
    <id>https://www.yanbinghu.com/2020/11/06/3161.html</id>
    <published>2020-11-06T08:00:00.000Z</published>
    <updated>2020-11-07T08:44:53.926Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有时候我们需要提供对外的API，通常会以头文件的形式提供。举个简单的例子：<br>提供一个从某个指定数开始打印的接口，<br><a id="more"></a><br>头文件内容如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来源：公众号编程珠玑</span></span><br><span class="line"><span class="comment">//作者：守望先生</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _TEST_API_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TEST_API_H</span></span><br><span class="line"><span class="comment">//test_api.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestApi</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    TestApi(<span class="keyword">int</span> s):start(s)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TestPrint</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> start_ = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//_TEST_API_H</span></span></span><br></pre></td></tr></table></figure></p><p>实现文件如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来源：公众号编程珠玑</span></span><br><span class="line"><span class="comment">//作者：守望先生</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test_api.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//test_api.cc</span></span><br><span class="line">TestApi::TestPrint(<span class="keyword">int</span> num)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = start_; i &lt; num; i++)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; i &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>类TestApi中有一个私有变量start_，头文件中是可以看到的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test_api.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  TestApi test_api&#123;<span class="number">10</span>&#125;;</span><br><span class="line">  test_api.TestPrint(<span class="number">15</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常规实现缺点"><a href="#常规实现缺点" class="headerlink" title="常规实现缺点"></a>常规实现缺点</h2><p>从前面的内容来看， 一切都还正常，但是有什么问题呢？</p><ul><li>头文件暴露了私有成员</li><li>实现与接口耦合</li><li>编译耦合</li></ul><p>第一点可以很明显的看出来，其中的私有变量start_能否在头文件中看到，如果实现越来越复杂，这里可能也会出现更多的私有变量。有人可能会问，私有变量外部也不能访问，暴露又何妨？</p><p>不过你只是提供几个接口，给别人看到这么多信息干啥呢？这样就会导致实现和接口耦合在了一起。</p><p>另外一方面，如果有另外一个库使用了这个库，而你的这个库实现变了，头文件就会变，而头文件一旦变动，就需要所有使用了这个库的程序都要重新编译！</p><p>这个代价是巨大的。</p><p>所以，我们应该尽可能地保证头文件不变动，或者说，尽可能隐藏实现，隐藏私有变量。</p><h2 id="PIMPL"><a href="#PIMPL" class="headerlink" title="PIMPL"></a>PIMPL</h2><p>Pointer to implementation，由指针指向实现，而不过多暴露细节。废话不多说，上代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来源：公众号编程珠玑</span></span><br><span class="line"><span class="comment">//作者：守望先生</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _TEST_API_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TEST_API_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="comment">//test_api.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestApi</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    TestApi(<span class="keyword">int</span> s);</span><br><span class="line">    ~TestApi();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TestPrint</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TestImpl</span>;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;TestImpl&gt; test_impl_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//_TEST_API_H</span></span></span><br></pre></td></tr></table></figure></p><p>从这个头文件中，我们可以看到：</p><ul><li>实现都在TestImpl中，因为只有一个私有的TestImpl变量，可以预见到，实现变化时，这个头文件是基本不需要动的</li><li>test<em>impl</em>是一个unique_ptr，因为我们使用的是现代C++，这里需要注意的一点是，它的构造函数和析构函数必须存在，否则会有编译问题。</li></ul><p>我们再来看下具体的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来源：公众号编程珠玑</span></span><br><span class="line"><span class="comment">//作者：守望先生</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test_api.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//test_api.cc</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestApi</span>:</span>:TestImpl&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TestPrint</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">    TestImpl(<span class="keyword">int</span> s):start_(s)&#123;&#125;</span><br><span class="line">    TestImpl() = <span class="keyword">default</span>;</span><br><span class="line">    ~TestImpl() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> start_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> TestApi::TestImpl::TestPrint(<span class="keyword">int</span> num)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = start_; i &lt; num; i++)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; i &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TestApi::TestApi(<span class="keyword">int</span> s)&#123;</span><br><span class="line">    test_impl_.reset(<span class="keyword">new</span> TestImpl(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestApi::TestPrint</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">  test_impl_-&gt;TestPrint(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意，析构函数需要</span></span><br><span class="line">TestApi::~TestApi() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure></p><p>从实现中看到，TestApi中的TestPrint调用了TestImpl中的TestPrint实现，而所有的具体实现细节和私有变量都在TestImpl中，即便实现变更了，其他库不需要重新编译，而仅仅是在生成可执行文件时重新链接。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从例子中，我们可以看到PIMPL模式中有以下优点：</p><ul><li>降低耦合，头文件稳定，类具体实现改变不影响其他模块的编译，只影响可执行程序的链接</li><li>接口和实现分离，提高稳定性</li></ul><p>当然了，由于实现在另外一个类中，所以会多一次调用，会有性能的损耗，但是这点几乎可以忽略。</p><p>代码地址：<a href="https://github.com/yanbinghu/examples/tree/main/pimpl" target="_blank" rel="noopener">源代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;有时候我们需要提供对外的API，通常会以头文件的形式提供。举个简单的例子：&lt;br&gt;提供一个从某个指定数开始打印的接口，&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://www.yanbinghu.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="CPP" scheme="https://www.yanbinghu.com/tags/CPP/"/>
    
      <category term="设计模式" scheme="https://www.yanbinghu.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="pimpl" scheme="https://www.yanbinghu.com/tags/pimpl/"/>
    
  </entry>
  
  <entry>
    <title>const修饰的变量无法被外部引用</title>
    <link href="https://www.yanbinghu.com/2020/11/01/37071.html"/>
    <id>https://www.yanbinghu.com/2020/11/01/37071.html</id>
    <published>2020-11-01T09:00:00.000Z</published>
    <updated>2020-11-07T08:24:32.591Z</updated>
    
    <content type="html"><![CDATA[<p> const变量能被其他文件extern引用吗？为什么？</p><p> 先来看一段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来源：公众号编程珠玑</span></span><br><span class="line"><span class="comment">// main.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 引用外部定义的const_int变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> const_int;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"const_int：%d\n"</span>,const_int);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// const.cc</span></span><br><span class="line"><span class="comment">// 定义const 变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> const_int  = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>编译链接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> $ g++ -o main main.cc const.cc</span><br><span class="line"> /tmp/ccWHAXxB.o: In function `main&apos;:</span><br><span class="line">main.cc:(.text+0x6): undefined reference to `const_int&apos;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><p>我们发现出现了链接问题，说const_int没有定义的引用，但我们确实在const.cc文件中定义了。</p><p>我们去掉const修饰符再编译一次，发现是可以的。从上面这个编译问题，就引出今天要讲的内容了。至于为什么会编译不过，最后再做解释。</p><p>当然你会发现，按照C代码去编译，是可以编译出来的。后面再解释。<br><a id="more"></a></p><h2 id="链接属性"><a href="#链接属性" class="headerlink" title="链接属性"></a>链接属性</h2><p>我们都知道，C/C++代码的编译通常经过预编译，汇编，编译，链接（参考<a href="https://www.yanbinghu.com/2018/10/10/27133.html">hello程序是怎么生成的</a>）通常会有变量会有三种链接属性：<em>外部链接，内部链接或无链接</em>。</p><p>具有函数作用域，块作用域或者函数原型作用域的变量都是无链接变量；具有文件作用域的变量可以是内部链接也可以是外部链接。而外部链接变量可以在多个文件中使用，内部链接变量只能在一个编译单元中使用（一个源代码文件和它包含的头文件）。</p><p>关于作用域，也可以参考《<a href="https://www.yanbinghu.com/2019/05/08/43402.html">全局变量，静态全局变量，局部变量，静态局部变量</a>》。<br> 说了这么多，举个具体的例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">// 作者：守望先生</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> external_link = <span class="number">10</span>;  <span class="comment">// 文件作用域，外部链接</span></span><br><span class="line"><span class="keyword">static</span> internal_link = <span class="number">20</span>; <span class="comment">// 文件作用域，内部链接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> no_link = <span class="number">30</span>;   <span class="comment">// 无链接</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d \n"</span>,external_link,internal_link,no_link);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里无链接变量还是比较好区分的，只要不是文件作用域的变量，基本是无链接属性。而文件作用域变量是内部链接还是外部链接呢？只要看前面是否有static修饰即可。当然对于C++，还要看是否有const修饰，后面我们再说。</p><h2 id="如何知道某个变量是什么链接属性？"><a href="#如何知道某个变量是什么链接属性？" class="headerlink" title="如何知道某个变量是什么链接属性？"></a>如何知道某个变量是什么链接属性？</h2><p>举个例子，在前面的代码中，我们按照C代码进行编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c const.c </span><br><span class="line">$ nm const.o |grep const_int</span><br><span class="line">0000000000000000 R const_int</span><br></pre></td></tr></table></figure></p><p> nm命令在《<a href="https://www.yanbinghu.com/2017/09/10/3456.html">linux常用命令-开发调试篇</a>》中略有介绍，它可以用来查看ELF文件的符号信息。</p><p>从这里的结果可以看到const_int前面是R修饰的，<br>R：该符号位于只读数据区，READONLY的含义</p><p>而<strong>该字母大写，其实也是表示它具有外部链接属性</strong>。</p><p>再看看按照C++代码编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -c const.c</span><br><span class="line">$ nm const.o |grep const_int</span><br><span class="line">0000000000000000 r _ZL9const_int</span><br></pre></td></tr></table></figure></p><p>可以看到，它的修饰符也是r，但是是小写的r，<strong>小写字母表示该变量具有内部链接属性</strong>。</p><p>nm命令非常实用，但本文不是重点。</p><h2 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h2><p> 说到const关键字，在《<a href="https://www.yanbinghu.com/2019/01/28/7442.html">const关键字到底该怎么用</a>》和《<a href="https://www.yanbinghu.com/2019/10/31/51504.html">C++中的const与C中的const有何差别？</a>》中已经分析过了，这里简单说一下，被const关键字修饰的变量，表明它是只读的，不希望被修改。</p><h2 id="extern关键字"><a href="#extern关键字" class="headerlink" title="extern关键字"></a>extern关键字</h2><p> extern关键字可以引用外部的定义，想必很多朋友已经很熟悉了，举个例子，如果把最开始的例子中的const关键字去掉，main.cc中的extern的意思，就是说有一个const_int变量，但是它在别的地方定义的，因此这里extern修饰一下，这样在链接阶段，它就会去其他的编译单元中找到它的定义，并链接。</p><p>当然，还有一个不太被关注的作用是，在C++中，它可以改变const变量的链接属性：</p><p>是的，在C++中，它改变了const_int的链接属性。我们可以修改const.c的内容如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> const_int  = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p><p> 然后再查看一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> $ nm const.o |grep const_int</span><br><span class="line">0000000000000000 R const_int</span><br></pre></td></tr></table></figure></p><p>发现没有，它前面的修饰变成大写的R了，所以这个时候，你再编译，就能编译过，而不会报错了，对于C，它本来就是外部链接属性，所以根本不会报错。</p><p>extern还有另外一个用法：<br>《<a href="https://www.yanbinghu.com/2019/08/25/29412.html">C++是如何调用C接口的</a>》？</p><h2 id="解疑"><a href="#解疑" class="headerlink" title="解疑"></a>解疑</h2><p>所以，链接报错的通常问题就是找不到定义，原因无非就是：</p><ul><li>未定义</li><li>在其他地方定义了，但是不具备外部链接属性</li><li>定义了，具备外部链接属性，但是链接顺序有问题</li></ul><p>由于在C++中，被const修饰的变量默认为内部链接属性，因为编译会找不到定义。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从一个编译问题，引出了很多内容，包括：</p><ul><li>作用域 —《<a href="https://www.yanbinghu.com/2019/05/08/43402.html">全局变量，静态全局变量，局部变量，静态局部变量</a>》</li><li>const关键字—《<a href="https://www.yanbinghu.com/2019/01/28/7442.html">const关键字到底该怎么用</a>》</li><li>extern关键字 </li><li>nm查看符号表</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; const变量能被其他文件extern引用吗？为什么？&lt;/p&gt;
&lt;p&gt; 先来看一段代码：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 来源：公众号编程珠玑&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// main.cc&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 引用外部定义的const_int变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; const_int;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;const_int：%d\n&quot;&lt;/span&gt;,const_int);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// const.cc&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 定义const 变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; const_int  = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;编译链接：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; $ g++ -o main main.cc const.cc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; /tmp/ccWHAXxB.o: In function `main&amp;apos;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;main.cc:(.text+0x6): undefined reference to `const_int&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;collect2: error: ld returned 1 exit status&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们发现出现了链接问题，说const_int没有定义的引用，但我们确实在const.cc文件中定义了。&lt;/p&gt;
&lt;p&gt;我们去掉const修饰符再编译一次，发现是可以的。从上面这个编译问题，就引出今天要讲的内容了。至于为什么会编译不过，最后再做解释。&lt;/p&gt;
&lt;p&gt;当然你会发现，按照C代码去编译，是可以编译出来的。后面再解释。&lt;br&gt;
    
    </summary>
    
      <category term="Cpp" scheme="https://www.yanbinghu.com/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://www.yanbinghu.com/tags/Cpp/"/>
    
      <category term="Linux" scheme="https://www.yanbinghu.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>daemon程序实现注意事项</title>
    <link href="https://www.yanbinghu.com/2020/10/06/45761.html"/>
    <id>https://www.yanbinghu.com/2020/10/06/45761.html</id>
    <published>2020-10-06T14:00:00.000Z</published>
    <updated>2020-10-09T14:23:30.178Z</updated>
    
    <content type="html"><![CDATA[<p>之前在《<a href="https://www.yanbinghu.com/2019/12/06/39731.html">如何让程序真正地后台运行</a>》一文中提到了程序后台运行的写法，但是里面的示例程序在某些场景下是会有问题的，这里先不说什么问题，我们先看看这个磁盘满的问题是怎么产生的，通过这篇文章你将会学习到大量linux命令的实操使用。</p><a id="more"></a><h2 id="找到导致磁盘满的程序"><a href="#找到导致磁盘满的程序" class="headerlink" title="找到导致磁盘满的程序"></a>找到导致磁盘满的程序</h2><p>当发现磁盘占用比较多的时候，可以通过下面的命令，查看各个挂载路径的占用情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> df -h</span></span><br><span class="line">udev            3.9G     0  3.9G    0% /dev</span><br><span class="line">tmpfs           784M  2.0M  782M    1% /run</span><br><span class="line">/dev/sda11       19G  6.5G   12G   37% /</span><br><span class="line">tmpfs           3.9G   91M  3.8G    3% /dev/shm</span><br><span class="line">tmpfs           5.0M  4.0K  5.0M    1% /run/lock</span><br><span class="line">tmpfs           3.9G     0  3.9G    0% /sys/fs/cgroup</span><br><span class="line">/dev/sda12      9.4G   37M  8.8G    1% /tmp</span><br><span class="line">/dev/sda14      6.4G  168M  5.9G    3% /boot</span><br><span class="line">/dev/sda10       57G  2.0G   52G    4% /home</span><br><span class="line">/dev/sda1       256M   33M  224M   13% /boot/efi</span><br><span class="line">tmpfs           784M   16K  784M    1% /run/user/121</span><br><span class="line">tmpfs           784M   44K  784M    1% /run/user/1000</span><br></pre></td></tr></table></figure><p>当然我这里并没有哪个挂载路径的磁盘占用率比较高，这里假设home占用比较高，然后可以通过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd /home</span><br><span class="line">$ du -h --max-depth=1</span><br><span class="line">1.9G./shouwang</span><br><span class="line">16K./lost+found</span><br><span class="line">1.9G.</span><br></pre></td></tr></table></figure><p>这样可以逐层知道哪些目录有了不该有的大文件。</p><p>当然你也可以使用find直接找出大文件，比如查找当前目录下大于800M的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -type f -size +800M</span><br></pre></td></tr></table></figure></p><p>find的用法可以参考《<a href="https://www.yanbinghu.com/2018/12/15/21083.html">find命令高级用法</a>》。</p><p>如果找到了该文件，并且确认是无用文件，那么就可以删除了。</p><p>但是如果<strong>仍然有程序打开了该文件，那么即便你删除了文件，其占用的磁盘空间也并不会释放</strong>，因为仍然它的”文件引用”不是0，文件并不会被删除。<br>在《<a href="https://www.yanbinghu.com/2020/05/10/50696.html">rm删除文件空间就释放了吗？</a>》一文中，有更加详细的解释。</p><p>所以你需要看一下，是否还有程序打开该文件，举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ lsof config.json</span><br><span class="line">COMMAND  PID     USER   FD   TYPE DEVICE SIZE/OFF    NODE NAME</span><br><span class="line">less    6750 shouwang    4r   REG   8,10      233 3411160 config.json</span><br></pre></td></tr></table></figure></p><p>从上面的结果，可以看到，是less程序打开了config.json文件，并且它的进程id是6750。</p><p>找到进程之后，根据实际情况决定是否需要停止程序，然后删除大文件。</p><h2 id="找不到大文件？"><a href="#找不到大文件？" class="headerlink" title="找不到大文件？"></a>找不到大文件？</h2><p>现实常常可能不如意，比如虽然可以通过df命令看到某些挂载路径磁盘占用率比较高，但是始终找不到大文件，那么你就要考虑，是不是大文件看似被删除了，但是还有程序打开。要找到这样的文件，其实也很简单，前面已经介绍过了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof |grep deleted</span><br></pre></td></tr></table></figure></p><p>lsof能看到被打开的文件，而如果文件被删除了（比如使用rm命令），但是仍然有程序打开，则会是deleted状态，举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ touch test.txt</span><br><span class="line">$ less test.txt</span><br></pre></td></tr></table></figure></p><p>创建一个文件test.txt，并随意输入一些内容，然后使用less命令打，随后在另一个终端，删除该文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rm test.txt</span><br><span class="line">$ lsof |grep test.txt |grep deleted</span><br><span class="line">less      6989              shouwang    4r      REG               8,10       134    3541262 /home/shouwang/workspaces/shell/testdeleted/test.txt (deleted)</span><br></pre></td></tr></table></figure></p><p>可以看到打开该文件的进程id为6989，我们看一下这个程序打开的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al /proc/6989/fd</span><br><span class="line">dr-x------ 2 shouwang shouwang  0 10月  6 10:57 .</span><br><span class="line">dr-xr-xr-x 9 shouwang shouwang  0 10月  6 10:56 ..</span><br><span class="line">lrwx------ 1 shouwang shouwang 64 10月  6 10:57 0 -&gt; /dev/pts/1</span><br><span class="line">lrwx------ 1 shouwang shouwang 64 10月  6 10:57 1 -&gt; /dev/pts/1</span><br><span class="line">lrwx------ 1 shouwang shouwang 64 10月  6 10:57 2 -&gt; /dev/pts/1</span><br><span class="line">lr-x------ 1 shouwang shouwang 64 10月  6 10:57 3 -&gt; /dev/tty</span><br><span class="line">lr-x------ 1 shouwang shouwang 64 10月  6 10:57 4 -&gt; &apos;/home/shouwang/workspaces/shell/testdeleted/test.txt (deleted)&apos;</span><br><span class="line">$ du -h</span><br></pre></td></tr></table></figure></p><p>（关于proc虚拟文件系统，可以参考《<a href="https://www.yanbinghu.com/2018/11/18/43716.html">Linux中不可错过的信息宝库</a>》）。从上面也可以看到，文件描述符4的文件为test.txt，但是deleted状态。</p><p>停止这个进程，你会发现所占用的磁盘空间会被释放。</p><h2 id="不完善的daemon实现"><a href="#不完善的daemon实现" class="headerlink" title="不完善的daemon实现"></a>不完善的daemon实现</h2><p>通常在终端启动一个程序后，文件描述符0，1，2通常对应标准输入，标准输出，标准错误。从前面的例子中也能窥见一二，它打开的是/dev/pts/1，其实就是当前终端。更多信息可以参考《<a href="https://www.yanbinghu.com/2018/10/26/9186.html">如何理解Linux shell中“2&gt;&amp;1”</a>》。</p><p>回到开始的问题，之前例子中daemonize的参考实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="comment">/*实现仅供参考，可根据实际情况调整*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daemonize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*清除文件权限掩码*/</span></span><br><span class="line">umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*父进程退出*/</span></span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">if</span>((pid=fork()) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*for 出错*/</span></span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> != pid)<span class="comment">/*父进程*/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"father exit\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*子进程，成为组长进程，并且摆脱终端*/</span></span><br><span class="line">setsid();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*修改工作目录*/</span></span><br><span class="line"><span class="keyword">if</span>(chdir(<span class="string">"/"</span>) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"change dir failed"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rl</span>;</span></span><br><span class="line"><span class="comment">/*先获取文件描述符最大值*/</span></span><br><span class="line"><span class="keyword">if</span>(getrlimit(RLIMIT_NOFILE,&amp;rl) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"get file decription failed"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果无限制，则设置为1024*/</span></span><br><span class="line"><span class="keyword">if</span>(rl.rlim_max == RLIM_INFINITY)</span><br><span class="line">rl.rlim_max = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*为了使得终端有输出，保留了文件描述符0，1，2;实际上父进程可能没有打开2以上的文件描述符*/</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">3</span>;i &lt; rl.rlim_max;i++)</span><br><span class="line">close(i);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span> == daemonize())</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"daemonize ok\n"</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"daemonize failed\n"</span>);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里注意到，daemonize函数最后关闭了2以上的文件描述符。</p><p>在其中一个终端运行上面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o daemon daemon.c  #编译</span><br><span class="line">$ ./daemon   #运行</span><br><span class="line">$ ls -al /proc/`pidof daemon`/fd  #查看打开的文件</span><br><span class="line">dr-x------ 2 shouwang shouwang  0 10月  6 11:26 .</span><br><span class="line">dr-xr-xr-x 9 shouwang shouwang  0 10月  6 11:26 ..</span><br><span class="line">lrwx------ 1 shouwang shouwang 64 10月  6 11:26 0 -&gt; /dev/pts/4</span><br><span class="line">lrwx------ 1 shouwang shouwang 64 10月  6 11:26 1 -&gt; /dev/pts/4</span><br><span class="line">lrwx------ 1 shouwang shouwang 64 10月  6 11:26 2 -&gt; /dev/pts/4</span><br></pre></td></tr></table></figure></p><p>可以看到0，1，2打开的是程序所在的终端，这时关闭该终端，在另外一个终端执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$  ls -al /proc/`pidof daemon`/fd </span><br><span class="line">lrwx------ 1 shouwang shouwang 64 10月  6 11:26 0 -&gt; &apos;/dev/pts/4 (deleted)&apos;</span><br><span class="line">lrwx------ 1 shouwang shouwang 64 10月  6 11:26 1 -&gt; &apos;/dev/pts/4 (deleted)&apos;</span><br><span class="line">lrwx------ 1 shouwang shouwang 64 10月  6 11:26 2 -&gt; &apos;/dev/pts/4 (deleted)&apos;</span><br></pre></td></tr></table></figure></p><p>发现0，1，2都是deleted状态了，因为关闭前面启动程序的终端后，也相当于删除了它标准输入输出和标准错误指向的文件。</p><p>实际上，到这里，都没有任何问题，程序中的printf打印最多无法打印出来而已。</p><p>但是，如果程序不是终端启动的呢？或者说没有终端的环境,比如crontab启动，at命令启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ at now &lt;&lt;&lt; “./daemon&quot;</span><br></pre></td></tr></table></figure></p><p>at命令表示当前时间执行daemon程序。<br>再看看它打开的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /proc/`pidof daemon`/fd</span><br><span class="line">lr-x------ 1 shouwang shouwang 64 10月  6 11:42 0 -&gt; &apos;/var/spool/cron/atjobs/a00001019765fe (deleted)&apos;</span><br><span class="line">lrwx------ 1 shouwang shouwang 64 10月  6 11:42 1 -&gt; &apos;/var/spool/cron/atspool/a00001019765fe (deleted)&apos;</span><br><span class="line">lrwx------ 1 shouwang shouwang 64 10月  6 11:42 2 -&gt; &apos;/var/spool/cron/atspool/a00001019765fe (deleted)&apos;</span><br></pre></td></tr></table></figure></p><p>看见没有，你会发现它打开了一些奇怪的文件。</p><h2 id="为什么会有这些奇怪的文件？"><a href="#为什么会有这些奇怪的文件？" class="headerlink" title="为什么会有这些奇怪的文件？"></a>为什么会有这些奇怪的文件？</h2><p>很明显，我们自己写的程序中并没有打开这样的文件，但是从文件名可以推断，它看能是cron程序打开的。那么怎么会变成daemon程序打开了呢？</p><p>这要从fork说起，之前在《<a href="https://www.yanbinghu.com/2019/08/11/28423.html">如何创建子进程？</a>》中说到过，fork出来的子进程会继承父进程的文件描述符，我们的daemon实现已经将2以上的描述符关闭了，但是并没有关闭0，1，2，而由于daemon程序自己实际上没有打开任何文件，0，1，2是空着的，实际上就变成了打开的是父进程曾经打开的文件。</p><p>但是由于printf持续向标准输出打印信息，即不断向描述符1打开的文件写入内容，而该文件又是deleted状态，最终可能会导致磁盘空间占用不断增大，但是又找不到实际的大文件。</p><p>为了验证我们的想法，可以看下前面的文件内容到底是什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ tail -5  /proc/`pidof daemon`/fd/1</span><br><span class="line">daemonize ok</span><br><span class="line">daemonize ok</span><br><span class="line">daemonize ok</span><br><span class="line">daemonize ok</span><br><span class="line">daemonize ok</span><br></pre></td></tr></table></figure></p><p>看到了吗，这既是我们程序的打印！<strong>竟然打印到一个毫无相关的文件中了</strong>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>从上面的例子可以看到，要想实现一个线上可用的daemon程序，还必须重定向标准输入，标准输出和标准错误，比例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* redirect stdin, stdout, and stderr to /dev/null */</span></span><br><span class="line">open(<span class="string">"/dev/null"</span>, O_RDONLY);</span><br><span class="line">open(<span class="string">"/dev/null"</span>, O_RDWR);</span><br><span class="line">open(<span class="string">"/dev/null"</span>, O_RDWR);</span><br></pre></td></tr></table></figure></p><p>如果我们不关心这些输入输出，则重定向到/dev/null，相当于丢弃该内容，关于/dev/null，这里有更多的介绍《<a href="https://www.yanbinghu.com/2019/11/20/49894.html">linux下这些特殊的文件</a>》。</p><p>是否要重定向标准输入输出，完全取决于你的实际应用场景，比如某些情况你可能就是需要将标准输出指向父进程的文件，则可以不需要重定向。当然了，<strong>至于实现，更推荐的做法是调用daemon函数</strong>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daemon</span><span class="params">(<span class="keyword">int</span> nochdir, <span class="keyword">int</span> noclose)</span></span>;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要涉及以下内容：</p><ul><li>查看各挂载路径空间占用情况 </li><li>查看目录空间占用情况</li><li>如何创建子进程—《<a href="https://www.yanbinghu.com/2019/08/11/28423.html">如何创建子进程？</a>》</li><li>标准输入，输出和标准错误—《<a href="https://www.yanbinghu.com/2018/10/26/9186.html">如何理解Linux shell中”2&gt;&amp;1”</a>》</li><li>查看进程打开文件信息—《<a href="https://www.yanbinghu.com/2019/03/05/61180.html">如何查看linux中文件打开情况</a>》</li><li>查找大文件—《<a href="https://www.yanbinghu.com/2018/12/15/21083.html">find命令高级用法</a>》</li><li>/dev/null特殊文件的用法 —《<a href="https://www.yanbinghu.com/2019/11/20/49894.html">linux下这些特殊的文件</a>》</li><li>查找被删除但仍有进程占用的文件</li><li>编写daemon程序注意事项</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在《&lt;a href=&quot;https://www.yanbinghu.com/2019/12/06/39731.html&quot;&gt;如何让程序真正地后台运行&lt;/a&gt;》一文中提到了程序后台运行的写法，但是里面的示例程序在某些场景下是会有问题的，这里先不说什么问题，我们先看看这个磁盘满的问题是怎么产生的，通过这篇文章你将会学习到大量linux命令的实操使用。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https://www.yanbinghu.com/categories/linux/"/>
    
    
      <category term="linux" scheme="https://www.yanbinghu.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>makefile入门</title>
    <link href="https://www.yanbinghu.com/2019/12/29/53040.html"/>
    <id>https://www.yanbinghu.com/2019/12/29/53040.html</id>
    <published>2019-12-29T12:00:00.000Z</published>
    <updated>2020-10-05T04:01:06.756Z</updated>
    
    <content type="html"><![CDATA[<p>作为Linux下的C/C++开发者，没接触过makefile一定说不过去，通常构建大型的C/C++项目都离不开makefile，也许你使用的是cmake或者其他类似的工具，但它们的本质都是类似的。</p><p>作为一个轻度使用者，应读者要求，斗胆介绍一下makefile，不过与普通的makfile教程不同的是，本文准备从另外一个角度来介绍。如有不妥之处，欢迎指出。<br><a id="more"></a></p><h2 id="makefie到底是什么"><a href="#makefie到底是什么" class="headerlink" title="makefie到底是什么"></a>makefie到底是什么</h2><p>在Linux下，对于下面这个简单的程序<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="built_in">pow</span>(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"10^4 = %d"</span>,c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们通常使用gcc就可以编译得到想要的程序了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o main main.c -lm</span><br></pre></td></tr></table></figure></p><p>（如果不理解为什么要加-lm，请参考《<a href="https://www.yanbinghu.com/2018/10/06/46212.html">一个奇怪的链接问题</a>》）。</p><p>对于单个文件的简单程序，一条命令就可以直接搞定了（编译+连接），但是如果是一个复杂的工程，可能有成千上万个文件，然后需要链接大量的动态或静态库。试想一下，你还想一条一条命令执行吗？<strong>懒惰的基因是刻在程序员骨子里的。</strong></p><p>因此你可能会想，那我写个脚本好了。嗯，听起来好多了。</p><p>文件多就多，你告诉我要编译哪里的文件，我遍历一下就好了，你再告诉我要链接哪些库，我一一帮你链接上就好了。</p><p>然而到这里又会想，既然编译链接都是这么类似的过程，能不能给它们写一些通用的规则，搞得这么复杂干嘛？然后按照规则去执行就好了。</p><p>而makefile就是这样的一个规则文件，make是规则的解释执行者。可以类比shell脚本和bash解释程序的关系。</p><p>所以，makefile并不仅仅用于编译链接，只不过它非常适合用于编译链接。</p><h2 id="makefile什么样？"><a href="#makefile什么样？" class="headerlink" title="makefile什么样？"></a>makefile什么样？</h2><p>它最重要的规则语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;target&gt; : &lt;prerequisites&gt; </span><br><span class="line">[tab]  &lt;commands&gt;</span><br></pre></td></tr></table></figure></p><p>咋一看，就这么个玩意？但是什么意思？</p><ul><li>target 要生成的目标文件名称</li><li><prerequisites> 要依赖的文件</prerequisites></li><li>[tab] 对，就是tab键，初学者很容易忽略这个问题，请用tab</li><li><commands> 要执行的指令</commands></li></ul><p>关键内容就这些，但是要细讲会有很多内容，本文仅举个简单的例子。假设要将前面的main.c复制名为pow.c的文件。<br>那么我们可以得到：</p><ul><li>target: pow.c 目标名称</li><li>prerequisites：main.c，即得到pow.c需要有main.c</li><li>commands：cp main.c pow.c</li></ul><p>因此我们得到我们的makefile文件内容如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">pow.c:main.c</span></span><br><span class="line">cp main.c pow.c</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm pow.c</span><br></pre></td></tr></table></figure></p><p>假设当前目录下没有main.c文件，然后在当前目录下执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make pow.c</span><br><span class="line">make: *** No rule to make target `main.c&apos;, needed by `pow.c&apos;.  Stop.</span><br></pre></td></tr></table></figure></p><p>我们发现会报错，因为你要依赖的文件找不到，而且也没有其他规则能够生成它。</p><p>现在把main.c放在当前目录下后继续执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make </span><br><span class="line">cp main.c pow.c</span><br></pre></td></tr></table></figure></p><p>看见没有，执行完make命令之后，我们的pow.c文件终于有了。</p><p>而执行下面的命令后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make clean</span><br><span class="line">rm pow.c</span><br></pre></td></tr></table></figure></p><p>你就会发现pow.c被删除了。</p><p>如果当前目录有clean文件会发生什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make clean</span><br><span class="line">make: `clean&apos; is up to date.</span><br></pre></td></tr></table></figure></p><p>至于原因，后面会讲到。</p><p>这里注意，如果你的makefile文件的文件名不是makefile，那么就需要指定具体名字，例如假设前面的文件名为test.txt：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make -f test.txt</span><br></pre></td></tr></table></figure></p><p>以上例子介绍了makefile使用的基本流程，生成目标，清除目标。然而实际上这里面的门道还有很多，例如伪目标，自动推导，隐晦规则，变量定义。本文作为认识性的文章暂时不具体介绍。</p><p>总结来说就是，给规则，按照规则生成目标。</p><h2 id="makefile做了什么？"><a href="#makefile做了什么？" class="headerlink" title="makefile做了什么？"></a>makefile做了什么？</h2><p>网上有很多教程介绍如何编写makefile的，很多也非常不错。不过本文换个角度来说。</p><p>既然我们要学makefile，那么就需要知道构建C/C++项目的时候，它应该做什么？然后再去学习如何编写makefile。</p><p>实际上它主要做的事情也很清楚，那就是编译和链接。这个在《<a href="https://www.yanbinghu.com/2018/10/10/27133.html">helo程序是如何编程可执行文件的</a>》中已经有所介绍，还不了解的朋友可以简单了解一下。那么放到makefile中具体要做什么呢？</p><ul><li>将源代码文件编译成可重定位目标文件.o（参考《<a href="https://www.yanbinghu.com/2019/06/27/47343.html">静态库和动态库的区别</a>》）</li><li>设置编译器选项，例如是否开启优化，传递宏，打开警告等</li><li>链接，将静态库或动态库与目标文件链接</li></ul><p>所以问题就变成了，如何利用makefile的语法规则快速的将成千上万的.c编译成.o，并且正确链接到需要的库。</p><p>而如果用makefile应该怎么写才能得到我们的程序呢？为了帮助说明，我们把前面的编译命令拆分为两条：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -g -Wall -c main.c -o main.o</span><br><span class="line">$ gcc -o main main.o -lm</span><br></pre></td></tr></table></figure></p><h4 id="设置编译器"><a href="#设置编译器" class="headerlink" title="设置编译器"></a>设置编译器</h4><p>由于我们使用的是gcc编译器（套件），因此可以像下面这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CC=gcc</span><br></pre></td></tr></table></figure></p><p>为了扩展性考虑，常常将编译器定义为某个变量，后面使用的时候就会方便很多。</p><h4 id="设置编译选项"><a href="#设置编译选项" class="headerlink" title="设置编译选项"></a>设置编译选项</h4><p>比如我们要设置-g选项用来调试，设置-Wall选项来输出更多警告信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS=-g -Wall</span><br></pre></td></tr></table></figure></p><h4 id="设置链接库"><a href="#设置链接库" class="headerlink" title="设置链接库"></a>设置链接库</h4><p>我们这里只用到了libm.so库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIBS=-lm</span><br></pre></td></tr></table></figure></p><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>我们的目标文件是main.o依赖main.c，该规则应该是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OBJ=main.o</span><br><span class="line">$(OBJ):main.c</span><br><span class="line">$(CC) $(CFLAGS) -c main.c -o $(OBJ)</span><br></pre></td></tr></table></figure></p><p>这样就得到了我们的目标文件。</p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>接下来就需要将目标文件和库文件链接在一起了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TARGET=main</span><br><span class="line">$(target):main.o</span><br><span class="line">$(CC) $(CFLAGS) -o $(TARGET) $(OBJ) $(LIBS)</span><br></pre></td></tr></table></figure></p><p>而为了使用make clean，即通常用于清除这些中间文件，因此需要加一个伪目标clean：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY:clean</span><br><span class="line">clean:</span><br><span class="line">rm $(OBJ) $(TARGET)</span><br></pre></td></tr></table></figure></p><p>伪目标的意思是，它不是一个真正的要生成的目标文件，.PHONY:clean说明了clean是一个伪目标。在这种情况下，即使当前目录下有clean文件，它也仍然会执行后面的指令。</p><p>否则如果当前目录下有clean文件，将不会执行rm动作，而认为目标文件已经是最新的了。</p><h4 id="完整内容"><a href="#完整内容" class="headerlink" title="完整内容"></a>完整内容</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">CFLAGS=-g -Wall</span><br><span class="line">LIBS=-lm</span><br><span class="line">OBJ=main.o</span><br><span class="line"><span class="variable">$(OBJ)</span>:main.c</span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c main.c -o <span class="variable">$(OBJ)</span></span><br><span class="line">TARGET=main</span><br><span class="line"><span class="variable">$(TARGET)</span>:main.o</span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJ)</span> <span class="variable">$(LIBS)</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm <span class="variable">$(OBJ)</span> <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure><p>可以看到，makefile文件中有三个目标，分别是main.o，main和clean，其中clean是一个伪目标。</p><p>注意，由于第一个目标是main.o，因此你单单执行make的时候，它只是会生成main.o而已，如果你再执行一次会发现它提示你说main.o已经是最新的了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">gcc -g -Wall -c main.c -o main.o</span><br><span class="line">$ make</span><br><span class="line">make: `main.o&apos; is up to date.</span><br></pre></td></tr></table></figure></p><p>为了得到main，我们执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ make main</span><br><span class="line">gcc -g -Wall -c main.c -o main.o</span><br><span class="line">gcc -g -Wall -o main main.o -lm</span><br><span class="line">$ ls </span><br><span class="line">main  main.c  main.o  makefile</span><br></pre></td></tr></table></figure></p><p>当然你也可以调整目标顺序。这里的目标文件main依赖的是main.o，它开始会去找main.o，发现这个文件也没有，就会看是不是有规则会生成main.o，欸，你还别说，真有。main.o又依赖main.c，也有，最终按照规则就会先生成main.o，然后生成mian。</p><p>如果要清除这些目标文件，那么可以执行make clean：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make clean</span><br><span class="line">rm main.o main</span><br><span class="line">$ ls </span><br><span class="line">main.c  makefile</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了两部分内容。</p><h4 id="makefile是什么东西"><a href="#makefile是什么东西" class="headerlink" title="makefile是什么东西"></a>makefile是什么东西</h4><p>它是一个规则文件，里面按照某种语法写好了，然后使用make来解释执行，就像shell脚本要用bash解释运行一样。通常会用makefile来构建C/C++项目。</p><h4 id="构建C-C-项目的makefile做了什么"><a href="#构建C-C-项目的makefile做了什么" class="headerlink" title="构建C/C++项目的makefile做了什么"></a>构建C/C++项目的makefile做了什么</h4><p>makefile主要做下面的事情（以C程序为例）</p><ul><li>用变量保存各种设置项，例如编译选项，编译器，宏，包含的头文件等</li><li>把.c编译成.o</li><li>把.o与库进行链接</li><li>清除生成的文件</li><li>安装程序</li></ul><p>其中最关键的事情就是编译链接，即想办法把.c变成.o（可重定位目标文件）;.o+.so（动态库）+.a（静态库）变成可执行文件。</p><p>对于文本提到的例子，看起来实在有些笨拙，一条指令搞定，却要写这么多行的makefile，但是它却指出了通常编写makefile的基本思路。</p><p>对于一个复杂的项目而言，makefile还有很多东西可介绍，例如如何设置变量，如何交叉编译，如何多个目录编译，如何自动推导，如何分支选择等等。这些都是后话了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为Linux下的C/C++开发者，没接触过makefile一定说不过去，通常构建大型的C/C++项目都离不开makefile，也许你使用的是cmake或者其他类似的工具，但它们的本质都是类似的。&lt;/p&gt;
&lt;p&gt;作为一个轻度使用者，应读者要求，斗胆介绍一下makefile，不过与普通的makfile教程不同的是，本文准备从另外一个角度来介绍。如有不妥之处，欢迎指出。&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="https://www.yanbinghu.com/categories/C/"/>
    
    
      <category term="C" scheme="https://www.yanbinghu.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>多线程一定更快吗</title>
    <link href="https://www.yanbinghu.com/2019/12/25/46016.html"/>
    <id>https://www.yanbinghu.com/2019/12/25/46016.html</id>
    <published>2019-12-25T14:00:00.000Z</published>
    <updated>2020-10-05T04:01:06.748Z</updated>
    
    <content type="html"><![CDATA[<p>在《<a href="https://www.yanbinghu.com/2019/12/23/52416.html">多线程排序</a>》中介绍了多线程排序，似乎看起来多线程快了很多，然而多线程就一定更快吗？<br><a id="more"></a></p><h2 id="为什么多线程就不一定快？"><a href="#为什么多线程就不一定快？" class="headerlink" title="为什么多线程就不一定快？"></a>为什么多线程就不一定快？</h2><p>还是拿《<a href="https://www.yanbinghu.com/2019/12/23/52416.html">多线程排序</a>》中的程序举例，下面是各个线程数量的排序结果:</p><div class="table-container"><table><thead><tr><th>线程数</th><th>时间/s</th></tr></thead><tbody><tr><td>1</td><td>2.393644</td></tr><tr><td>2</td><td>1.367392</td></tr><tr><td>3</td><td>1.386448</td></tr><tr><td>4</td><td>1.036919</td></tr><tr><td>5</td><td>1.097992</td></tr><tr><td>6</td><td>1.218000</td></tr><tr><td>7</td><td>1.184615</td></tr><tr><td>8</td><td>1.176258</td></tr></tbody></table></div><p>以上结果可能不准确，但是体现了一些变化趋势，即并不是线程数量越多越快，也不是单线程最快，而是线程数为4的时候最快。</p><p>为什么呢？</p><p>原因在于我的机器只有4个逻辑CPU，因此4是最合适的。为了不解释太多术语，简单解释一下。一个CPU就像一条流水线，会执行一系列指令，当你很多指定拆成4份（4线程）的时候，它是正好最合适的，少的时候，有一个闲着；而多了，就会存在抢占的情况。举个简单的例子，假设有4个水管可以出水，你现在去接水，那么你在每个水管下放一个桶去接水，自然要比只在一个水管下去接水要快的，但是如果你的水桶数量多于水管数，为了每个水桶都要有水，你在这个过程中就需要去切换水桶，每个水桶换一下，才能都接得上，<strong>而换的这个过程就像线程的上下文切换带来的开销</strong>。</p><p>因此，<strong>并不是线程越多越快，最合适的才最快。</strong></p><h2 id="单线程有时候反而更快"><a href="#单线程有时候反而更快" class="headerlink" title="单线程有时候反而更快"></a>单线程有时候反而更快</h2><p>说到这你可能更会奇怪了，为什么单线程有时候反而会更快呢？还是拿接水为例，假设虽然有4个水管，但是你只有一个桶，因此你一个人从这个水管里一直接水是最快的，而如果你拿两个桶，这个接一点，又换一下，那个接一点，又换一下，中间显然有中断，相同时间内单个桶接的比较多；这就是单核CPU妄图使用多线程提高效率或者每个线程都需要竞争同一把锁而实际可能会导致更慢的缘故。</p><p>举个绑核的例子：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> taskset -c 1 taskset -c 1 ./multiThread 4</span></span><br><span class="line">thread num:4</span><br><span class="line">time 2.378558</span><br></pre></td></tr></table></figure></p><p>我使用taskset将程序绑定在一个CPU上运行，可以看其时间足足是不绑核的时候的两倍有余。</p><p>什么叫都需要竞争呢？举个极端的例子，我们修改前面的工作线程代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*比较线程，采用快速排序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">workThread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    SortInfo *sortInfo = (SortInfo*)arg;</span><br><span class="line">    <span class="keyword">long</span> idx = sortInfo-&gt;startIdx;</span><br><span class="line">    <span class="keyword">long</span> num = sortInfo-&gt;num;</span><br><span class="line">    qsort(&amp;nums[idx],num,<span class="keyword">sizeof</span>(<span class="keyword">long</span>),compare);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    pthread_barrier_wait(&amp;b);</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的例子比较极端，在排序的时候都给它们加上了锁（关于锁，后面会有文章进行更加详细的介绍。），即哪个线程拿到了锁，就可以继续工作，没有拿到的继续等待。使用完成后再释放。<br>在这样的情况下，看看4线程还有效果吗？<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./multiThread 4</span></span><br><span class="line">thread num:4</span><br><span class="line">time 2.480588</span><br></pre></td></tr></table></figure></p><p>是最快的时候两倍多的时间！而且还比单个线程的时候要慢！！！</p><p>而另外一种情况，比如说从队列中取出数据，然后进行耗时处理，那么对取出数据的操作进行加锁是可行的，多线程的情况仍然能提高处理速度。但如果你仅仅是读取数据，那么单线程的情况可能会比多线程要快，<strong>因为它避免了线程上下文切换的开销</strong>。</p><h4 id="扩展介绍-绑核"><a href="#扩展介绍-绑核" class="headerlink" title="扩展介绍-绑核"></a>扩展介绍-绑核</h4><p>为什么要绑核？</p><ul><li>充分利用CPU，减少CPU之间上下文切换</li><li>指定程序运行在指定CPU，便于区分</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> taskset -c 1 ./proName</span></span><br></pre></td></tr></table></figure><p>将proName绑定在第二个核。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> taskset -c 1-3  ./proName</span></span><br></pre></td></tr></table></figure></p><p>绑定运行在第二个到第四个核。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> taskset -p 3569</span></span><br><span class="line">pid 3569's current affinity mask: f</span><br></pre></td></tr></table></figure><p>查看进程3569当前运行在哪个核上。</p><p>mask f转为二进制即为1111，因此四个核都有运行。</p><p>当然除了命令行，还有函数接口可以使用，这里就不再扩展了。</p><h2 id="如何查看机器的CPU数量"><a href="#如何查看机器的CPU数量" class="headerlink" title="如何查看机器的CPU数量"></a>如何查看机器的CPU数量</h2><p>物理CPU个数，就是你实际CPU的个数：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/cpuinfo | grep <span class="string">"physical id"</span> | sort -u | wc -l </span></span><br><span class="line">1</span><br></pre></td></tr></table></figure></p><p>CPU物理核数，就是你的一个CPU上有多少个核心，现在很多CPU都是多核：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/cpuinfo | grep <span class="string">"core id"</span> | sort -u | wc -l</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure></p><p> CPU逻辑核数，一颗物理CPU可以有多个物理内核，加上超线程技术，会让CPU看起来有很多个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/cpuinfo | grep &quot;processor&quot; | sort -u | wc -l</span><br><span class="line">4</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>线程上下文切换是有开销的，如果它的收益不能超过它的开销，那么使用多线程来提高效率将得不偿失</strong>。因此不要盲目推崇多线程。如果为了提高效率采用多线程，那么线程中最多应为逻辑CPU数。也就是说如果你的程序绑在一个核上或者你只有一个CPU一个核，那么采用多线程只能提高同时处理的能力，而不能提高处理效率。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在《&lt;a href=&quot;https://www.yanbinghu.com/2019/12/23/52416.html&quot;&gt;多线程排序&lt;/a&gt;》中介绍了多线程排序，似乎看起来多线程快了很多，然而多线程就一定更快吗？&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="https://www.yanbinghu.com/categories/C/"/>
    
    
      <category term="C" scheme="https://www.yanbinghu.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>多线程排序</title>
    <link href="https://www.yanbinghu.com/2019/12/23/52416.html"/>
    <id>https://www.yanbinghu.com/2019/12/23/52416.html</id>
    <published>2019-12-23T14:00:00.000Z</published>
    <updated>2020-10-05T04:01:06.748Z</updated>
    
    <content type="html"><![CDATA[<p>在《<a href="https://www.yanbinghu.com/2019/12/17/19410.html">系统编程-多线程</a>》中已经了解了多线程的一些特点，其中包括快！那么今天就来看看如何利用多线程来排序。<br><a id="more"></a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们的思路是这样的：</p><ul><li>假设有N个线程，则将数组数M据分为N组</li><li>每个线程对其中的一组数据使用库函数提供的快速排序算法</li><li>所有线程排序完成后，将每组排序好的数组合并</li></ul><p>举个例子，使用4个线程对11个数据进行排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12,10,4,7,9,6,8,1,5,16,11</span><br></pre></td></tr></table></figure></p><p>由于4不能被10整除，因此，前面三个线程，每个负责排序10%（4-1）= 3三个数，最后一个线程负责排序最后两个数。</p><div class="table-container"><table><thead><tr><th>线程0</th><th>线程1</th><th>线程2</th><th>线程3</th></tr></thead><tbody><tr><td>12,10,4</td><td>7,9,6</td><td>8,1,5</td><td>16,11</td></tr></tbody></table></div><p>假设这4个线程都完成了自己的工作后，内容如下：</p><div class="table-container"><table><thead><tr><th>线程0</th><th>线程1</th><th>线程2</th><th>线程3</th></tr></thead><tbody><tr><td>4,10,12</td><td>6,7,9</td><td>1,5,8</td><td>11,16</td></tr></tbody></table></div><p>最后由主线程将已经排好的每组进行合并：</p><ul><li>比较每组的第一个，选出最小的一个，这里是线程2的1，放到新数组的下标0处</li><li>将1放到新的数组最开始的位置，线程的下次计较的内容后移，即下次比较时，比较线程2的第二个数。</li><li>循环比较</li></ul><p>最终可以得到合并的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 4 5 6 7 8 9 10 11 12 16</span><br></pre></td></tr></table></figure></p><h2 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h2><p>通过上面的分析，我们需要多个线程进行排序后，一起交给主线程合并，因此需要有方法等待所有线程完成事情之后，再退出。<br>在《<a href="https://www.yanbinghu.com/2019/12/17/19410.html">系统编程-多线程</a>》中介绍了pthread_join，今天我们使用pthread_barrier_wait。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_destroy</span><span class="params">(<span class="keyword">pthread_barrier_t</span> *barrier)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_init</span><span class="params">(<span class="keyword">pthread_barrier_t</span> *<span class="keyword">restrict</span> barrier,</span></span></span><br><span class="line">const pthread_barrierattr_t *restrict attr, unsigned count)；</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_wait</span><span class="params">(<span class="keyword">pthread_barrier_t</span> *barrier)</span></span>;</span><br></pre></td></tr></table></figure></p><p>在解释之前说明一下基本原理，pthread_barrier_wait等待某一个条件达到（计数到达），一旦达到后就会继续往后执行。当然了，如果你希望各个线程完成它自己的工作，主线程再进行合并动作，则你等待的数量可以再加一个。：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//https://www.yanbinghu.com</span></span><br><span class="line"><span class="comment">//barrier.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pthread_barrier_t</span> b;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">workThread</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread %d\n"</span>,*(<span class="keyword">int</span>*)arg);</span><br><span class="line">    pthread_barrier_wait(&amp;b);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> threadNum = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="comment">/*计数为创建线程数+1*/</span></span><br><span class="line">    pthread_barrier_init(&amp;b,<span class="literal">NULL</span>,threadNum + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="comment">/*创建多个线程*/</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; threadNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        err = pthread_create(&amp;tid,<span class="literal">NULL</span>,workThread,(<span class="keyword">void</span>*)&amp;i);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> != err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"create thread failed\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"tid:%ld\n"</span>,tid);</span><br><span class="line">        usleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_barrier_wait(&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"all thread finished\n"</span>);</span><br><span class="line">    <span class="comment">/*销毁*/</span></span><br><span class="line">    pthread_barrier_destroy(&amp;b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中，pthread_barrier_init用来初始化相关资源，而pthread_barrier_destroy用来销毁相关资源。<br>编译运行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -o barrier barrier.c  -lpthread</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./barrier</span></span><br><span class="line">tid:140323085256448</span><br><span class="line">thread 0</span><br><span class="line">tid:140323076863744</span><br><span class="line">thread 1</span><br><span class="line">tid:140323068471040</span><br><span class="line">thread 2</span><br><span class="line">tid:140323060078336</span><br><span class="line">thread 3</span><br><span class="line">all thread finished</span><br></pre></td></tr></table></figure></p><h2 id="比较函数"><a href="#比较函数" class="headerlink" title="比较函数"></a>比较函数</h2><p>为了使用qsort函数，我们需要实现自己的比较函数，参考《<a href="https://www.yanbinghu.com/2019/01/03/3593.html">高级指针话题-函数指针</a>》：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//https:www.yanbinghu.com</span></span><br><span class="line"><span class="comment">/*比较函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* num1, <span class="keyword">const</span> <span class="keyword">void</span>* num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> l1 = *(<span class="keyword">long</span>*)num1;</span><br><span class="line">    <span class="keyword">long</span> l2 = *(<span class="keyword">long</span>*)num2;</span><br><span class="line">    <span class="keyword">if</span>(l1 == l2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l1 &lt; l2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>对于每个线程完成它自己的任务之后，需要合并所有内容，关于合并的逻辑前面已经举例了，这里不再多介绍。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//https://www.yanbinghu.com</span></span><br><span class="line"><span class="comment">/*要排序的数组信息*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SortInfo_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> startIdx; <span class="comment">//数组启始下标</span></span><br><span class="line">    <span class="keyword">long</span> num;<span class="comment">//要排序的数量</span></span><br><span class="line">&#125;SortInfo;</span><br><span class="line"><span class="comment">/*合并线程已经排序好的内容*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(SortInfo *sortInfos,<span class="keyword">size_t</span> threadNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> idx[threadNum];</span><br><span class="line">    <span class="built_in">memset</span>(idx,<span class="number">0</span>,threadNum);</span><br><span class="line">    <span class="keyword">long</span> i,minidx,sidx,num;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; threadNum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        idx[i] = sortInfos[i].startIdx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(sidx = <span class="number">0</span>;sidx &lt; NUM;sidx++)</span><br><span class="line">    &#123;</span><br><span class="line">        num = LONG_MAX;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; threadNum;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(idx[i] &lt; (sortInfos[i].startIdx + sortInfos[i].num) &amp;&amp; (nums[idx[i]] &lt; num))</span><br><span class="line">            &#123;</span><br><span class="line">                num = nums[idx[i]];</span><br><span class="line">                minidx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        snums[sidx] = nums[idx[minidx]];</span><br><span class="line">        idx[minidx]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h2><p>关于生成方法，参考《<a href="https://www.yanbinghu.com/2019/12/22/6131.html">随机数生成的N种姿势</a>》。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">https://www.yanbinghu.com</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 8000000L</span></span><br><span class="line"><span class="keyword">long</span> nums[NUM];</span><br><span class="line"><span class="keyword">long</span> snums[NUM];</span><br><span class="line"><span class="keyword">pthread_barrier_t</span> b;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">/*比较函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* num1, <span class="keyword">const</span> <span class="keyword">void</span>* num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> l1 = *(<span class="keyword">long</span>*)num1;</span><br><span class="line">    <span class="keyword">long</span> l2 = *(<span class="keyword">long</span>*)num2;</span><br><span class="line">    <span class="keyword">if</span>(l1 == l2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l1 &lt; l2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*要排序的数组信息*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SortInfo_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> startIdx; <span class="comment">//数组启始下标</span></span><br><span class="line">    <span class="keyword">long</span> num;<span class="comment">//要排序的数量</span></span><br><span class="line">&#125;SortInfo;</span><br><span class="line"><span class="comment">/*比较线程，采用快速排序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">workThread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    SortInfo *sortInfo = (SortInfo*)arg;</span><br><span class="line">    <span class="keyword">long</span> idx = sortInfo-&gt;startIdx;</span><br><span class="line">    <span class="keyword">long</span> num = sortInfo-&gt;num;</span><br><span class="line">    qsort(&amp;nums[idx],num,<span class="keyword">sizeof</span>(<span class="keyword">long</span>),compare);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    pthread_barrier_wait(&amp;b);</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*合并线程已经排序好的内容*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(SortInfo *sortInfos,<span class="keyword">size_t</span> threadNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> idx[threadNum];</span><br><span class="line">    <span class="built_in">memset</span>(idx,<span class="number">0</span>,threadNum);</span><br><span class="line">    <span class="keyword">long</span> i,minidx,sidx,num;</span><br><span class="line">    <span class="comment">/*记录索引信息*/</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; threadNum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        idx[i] = sortInfos[i].startIdx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*遍历各个数据，已经比较过后，比较下标增加*/</span></span><br><span class="line">    <span class="keyword">for</span>(sidx = <span class="number">0</span>;sidx &lt; NUM;sidx++)</span><br><span class="line">    &#123;</span><br><span class="line">        num = LONG_MAX;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; threadNum;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(idx[i] &lt; (sortInfos[i].startIdx + sortInfos[i].num) &amp;&amp; (nums[idx[i]] &lt; num))</span><br><span class="line">            &#123;</span><br><span class="line">                num = nums[idx[i]];</span><br><span class="line">                minidx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        snums[sidx] = nums[idx[minidx]];</span><br><span class="line">        idx[minidx]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*记录耗费时间*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">start</span>,<span class="title">end</span>;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> startusec,endusec;</span><br><span class="line">    <span class="keyword">double</span> elapsed;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;<span class="comment">/*线程id*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> perThreadNum;</span><br><span class="line">    <span class="keyword">long</span> lastThreadNum;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*获取线程数量，默认为1*/</span></span><br><span class="line">    <span class="keyword">size_t</span> threadNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">1</span>)</span><br><span class="line">        threadNum = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == threadNum)</span><br><span class="line">        threadNum = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread num:%zu\n"</span>,threadNum);</span><br><span class="line">    SortInfo *sortInfos = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SortInfo)*threadNum);</span><br><span class="line">    <span class="built_in">memset</span>(sortInfos,<span class="number">0</span>,<span class="keyword">sizeof</span>(SortInfo)*threadNum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*生成随机数组*/</span></span><br><span class="line">    srandom(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; NUM;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[i] = random();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*如果不能整除，调整最后一个线程处理的数据量*/</span></span><br><span class="line">    <span class="keyword">long</span> PER_THREAD_NUM = NUM / threadNum;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> != NUM % threadNum)</span><br><span class="line">    &#123;</span><br><span class="line">        perThreadNum = NUM / (threadNum - <span class="number">1</span>);</span><br><span class="line">        lastThreadNum = NUM % (threadNum - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        perThreadNum = PER_THREAD_NUM;</span><br><span class="line">        lastThreadNum = PER_THREAD_NUM; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;start,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_barrier_init(&amp;b,<span class="literal">NULL</span>,threadNum + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/*创建线程，并进行排序，传入要排序的部分*/</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; threadNum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sortInfos[i].startIdx = i*perThreadNum;</span><br><span class="line">        sortInfos[i].num = perThreadNum;</span><br><span class="line">        <span class="keyword">if</span>(i == threadNum - <span class="number">1</span>)</span><br><span class="line">           sortInfos[i].num = lastThreadNum; </span><br><span class="line">        err = pthread_create(&amp;tid,<span class="literal">NULL</span>,workThread,(<span class="keyword">void</span>*)(&amp;sortInfos[i]));</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> != err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"create failed\n"</span>);</span><br><span class="line">            <span class="built_in">free</span>(sortInfos);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_barrier_wait(&amp;b);</span><br><span class="line">    pthread_barrier_destroy(&amp;b);</span><br><span class="line">    <span class="comment">/*合并*/</span></span><br><span class="line">    merge(&amp;sortInfos[<span class="number">0</span>],threadNum);</span><br><span class="line">    gettimeofday(&amp;end,<span class="literal">NULL</span>);</span><br><span class="line">    startusec = start.tv_sec * <span class="number">1000000</span> + start.tv_usec;</span><br><span class="line">    endusec = end.tv_sec * <span class="number">1000000</span> + end.tv_usec;</span><br><span class="line">    elapsed = (<span class="keyword">double</span>)(endusec - startusec)/<span class="number">1000000.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"time %f\n"</span>,elapsed);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NUM;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf("%ld\n",snums[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(sortInfos);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或阅读原文查看。</p><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>对800W数据进行排序，排序时间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ threadSort 1</span><br><span class="line">thread num:1</span><br><span class="line">time 2.369488</span><br></pre></td></tr></table></figure></p><p>使用4个线程时：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ threadSort <span class="number">4</span></span><br><span class="line">thread num:<span class="number">4</span></span><br><span class="line">time <span class="number">1.029097</span></span><br></pre></td></tr></table></figure></p><p>可以看到速度提升是比较明显的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以看到使用4线程排序要比单个线程排序快很多，不过以上实现仅供参考，本文例子可能也存在不妥之处，请根据实际数据情况选择合适的排序算法。但是，多线程就一定快吗？敬请关注下一篇。</p><p>参考：《unix环境高级编程》</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在《&lt;a href=&quot;https://www.yanbinghu.com/2019/12/17/19410.html&quot;&gt;系统编程-多线程&lt;/a&gt;》中已经了解了多线程的一些特点，其中包括快！那么今天就来看看如何利用多线程来排序。&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="https://www.yanbinghu.com/categories/C/"/>
    
    
      <category term="C" scheme="https://www.yanbinghu.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C语言生成随机数</title>
    <link href="https://www.yanbinghu.com/2019/12/22/6131.html"/>
    <id>https://www.yanbinghu.com/2019/12/22/6131.html</id>
    <published>2019-12-22T14:10:00.000Z</published>
    <updated>2020-10-05T04:01:06.752Z</updated>
    
    <content type="html"><![CDATA[<p>首先需要说明的是，计算机中生成的随机数严格来说都是伪随机，即非真正的随机数，真正随机数的随机样本不可重现。那么我们来看看代码中有哪些方式可以生成随机数。<br><a id="more"></a></p><h2 id="rand"><a href="#rand" class="headerlink" title="rand"></a>rand</h2><p>rand函数声明如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></p><p>rand函数返回[0,RAND_MAX）范围的随机整数，在我的机器上，RAND_MAX为2147483647。<br>使用示例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">rand.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,rand());</span><br><span class="line">        i++;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o rand rand.c</span><br><span class="line">./rand</span><br><span class="line">1804289383 846930886 1681692777 1714636915 1957747793</span><br></pre></td></tr></table></figure></p><p>多运行几次，你就会惊喜地发现，每次运行的结果都是一样的！！！这还玩个毛线？</p><h2 id="srand"><a href="#srand" class="headerlink" title="srand"></a>srand</h2><p>别急，rand虽然每次运行的结果都是一样的，那是因为它的种子默认为1。每一个种子会有一串看似随机的序列，每次取下一个出来，整体都近乎是随机分布的，但是如果你的种子每次都是一样的，那么每次运行可能得到的结果也是一样的。我们需要利用srand给它一个种子。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">srand</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seed)</span></span>;</span><br></pre></td></tr></table></figure></p><p>为了保证我们每次的得到的随机数不一样，我们必须在每次调用时，都确保种子不一样，因此通常会选择使用时间作为种子。注意这只是通常的种子选择，你可以根据实际使用需求进行选择。</p><p>于是我们在使用之前设置好种子，使用示例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">rand.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));<span class="comment">//设置随机种子，注意只需要设置一次即可</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">5</span>)<span class="comment">//生成5个随机数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,rand());</span><br><span class="line">        i++;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在好了，每次运行生成的都不一样了。但是还有一个问题，如果这种方式在多线程下使用，也是不可取的，因为rand不是可重入函数。它的每次调用都会修改一些隐藏的属性，因此在多线程中并不会使用它。</p><h2 id="rand-r"><a href="#rand-r" class="headerlink" title="rand_r"></a>rand_r</h2><p>为了在多线程下使用，我们使用rand_r，使用方式和rand是一样的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand_r</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> *seedp)</span></span>;</span><br></pre></td></tr></table></figure></p><p>使用示例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seed = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">5</span>)<span class="comment">//生成5个随机数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,rand_r(&amp;seed));</span><br><span class="line">        i++;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>多线程中，多个线程可能几乎同时调用，那它们的种子可能也一样，如果想不一样，还可以将种子设置成和线程id有关。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> seed  = time(<span class="literal">NULL</span>)^pthread_self();</span><br></pre></td></tr></table></figure></p><h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><p>通过前面的例子可以发现，rand生成的整数范围是有限的，为了生成更大范围，可以使用random：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">random</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">srandom</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seed)</span></span>;</span><br></pre></td></tr></table></figure></p><p>random返回的类型为long int，因此在一定程度上，它生成的范围要大得多。另外与rand类似，需要使用srandom函数设置种子。具体的例子就不再放出了。</p><h2 id="生成指定范围随机数"><a href="#生成指定范围随机数" class="headerlink" title="生成指定范围随机数"></a>生成指定范围随机数</h2><p>前面的例子都是生成[1,RAND_MAX]之间的数，如果要生成指定区间的随机数呢？假设a和b不超过int范围以及它们的差值不超过rand的生成范围。</p><h4 id="a-b"><a href="#a-b" class="headerlink" title="[a,b)"></a>[a,b)</h4><p>左闭右开区间，即包含a，不包含：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(rand() % (b - a)) + a;</span><br></pre></td></tr></table></figure></p><h4 id="a-b-1"><a href="#a-b-1" class="headerlink" title="[a,b]"></a>[a,b]</h4><p>左闭右闭，即包含a和b：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(rand() % (b - a + <span class="number">1</span>)) + a;</span><br></pre></td></tr></table></figure></p><h4 id="a-b-2"><a href="#a-b-2" class="headerlink" title="(a,b]"></a>(a,b]</h4><p>左开右闭，即不包含a，包含b：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(rand() % (b-a)) + a + <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><h4 id="0到1之间的浮点数"><a href="#0到1之间的浮点数" class="headerlink" title="0到1之间的浮点数"></a>0到1之间的浮点数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rand()/(<span class="keyword">double</span>)RAND_MAX;</span><br></pre></td></tr></table></figure><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>生成[2,10)之间的随机数5个：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));<span class="comment">//设置随机种子，注意只需要设置一次即可</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">5</span>)<span class="comment">//生成5个随机数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,( rand() % ( b - a ) )+ a);</span><br><span class="line">        i++;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>记住，通过这些方法生成的都是伪随机数，而一个好的随机算法，它的随机性很强，可能需要根据使用场景去设计具体的算法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先需要说明的是，计算机中生成的随机数严格来说都是伪随机，即非真正的随机数，真正随机数的随机样本不可重现。那么我们来看看代码中有哪些方式可以生成随机数。&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="https://www.yanbinghu.com/categories/C/"/>
    
    
      <category term="C" scheme="https://www.yanbinghu.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>系统编程-文件读写</title>
    <link href="https://www.yanbinghu.com/2019/12/19/8355.html"/>
    <id>https://www.yanbinghu.com/2019/12/19/8355.html</id>
    <published>2019-12-19T13:30:00.000Z</published>
    <updated>2020-10-05T04:01:06.748Z</updated>
    
    <content type="html"><![CDATA[<p>在《<a href="https://www.yanbinghu.com/2019/12/11/54424.html">系统编程-文件IO</a>》中简单介绍了文件I/O的基本流程，无论选项或者参数多么变化多端，其流程大抵相同，不过是获取文件描述符，用描述符进行操作，关闭描述符，三步而已。那么文件读写又是怎样的流程？需要注意什么？<br><a id="more"></a></p><h2 id="write-read"><a href="#write-read" class="headerlink" title="write/read"></a>write/read</h2><p>在说明这些常见出错之前，就必须先了解其基本用法了。需要注意的是，write/read是不带缓冲的，调用一次，写一次。与fwrite/fread有区别，另外write/read为系统调用，频繁地系统调用将会增加开销，可参考《<a href="https://www.yanbinghu.com/2018/05/28/26708.html">库函数和系统调用的区别</a>》。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure></p><p>参数解释：</p><ul><li>fd  文件描述符，这个应该不用多做解释</li><li>buf 要写入的内容，或者读出内容存储的buf，合适的大小非常关键</li><li>count 读或写的内容大小</li></ul><p>这里有两点需要注意一下。</p><p>返回值为ssize_t类型，因为它的返回值可以为负，表示出错，有趣的是这样一来使得其能表示的读写字节范围少了近一半。<br>返回大于0，表示读或写入对应的字节数。对于read，返回0表示到文件结尾。</p><p>另外，我们还注意到，write函数的第二个参数由const修饰。为什么要使用const来修饰？</p><p>很显然，在写的过程中，write函数不应该对buf的内容进行修改，它仅仅是从buf中读取罢了。这里在编码时常用的设计，如果不希望该函数修改其内容，则加上const限定符。const详细说明参考《<a href="https://www.yanbinghu.com/2019/01/28/7442.html">const关键字到底该怎么用？</a>》。</p><p>那么返回的读写大小，和参数里的count大小有何区别？前者是真实读写的字节数，而后者是期望读写的字节数。举个简单的例子，文件中有16字节内容，而你尝试读64字节，自然最终只会读到16字节。</p><h2 id="正常读写"><a href="#正常读写" class="headerlink" title="正常读写"></a>正常读写</h2><p>正常读写的例子如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//博客：https://www.yanbinghu.com</span></span><br><span class="line"><span class="comment">//file.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> writeBuf[] = <span class="string">"https://www.yanbinghu.com"</span>;</span><br><span class="line">    <span class="keyword">char</span> readBuf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">/*可读可写，不存在时创建，有内容时截断*/</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"test.txt"</span>,O_RDWR | O_CREAT | O_TRUNC);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*写内容*/</span></span><br><span class="line">    <span class="keyword">ssize_t</span> wLen = write(fd,writeBuf,<span class="keyword">sizeof</span>(writeBuf));</span><br><span class="line">    <span class="keyword">if</span>(wLen &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"write failed"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"write len:%ld\n"</span>,wLen);</span><br><span class="line">    <span class="keyword">ssize_t</span> rLen = read(fd,readBuf,<span class="keyword">sizeof</span>(readBuf));</span><br><span class="line">    <span class="keyword">if</span>(rLen &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"read failed"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    readBuf[<span class="keyword">sizeof</span>(readBuf)<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"read content:%s\n"</span>,readBuf);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译运行，然后你就会惊喜地发现，结果并不是如你想地那样：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -o writeFile file.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./writeFile</span></span><br><span class="line">write len:26</span><br><span class="line">read content:</span><br></pre></td></tr></table></figure></p><p>我们查看文件可以看到内容已经写进去了，但是读取出来地内容却是空！</p><p>这是为何？<br>理解这个问题需要理解文件描述符和偏移量。</p><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>文件描述符虽然只是一个整型值，但它只是一个索引值，它指向了该进程打开文件的记录表。还记得常说的“一切皆文件”吗？实际上，即使你每打开一个TCP链接，都会有一个对应的文件描述符。这个记录表中包含了很多与文件相关地信息，例如文件偏移量，inode，状态标志等等。</p><p>而你每一次进行读写，都会影响所谓地文件偏移量。</p><p>因此你在第一次进行写之后，文件偏移量类似于下面这样：</p><div class="table-container"><table><thead><tr><th><a href="https://www.yanbinghu.com\0">https://www.yanbinghu.com\0</a></th><th></th><th></th></tr></thead><tbody><tr><td></td><td>&uarr;</td></tr></tbody></table></div><p>那么你进行第一次读的时候，文件偏移已经到文件的末尾了（此时函数返回值为0），所以你肯定读不出任何内容，因此你需要移动偏移指针。</p><h4 id="设置偏移量"><a href="#设置偏移量" class="headerlink" title="设置偏移量"></a>设置偏移量</h4><p>为了读取写入后的内容，我们必须要设置偏移量，设置成像下面这样：</p><div class="table-container"><table><thead><tr><th><a href="https://www.yanbinghu.com\0">https://www.yanbinghu.com\0</a></th><th></th><th></th></tr></thead><tbody><tr><td>&uarr;</td><td></td></tr></tbody></table></div><p>有人可能会好奇，这最后为什么还有一个\0？很显然，它被自动加上了，具体原因可以参考《<a href="https://www.yanbinghu.com/2019/08/19/18180.html">NULL,0,’0’你真的分清了吗</a>》。</p><p>还有人会问，你怎么看出有一个\0？用od命令看一下就知道了。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> od -c test.txt</span></span><br><span class="line">0000000   h   t   t   p   s   :   /   /   w   w   w   .   y   a   n   b</span><br><span class="line">0000020   i   n   g   h   u   .   c   o   m  \0</span><br><span class="line">0000032</span><br></pre></td></tr></table></figure></p><p>现在看到了吧。</p><p>为了设置偏移量，我们需要用到函数lseek：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">lseek</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure></p><p>成功返回新的文件偏移量，出错返回-1。</p><p>有必要对参数进行解释</p><ul><li>offset 相对于whence的偏移量</li><li>whence 相对位置</li></ul><p>其中whence有三个值</p><ul><li>SEEK_SET  文件开始处</li><li>SEEK_CUR  当前位置</li><li>SEEK_END   文件末尾</li></ul><p>举个例子，假设当前offset为-4，whence为SEEK_CUR，那么当写完内容，并设置该选项后的文件偏移位置如下：</p><div class="table-container"><table><thead><tr><th><a href="https://www.yanbinghu" target="_blank" rel="noopener">https://www.yanbinghu</a>.</th><th>com</th><th></th></tr></thead><tbody><tr><td></td><td>&uarr;</td></tr></tbody></table></div><p>注意，offset是可以为负的。</p><p>说白了可以设置偏移位置，而设置可以相对三个位置，开头，当前和结尾。</p><h4 id="读取写入的内容"><a href="#读取写入的内容" class="headerlink" title="读取写入的内容"></a>读取写入的内容</h4><p>好了，为了读取到我们写入的内容，我们已经知道怎么做了，就是设置偏移量在文件开头，即在读之前加上下面的语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lseek(fd, 0, SEEK_SET);//注意检查返回值</span><br></pre></td></tr></table></figure></p><p>然后再次编译运行：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">write len:<span class="number">26</span></span><br><span class="line">read content:https:<span class="comment">//www.yanbinghu.com</span></span><br></pre></td></tr></table></figure></p><p>如你所愿！</p><h2 id="常见报错"><a href="#常见报错" class="headerlink" title="常见报错"></a>常见报错</h2><p>使用不当或者出错的时候会有错误信息，这在编码的时候就需要注意检查。</p><h4 id="Bad-file-descriptor"><a href="#Bad-file-descriptor" class="headerlink" title="Bad file descriptor"></a>Bad file descriptor</h4><p>通常使用了一个并不合法的文件描述符，例如，该文件描述符已经关闭。通常你可以通过下面的命令来观察文件描述符的打开情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al /proc/`pidof procName`/fd/</span><br></pre></td></tr></table></figure></p><p>这里的procName是你正在运行的程序名。</p><p>也有可能是你打开模式不对，例如，以只读方式打开，却尝试写。</p><h4 id="Interrupted-system-call"><a href="#Interrupted-system-call" class="headerlink" title="Interrupted system call"></a>Interrupted system call</h4><p>通常是在读写过程中被中断，常见的如对socket进行读写时，链接被意外中断，或者读写时，进程被中断等等。</p><h4 id="File-exists"><a href="#File-exists" class="headerlink" title="File exists"></a>File exists</h4><p>通常在你想创建一个文件，但是文件已经存在的情况。</p><h4 id="No-such-file-or-directory"><a href="#No-such-file-or-directory" class="headerlink" title="No such file or directory"></a>No such file or directory</h4><p>就如字面意思，通常是文件或者目录不存在，也许你使用了O_CREATE标志，但是如果你的目录不存在，文件也无法创建成功。</p><p>还有一种情况是，你已经打开了该文件，程序执行过程中，该文件又被人删除了，删除后又创建了一个文件名一样的文件，这样的情况下，也有可能会提示该错误。</p><h4 id="Too-many-open-fileswrite"><a href="#Too-many-open-fileswrite" class="headerlink" title="Too many open fileswrite"></a>Too many open fileswrite</h4><p>进程打开的文件过多。一个进程打开的文件数量是有限的，具体可以通过：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ulimit -n</span><br><span class="line">65535</span><br></pre></td></tr></table></figure></p><p>至于当前已经打开了多少，可以这样统计：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /proc/`pidof proName`/fd/ |wc -l</span><br></pre></td></tr></table></figure></p><p>proName为你的进程名。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一些常见错误中很多涉及到网络的读写，这里暂时没有提及。</p><p>一般情况，不会用同一个文件描述符对文件进行既读又写，一旦出现这样的场景时，需要注意偏移量的设置。虽然本文的I/O函数不带缓冲，但是读写时，选择合适的buf大小也非常关键。</p><p>另外编程中也有以下建议：</p><ul><li>检查接口的返回值，处理出错场景</li><li>对于不期望被修改内容的参数，添加const限定符</li><li>善用man手册</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在《&lt;a href=&quot;https://www.yanbinghu.com/2019/12/11/54424.html&quot;&gt;系统编程-文件IO&lt;/a&gt;》中简单介绍了文件I/O的基本流程，无论选项或者参数多么变化多端，其流程大抵相同，不过是获取文件描述符，用描述符进行操作，关闭描述符，三步而已。那么文件读写又是怎样的流程？需要注意什么？&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="https://www.yanbinghu.com/categories/C/"/>
    
    
      <category term="C" scheme="https://www.yanbinghu.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>系统编程-多线程(1)</title>
    <link href="https://www.yanbinghu.com/2019/12/17/19410.html"/>
    <id>https://www.yanbinghu.com/2019/12/17/19410.html</id>
    <published>2019-12-17T14:30:00.000Z</published>
    <updated>2020-10-05T04:01:06.748Z</updated>
    
    <content type="html"><![CDATA[<p>多线程，作为一个开发者，这个名词应该不陌生。我在《<a href="https://www.yanbinghu.com/2018/09/07/47517.html">对进程和线程的一些总结</a>》中也有介绍，这里就不详述。<br><a id="more"></a></p><h2 id="为什么要用多线程"><a href="#为什么要用多线程" class="headerlink" title="为什么要用多线程"></a>为什么要用多线程</h2><p>很显然，多线程能够同时执行多个任务。举个例子，你打开某视频播放器，点击下载某个视频，然后你发现这个时候一直在下载，其他啥都干不了，那你肯定骂*。所以在这种情况下，可以使用多线程，让下载任务继续，同时也能继续其他操作。</p><p>作为一个包工头，一堆砖要搬，但是就一个人，可是你只能搬这么多，怎么办？多找几个人一起搬呗，但是其他人就也需要付工钱，没关系，能早点干完也就行了，反正总体工钱差不多。</p><p>同样的，如果有一个任务特别耗时，而这个任务可以拆分为多个任务，那么就可以让每个线程去执行一个任务，这样任务就可以更快地完成了。</p><h2 id="代价"><a href="#代价" class="headerlink" title="代价"></a>代价</h2><p>听起来都很好，但是多线程是有代价的。由于它们“同时”进行任务，那么它们任务的有序性就很难保障，而且一旦任务相关，它们之间可能还会竞争某些公共资源，造成死锁等问题。</p><h2 id="绑核"><a href="#绑核" class="headerlink" title="绑核"></a>绑核</h2><p>通过下面的命令可将进程proName程序绑在1核运行：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskset -c <span class="number">1</span> ./proName</span><br></pre></td></tr></table></figure></p><p>而如果只绑定了一个核，那么同一时刻，只有一个线程在运行，而线程之间的切换又会消耗资源，那么这种情况下反而会导致性能降低。</p><p>另外一种情况，就是设置的线程数大于总的逻辑CPU数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/cpuinfo| grep <span class="string">"processor"</span>| wc -l</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure></p><p>这样的情况下，设置更多的线程并不会提高处理速度。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>优点：</p><ul><li>更快，加快处理任务</li><li>更强，同时处理多任务</li></ul><p>缺点：</p><ul><li>难控制，编程困难</li><li>不当使用降低性能，线程切换</li><li>bug难定位，资源竞争</li></ul><h2 id="如何创建多线程"><a href="#如何创建多线程" class="headerlink" title="如何创建多线程"></a>如何创建多线程</h2><p>普通的进程通常只有一个线程，称为主线程。</p><p>创建线程需要使用下面的函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">void</span> *(*start_routine) (<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure></p><p>参数有必要做一下说明</p><ul><li>thread 线程ID指针，创建成功时，会保存在此</li><li>attr 线程属性，控制线程的一些行为</li><li>start_routine 线程运行起始地址，是一个函数指针</li><li>arg 函数的参数，只有一个参数，因此多个参数需要打包在一起</li></ul><p>创建成功时，返回0，否则出错。<br>看到了吗，到处都有void*的身影（参考《<a href="https://www.yanbinghu.com/2019/12/15/19682.html">void*是什么玩意</a>》）。</p><p>使用时注意包含头文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br></pre></td></tr></table></figure></p><p>，并且在链接时加上-lpthread，因此它不在libc库中。在《<a href="https://www.yanbinghu.com/2018/10/06/46212.html">一个奇怪的链接问题</a>》中提到，对于非glibc库中的库函数，都需要显式链接对应的库。</p><p>试着写一个简单的多线程程序，简单起见，我们暂时不设置任何属性，将attr字段设置为NULL：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">myThread</span><span class="params">(<span class="keyword">void</span> *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"thread run,value is %d\n"</span>,*(<span class="keyword">int</span>*)id);</span><br><span class="line"><span class="comment">//return NULL; 这种方式也可以退出线程</span></span><br><span class="line">pthread_exit((<span class="keyword">void</span>*)<span class="number">0</span>);<span class="comment">//退出线程</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> tid ;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> status = pthread_create(&amp;tid,<span class="literal">NULL</span>,myThread,(<span class="keyword">void</span>*)&amp;i);</span><br><span class="line"><span class="keyword">if</span>(status &lt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"crete failed\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main func finished\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译运行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -o main main.c -lpthread</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./main</span></span><br><span class="line">main func finished</span><br></pre></td></tr></table></figure></p><p>发现运行的结果并不如我们预期那样，就好像线程没有执行一样。</p><p>原因在于，如果主线程退出了，那么其他线程也会退出。所谓，皮之不存，毛将焉附，所有线程都共同使用很多资源，相关内容也可以从《<a href="https://www.yanbinghu.com/2018/09/07/47517.html">对进程和线程的一些总结</a>》中了解到。<br>如何改进呢？我们可以等线程执行完啊，于是，在主线程退出前sleep:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> tid ;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> status = pthread_create(&amp;tid,<span class="literal">NULL</span>,myThread,(<span class="keyword">void</span>*)&amp;i);</span><br><span class="line"><span class="keyword">if</span>(status &lt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"crete failed\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main func finished\n"</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就好了（注意添加头文件<figure class="highlight plain"><figcaption><span><unistd.h>```）。</unistd.h></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">main func finished</span><br><span class="line">thread run,value is 10</span><br></pre></td></tr></table></figure></p><p>但是你会发现，<figure class="highlight plain"><figcaption><span>func finished```可能会先打印。这也就呼应了文章标题。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">但是转念一想，如果线程执行的时间超过一秒呢，难道就要sleep更长时间吗？而很多时候甚至根本不知道线程要执行多长时间，那怎么办呢？</span><br><span class="line"></span><br><span class="line">还可以使用：</span><br><span class="line">```c</span><br><span class="line">int pthread_join(pthread_t thread, void **retval);</span><br></pre></td></tr></table></figure></p><p>thread是前面获得的线程id，而retval包含了线程的返回信息，假设我们完全不关心线程的退出状态，那么可以设置为NULL。</p><p>修改代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> tid ;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> status = pthread_create(&amp;tid,<span class="literal">NULL</span>,myThread,(<span class="keyword">void</span>*)&amp;i);</span><br><span class="line"><span class="keyword">if</span>(status &lt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"crete failed\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main func finished\n"</span>);</span><br><span class="line">    pthread_join(tid,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种情况同样可以达到目的，pthread_join，会阻塞程序，直到线程退出（前提是线程为非分离线程）。</p><h2 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h2><p>以下几种情况下，线程会终止</p><ul><li>线程函数返回</li><li>调用pthread_exit，主线程调用无碍</li><li>调用pthread_cancel</li><li>调用exit，或者主线程退出，所有线程终止<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2>假如修改下面的代码：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> tid;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> status = pthread_create(&amp;tid,<span class="literal">NULL</span>,myThread,(<span class="keyword">void</span>*)&amp;i);</span><br><span class="line"><span class="keyword">if</span>(status &lt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"crete failed\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">i = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main func finished\n"</span>);</span><br><span class="line">pthread_join(tid,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在创建线程后，修改i的值，你会发现在线程中打印的不会是10，而是6。</p><p>也就是说，创建线程的时候，传入的参数必须确保其使用这个参数时，参数没有被修改，否则的话，拿到的将是错误的值，</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文通过一些小例子，简单介绍了线程概念，对于绑核，多线程同步等问题均一笔带过，将在后面的文章中继续介绍。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多线程，作为一个开发者，这个名词应该不陌生。我在《&lt;a href=&quot;https://www.yanbinghu.com/2018/09/07/47517.html&quot;&gt;对进程和线程的一些总结&lt;/a&gt;》中也有介绍，这里就不详述。&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="https://www.yanbinghu.com/categories/C/"/>
    
    
      <category term="C" scheme="https://www.yanbinghu.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>void*到底是什么玩意？</title>
    <link href="https://www.yanbinghu.com/2019/12/15/19682.html"/>
    <id>https://www.yanbinghu.com/2019/12/15/19682.html</id>
    <published>2019-12-15T13:10:00.000Z</published>
    <updated>2020-10-05T04:01:06.748Z</updated>
    
    <content type="html"><![CDATA[<p>说到C就不得不提指针，而一提到指针，有一个是比较特殊的，那就是void*。</p><p>void*到底是怎样的存在？</p><a id="more"></a><h2 id="指针类型的含义"><a href="#指针类型的含义" class="headerlink" title="指针类型的含义"></a>指针类型的含义</h2><p>在说明void*之前，先了解一下普通指针类型的含义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">0x01020304</span>,<span class="number">2019</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *b = a;</span><br><span class="line">    <span class="keyword">char</span> *c = (<span class="keyword">char</span>*)&amp;a[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b+1:%d\n"</span>,*(b+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c+1:%d\n"</span>,*(c+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b+1:2019</span><br><span class="line">c+1:3</span><br></pre></td></tr></table></figure></p><p>对于上面的结果，也许你并不感到意外。如果你的疑问是为什么不是2而是3，那么建议你看看《<a href="https://www.yanbinghu.com/2018/10/02/25450.html">理一理字节序的事</a>》。同样是指针类型，b和c有什么区别？<br>一个是指向整型的指针，一个是指向char型的指针，当它们执行算术运算时，它们的步长就是对应类型占用空间大小。<br>即<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b + <span class="number">1</span> <span class="comment">//移动sizeof(int)字节</span></span><br></pre></td></tr></table></figure></p><div class="table-container"><table><thead><tr><th>04</th><th>03</th><th>02</th><th>01</th><th>2019</th></tr></thead><tbody><tr><td>字节0</td><td>字节1</td><td>字节2</td><td>字节3</td><td>字节4~7</td></tr><tr><td></td><td></td><td></td><td></td><td>&uarr;</td></tr></tbody></table></div><p>指针移动4个字节后，指向的就是2019了，解引用自然得到2019。</p><p>而对于c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c + <span class="number">1</span> <span class="comment">//移动sizeof(char)字节</span></span><br></pre></td></tr></table></figure></p><p>它的指向如下：</p><div class="table-container"><table><thead><tr><th>04</th><th>03</th><th>02</th><th>01</th><th>2019</th></tr></thead><tbody><tr><td>字节0</td><td>字节1</td><td>字节2</td><td>字节3</td><td>字节4~7</td></tr><tr><td></td><td>&uarr;</td><td></td><td></td></tr></tbody></table></div><p>解引用之后，自然得到3。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>各种类型之间没有本质区别，只是解释内存中的数据方式不同。</p><p>例如，对于int型指针b，解引用时，会解析4字节，算术运算时，也是以该类型占用空间大小为单位，所以b+1，移动4字节，解引用，处理4字节内容，得到2019。</p><p>对于char型指针c，解引用时，会解析1个字节，算术运算时，也是以sizeof(char)为单位，所以c+1，移动一字节，解引用，处理1字节，得到03。</p><p>所以像下面这样的操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = &#123;<span class="number">01</span>,<span class="number">02</span>,<span class="number">03</span>,<span class="number">04</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *b = (<span class="keyword">int</span>*)a+<span class="number">2</span>;</span><br></pre></td></tr></table></figure></p><p>如果你试图解引用b，即*b，就可能遇到无法预料的问题，因为将会访问非法内存位置。</p><p>a+2，移动sizeof(char)字节，指向03，此时按照int类型指针解引用，由于int类型解引用会处理4字节内存，但是后面已经没有属于数组a的合法内容了，因此可能出错。</p><h2 id="指针占用空间大小"><a href="#指针占用空间大小" class="headerlink" title="指针占用空间大小"></a>指针占用空间大小</h2><p>正由于它们没有本质区别，它们占用空间大小在同一个程序中都是固定的，对于32位程序，占用4字节空间，64位占用8字节，而正因如此，64位程序理论能使用的内存是足够大的，而32位程序理论上能使用的不过4G（2^（4*8bit)），再加上内核空间的使用，真正能用到的可能就3G左右。</p><p>如果你的系统是64位的，那么默认情况下，编译出来的程序也是64位的。如果你想编译为32位，可以使用-m32参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -m32 -o main main.c</span><br></pre></td></tr></table></figure></p><p>如何确定是多少位的程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -h main</span><br><span class="line">Class:                             ELF32</span><br></pre></td></tr></table></figure></p><p>上面的ELF32，表明了它是32位程序。或者可以看Machine字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Machine:                           Intel 80386</span><br></pre></td></tr></table></figure></p><h2 id="void"><a href="#void" class="headerlink" title="void*"></a>void*</h2><p>说回void*，前面说了，指针的类型不过是解释数据的方式不同罢了，这样的道理也可用于很多场合的强制类型转换，例如将int类型指针转换为char型指针，并不会改变内存的实际内容，只是修改了解释方式而已。而void <em>是一种无类型指针，任何类型指针都可以转为void\</em>，它无条件接受各种类型。</p><p>而既然是无类型指针，那么就不要尝试做下面的事情：</p><ul><li>解引用</li><li>算术运算</li></ul><p>由于不知道其解引用操作的内存大小，以及算术运算操作的大小，因此它的结果是未知的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *b = &amp;a;</span><br><span class="line">    <span class="keyword">void</span> *c = b;</span><br><span class="line">    *c;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译警告如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning: dereferencing ‘void *’ pointer</span><br></pre></td></tr></table></figure></p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>既然如此，那么void*有什么用呢？</p><p>实际上我们在很多接口中都会发现它们的参数类型都是void*,例如:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure></p><p>为何要如此设计？因为对于这种通用型接口，你不知道用户的数据类型是什么，但是你必须能够处理用户的各种类型数据，因而会使用void*。void*能包容地接受各种类型的指针。</p><p>也就是说，如果你期望接口能够接受任何类型的参数，你可以使用void*类型。</p><p>但是在具体使用的时候，你必须转换为具体的指针类型。例如，你传入接口的是int*，那么你在使用的时候就应该按照int*使用。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>使用void*需要特别注意的是，你必须清楚原始传入的是什么类型，然后转换成对应类型。例如，你准备使用库函数qsort进行排序：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">void</span> *base,<span class="keyword">size_t</span> nmemb,<span class="keyword">size_t</span> size , <span class="keyword">int</span>(*compar)(<span class="keyword">const</span> <span class="keyword">void</span> *,<span class="keyword">const</span> <span class="keyword">void</span> *))</span></span>;</span><br></pre></td></tr></table></figure></p><p>它的第三个参数就是比较函数，它接受的参数都是const void*，如果你的比较对象是一个结构体类型，那么你自己在实现compar函数的时候，也必须是转换为该结构体类型使用。</p><p>举个例子，你要实现学生信息按照成绩比较：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student_tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[STU_NAME_LEN];  <span class="comment">//学生姓名</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> id;          <span class="comment">//学生学号</span></span><br><span class="line">    <span class="keyword">int</span> score;                <span class="comment">//学生成绩</span></span><br><span class="line">&#125;<span class="keyword">student_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">studentCompare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *stu1,<span class="keyword">const</span> <span class="keyword">void</span> *stu2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="comment">/*强转成需要比较的数据结构*/</span></span><br><span class="line">    <span class="keyword">student_t</span> *value1 = (<span class="keyword">student_t</span>*)stu1;</span><br><span class="line">    <span class="keyword">student_t</span> *value2 = (<span class="keyword">student_t</span>*)stu2;</span><br><span class="line">    <span class="keyword">return</span> value1-&gt;score-value2-&gt;score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在将其传入<code>studentCompare</code>函数后，必须转换为其对应的类型进行处理。<br>更多函数指针相关内容可以参考《<a href="https://www.yanbinghu.com/2019/01/03/3593.html">高级指针话题-函数指针</a>》。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>void*很强大，但是一定要在合适的时候使用；同时强转很逆天，但是一定要注意前后的类型是否真的能正确转换。</p><p>通俗地说void*：</p><ul><li>这里有一片内存数据，我也不知道什么类型，给你了，你自己想怎么用怎么用吧，不过要用对奥！</li><li>我这里什么类型都能处理，你给我一片内存数据就可以了</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说到C就不得不提指针，而一提到指针，有一个是比较特殊的，那就是void*。&lt;/p&gt;
&lt;p&gt;void*到底是怎样的存在？&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="https://www.yanbinghu.com/categories/C/"/>
    
    
      <category term="C" scheme="https://www.yanbinghu.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>系统编程-文件I/O操作</title>
    <link href="https://www.yanbinghu.com/2019/12/11/54424.html"/>
    <id>https://www.yanbinghu.com/2019/12/11/54424.html</id>
    <published>2019-12-11T14:00:00.000Z</published>
    <updated>2020-10-05T04:01:06.748Z</updated>
    
    <content type="html"><![CDATA[<p>我们都听过Linux下一切皆文件，实际上无论是普通的文件读写，还是网络IO读写，它们都有着类似的操作过程。本文通过基本文件IO操作，来了解Linux“一切文件”的读写。当然过程中穿插着很多其他内容。<br><a id="more"></a></p><h2 id="文件I-O过程"><a href="#文件I-O过程" class="headerlink" title="文件I/O过程"></a>文件I/O过程</h2><p>在介绍具体的函数使用之前，我必须说明一下文件I/O的基本过程。它们类似过程如下：</p><ul><li>以某种模式打开文件，获取一个文件描述符</li><li>对文件进行读写</li><li>不需要时，关闭文件描述符</li></ul><p>文件描述符是什么？你可以认为是一个对文件进行操作的凭据，你只有通过它才能对文件进行读写。它是一个非负整数。通常0是标准输入，1是标准输出，2是标准错误（参考《》）。正是有了它们，你的简单程序才可以从控制台读入数据，输出日志，输出错误打印等等。</p><p>记得很小的时候，家里连压水的工具都没有，需要用水的时候，都是用一个小点的桶从井里打水。</p><p>类比文件I/O操作，打开井盖，拿到绑着绳子的水桶，就像是打开文件，获取文件描述符；而打水的过程，就像对文件进行读写；最后需要的时候，又把桶放回去，并盖上井盖；而这就像关闭文件描述符。</p><p>当然了，如果嫌弃里面的小桶打水太慢，有的人可能会用一担大桶用来装水，装满一担后，再挑走使用。而这个过程就像使用了缓冲。（参考《<a href="https://www.yanbinghu.com/2019/12/01/27836.html">不可不知的三种缓冲</a>》）。</p><p>说了这么多废话，文件I/O到底怎么操作呢？本文介绍的是不带缓冲的I/O函数。</p><h2 id="打开文件，获取文件描述符"><a href="#打开文件，获取文件描述符" class="headerlink" title="打开文件，获取文件描述符"></a>打开文件，获取文件描述符</h2><p>主要函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure></p><p>参数解释：</p><ul><li>pathname 文件名</li><li>flags 打开选项</li></ul><p>这里的文件名应该不用过多解释，但是flags需要做一些说明，<br>它须指定以下五个中的一个：</p><ul><li>O_RDONLY  只读</li><li>O_WRONLY  只写</li><li>O_RDWR    可读可写</li><li>O_EXEC   执行打开</li><li>O_SEARCH  搜索打开（针对目录）</li></ul><p>而下面的选项是可选的：</p><ul><li>O_APPEND 写时追加到文件末尾</li><li>O_CREAT  文件不存在时创建，且必须指定文件访问权限位</li><li>O_TRUNC    文件存在时，且以只写，或者读写方式打开，则截断长度为0</li><li>……</li></ul><p>当打开成功时返回文件描述符，否则返回-1，并且设置errno。</p><h2 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h2><p>读写操作主要有两个函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unisdt.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf,<span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf,<span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure></p><p>参数说明：</p><ul><li>fd 文件描述符</li><li>buf 要读写的内容</li><li>nbytes 读写的内容大小</li></ul><p>这里的fd就是前面拿到的文件描述符。篇幅有限， 本文暂不涉及具体的读写介绍。</p><h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><p>调用close函数即可，它的参数是前面打开的时候获得的文件描述符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int close(int fd);</span><br></pre></td></tr></table></figure></p><p>成功返回0，失败则返回-1，并且会设置errno。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>以上都太过理论化了，那么理论结合实际来看看，究竟是怎样的。</p><h4 id="打开一个不存在的文件"><a href="#打开一个不存在的文件" class="headerlink" title="打开一个不存在的文件"></a>打开一个不存在的文件</h4><p>这是最简单的情况，现在假设，当前目录下没有test.txt<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"test.txt"</span>,O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == fd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//perror("open failed:");</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"open failed:%s\n"</span>, strerror(errno)); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"open ok\n"</span>);</span><br><span class="line">    <span class="keyword">char</span> test[] = <span class="string">"wechat:shouwangxiansheng\n"</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> len = write(fd,test,<span class="keyword">sizeof</span>(test));</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == len)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"write failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行报错：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open failed: No such file <span class="keyword">or</span> directory</span><br></pre></td></tr></table></figure></p><p>还记得前面说的，如果出错就会设置errno吗？当open返回-1（很多系统接口类似）时，就会设置errno，这个时候就可以调用perror接口打印对应的错误信息。便于我们定位问题。即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">perror(&quot;open failed:&quot;);</span><br><span class="line">printf(&quot;open failed:%s\n&quot;, strerror(errno));</span><br></pre></td></tr></table></figure></p><p>上面两种方式都可以打印出错误信息，区别在于，前者输出到标准错误，后者输出到标准输出。</p><p>还记得在《<a href="https://www.yanbinghu.com/2019/12/01/27836.html">不可不知的三种缓冲</a>》中说的吗？标准错误通常是不带缓冲的。</p><h4 id="打开一个文件，不存在时创建"><a href="#打开一个文件，不存在时创建" class="headerlink" title="打开一个文件，不存在时创建"></a>打开一个文件，不存在时创建</h4><p>既然不存在时，会打开失败，那么不存在就创建好了，这就用到了O_CREATE标志。因此修改open函数那一行：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"test.txt"</span>,O_WRONLY | O_CREAT);</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open ok</span><br></pre></td></tr></table></figure></p><p>并且会在test.txt发现写入的内容。</p><p>注意到，多个标志使用|构成flags参数。</p><h4 id="打开一个文件，存在时截断"><a href="#打开一个文件，存在时截断" class="headerlink" title="打开一个文件，存在时截断"></a>打开一个文件，存在时截断</h4><p>好了，前面已经实现了文件不存在时，创建，存在时也可以正常打开，如果存在时，又不想要原先的内容？那就需要用到O_TRUNC标志。<br>修改open行如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"test.txt"</span>,O_RDONLY | O_CREAT | O_TRUNC);</span><br></pre></td></tr></table></figure></p><p>现在假设test.txt文件存在，且里面有内容，再次运行后，发现打开文件正常，且内容只有新加入的，而没有之前存在的。</p><h4 id="在打开的文件后追加内容"><a href="#在打开的文件后追加内容" class="headerlink" title="在打开的文件后追加内容"></a>在打开的文件后追加内容</h4><p>如果想在打开的文件后追加内容，那么可以使用O_APPEND标志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fd = open(&quot;test.txt&quot;,O_RDONLY | O_CREAT | O_APPEND);</span><br></pre></td></tr></table></figure></p><p>这样如果原来test.txt中有内容，则可以往文件中追加内容。</p><h4 id="只读打开的文件进行写操作"><a href="#只读打开的文件进行写操作" class="headerlink" title="只读打开的文件进行写操作"></a>只读打开的文件进行写操作</h4><p>前面提到了5个打开标志，如果以只读方式尝试写会怎样？<br>修改open行：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"test.txt"</span>,O_RDONLY);</span><br></pre></td></tr></table></figure></p><p>你会发现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">open ok</span><br><span class="line">write failed: Bad file descriptor</span><br></pre></td></tr></table></figure></p><p>以只读方式打开，却尝试写，自然是会写失败了。因此对应的操作要设置对应的标志位，否则会失败。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是文件I/O的基本操作。关键就三个步骤：</p><ul><li>以某种模式打开</li><li>操作</li><li>关闭</li></ul><p>错误处理原则：<br>返回-1，则出错，会设置errno，可通过perror或者strerror打印错误信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们都听过Linux下一切皆文件，实际上无论是普通的文件读写，还是网络IO读写，它们都有着类似的操作过程。本文通过基本文件IO操作，来了解Linux“一切文件”的读写。当然过程中穿插着很多其他内容。&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="https://www.yanbinghu.com/categories/C/"/>
    
    
      <category term="C" scheme="https://www.yanbinghu.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>如何让程序真正地后台运行？</title>
    <link href="https://www.yanbinghu.com/2019/12/06/39731.html"/>
    <id>https://www.yanbinghu.com/2019/12/06/39731.html</id>
    <published>2019-12-06T13:30:00.000Z</published>
    <updated>2020-10-06T03:19:51.555Z</updated>
    
    <content type="html"><![CDATA[<p>如何实现一个守护进程？如何让程序在后台运行?这是后台开发面试常问的一道题，那么守护进程到底是什么？又该如何实现？<br><a id="more"></a></p><h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p>守护进程通常生存期长，很多是在系统启动时启动，系统退出时才关闭。它们的特点通常没有控制终端，后台运行。</p><p>有人可能会会心一笑，后台运行程序，我知道呀。还有两种方式呢<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./hello &amp;</span><br></pre></td></tr></table></figure></p><p>看，多么简单。但是运行之后，你试着关闭当前终端，你会发现程序会停止运行，因为一旦关闭终端，程序会收到一个信号SIGHUP，而收到该信号默认的动作就是程序退出。</p><p>没关系啊，我还有招：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ nohup ./hello &amp; #注意这里&amp;是必要的，否则不会变成后台进程</span><br><span class="line">$ jobs</span><br><span class="line">[1]+  Running                 nohup ./hello &amp;</span><br></pre></td></tr></table></figure></p><p>我使用nohup命令总可以了吧？</p><p>挺好的，nohup会忽略SIGHUP命令，并有了&amp;的加持，即便终端关了，也能继续执行。但它的终端输出还会记录默认还在nohup.out文件中，同时，如果将huponexit关闭，它同样难逃命运：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ shopt -s huponexit  #shopt -u huponexit 设置为off</span><br><span class="line">$ shopt |grep onexit</span><br><span class="line">huponexit       on</span><br></pre></td></tr></table></figure></p><p>一旦终端退出（ctrl+D）后，nohup也救不了。</p><p>下面要介绍的守护进程一一种完全脱离终端，有着自己的会话。<br>如果你在你的Linux系统中执行下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps -elf</span><br></pre></td></tr></table></figure></p><p>就会发现一些进程的tty列是？，当然这并不是说明它们是守护进程，而那些用[]括起来的，是内核守护进程</p><p>想象一下，如果没有任何人登录的服务器上面的运行程序，难道每次执行的时候都要使用nuhup+&amp;？况且，一旦系统的huponexit选项是打开的，这种方式仍然无法避免终端关闭程序就退出的命运！</p><p>那么就需要实现用户守护进程了，或者说daemon化。</p><h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><p>其实现过程基本遵循以下原则：</p><ul><li>调用umask设置文件模式，通常设置为0。为了便于后续创建文件，不使用继承而来的父进程的设置，需要设置新的权限掩码。</li><li>调用fork，创建子进程，并且父进程退出</li><li>调用setdid创建新的会话（一个或多个进程组的集合），由于当前进程不是一个进程组的组长，因此会创建一个新的会话，却成为组长进程，同时没有控制终端。</li><li>将当前工作目录切换为根目录。同样的，其工作目录可能是从父进程继承而来的，可以自己另立山头。</li><li>关闭不需要的文件描述符。同样的，可能从父进程继承了一些打开的文件描述符，而这些描述符可能再也不需要，因此可以关闭。</li><li>重定向标准输出，标准输入和标准错误到/dev/null（相关阅读：）</li></ul><p>实际上，从上面的描述可以发现，这些规则都有几乎相同的目标，那就是不想成为富二代，摆脱父亲的控制。（在<a href="https://www.yanbinghu.com/2019/08/11/28423.html">fork的介绍</a>中，我们说到，儿子从父亲那里继承了很多东西）</p><ul><li>重新设置权限掩码，避免受父进程影响</li><li>创建新的会话，脱离终端</li><li>使用新的工作目录</li><li>关闭不需要的文件描述符</li><li>关闭标准输入，标准输出和标准错误</li></ul><p>所以通过这些也可以明白，有些规则并不是完全强制的，可根据实际程序的情况进行设置，不过按照常规做法是一个比较好的选择。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>参考代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*实现仅供参考，可根据实际情况调整*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daemonize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*清除文件权限掩码*/</span></span><br><span class="line">umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*父进程退出*/</span></span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">if</span>((pid=fork()) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*for 出错*/</span></span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> != pid)<span class="comment">/*父进程*/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"father exit\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*子进程，成为组长进程，并且摆脱终端*/</span></span><br><span class="line">setsid();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*修改工作目录*/</span></span><br><span class="line"><span class="keyword">if</span>(chdir(<span class="string">"/"</span>) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"change dir failed"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rl</span>;</span></span><br><span class="line"><span class="comment">/*先获取文件描述符最大值*/</span></span><br><span class="line"><span class="keyword">if</span>(getrlimit(RLIMIT_NOFILE,&amp;rl) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"get file decription failed"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果无限制，则设置为1024*/</span></span><br><span class="line"><span class="keyword">if</span>(rl.rlim_max == RLIM_INFINITY)</span><br><span class="line">rl.rlim_max = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*为了使得终端有输出，保留了文件描述符0，1，2;实际上父进程可能没有打开2以上的文件描述符*/</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">3</span>;i &lt; rl.rlim_max;i++)</span><br><span class="line">close(i);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span> == daemonize())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"daemonize ok\n"</span>);</span><br><span class="line">sleep(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"daemonize failed\n"</span>);</span><br><span class="line">sleep(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译运行，你就会发现，它已经可以欢脱地运行啦。</p><p>代码中有几个点，需要关注一下。为了保留printf的输出，我在daemonize函数中，并没有关闭所有的文件描述符，0，1，2可以参考《<a href="https://www.yanbinghu.com/2018/10/26/9186.html">如何理解Linux shell中“2&gt;&amp;1”</a>》，当然了，如果想让printf的输出保存到文件，也有方法，可以参考《<a href="https://www.yanbinghu.com/2019/11/21/44978.html">优雅地保存printf的打印</a>》，这里就不再赘述了。</p><h2 id="实际实现"><a href="#实际实现" class="headerlink" title="实际实现"></a>实际实现</h2><p>实际上，已经有一个接口可以帮我们做这些事情：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int daemon(int nochdir, int noclose);</span><br></pre></td></tr></table></figure></p><p>即daemon函数，它有两个参数</p><ul><li>nochdir 为0时，表示修改其根目录为/，否则不变</li><li>noclose，为0时，表示将标准输入，标准输出，标准错误重定向到/dev/null。</li></ul><p>简单例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span> == daemon(<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"daemon ok\n"</span>);</span><br><span class="line">sleep(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"daemon failed\n"</span>);</span><br><span class="line">sleep(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果你还要实现单例化，可以参考《<a href="https://www.yanbinghu.com/2019/11/28/46317.html">如何实现单例运行</a>》，使得同时只有一个该进程运行。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就进程后台运行以及是守护进程实现的介绍，关键点有</p><ul><li>创建子进程，父进程退出</li><li>创建新的会话，脱离终端</li></ul><p>附上daemon的源码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daemon</span><span class="params">(nochdir, noclose)</span></span></span><br><span class="line">int nochdir, noclose;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (fork()) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line"><span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (setsid() == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!nochdir)</span><br><span class="line">(<span class="keyword">void</span>)chdir(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!noclose &amp;&amp; (fd = open(_PATH_DEVNULL, O_RDWR, <span class="number">0</span>)) != <span class="number">-1</span>) </span><br><span class="line">&#123;</span><br><span class="line">(<span class="keyword">void</span>)dup2(fd, STDIN_FILENO);</span><br><span class="line">(<span class="keyword">void</span>)dup2(fd, STDOUT_FILENO);</span><br><span class="line">(<span class="keyword">void</span>)dup2(fd, STDERR_FILENO);</span><br><span class="line"><span class="keyword">if</span> (fd &gt; <span class="number">2</span>)</span><br><span class="line">(<span class="keyword">void</span>)close (fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何实现一个守护进程？如何让程序在后台运行?这是后台开发面试常问的一道题，那么守护进程到底是什么？又该如何实现？&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="https://www.yanbinghu.com/categories/C/"/>
    
    
      <category term="C" scheme="https://www.yanbinghu.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++11-shared_ptr详解</title>
    <link href="https://www.yanbinghu.com/2019/12/05/33986.html"/>
    <id>https://www.yanbinghu.com/2019/12/05/33986.html</id>
    <published>2019-12-05T14:30:00.000Z</published>
    <updated>2020-10-05T04:01:06.752Z</updated>
    
    <content type="html"><![CDATA[<p>《<a href="https://www.yanbinghu.com/2019/11/07/11278.html">C++11 unique_ptr</a>》说到，如果有可能就使用unique_ptr，然后很多时候对象是需要共享的，因此shared_ptr也就会用得很多。shared_ptr允许多个指针指向同一个对象，当指向对象的最后一个shared_ptr销毁时，该对象也就会自动销毁。</p><a id="more"></a><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>它的很多操作与unique_ptr类似。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp;<span class="comment">//声明一个指向int类型的智能指针</span></span><br><span class="line">sp.reset(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>));</span><br><span class="line"><span class="keyword">auto</span> sp1 = make_shared&lt;<span class="built_in">string</span>&gt;(<span class="string">"hello"</span>);<span class="comment">//sp1是一个智能指针</span></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span> <span class="title">sp2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>);</span></span></span><br></pre></td></tr></table></figure></p><p>而make_shared方式是推荐的一种，它使用一次分配，比较安全。</p><h2 id="那些操作会改变计数"><a href="#那些操作会改变计数" class="headerlink" title="那些操作会改变计数"></a>那些操作会改变计数</h2><p>我们都知道，当引用计数为0时，shared_ptr所管理的对象自动销毁，那么那些情况会影响引用计数呢？</p><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto sp = make_shared&lt;int&gt;(1024);//sp的引用计数为1</span><br></pre></td></tr></table></figure></p><p>再比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto sp1 = make_shared&lt;string&gt;(&quot;obj1&quot;);</span><br><span class="line">auto sp2 = make_shared&lt;string&gt;(&quot;obj2&quot;);</span><br><span class="line">auto sp1 = sp2;</span><br></pre></td></tr></table></figure></p><p>该操作会减少sp1的引用计数，增加sp2的引用计数。有的人可能不理解，为什么这样还会减少sp1的引用计数？</p><p>试想一下，sp1指向对象obj1，sp2指向对象obj2，那么赋值之后，sp1也会指向obj2，那就是说指向obj1的就少了，指向obj2的就会多，如果此时没有其他shared_ptr指向obj1，那么obj1将会销毁。</p><h4 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h4><p>例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sp2 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">1024</span>);</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sp1</span><span class="params">(sp2)</span></span>;</span><br></pre></td></tr></table></figure></p><p>该操作会使得sp1和sp2都指向同一个对象。</p><p>而关于拷贝比较容易忽略的就是作为参数传入函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sp2 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">1024</span>);</span><br><span class="line">func(sp2);<span class="comment">//func的执行会增加其引用计数</span></span><br></pre></td></tr></table></figure></p><p>可以看一个具体的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来源：公众号编程珠玑</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func0</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"fun0:"</span>&lt;&lt;sp.use_count()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; &amp;sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"fun1:"</span>&lt;&lt;sp.use_count()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sp = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">1024</span>);</span><br><span class="line">    func0(sp);</span><br><span class="line">    func1(sp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其运行输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun0:2                                                    </span><br><span class="line">fun1:1</span><br></pre></td></tr></table></figure></p><p>很显然，fun0，拷贝了shard_ptr sp，而fun1，并没有拷贝，因此前者会增加引用计数，而后者并不影响。关于参数传值的问题，可以参考《<a href="https://www.yanbinghu.com/2019/06/20/53981.html">传值与传指针</a>》和《令人疑惑的引用和指针》。</p><h4 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h4><p>调用reset会减少计数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.reset()</span><br></pre></td></tr></table></figure></p><p>而如果sp是唯一指向该对象的，则该对象被销毁。</p><h2 id="应当注意使用的方式"><a href="#应当注意使用的方式" class="headerlink" title="应当注意使用的方式"></a>应当注意使用的方式</h2><p>虽然shared_ptr能很大程度避免内存泄漏，但是使用不当，仍然可能导致意外发生。</p><h4 id="存放于容器中的shared-ptr"><a href="#存放于容器中的shared-ptr" class="headerlink" title="存放于容器中的shared_ptr"></a>存放于容器中的shared_ptr</h4><p>如果你的容器中存放的时shared_ptr，而你后面又不再需要它时，记得使用erase删除那些不要的元素，否则由于引用计数一直存在，其对象将始终得不到销毁，除非容器本身销毁。</p><h4 id="不要使用多个裸指针初始化多个shared-ptr"><a href="#不要使用多个裸指针初始化多个shared-ptr" class="headerlink" title="不要使用多个裸指针初始化多个shared_ptr"></a>不要使用多个裸指针初始化多个shared_ptr</h4><p>注意，下面方式是不该使用的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *p = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">sp1</span><span class="params">(p)</span></span>;</span><br><span class="line">    <span class="comment">/*不要这样做！！*/</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">sp2</span><span class="params">(p)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样会导致两个shared_ptr管理同一个对象，当其中一个被销毁时，其管理的对象会被销毁，而另外一个销毁时，对象会二次销毁，然而实际上，对象已经不在了，最终造成严重后果。</p><p>而与这种情况类似的，就是使用get()获取裸指针，然后去初始化另外一个shared_ptr，或者delete get返回的指针：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sp = <span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">"wechat:shouwangxiansheng"</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *p = sp.get();</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">sp2</span><span class="params">(p)</span></span>;<span class="comment">/*不要这样做!!*/</span></span><br><span class="line">    <span class="keyword">delete</span> p;<span class="comment">/*不要这样做*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="如果对象不是new分配的，请传递删除器"><a href="#如果对象不是new分配的，请传递删除器" class="headerlink" title="如果对象不是new分配的，请传递删除器"></a>如果对象不是new分配的，请传递删除器</h4><p>与unique_ptr类似，它可以指定删除器，默认是使用delete。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myClose</span><span class="params">(<span class="keyword">int</span> *fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    close(*fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> socketFd = <span class="number">10</span>;<span class="comment">//just for example</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">up</span><span class="params">(&amp;socketFd,myClose)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="与unique-ptr的区别"><a href="#与unique-ptr的区别" class="headerlink" title="与unique_ptr的区别"></a>与unique_ptr的区别</h2><p>首先最明显的区别自然是它们一个是专享对象，一个是共享对象。而正是由于共享，包括要维护引用计数等，它带来的开销相比于unique_ptr来说要大。</p><p>另外，shared_ptr无法直接处理数组，因为它使用delete来销毁对象，而对于数组，需要用delete[]。因此，需要指定删除器：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/来源：公众号【编程珠玑】</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sp = <span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">"wechat:shouwangxiansheng"</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *p = sp.get();</span><br><span class="line">    <span class="comment">//std::shared_ptr&lt;int&gt; sp1(new int[10]);//不能这样</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>],[](<span class="keyword">int</span> *p)&#123;<span class="keyword">delete</span>[] p;&#125;)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>示例中使用了lambda表达式。</p><p>不过一般来说，好好的容器不用，为什么要用动态数组呢？</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是shared_ptr基本内容，一般来说，规范使用shared_ptr能很大程度避免内存泄露。注意，shared_ptr提供，*，-&gt;操作，不直接提供指针运算和[]。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《&lt;a href=&quot;https://www.yanbinghu.com/2019/11/07/11278.html&quot;&gt;C++11 unique_ptr&lt;/a&gt;》说到，如果有可能就使用unique_ptr，然后很多时候对象是需要共享的，因此shared_ptr也就会用得很多。shared_ptr允许多个指针指向同一个对象，当指向对象的最后一个shared_ptr销毁时，该对象也就会自动销毁。&lt;/p&gt;
    
    </summary>
    
      <category term="Cpp" scheme="https://www.yanbinghu.com/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://www.yanbinghu.com/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>更改默认缓冲类型</title>
    <link href="https://www.yanbinghu.com/2019/12/03/1372.html"/>
    <id>https://www.yanbinghu.com/2019/12/03/1372.html</id>
    <published>2019-12-03T14:00:00.000Z</published>
    <updated>2020-10-05T04:01:06.748Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇《<a href="https://www.yanbinghu.com/2019/12/01/27836.html">不可不知的缓冲类型</a>》中说到了三种缓冲类型，看起来很简单对不对？今天我们看看如何修改这些默认的缓冲类型，以及在实际中可能遇到哪些问题。<br><a id="more"></a></p><h2 id="更改缓冲类型"><a href="#更改缓冲类型" class="headerlink" title="更改缓冲类型"></a>更改缓冲类型</h2><p>在上一篇中说到了一些默认的缓冲类型，例如：</p><ul><li>指向终端设备的流是行缓冲的</li><li>标准错误是不带缓冲的</li><li>指向文件的流是全缓冲的</li><li>……</li></ul><p>那么这些默认的缓冲类型如何修改？</p><p>有几个函数可以用来更改缓冲类型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE *stream, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuffer</span><span class="params">(FILE *stream, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setlinebuf</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE *stream,<span class="keyword">char</span> *buf, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure></p><p>参数说明如下：</p><ul><li>stream FILE *类型，文件指针</li><li>buf 缓冲区指针</li><li>mode 缓冲模式，包括_IOFBF（全缓冲），_IOLBF（行缓冲），_IONBF（不带缓冲）</li><li>size 缓冲区大小</li></ul><p>这里有四个相关函数，作用类似，只是修改范围不一。<br>setbuf函数中，如果buf设置为NULL，则缓冲关闭；否则指向长度为BUFSIZ长度的缓冲区，并且是行缓冲。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//网址：https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"bianchengzhuji"</span>);</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过设置stdout（标准输出）的第二个参数为NULL，将其变成了不带缓冲，因此你运行后发现，printf的打印会立即显示在终端。</p><p>当然你也可以通过setvbuf，如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//网址：https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"bianchengzhuji"</span>);</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里设置为不带缓冲，则会忽略buf和size参数。设置为全缓冲或者行缓冲的时候。并且buf为NULL，会使用合适长度的系统buffer，否则使用用户自定义buffer。</p><p>缓冲区的设置就介绍到这里。</p><h2 id="fputs没有及时输出"><a href="#fputs没有及时输出" class="headerlink" title="fputs没有及时输出"></a>fputs没有及时输出</h2><p>其实在有了前面的基础之后，很多问题就迎刃而解了。<br>看看下面的例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//网址：https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//setbuf(stdout,NULL);</span></span><br><span class="line">    fputc(<span class="string">'a'</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>比如你就想输出一个字符，就打印到终端，但是按照上面的方法，字符并不会被及时输出到终端，因此它默认是行缓冲的。打开注释行，设置为不带缓冲就可以了。</p><h2 id="printf打印的日志没有输出"><a href="#printf打印的日志没有输出" class="headerlink" title="printf打印的日志没有输出"></a>printf打印的日志没有输出</h2><p>不知道你有没有遇到过这样的情况，准备调试某一个bug，发现每次运行到某个地方，打印就结束了，然后就挂了，让你误以为程序执行到打印的地方就结束了，然而有可能程序执行到后面，只是由于打印是行缓冲的，导致部分打印没有出来，很可能就是你没有加上换行符打印而已。</p><p>这时候你可以设置为不带缓冲，或者关键位置fflush，或者打印记得加上换行符。</p><p>当然你还可以用GDB，参考《<a href="https://www.yanbinghu.com/2019/04/20/41283.html">GDB调试指南</a>》。</p><h2 id="fflush之后文件还是丢失了"><a href="#fflush之后文件还是丢失了" class="headerlink" title="fflush之后文件还是丢失了"></a>fflush之后文件还是丢失了</h2><p>看完前面的内容之后，是不是觉得豁然开朗了？别高兴的太早。</p><p>以上措施并不是万事大吉。</p><p>你可能会踩到什么坑？</p><ul><li>文件内容写完后，fflush了，内容也有了，然后完成后，系统马上复位，复位起来后，文件内容还是丢失了</li><li>解压一个压缩包，解压成功，系统复位后，还是发现文件大小为0，文件丢失了</li></ul><p>如果你目前还没有遇到过这样的问题，那么你就需要格外注意了。</p><p>虽然前面fflush等措施将缓冲区的内容进行了I/O操作，但是操作系统还需要将文件系统的buffer写入磁盘，因此，如果此时直接复位会导致文件丢失！</p><p>怎么办呢？可以使用</p><ul><li>fsync/sync函数</li><li>sync命令</li></ul><p>以上函数或者命令强制将文件系统的buffer写入磁盘，但是根据内容大小不一而需要不一样的时间。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>理解缓冲区的概念会让你在编程中受益无穷。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇《&lt;a href=&quot;https://www.yanbinghu.com/2019/12/01/27836.html&quot;&gt;不可不知的缓冲类型&lt;/a&gt;》中说到了三种缓冲类型，看起来很简单对不对？今天我们看看如何修改这些默认的缓冲类型，以及在实际中可能遇到哪些问题。&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="https://www.yanbinghu.com/categories/C/"/>
    
    
      <category term="C" scheme="https://www.yanbinghu.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>三种缓冲类型</title>
    <link href="https://www.yanbinghu.com/2019/12/01/27836.html"/>
    <id>https://www.yanbinghu.com/2019/12/01/27836.html</id>
    <published>2019-12-01T13:30:00.000Z</published>
    <updated>2020-10-05T04:01:06.748Z</updated>
    
    <content type="html"><![CDATA[<p>今天来说说缓冲的事。也许你已经听说过三种缓冲模式，但是今天要讲的不止这些。<br><a id="more"></a></p><h2 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h2><p>为了减少使用read和write调用的次数，标准IO库提供了缓冲，有人可能会问，为什么要减少它们的调用次数？很明显read和write是系统调用，它们花费的时间将会更多，本文不展开描述，可以参考《<a href="https://www.yanbinghu.com/2018/05/28/26708.html">库函数和系统调用</a>》。那么有哪三种缓冲类型呢？</p><h2 id="全缓冲"><a href="#全缓冲" class="headerlink" title="全缓冲"></a>全缓冲</h2><p>在全缓冲的情况下，在填满标准I/O缓冲区后，才进行实际的I/O操作。写磁盘文件通常就是全缓冲的。举个例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">博客：https://www.yanbinghu.com</span></span><br><span class="line"><span class="comment">buff.c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*以可读可写的方式打开*/</span></span><br><span class="line">    FILE *fp = fopen(<span class="string">"./test.txt"</span>,<span class="string">"w+"</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == fp)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open file failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*写入内容*/</span></span><br><span class="line">    <span class="keyword">char</span> buf[] = <span class="string">"wechat:shouwangxiansheng\n"</span>;</span><br><span class="line">    fwrite(buf,<span class="keyword">sizeof</span>(<span class="keyword">char</span>),<span class="keyword">sizeof</span>(buf),fp);</span><br><span class="line">    <span class="comment">//fflush(fp);</span></span><br><span class="line">    <span class="comment">/*sleep一段时间，以便观察*/</span></span><br><span class="line">    sleep(<span class="number">20</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们编译并运行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -o buff buff.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./buff</span></span><br></pre></td></tr></table></figure></p><p>此时观察test.txt：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.txt</span><br></pre></td></tr></table></figure></p><p>发现它的内容是空。</p><p>原因在于它默认是全缓冲的，因此在将内容写入文件后，并没有直接存在文件中，当程序关闭文件或者程序运行完成退出后，再次查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.txt</span><br><span class="line">wechat:shouwangxiansheng</span><br></pre></td></tr></table></figure></p><p>发现文件已经有了内容。</p><p>除了等待程序运行完成，还可以使用fflush函数，它可以将缓冲区中的内容写入到磁盘中（终端驱动设备表示丢弃缓冲区的数据）。</p><p>所以将fwrite下面一行的注释去掉后，就可以发现，写入之后，就可以直接在文件中看到内容了。</p><p>所以当你在写一个文件，但是查看文件却没有任何写入内容时，不要一直怀疑自己的代码。</p><h2 id="行缓冲"><a href="#行缓冲" class="headerlink" title="行缓冲"></a>行缓冲</h2><p>行缓冲指的是当遇到换行符时，或者缓冲区已经满了（一般1024字节），标准I/O库执行I/O操作。同样举个例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">博客：https://www.yanbinghu.com</span></span><br><span class="line"><span class="comment">lineBuff.c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wechat:shouwangxiansheng"</span>);</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译运行上面的程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o lineBuff lineBuff.c</span><br><span class="line">$ ./lineBuff</span><br></pre></td></tr></table></figure></p><p>你会发现，printf执行完了之后，内容并没有马上输出到终端，而是在程序运行完之后才输出。</p><p>聪明的你当然也知道，要想打印完后直接输出到终端，只需要改成下面这样就可以了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"wechat:shouwangxiansheng\n"</span>);</span><br></pre></td></tr></table></figure></p><h2 id="不带缓冲"><a href="#不带缓冲" class="headerlink" title="不带缓冲"></a>不带缓冲</h2><p>这个从字面就可以理解其意思了。同样举个例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">博客：https://www.yanbinghu.com</span></span><br><span class="line"><span class="comment">noBuff.c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"wechat:shouwangxiansheng"</span>);</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译运行你就会发现，运行完fprintf语句后，内容直接输出在终端，而不需要等到换行。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的一些例子，我们也发现了这样一些规律：</p><ul><li>通常磁盘上的文件是全缓冲区的</li><li>标准输入和标准输入通常是行缓冲的</li><li>指向终端设备的流通常是行缓冲，而指向文件时，则是全缓冲</li><li>为了尽可能显示错误信息，标准错误是不带缓冲的</li></ul><p>当然这还没有完，下一篇将带你踩更多的坑。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来说说缓冲的事。也许你已经听说过三种缓冲模式，但是今天要讲的不止这些。&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="https://www.yanbinghu.com/categories/C/"/>
    
    
      <category term="C" scheme="https://www.yanbinghu.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>单例运行-C语言实现</title>
    <link href="https://www.yanbinghu.com/2019/11/28/46317.html"/>
    <id>https://www.yanbinghu.com/2019/11/28/46317.html</id>
    <published>2019-11-28T13:30:00.000Z</published>
    <updated>2020-10-05T04:01:06.748Z</updated>
    
    <content type="html"><![CDATA[<p>有些程序我们希望在一台机器上只有一个实例在运行，我在windows下也遇到过很多类似这样的程序，如QQ，它只允许同时运行一个。那么我们在Linux该如何实现这样的单例运行的程序呢？<br><a id="more"></a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>实现这样的程序方法很多，但是总体思路都是类似的：</p><ul><li>1.启动程序，检测标志，判断是否有同样的程序运行，是则2，否则3</li><li>2.程序退出</li><li>3.程序启动，并设置标志，以便下次启动时检测</li></ul><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>按照这种思路，实现的方法有很多种，例如使用ps等命令获取该进程的进程数，大于0 表示已有运行；启动后写一个临时文件，如果下次启动时发现有该文件，则直接退出；创建一个文件并加锁，退出时删除文件，新的程序启动时试图加锁，如果失败，则说明已有实例运行……</p><p>除了上面说到的这些，可能还有一些其他的实际做法，但是本文介绍一种实用并且也是非常通用的做法，即文件锁的方法。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>程序在启动后，打开一个program.pid文件（无则创建），然后试图去设置文件锁（如果还不理解锁的概念，可以简单理解为，一旦a写锁定了，b就无法进一步写操作了，除非a释放锁），如果设置成功，就将该程序的进程ID写入该文件；如果加锁失败，那么说明已经有另外一个实例在运行了，则退出此次启动。而当前已经运行的程序如果退出了，该文件会自动解除锁定。</p><p>实际上，我们观察一下/var/run/目录下，有很多类似这样的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /var/run/*.pid</span><br><span class="line">-rw-r--r-- 1 root root 5 11月 24 08:19 /var/run/acpid.pid</span><br><span class="line">-rw-r--r-- 1 root root 5 11月 24 08:19 /var/run/atd.pid</span><br><span class="line">-rw-r--r-- 1 root root 5 11月 24 08:19 /var/run/crond.pid</span><br><span class="line">-rw-r--r-- 1 root root 5 11月 24 09:08 /var/run/dhclient-wlp3s0.pid</span><br><span class="line">-rw-r--r-- 1 root root 4 11月 24 08:19 /var/run/docker.pid</span><br></pre></td></tr></table></figure></p><p>不过这个位置通常只有root用户能够写入。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在看代码实现之前，先看下文件锁（记录锁）和fcntl函数。<br>flock结构至少包含以下字段：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flock</span> &#123;</span></span><br><span class="line">    short l_type; <span class="comment">/*锁类型 F_RDLCK,F_WRLCK, F_UNLCK*/</span></span><br><span class="line">    short l_whence;  <span class="comment">/* 偏移开始的位置 SEEK_SET, SEEK_CUR, SEEK_END */</span></span><br><span class="line">    <span class="keyword">off_t</span> l_start;   <span class="comment">/* 开始锁定区域*/</span></span><br><span class="line">    <span class="keyword">off_t</span> l_len;     <span class="comment">/* 锁定字节数 */</span></span><br><span class="line">    <span class="keyword">pid_t</span> l_pid;     <span class="comment">/* 记录锁的进程ID*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>从结构体成员可以看到，它不仅可以锁整个文件，还可以锁某个区域，但是本文仅用于锁定整个文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* arg */</span></span></span></span><br></pre></td></tr></table></figure><p>fcntl函数的cmd选项也很多，本文只用到F_SETLK（或F_SETLKW，），即设置锁。<br>结合以上两者，参考代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//博客：https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROC_NAME <span class="meta-string">"single_instance"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PID_FILE_PATH <span class="meta-string">"/var/run/"</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lockFile</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *procname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*判断是否已经有实例在运行*/</span></span><br><span class="line">    <span class="keyword">if</span>(isRunning(PROC_NAME))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"run ok\n"</span>);</span><br><span class="line">    sleep(<span class="number">20</span>);<span class="comment">//避免程序立即退出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*锁文件还可以使用flock，目的是类似的。不过是它是BSD系统调用，并且某些版本不支持NFS，出于移植性考虑，使用fcntl*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lockFile</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">fl</span>;</span></span><br><span class="line">    fl.l_type   = F_WRLCK;<span class="comment">//设置写锁</span></span><br><span class="line">    fl.l_start  = <span class="number">0</span>;</span><br><span class="line">    fl.l_whence = SEEK_SET;</span><br><span class="line">    fl.l_len    = <span class="number">0</span>;</span><br><span class="line">    fl.l_pid = <span class="number">-1</span>;<span class="comment">//锁定文件，设置为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(fcntl(fd, F_SETLK, &amp;fl));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *procname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(filename, <span class="string">"%s%s.pid"</span>,PID_FILE_PATH,procname);</span><br><span class="line">    <span class="keyword">int</span> fd = open(filename, O_CREAT|O_RDWR );<span class="comment">//可读可写，不存在时创建</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"open file %s failed!\n"</span>, filename);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == lockFile(fd)) <span class="comment">/*尝试加锁*/</span></span><br><span class="line">    &#123;                                                  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s is already running\n"</span>, procname);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        ftruncate(fd, <span class="number">0</span>);<span class="comment">/*截断文件，重新写入pid*/</span></span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">"%ld"</span>, (<span class="keyword">long</span>)getpid());</span><br><span class="line">        write(fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o single_instance single_instance.c</span><br><span class="line">$ ./single_instance  #注意root权限运行，或者调整pid文件位置</span><br><span class="line">run ok</span><br></pre></td></tr></table></figure><p>查看pid文件目录下已经有了pidfile：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al /var/run/single_instance.pid</span><br><span class="line">-rw-r--r-- 1 root root 6 11月 24 11:36 /var/run/single_instance.pid</span><br></pre></td></tr></table></figure></p><p>在另外一个终端再次尝试运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./single_instance</span><br><span class="line">single_instance is already running</span><br></pre></td></tr></table></figure></p><p>如果你想控制同一个目录下的bin文件只能运行一个，那么可以设置pid文件的位置为当前目录。</p><p>这种方式有什么特点呢：</p><ul><li>简单可靠</li><li>可读可见，相比于信号量或共享内存，它更容易观察</li><li>无性能要求，启动时加锁，结束释放。</li><li>一旦出现异常没有释放，也可以手动删除文件</li></ul><p>当然对于BSD系统，还可以使用下面的接口来完成：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">pidfh</span> *</span></span><br><span class="line"><span class="class">     <span class="title">pidfile_open</span>(<span class="title">const</span> <span class="title">char</span> *<span class="title">path</span>, <span class="title">mode_t</span> <span class="title">mode</span>, <span class="title">pid_t</span> *<span class="title">pidptr</span>);</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pidfile_write</span><span class="params">(struct pidfh *pfh)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pidfile_close</span><span class="params">(struct pidfh *pfh)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pidfile_remove</span><span class="params">(struct pidfh *pfh)</span></span>;</span><br></pre></td></tr></table></figure></p><p>本文就不过多介绍了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单例运行的基本原理是类似的，而pid文件是一种常见的单例运行的方式，很多知名的开源组件都是使用类似的方式。对于shell脚本，还可以使用flock命令进行类似的操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有些程序我们希望在一台机器上只有一个实例在运行，我在windows下也遇到过很多类似这样的程序，如QQ，它只允许同时运行一个。那么我们在Linux该如何实现这样的单例运行的程序呢？&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="https://www.yanbinghu.com/categories/C/"/>
    
    
      <category term="C" scheme="https://www.yanbinghu.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>dd命令详解--磁盘读写测试</title>
    <link href="https://www.yanbinghu.com/2019/11/25/51682.html"/>
    <id>https://www.yanbinghu.com/2019/11/25/51682.html</id>
    <published>2019-11-25T14:00:00.000Z</published>
    <updated>2020-10-05T04:01:06.756Z</updated>
    
    <content type="html"><![CDATA[<p>有时候需要测试磁盘读写速度，或者临时读写文件，不想临时写代码？有没有测试使用的命令？当然有！<br><a id="more"></a></p><h2 id="dd命令"><a href="#dd命令" class="headerlink" title="dd命令"></a>dd命令</h2><p>dd命令可以用于文件的拷贝或者内容转换。常见操作选项如下：</p><ul><li>bs=BYTES  一次读写字节数</li><li>ibs=BYTES 一次读的字节数</li><li>obs=BYTES 一次写的字节数</li><li>cbs=BYTES 一次转换的字节数</li><li>count=N 读写次数</li><li>of=FILE  将内容写到FILE，默认写入标准输出</li><li>if=FILE  从FILE中读取，默认从标准输入读取</li><li>conv=CONVS 转换标志</li></ul><p>更多选项可查看man手册。</p><p>来看一些实例。</p><h2 id="将文件的内容进行大小写转换"><a href="#将文件的内容进行大小写转换" class="headerlink" title="将文件的内容进行大小写转换"></a>将文件的内容进行大小写转换</h2><p>加入文件test.txt中有以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shouwangxiansheng</span><br></pre></td></tr></table></figure></p><p>现在要将内容转换为大写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ dd if=test.txt of=utest.txt conv=ucase</span><br><span class="line">0+1 records in</span><br><span class="line">0+1 records out</span><br><span class="line">18 bytes copied, 0.0123523 s, 1.5 kB/s</span><br></pre></td></tr></table></figure></p><p>执行完成后，再看看utest.txt中的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOUWANGXIANSHEN</span><br></pre></td></tr></table></figure></p><p>看到没，已经将所有内容转换为大写了。<br>当然还有其他方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.txt | tr &apos;a-z&apos; &apos;A-Z&apos; &gt; utest.txt</span><br></pre></td></tr></table></figure></p><p>解释一下，conv=ucase，表示转换操作是转换为大写，你还可以使用：</p><ul><li>lcase 转换为小写</li><li>ucase 转换为大写</li><li>swab 相邻字节交换</li></ul><h2 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h2><p>例如将test.txt文件内容拷贝到test0.txt文件，每次拷贝1024字节：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dd if=test.txt of=test0.txt bs=1024</span><br></pre></td></tr></table></figure></p><p>读取指定次数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  dd if=a of=b bs=1024 count=10 #读取10次</span><br></pre></td></tr></table></figure></p><p>跳过指定块大小开始读取：<br>假设ibs=1，那么，每次读取1字节，而skip=4，则会从第五个字节开始读取：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=test.txt of=test0.txt ibs=1 skip=4</span><br></pre></td></tr></table></figure></p><p>得到内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$cat test0.txt</span><br><span class="line">wangxiansheng</span><br></pre></td></tr></table></figure></p><p>那如果要从指定位置开始写呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=test.txt of=test0.txt obs=1 seek=5</span><br></pre></td></tr></table></figure></p><p>这些写入的内容就会从test0.txt的第六个字节开始写，而会保留前面的5个字节。</p><p>注意，由于这里我设置了ibs或者obs为1，所以skip和seek的单位都是字节，但是如果前面设置的是如1M，那么跳过的就是N兆了。</p><h2 id="生成随机文件"><a href="#生成随机文件" class="headerlink" title="生成随机文件"></a>生成随机文件</h2><p>还记得在《<a href="https://www.yanbinghu.com/2019/11/20/49894.html">Linux字符设备文件</a>》中提到的特殊字符文件吗？结合dd命令，我们可以生成一些随机内容的文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dd if=/dev/urandom of=temp.txt count=2</span><br></pre></td></tr></table></figure></p><p>执行之后就会读取2个块大小的数据到temp.txt中。</p><h2 id="磁盘读写测试"><a href="#磁盘读写测试" class="headerlink" title="磁盘读写测试"></a>磁盘读写测试</h2><p>由于dd命令每次执行完成后都会显示其速度，因此可以利用它来测试当前的磁盘读写情况。<br>这里还有一个选项oflag=FLAGS用来设置一些读写方式，FLAG常见选项有：</p><ul><li>direct 使用直接IO</li><li>nonblock 使用非阻塞IO</li><li>noatime 不更新访问时间</li><li>nocache  丢弃缓存</li><li>sync   读写一次就写到磁盘</li><li>fsync 最后要写到磁盘</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ dd if=/dev/urandom of=testfile count=100 oflag=sync</span><br><span class="line">100+0 records in</span><br><span class="line">100+0 records out</span><br><span class="line">51200 bytes (51 kB, 50 KiB) copied, 0.0011526 s, 44.4 MB/s</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>dd命令可用于文件拷贝，文件内容大小写转换，磁盘读写测试等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候需要测试磁盘读写速度，或者临时读写文件，不想临时写代码？有没有测试使用的命令？当然有！&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="https://www.yanbinghu.com/categories/linux/"/>
    
    
      <category term="linux" scheme="https://www.yanbinghu.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>printf打印保存在文件中</title>
    <link href="https://www.yanbinghu.com/2019/11/21/44978.html"/>
    <id>https://www.yanbinghu.com/2019/11/21/44978.html</id>
    <published>2019-11-21T14:00:00.000Z</published>
    <updated>2020-10-05T04:01:06.748Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道，一般使用printf的打印都会直接打印在终端，如果想要存储在文件里呢？我想你可能想到的是重定向。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ program &gt; result.txt</span><br></pre></td></tr></table></figure></p><p>这样printf的输出就存储在result.txt中了。相关内容可以参考《<a href="https://www.yanbinghu.com/2018/10/26/9186.html">如何理解Linux shell中“2&gt;&amp;1”</a>》。<br><a id="more"></a><br>当然了，如果你既想打印在终端，又想保存在文件，还可以使用tee命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">program | tee result.txt</span><br></pre></td></tr></table></figure></p><p>注：program为你运行的程序。</p><p>不过文本介绍了不是通过命令行的方式，而是通过代码实现。</p><h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><p>你可能会想，那不用printf，直接将打印写入到文件不就可以了？类似于下面这样：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来源：公众号编程珠玑 网站：https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">"log.txt"</span>,<span class="string">"w+"</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == fp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"open failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(fp,<span class="string">"test content %d\n"</span>,a);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不过这需要将原先的printf改用fprintf，修改了最原始的代码。但是本文并不是说明如何实现一个logging功能，而是​如何将printf的原始打印保存在文件中。​</p><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>实际上，我们的程序在运行起来后，都会有三个文件描述符：</p><ul><li>0  标准输入</li><li>1  标准输出</li><li>2  标准错误</li></ul><p>一般标准输出都是都直接输出到终端。</p><p>我们可以用一个程序简单观察一下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sleep(<span class="number">20</span>);<span class="comment">//为了避免立即退出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假设编译出来的程序为test：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o test test.c</span><br><span class="line">$ ./test &amp;</span><br><span class="line">$ ls -l /proc/`pidof test`/fd</span><br></pre></td></tr></table></figure></p><p>这里关于proc文件系统可以参考《<a href="https://www.yanbinghu.com/2018/11/18/43716.html">Linux中不可错过的信息宝库</a>》，pidof test用于获取test进程id，其fd目录可以看到打开的文件描述符，关于文件打开可以参考《查看文件打开的多种方式》。<br>其输出结果如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lrwx------ <span class="number">1</span> root root <span class="number">64</span> Nov <span class="number">16</span> <span class="number">16</span>:<span class="number">26</span> <span class="number">0</span> -&gt; /dev/pts/<span class="number">0</span></span><br><span class="line">lrwx------ <span class="number">1</span> root root <span class="number">64</span> Nov <span class="number">16</span> <span class="number">16</span>:<span class="number">26</span> <span class="number">1</span> -&gt; /dev/pts/<span class="number">0</span></span><br><span class="line">lrwx------ <span class="number">1</span> root root <span class="number">64</span> Nov <span class="number">16</span> <span class="number">16</span>:<span class="number">26</span> <span class="number">2</span> -&gt; /dev/pts/<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>看到了吗，0，1，2都重定向到了/dev/pts/0，其实就是当前终端（参考《》）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tty</span><br><span class="line">/dev/pts/0</span><br></pre></td></tr></table></figure></p><p>所以如果我们要将printf的打印保存到文件中，实际上就让它重定向到这个文件就可以了。这里我们用到freopen函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *mode, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure></p><p>参数说明：</p><ul><li>path：需要重定向到的文件名或文件路径。</li><li>mode：代表文件访问权限的字符串。例如，”r”表示“只读访问”、”w”表示“只写访问”、”a”表示“追加写入”。</li><li>stream：需要被重定向的文件流。</li></ul><p>那么要完成前面的任务也就很简单了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp = freopen(<span class="string">"test.log"</span>,<span class="string">"w+"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == fp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"reopen failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"bianchengzhuji\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"shouwangxiansheng\n"</span>);</span><br><span class="line">    sleep(<span class="number">20</span>);<span class="comment">//便于观察</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重新编译后运行查看其打开的文件描述符：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lrwx------ <span class="number">1</span> root root <span class="number">64</span> Nov <span class="number">16</span> <span class="number">16</span>:<span class="number">34</span> <span class="number">0</span> -&gt; /dev/pts/<span class="number">0</span></span><br><span class="line">lrwx------ <span class="number">1</span> root root <span class="number">64</span> Nov <span class="number">16</span> <span class="number">16</span>:<span class="number">34</span> <span class="number">1</span> -&gt; /data/workspaces/test.<span class="built_in">log</span></span><br><span class="line">lrwx------ <span class="number">1</span> root root <span class="number">64</span> Nov <span class="number">16</span> <span class="number">16</span>:<span class="number">34</span> <span class="number">2</span> -&gt; /dev/pts/<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>看到了吗，它现在重定向到test.log了，并且终端也没有printf的打印。随后我们也在文件test.log中看到了下面的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bianchengzhuji</span><br></pre></td></tr></table></figure></p><p>有人可能会有下面的疑问：</p><ul><li>怎么恢复？</li><li>为什么要这样做？</li></ul><p>首先来看怎么恢复，实际上恢复的原理是类似的，既然最开始它从定向到了/dev/pts/0，那么我们只需要重定向回去就可以了，但是在不同的终端，它的tty名字可能不同，因此需要使用ttyname函数获取原先stdout的tty名字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int ttyname_r(int fd, char *buf, size_t buflen);</span><br></pre></td></tr></table></figure></p><p>又可以重新定向到/dev/pts/0了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ttyName[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ttyname_r(<span class="built_in">stdin</span>,ttyName,<span class="number">128</span>);</span><br><span class="line">    FILE *fp = freopen(<span class="string">"test.log"</span>,<span class="string">"w+"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == fp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"reopen failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"bianchengzhuji\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"shouwangxiansheng\n"</span>);</span><br><span class="line">    sleep(<span class="number">20</span>);</span><br><span class="line">    freopen(ttyName,<span class="string">"w+"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"std out to %s\n"</span>,ttyName);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最终运行会发现两个结果：</p><ul><li>std out to 打印到终端</li><li>打开的文件描述符1被重定向到/dev/pts/0</li></ul><p>除了上面这种方式，还有一种方式是使用dup2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int dup2(int oldfd, int newfd);</span><br></pre></td></tr></table></figure></p><p>它是用来复制文件描述符的，会使得newfd成为oldfd的副本.所以与上面看到不同的是，标准输出和往fd写入的内容，都会存储在文件test.log中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"test.log"</span>,O_WRONLY|O_CREAT);</span><br><span class="line">    dup2(fd,<span class="number">1</span>);<span class="comment">//1代表标准输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"bianchengzhuji\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"shouwangxiansheng\n"</span>);</span><br><span class="line">    sleep(<span class="number">20</span>);</span><br><span class="line">close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>观察的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lrwx------ 1 root root 64 Nov 17 17:03 0 -&gt; /dev/pts/0</span><br><span class="line">l-wx------ 1 root root 64 Nov 17 17:03 1 -&gt; /data/workspaces/test.log</span><br><span class="line">lrwx------ 1 root root 64 Nov 17 17:03 2 -&gt; /dev/pts/0</span><br><span class="line">l-wx------ 1 root root 64 Nov 17 17:03 3 -&gt; /data/workspaces/test.log</span><br></pre></td></tr></table></figure></p><p>这种情况适合于将标准输出的内容和其他写文件的内容一并保存到文件中。</p><h2 id="如何关闭printf打印"><a href="#如何关闭printf打印" class="headerlink" title="如何关闭printf打印"></a>如何关闭printf打印</h2><p>实际上非常简单，进程启动后，只需要关闭文件描述符1（标准输出）,2（标准错误）​即可。什么情况下会需要呢？有些后台进程有自己的日志记录方式，而不想让printf的信息打印在终端，因此可能会关闭​。​</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文本旨在通过将printf的打印存储在文件中来介绍重定向，以及0，1，2文件描述符。如果你不想保留标准输出，可以将其重定向到/dev/null，如果想保留，且单独保留到特定文件，可以使用freopen，如果想保留，且和其他内容保留到同一文件，使用dup2。如果一行代码都不想动，使用命令行重定向。如果你完全不关心，当我啥都没说。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们都知道，一般使用printf的打印都会直接打印在终端，如果想要存储在文件里呢？我想你可能想到的是重定向。例如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ program &amp;gt; result.txt&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这样printf的输出就存储在result.txt中了。相关内容可以参考《&lt;a href=&quot;https://www.yanbinghu.com/2018/10/26/9186.html&quot;&gt;如何理解Linux shell中“2&amp;gt;&amp;amp;1”&lt;/a&gt;》。&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="https://www.yanbinghu.com/categories/C/"/>
    
    
      <category term="C" scheme="https://www.yanbinghu.com/tags/C/"/>
    
  </entry>
  
</feed>
