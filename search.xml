<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>计算机精品书单</title>
    <url>/2019/10/23/4999.html</url>
    <content><![CDATA[<p>经常有读者让我推荐书籍，这次我就把我私藏的计算机书单分享给你们！不过由于时间匆忙，不会进行更加详细的介绍。<br><a id="more"></a></p>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>由于每个人的情况不一样，推荐的书并不一定适合你，也不一定适合当前阶段的你，有的书籍可能存在内容重复，所以根据自己的阶段情况进行选择即可。虽说如此，以下书单中提单的书均为优质书籍。<br>另外说，本人从事的是Linux/C/C++应用开发相关工作，因此主要书籍与此相关，涉及操作系统，Linux，C/C++，网络，编译链接，算法，数据库等内容，其他方向的会提到，但可能不全，欢迎补充。</p>
<p>以下整理均来自公众号【编程珠玑】<br>作者：守望先生</p>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><ul>
<li>《C程序设计语言》（经典，不适合小白入门）</li>
<li>《C语言程序设计：现代方法》</li>
<li>《C primer plus》（入门推荐）</li>
<li>《C陷阱和缺陷》</li>
<li>《C专家编程》</li>
<li>《C和指针》（领悟指针精髓）</li>
<li>《C语言接口与实现》</li>
<li>《C11标准文档》（非书，可查阅）</li>
</ul>
<p>推荐文<a href>C语言必读</a></p>
<h2 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h2><ul>
<li>《C++ primer》（适合有一定基础）</li>
<li>《C++标准库》</li>
<li>《Effective Modern C++ 》</li>
<li>《more effective C++》</li>
<li>《深度探索C++对象模型》</li>
<li>《STL源码剖析》</li>
<li>《effective STL》</li>
<li>《C++ template》</li>
<li>《Exceptional C++》</li>
<li>《C++编程思想》</li>
<li>《C++语言的设计和演化》</li>
</ul>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><ul>
<li>《effective java》</li>
<li>《Java核心技术卷》（有两卷）</li>
<li>《Java语言程序设计》（有两卷）</li>
<li>《深入理解Java虚拟机》</li>
<li>《Java编程思想》（进阶）</li>
<li>《Java并发编程实战》</li>
</ul>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><ul>
<li>《ython编程 : 从入门到实践》</li>
<li>《A Byte of Python》（快速上手）</li>
<li>《Python编程快速上手》（适合完全零基础）</li>
<li>《流畅的Python》（非小白入门所选）</li>
<li>《Python Cookbook》</li>
</ul>
<h2 id="GO"><a href="#GO" class="headerlink" title="GO"></a>GO</h2><ul>
<li>《go程序设计语言》</li>
</ul>
<h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><ul>
<li>《编码：隐匿在计算机软硬件背后的语言》</li>
<li>《深入理解计算机系统》（强烈推荐）</li>
<li>《计算机程序的构造和解释》</li>
<li>《计算机组成与设计 : 硬件/软件接口》</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul>
<li>《算法导论》（大钻头，不易读）</li>
<li>《编程珠玑》</li>
<li>《算法》（相对易读）</li>
<li>《数据结构与算法分析-C语言描述》</li>
</ul>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ul>
<li>《计算机网络》</li>
<li>《计算机网络-自顶向下方法》</li>
<li>《TCP/IP详解-卷1》</li>
<li>《网络是怎样连接的》</li>
</ul>
<h2 id="编译链接"><a href="#编译链接" class="headerlink" title="编译链接"></a>编译链接</h2><ul>
<li>《编译原理》（龙书）</li>
<li>《程序员的自我修养-装载，链接和库》</li>
</ul>
<h2 id="操作系统-Linux"><a href="#操作系统-Linux" class="headerlink" title="操作系统/Linux"></a>操作系统/Linux</h2><ul>
<li>《现代操作系统》（中文版感觉有点晦涩）</li>
<li>《操作系统精髓与设计原理》</li>
<li>《操作系统概念》</li>
<li>《Linux内核设计与实现》（整体介绍，不如后面两本深入）</li>
<li>《深入理解Linux内核》</li>
<li>《深入Linux内核架构》（大砖头，讲解了Linux中关键部分）</li>
<li>《鸟哥的linux私房菜基础篇》（基础篇可入门Linux）</li>
<li>《Linux命令行与shell脚本编程大全》</li>
<li>《<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/index.html" target="_blank" rel="noopener">Linux Tools Quick Tutorial</a>》 （教程）</li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul>
<li>《Mysql必知必会》（超薄小册子）</li>
<li>《高性能Mysql》</li>
<li>《redis设计与实现》（学习里面的设计思路，数据结构与算法）</li>
<li>《数据库系统实现》</li>
</ul>
<h2 id="系统-网络编程"><a href="#系统-网络编程" class="headerlink" title="系统/网络编程"></a>系统/网络编程</h2><ul>
<li>《Unix环境高级编程》（APUE）（经典）</li>
<li>《Unix网络编程》（UNP）（两卷，经典）</li>
<li>《Linux/UNIX系统编程手册》</li>
</ul>
<h2 id="设计-软件工程"><a href="#设计-软件工程" class="headerlink" title="设计/软件工程"></a>设计/软件工程</h2><ul>
<li>《代码大全》</li>
<li>《代码整洁之道》</li>
<li>《程序员修炼之道》</li>
<li>《Unix编程艺术》</li>
<li>《重构》</li>
<li>《敏捷软件开发：原则、模式与实践》</li>
<li>《设计模式_可复用面向对象软件的基础》</li>
</ul>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul>
<li>《pro git》在线文档</li>
</ul>
<h2 id="工作面试"><a href="#工作面试" class="headerlink" title="工作面试"></a>工作面试</h2><ul>
<li>《编程之美——微软技术面试心得》</li>
<li>《剑指offer 名企面试官精讲典型编程题》</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>《浪潮之巅》</li>
<li>《黑客与画家》</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>书籍皆为好书，但不一定适合现阶段的你，请慎重选择。</li>
<li>非完整版，可继续关注阅读原文</li>
<li>后期进行更加详细的介绍。</li>
</ul>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>学Linux到底学什么</title>
    <url>/2019/09/25/14472.html</url>
    <content><![CDATA[<p>我们常常听到很多人说要学学Linux或者被人告知说应该学学Linux，那么学Linux到底要学什么？<br><a id="more"></a></p>
<h2 id="为什么要学Linux"><a href="#为什么要学Linux" class="headerlink" title="为什么要学Linux"></a>为什么要学Linux</h2><p>在回答学什么之前，我们先看看为什么要学。首先我们需要认识到的是，很多服务器使用的是Linux系统，而作为服务器应用程序的开发者或者维护者，如果不了解Linux的基本使用，该如何进行开发或者维护呢？</p>
<p>当然，也有可能你听说Linux更高大上，或者是说Linux对开发者更加友好（Windows用户把刀放下），这都是题外话了。</p>
<p>在我看来，学习Linux主要有以下两点原因</p>
<ul>
<li>使用<strong>标准C/C++</strong> 编写运行在Linux上的应用程序</li>
<li>编写部署在Linux上的应用程序，如Python，Java web服务程序</li>
<li>一探究竟。众所周知，Linux开源，windows并非如此。</li>
</ul>
<p>而对于Python，它有Python解释器，Java有Java虚拟机，他们实际上对Linux的需求是没有C/C++来的高。即便如此，Linux也是值得Python/Java开发者去学习的。</p>
<h2 id="Linux学习方向"><a href="#Linux学习方向" class="headerlink" title="Linux学习方向"></a>Linux学习方向</h2><p>那么一般说的学Linux是要学什么呢？方向不同，要学习的内容也不同，可以大致分为这么几个方向：</p>
<ul>
<li>运维，维护Linux服务器</li>
<li>应用开发，开发Linux应用程序</li>
<li>底层开发</li>
</ul>
<p>我本人是做Linux应用开发的，因此对于运维方向和底层方向不是很了解，这里仅简单说一下。</p>
<p>运维Linux主要需要学会对服务器的基本部署，监控，配置，管理等等， 你可以认为，这些机器归你管了，7*24小时保障它能正常提供服务（删库跑路就别做了），所以7月24日请对运维的朋友好点。也欢迎运维的朋友留言纠正或者补充我的说法。</p>
<p>底层开发需要了解uboot，文件系统，内核等底层相关内容，主要工作可能涉及文件系统裁剪，驱动开发，内核模块定制（如内存管理，进程调度）等等。底层开发总体来说要求比较高。</p>
<p>应用开发自然是需要学习如何开发在Linux上运行的应用程序，如何定位Linux应用程序问题等等。</p>
<h2 id="Linux应用开发学什么"><a href="#Linux应用开发学什么" class="headerlink" title="Linux应用开发学什么"></a>Linux应用开发学什么</h2><p>Linux的学习很多会以命令为主，因而初学会觉得枯燥甚至疑惑，鼠标点点点就能完成的事，为什么要劈里啪啦敲这么多？这里给出两点理由，也欢迎你补充：</p>
<ul>
<li>出于资源的考虑，绝大部分Linux服务器没有图形界面</li>
<li>命令行便于自动化，将一系列操作写入脚本，可代替手动操作</li>
</ul>
<p>而它的学习我把它分为这么几个阶段：</p>
<ul>
<li>基本使用</li>
<li>开发调试</li>
<li>系统认识</li>
</ul>
<p>这三个阶段对知识积累的要求不一样，但总体来说并没有严格的先后之分。</p>
<p>类于windows，当年你学习windows的时候学了什么？</p>
<ul>
<li>开关机？</li>
<li>安装卸载软件？如安装视频播放器，音乐播放器（为啥要安这玩意？）。</li>
<li>如何打开安装的软件？如打开浏览器上网，打开编辑器写文档</li>
<li>如何存放自己的资料？移动，创建，删除等等</li>
<li>如何使用office 办公软件</li>
<li>……</li>
</ul>
<p>是不是想想好像也没有特意地去学习？</p>
<p>那么对于学习Linux来说也是类似的，就是学会这些最普通的使用，</p>
<ul>
<li>如何开关机</li>
<li>如何上网</li>
<li>如何打开命令行</li>
<li>如何使用命令行安装卸载软件</li>
<li>如何编辑文本</li>
<li>如何创建，移动，删除文件</li>
<li>如何查看文件内容，解压缩文件</li>
<li>……</li>
</ul>
<p><strong>这个阶段最难的就是从图形界面到命令行的转换</strong>。</p>
<p>那么第二阶段呢，就需要学会：</p>
<ul>
<li>如何编写Linux应用程序</li>
<li>如何编译或者构建你的程序</li>
<li>如何运行你的程序</li>
<li>如何定位程序bug</li>
</ul>
<p>而第三阶段，则是一个需要漫长的学习过程，但都是为开发服务，包括：</p>
<ul>
<li>理解并践行一切皆文件</li>
<li>ELF文件，Linux主要可执行文件格式</li>
<li>Linux各大机制的基本原理，如进程调度，内存管理，虚拟内存，文件系统等，既然要写Linux应用程序，怎么能不了解它所在平台的主要机制呢？</li>
</ul>
<p>越是疑难问题，越需要这些最基本的知识。</p>
<h2 id="怎么学？"><a href="#怎么学？" class="headerlink" title="怎么学？"></a>怎么学？</h2><p>来到了大家最关心的问题了，同样的，每个人的情况不太一样，这里只给出我的个人建议。</p>
<p>关于第一阶段，你可以先定个小目标，例如<strong>一段时间内学会在Linux下进行你的日常活动（玩游戏就算了）</strong>，例如编写文档，看视频等等。同时建议：</p>
<ul>
<li>选择主流的发行版，如ubuntu，centos等，遇到问题时比较容易解决</li>
<li>在window下安装虚拟机，这样Linux环境就随你折腾了</li>
</ul>
<p>在这期间，你可能需要了解</p>
<ul>
<li>使用apt-get或者yum安装或卸载软件</li>
<li><a href="https://www.yanbinghu.com/2018/10/19/64149.html">使用tar,unzip,zip,gz等解压缩软件安装包</a></li>
<li>了解运行环境，学会如何执行命令</li>
</ul>
<p>这里的学习你可以通过网上搜索资料（视频教程或者博客文章）或者购买相关书籍进行操练。如果你不想安装虚拟机或者docker，你可以通过一些<a href="https://mp.weixin.qq.com/s?__biz=MzI2OTA3NTk3Ng==&amp;mid=2649285038&amp;idx=1&amp;sn=f26e510c7f6c718742297c21121f6b81&amp;chksm=f2f992c9c58e1bdfa37b5643ba1f163df5f139713de421fe7cba485027bc94473af4334c98b7&amp;token=1798491206&amp;lang=zh_CN#rd" target="_blank" rel="noopener">在线的Linux</a>来体验。</p>
<p>第二阶段也是主要的阶段，这一阶段要学习的东西非常多，多是命令的学习，这里同样可以参考《鸟哥的Linux私房菜-基础篇》。不过初期阶段建议抱着一个目的去学习，就是<strong>如何在Linux写一个完整的程序</strong>，为了达到这个目的你需要学习</p>
<ul>
<li>cd touch cp mv rm ls，find，切换目录，创建，复制，移动，删除，查看，查找等等</li>
<li>vi/vim 编写代码，这里有一个<a href="https://www.openvim.com/s" target="_blank" rel="noopener">在线练习网站</a></li>
<li>gcc编译代码，后期可能需要学习makefile，cmake等构建工具</li>
<li>版本管理，git也是当前必备的一个工具了，学习资料推荐<a href="https://progit.bootcss.com/" target="_blank" rel="noopener">pro git</a></li>
<li>gdb调试，可以参考《<a href="https://www.yanbinghu.com/2019/04/20/41283.html">GDB调试指南</a>》</li>
<li>问题定位，除了观察最基本的打印之外，还需要知道，<a href="https://www.yanbinghu.com/2018/04/06/53515.html">如何查看进程信息（ps）</a>，<a href="https://www.yanbinghu.com/2019/06/30/19183.html">如何查看网络连接信息（ss，netstat）</a>，如何强制停止进程（kill -9）<a href="https://www.yanbinghu.com/2019/03/05/61180.html">如何查看进程文件打开情况（lsof）</a>，<a href="https://www.yanbinghu.com/2018/10/05/61779.html">如何多种姿势查看文本文件（cat，tail，more，less）</a>等等。</li>
<li>脚本学习，学习Linux，就不得不学习shell脚本了，它在很多时候能毫无抱怨地帮你做事，前提是你会调教。《Linux命令行与shell脚本编程大全》也是调教教程之一。这里也有一些《<a href="https://www.yanbinghu.com/2019/05/07/53959.html">必备的shell知识</a>》</li>
</ul>
<p>这个过程涉及到的命令非常多，但是<strong>不建议每一个都去细学</strong>，首先<strong>知道有这么一个命令即可</strong>，然后需要的时候能够快速找到用法，如<a href="https://www.yanbinghu.com/2018/12/04/41455.html">通过man命令查看手册</a>。总之，<strong>记住你的目标就是流畅地进行开发调试</strong>，而在达成这个目标地过程中，你自己也会慢慢接触到更多。有兴趣的也可以看这个<a href="https://www.yanbinghu.com/categories/linux/">文章合集</a>。</p>
<p>但是有必要说明的是，开发Linux应用程序并不一定要在Linux下编写代码，你可以选择利用samba等工具在windows和linux之间共享文件，然后再在windows下熟悉的工具中或者你认为比较强大合适的工具中编写代码，在Linux下进行编译调试即可。当然你也可以选择Linux下的IDE，或者将<a href="https://www.yanbinghu.com/2017/10/22/5844.html">vim调教一下</a>也是可以的。</p>
<p>第三阶段要求是比较高的，这个时候你应该学习过操作系统的相关课程，然后你可以通过诸如《深入理解计算机系统》，《Linux内核设计与实现》，《深入Linux内核架构》，《深入理解Linux内核》等书籍进行相关概念学习，也可以通过阅读源码进行深入学习，最终，你需要了解堆和栈，内存管理，进程调度，虚拟内存，文件系统等相关知识。<br>当然相关命令学习也必不可少，例如readelf，nm，ipcs，iostat，objdump，free，chrt，pmap，uptime，top，pidstat等。</p>
<p>以上就是三个阶段Linux相关的学习内容和建议，实际上C/C++相关的同步学习也非常重要，包括相关数据结构与算法，系统编程，网络编程等内容的学习，否则看到很多命令的结果仍然会一脸懵逼。</p>
<p><strong>最后，建议实践再实践</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>限于本人知识水平有限，以上属个人建议和看法，仅供参考，欢迎留言纠正或补充。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客优化日志</title>
    <url>/2017/07/28/56337.html</url>
    <content><![CDATA[<p>由于各种原因，网站会有各种变化以及配置的增加，以日志记下改动</p>
<p><a href="https://www.yanbinghu.com/2016/11/13/4800.html">搭建教程和常见问题</a><br><a id="more"></a></p>
<h3 id="2019年11月16日更新"><a href="#2019年11月16日更新" class="headerlink" title="2019年11月16日更新"></a>2019年11月16日更新</h3><p>修改文章的间距。<br>原先文章之间间距过大，调整一下，修改文件themes/next/source/css/_schemes/Mist/_post-expanded.styl<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.post &#123; margin-top: 60px; &#125;</span><br></pre></td></tr></table></figure></p>
<p>原先是120px，我修改为60px。注意选择你对应的主题进行修改，我这里使用的Mist，因此修改这个。</p>
<h3 id="2019年8月18日更新"><a href="#2019年8月18日更新" class="headerlink" title="2019年8月18日更新"></a>2019年8月18日更新</h3><h4 id="增加豆瓣读书"><a href="#增加豆瓣读书" class="headerlink" title="增加豆瓣读书"></a>增加豆瓣读书</h4><p>1.安装插件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-douban --save</span><br></pre></td></tr></table></figure></p>
<p>2.在主站点配置文件增加以下内容，注意是主站点配置文件不是主题配置文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">douban:</span><br><span class="line">  user:  # 个人豆瓣ID</span><br><span class="line">  builtin: false</span><br><span class="line">  book:</span><br><span class="line">    title: &apos;This is my book title&apos;</span><br><span class="line">    quote: &apos;This is my book quote&apos;</span><br><span class="line">  movie:</span><br><span class="line">    title: &apos;This is my movie title&apos;</span><br><span class="line">    quote: &apos;This is my movie quote&apos;</span><br><span class="line">  game:</span><br><span class="line">    title: &apos;This is my game title&apos;</span><br><span class="line">    quote: &apos;This is my game quote&apos;</span><br><span class="line">  timeout: 10000</span><br></pre></td></tr></table></figure></p>
<p>如果不需要电影和游戏部分可以注释掉，注意，我在使用的时候发现如果把builtin设置为true，最后没有获取到书籍信息。</p>
<p>3.修改主题配置文件，在菜单那里增加一项：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">书籍: /books/ || book</span><br></pre></td></tr></table></figure></p>
<p>4.执行命令生成豆瓣读书页面：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo douban</span><br></pre></td></tr></table></figure></p>
<p>5.继续其他内容的生成和部署，注意部署要使用hexo deploy了，不能用简写的hexo d，因此douban简写也是d。</p>
<h3 id="2019年4月15日更新"><a href="#2019年4月15日更新" class="headerlink" title="2019年4月15日更新"></a>2019年4月15日更新</h3><h4 id="增加cnzz站点统计PV，UV等信息"><a href="#增加cnzz站点统计PV，UV等信息" class="headerlink" title="增加cnzz站点统计PV，UV等信息"></a>增加cnzz站点统计PV，UV等信息</h4><p>1.注册友盟账号:<a href="https://www.umeng.com/" target="_blank" rel="noopener">https://www.umeng.com/</a><br>2.选择-产品-网站统计添加要统计的网站信息<br>3.站点设置-获取代码，注意是复制图中所示的代码之一，而不是前面的代码，否则只会显示图标而不显示统计结果。</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/cnzz.png" alt="cnzz统计"></p>
<p>找到主题下cnzz的文件，例如next主题修改/next/layout/_third-party/analytics/cnzz-analytics.swig<br>文件内容如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.cnzz_siteid %&#125;</span><br><span class="line">&lt;div&gt;</span><br><span class="line"></span><br><span class="line">这里替换成你复制的内容</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>添加完成后，记得修改next主题配置文件，将cnzz相关信息修改：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnzz_siteid: 这里替换成你自己的id</span><br></pre></td></tr></table></figure></p>
<p>效果可访问<a href="https://www.yanbinghu.com">https://www.yanbinghu.com</a>。</p>
<h4 id="文章添加置顶功能"><a href="#文章添加置顶功能" class="headerlink" title="文章添加置顶功能"></a>文章添加置顶功能</h4><p>1.安装插件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure></p>
<p>2.修改样式，打开next/layout/_macro/post.swig，找到class为post-meta的div,插入下面的内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">    &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt;</span><br><span class="line">    &lt;font color=&quot;green&quot;&gt;置顶&lt;/font&gt;</span><br><span class="line">    &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用时，只需要在文章的开头加：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">top: true</span><br></pre></td></tr></table></figure></p>
<p>即可。</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/zhiding.png" alt="置顶"></p>
<p>效果可访问<a href="https://www.yanbinghu.com">https://www.yanbinghu.com</a>。</p>
<h4 id="添加标签云"><a href="#添加标签云" class="headerlink" title="添加标签云"></a>添加标签云</h4><p>安装插件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-tag-cloud --save</span><br></pre></td></tr></table></figure></p>
<p>打开next/layout/_custom/sidebar.swig<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if site.tags.length &gt; 1 %&#125;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcloud.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcanvas.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;div class=&quot;widget-wrap&quot;&gt;</span><br><span class="line">    &lt;h3 class=&quot;widget-title&quot;&gt;Tag Cloud&lt;/h3&gt;</span><br><span class="line">    &lt;div id=&quot;myCanvasContainer&quot; class=&quot;widget tagcloud&quot;&gt;</span><br><span class="line">        &lt;canvas width=&quot;250&quot; height=&quot;250&quot; id=&quot;resCanvas&quot; style=&quot;width=100%&quot;&gt;</span><br><span class="line">            &#123;&#123; list_tags() &#125;&#125;</span><br><span class="line">        &lt;/canvas&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p>
<p>效果可访问<a href="https://www.yanbinghu.com">https://www.yanbinghu.com</a>。</p>
<h3 id="2019年3月8日更新"><a href="#2019年3月8日更新" class="headerlink" title="2019年3月8日更新"></a>2019年3月8日更新</h3><h4 id="解决出现mixed-content的问题"><a href="#解决出现mixed-content的问题" class="headerlink" title="解决出现mixed content的问题"></a>解决出现mixed content的问题</h4><p>某篇文章内容空白，打开控制台发现下面的内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mixed Content: The page at &apos;https://www.yanbinghu.com/2019/03/09/61352.html&apos; was loaded over HTTPS, but requested an insecure script &apos;http://www.qq.com/404/search_children.js&apos;. This request has been blocked; the content must be served over HTTPS.</span><br></pre></td></tr></table></figure></p>
<p>发现是网站https访问的，但是我的404页面中又使用了http访问，因此导致mixed content的错误。<br>解决方法：<br>修改404页面，将http改为https。</p>
<h3 id="2019年2月4日更新"><a href="#2019年2月4日更新" class="headerlink" title="2019年2月4日更新"></a>2019年2月4日更新</h3><h4 id="解决百度分享不显示的问题"><a href="#解决百度分享不显示的问题" class="headerlink" title="解决百度分享不显示的问题"></a>解决百度分享不显示的问题</h4><p>百度分享不支持https,因此无法显示。解决方法：<br><a href="https://github.com/hrwhisper/baiduShare" target="_blank" rel="noopener">https://github.com/hrwhisper/baiduShare</a></p>
<p>将api/js/conf/define.js中的<a href="https://github.com/hrwhisper/baiduShare/修改为/" target="_blank" rel="noopener">https://github.com/hrwhisper/baiduShare/修改为/</a><br>将next主题下的layout/_partials/share/baidushare.swig中的//bdimg.share.baidu.com去掉<br>注明：后续未能生效，去掉</p>
<h3 id="2019年2月27日更新"><a href="#2019年2月27日更新" class="headerlink" title="2019年2月27日更新"></a>2019年2月27日更新</h3><h4 id="优化首页标题"><a href="#优化首页标题" class="headerlink" title="优化首页标题"></a>优化首页标题</h4><p>修改next主题配置文件，将index_with_subtitle改为true，这样网站的标题将会由主标题和子标题组成。<br>这样标题就变成了网站名称-网站描述的格式。</p>
<h3 id="2019年1月31日更新"><a href="#2019年1月31日更新" class="headerlink" title="2019年1月31日更新"></a>2019年1月31日更新</h3><h4 id="hexo博客seo"><a href="#hexo博客seo" class="headerlink" title="hexo博客seo"></a>hexo博客seo</h4><p>1.增加页面关键字，修改next主题配置文件中的keywords:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keywords: &quot;C语言,Cpp,Linux,Go,Python,算法&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="2019年1月29日更新"><a href="#2019年1月29日更新" class="headerlink" title="2019年1月29日更新"></a>2019年1月29日更新</h3><h4 id="增加友情链接"><a href="#增加友情链接" class="headerlink" title="增加友情链接"></a>增加友情链接</h4><p>修改next主题配置，增加友情链接</p>
<h4 id="修改版权声明信息"><a href="#修改版权声明信息" class="headerlink" title="修改版权声明信息"></a>修改版权声明信息</h4><p>修改next主题下的language/zh-Hans.yml中的版权声明相关内容即可。</p>
<h3 id="2019年1月28日更新"><a href="#2019年1月28日更新" class="headerlink" title="2019年1月28日更新"></a>2019年1月28日更新</h3><h4 id="解决hexo-公式渲染不完整的问题"><a href="#解决hexo-公式渲染不完整的问题" class="headerlink" title="解决hexo 公式渲染不完整的问题"></a>解决hexo 公式渲染不完整的问题</h4><p>原来的渲染引擎有问题，需要卸载，并重新安装完好的MathJax渲染引擎：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure></p>
<h3 id="2018年12月13日更新"><a href="#2018年12月13日更新" class="headerlink" title="2018年12月13日更新"></a>2018年12月13日更新</h3><h4 id="增加google站点地图"><a href="#增加google站点地图" class="headerlink" title="增加google站点地图"></a>增加google站点地图</h4><p>安装插件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure></p>
<p>特别注意，配置文件中的url需要填写成你自己网站的全地址，例如，我的url地址是<a href="https://www.yanbinghu.com">https://www.yanbinghu.com</a></p>
<h3 id="2018年12月11日更新"><a href="#2018年12月11日更新" class="headerlink" title="2018年12月11日更新"></a>2018年12月11日更新</h3><h4 id="解决卜算子计数脚本失效问题"><a href="#解决卜算子计数脚本失效问题" class="headerlink" title="解决卜算子计数脚本失效问题"></a>解决卜算子计数脚本失效问题</h4><p>原因：通过浏览器右键检查元素查看控制台可以看到，有一个js文件加载失败。<br>打开next主题next/layout/_third-party/analytics/busuanzi-counter.swig 中卜算子脚本地址<br>修改为：<a href="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" target="_blank" rel="noopener">https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js</a></p>
<h3 id="2018年9月5日更新"><a href="#2018年9月5日更新" class="headerlink" title="2018年9月5日更新"></a>2018年9月5日更新</h3><h4 id="博客内容免密部署"><a href="#博客内容免密部署" class="headerlink" title="博客内容免密部署"></a>博客内容免密部署</h4><p>方法：<br>本地生成ssh key，并部署到github或coding上去，并且修改_config.yml deploy的repository属性<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#repository: https://github.com/yonghuming/yonghuming.github.io.git </span><br><span class="line">repository: git@github.com:yonghuming/yonghuming.github.io.git #yonghuming为自己的github账户名</span><br></pre></td></tr></table></figure></p>
<h4 id="让百度收录网站地址"><a href="#让百度收录网站地址" class="headerlink" title="让百度收录网站地址"></a>让百度收录网站地址</h4><p>与google收录类似，但是时间比较长，并且由于github屏蔽了百度爬虫，因此在百度自动爬取时会出现403错误。</p>
<h4 id="强制https访问网站"><a href="#强制https访问网站" class="headerlink" title="强制https访问网站"></a>强制https访问网站</h4><p>github pages默认情况下是http访问的，有时候http会被浏览器标识为不安全，因此，需要更改github pages的设置，强制https访问网站。<br>设置方法：进入github pages项目—&gt;setting—&gt;勾选Enfoce HTTPS</p>
<h3 id="2018年9月4日更新"><a href="#2018年9月4日更新" class="headerlink" title="2018年9月4日更新"></a>2018年9月4日更新</h3><h4 id="添加微信公众号"><a href="#添加微信公众号" class="headerlink" title="添加微信公众号"></a>添加微信公众号</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wechat_subscriber:</span><br><span class="line">  enabled: true</span><br><span class="line">  qcode: /pictures/qrcode.jpg   #二维码路径</span><br><span class="line">  description: 欢迎关注个人微信公众号#描述</span><br></pre></td></tr></table></figure>
<h3 id="2018年6月2日更新"><a href="#2018年6月2日更新" class="headerlink" title="2018年6月2日更新"></a>2018年6月2日更新</h3><h4 id="将jiathis分享更换为百度分享"><a href="#将jiathis分享更换为百度分享" class="headerlink" title="将jiathis分享更换为百度分享"></a>将jiathis分享更换为百度分享</h4><p>由于jiathis分享已停止服务，因此将其更换为百度分享。</p>
<h4 id="文章底部添加版权声明"><a href="#文章底部添加版权声明" class="headerlink" title="文章底部添加版权声明"></a>文章底部添加版权声明</h4><p>将配置文件的post_copyright的enable选项设为true即可。</p>
<h3 id="2017年10月22日更新"><a href="#2017年10月22日更新" class="headerlink" title="2017年10月22日更新"></a>2017年10月22日更新</h3><h4 id="修改字体"><a href="#修改字体" class="headerlink" title="修改字体"></a>修改字体</h4><p>修改字体大小，可通过修改/source/css/_variables/base.styl<br>中的font-size-base，这是修改除标题以外的其他内容字体大小。<br>code-font-size修改代码字体大小。<br>font-family-base 修改字体</p>
<h3 id="2017年10月21日更新"><a href="#2017年10月21日更新" class="headerlink" title="2017年10月21日更新"></a>2017年10月21日更新</h3><h4 id="修改链接样式"><a href="#修改链接样式" class="headerlink" title="修改链接样式"></a>修改链接样式</h4><p>修改文件source\css_common\components\post\post.styl<br>增加内容<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.post-body p a&#123;</span><br><span class="line">  color: #0593d3;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  border-bottom: 1px solid #0593d3;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: #fc6423;</span><br><span class="line">    border-bottom: none;</span><br><span class="line">    border-bottom: 1px solid #fc6423;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="增加gitment和gitalk评论系统"><a href="#增加gitment和gitalk评论系统" class="headerlink" title="增加gitment和gitalk评论系统"></a>增加gitment和gitalk评论系统</h4><p>具体内容见文章<a href="http://www.yanbinghu.com/2017/10/20/46383.html#more">hexo 博客next主题集成gitment或者gitalk评论系统</a></p>
<h4 id="修改tag标签"><a href="#修改tag标签" class="headerlink" title="修改tag标签"></a>修改tag标签</h4><p>修改layout/_macro/post.swig<br>搜索 rel=”tag”&gt;#，将 # 换成 <i class="fa fa-tag"></i></p>
<h3 id="2017年7月29日更新"><a href="#2017年7月29日更新" class="headerlink" title="2017年7月29日更新"></a>2017年7月29日更新</h3><h4 id="添加RSS订阅"><a href="#添加RSS订阅" class="headerlink" title="添加RSS订阅"></a>添加RSS订阅</h4><pre><code>npm install hexo-generator-feed --save
</code></pre><h4 id="增加友情链接-1"><a href="#增加友情链接-1" class="headerlink" title="增加友情链接"></a>增加友情链接</h4><h4 id="更新关于我页面"><a href="#更新关于我页面" class="headerlink" title="更新关于我页面"></a>更新关于我页面</h4><h4 id="文章添加更新日期"><a href="#文章添加更新日期" class="headerlink" title="文章添加更新日期"></a>文章添加更新日期</h4><h3 id="2017年7月28日更新"><a href="#2017年7月28日更新" class="headerlink" title="2017年7月28日更新"></a>2017年7月28日更新</h3><h4 id="1-添加来必力评论系统"><a href="#1-添加来必力评论系统" class="headerlink" title="1.添加来必力评论系统"></a>1.添加来必力评论系统</h4><p>由于网易跟帖停止服务，将跟帖评论系统更换为来必力评论系统。</p>
<p>在<a href="https://livere.com/注册并添加你的网站，同时" target="_blank" rel="noopener">https://livere.com/注册并添加你的网站，同时</a><br>修改next主题配置文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Support for LiveRe comments system.</span><br><span class="line"># You can get your uid from https://livere.com/insight/myCode (General web site)</span><br><span class="line">livere_uid: ××××××××××××××××××</span><br></pre></td></tr></table></figure></p>
<p>目前来看，来必力支持的第三方登录比较多，包括微信，qq，github，领英，豆瓣，google+，facebook等主流社交账号登录。</p>
<h4 id="2-添加打赏功能"><a href="#2-添加打赏功能" class="headerlink" title="2.添加打赏功能"></a>2.添加打赏功能</h4><p>修改配置文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！</span><br><span class="line">wechatpay: /wechatpay.jpg</span><br><span class="line">alipay: /alipay.jpg</span><br></pre></td></tr></table></figure></p>
<p>wechatpay.jpg 和alipay.jpg分别是微信和支付宝的收款二维码。可放在hexo的resource目录下。</p>
<h4 id="3-添加文章的字数统计和阅读时长统计"><a href="#3-添加文章的字数统计和阅读时长统计" class="headerlink" title="3.添加文章的字数统计和阅读时长统计"></a>3.添加文章的字数统计和阅读时长统计</h4><p>修改配置文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https://github.com/willin/hexo-wordcount</span><br><span class="line">post_wordcount:</span><br><span class="line">  item_text: true</span><br><span class="line">  wordcount: true</span><br><span class="line">  min2read: true</span><br></pre></td></tr></table></figure></p>
<p>另外，在hexo根目录下执行命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i --save hexo-wordcount</span><br></pre></td></tr></table></figure></p>
<p>安装成功后即可。</p>
<h4 id="4添加站内搜索"><a href="#4添加站内搜索" class="headerlink" title="4添加站内搜索"></a>4添加站内搜索</h4><pre><code> 安装hexo-generator-search

 npm install hexo-generator-searchdb --save

在站点的_config.yml中添加
</code></pre><p>search:<br>  path: search.xml<br>  field: post<br>  format: html<br>  limit: 10000</p>
<pre><code>同时在next主题中开启local search
</code></pre><h4 id="5-问题"><a href="#5-问题" class="headerlink" title="5.问题"></a>5.问题</h4>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
        <tag>更新日志</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>const修饰的变量无法被外部引用</title>
    <url>/2020/11/01/37071.html</url>
    <content><![CDATA[<p> const变量能被其他文件extern引用吗？为什么？</p>
<p> 先来看一段代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 来源：公众号编程珠玑</span></span><br><span class="line"><span class="comment">// main.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 引用外部定义的const_int变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> const_int;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"const_int：%d\n"</span>,const_int);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// const.cc</span></span><br><span class="line"><span class="comment">// 定义const 变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> const_int  = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>编译链接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> $ g++ -o main main.cc const.cc</span><br><span class="line"> /tmp/ccWHAXxB.o: In function `main&apos;:</span><br><span class="line">main.cc:(.text+0x6): undefined reference to `const_int&apos;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>
<p>我们发现出现了链接问题，说const_int没有定义的引用，但我们确实在const.cc文件中定义了。</p>
<p>我们去掉const修饰符再编译一次，发现是可以的。从上面这个编译问题，就引出今天要讲的内容了。至于为什么会编译不过，最后再做解释。</p>
<p>当然你会发现，按照C代码去编译，是可以编译出来的。后面再解释。</p>
<h2 id="链接属性"><a href="#链接属性" class="headerlink" title="链接属性"></a>链接属性</h2><p>我们都知道，C/C++代码的编译通常经过预编译，汇编，编译，链接（参考<a href="https://www.yanbinghu.com/2018/10/10/27133.html">hello程序是怎么生成的</a>）通常会有变量会有三种链接属性：<em>外部链接，内部链接或无链接</em>。</p>
<p>具有函数作用域，块作用域或者函数原型作用域的变量都是无链接变量；具有文件作用域的变量可以是内部链接也可以是外部链接。而外部链接变量可以在多个文件中使用，内部链接变量只能在一个编译单元中使用（一个源代码文件和它包含的头文件）。</p>
<p>关于作用域，也可以参考《<a href="https://www.yanbinghu.com/2019/05/08/43402.html">全局变量，静态全局变量，局部变量，静态局部变量</a>》。<br> 说了这么多，举个具体的例子：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">// 作者：守望先生</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> external_link = <span class="number">10</span>;  <span class="comment">// 文件作用域，外部链接</span></span><br><span class="line"><span class="keyword">static</span> internal_link = <span class="number">20</span>; <span class="comment">// 文件作用域，内部链接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> no_link = <span class="number">30</span>;   <span class="comment">// 无链接</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d \n"</span>,external_link,internal_link,no_link);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里无链接变量还是比较好区分的，只要不是文件作用域的变量，基本是无链接属性。而文件作用域变量是内部链接还是外部链接呢？只要看前面是否有static修饰即可。当然对于C++，还要看是否有const修饰，后面我们再说。</p>
<h2 id="如何知道某个变量是什么链接属性？"><a href="#如何知道某个变量是什么链接属性？" class="headerlink" title="如何知道某个变量是什么链接属性？"></a>如何知道某个变量是什么链接属性？</h2><p>举个例子，在前面的代码中，我们按照C代码进行编译：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -c const.c </span><br><span class="line">$ nm const.o |grep const_int</span><br><span class="line">0000000000000000 R const_int</span><br></pre></td></tr></table></figure></p>
<p> nm命令在《<a href="https://www.yanbinghu.com/2017/09/10/3456.html">linux常用命令-开发调试篇</a>》中略有介绍，它可以用来查看ELF文件的符号信息。</p>
<p>从这里的结果可以看到const_int前面是R修饰的，<br>R：该符号位于只读数据区，READONLY的含义</p>
<p>而<strong>该字母大写，其实也是表示它具有外部链接属性</strong>。</p>
<p>再看看按照C++代码编译：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ g++ -c const.c</span><br><span class="line">$ nm const.o |grep const_int</span><br><span class="line">0000000000000000 r _ZL9const_int</span><br></pre></td></tr></table></figure></p>
<p>可以看到，它的修饰符也是r，但是是小写的r，<strong>小写字母表示该变量具有内部链接属性</strong>。</p>
<p>nm命令非常实用，但本文不是重点。</p>
<h2 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h2><p> 说到const关键字，在《<a href="https://www.yanbinghu.com/2019/01/28/7442.html">const关键字到底该怎么用</a>》和《<a href="https://www.yanbinghu.com/2019/10/31/51504.html">C++中的const与C中的const有何差别？</a>》中已经分析过了，这里简单说一下，被const关键字修饰的变量，表明它是只读的，不希望被修改。</p>
<h2 id="extern关键字"><a href="#extern关键字" class="headerlink" title="extern关键字"></a>extern关键字</h2><p> extern关键字可以引用外部的定义，想必很多朋友已经很熟悉了，举个例子，如果把最开始的例子中的const关键字去掉，main.cc中的extern的意思，就是说有一个const_int变量，但是它在别的地方定义的，因此这里extern修饰一下，这样在链接阶段，它就会去其他的编译单元中找到它的定义，并链接。</p>
<p>当然，还有一个不太被关注的作用是，在C++中，它可以改变const变量的链接属性：</p>
<p>是的，在C++中，它改变了const_int的链接属性。我们可以修改const.c的内容如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> const_int  = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p>
<p> 然后再查看一下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> $ nm const.o |grep const_int</span><br><span class="line">0000000000000000 R const_int</span><br></pre></td></tr></table></figure></p>
<p>发现没有，它前面的修饰变成大写的R了，所以这个时候，你再编译，就能编译过，而不会报错了，对于C，它本来就是外部链接属性，所以根本不会报错。</p>
<p>extern还有另外一个用法：<br>《<a href="https://www.yanbinghu.com/2019/08/25/29412.html">C++是如何调用C接口的</a>》？</p>
<h2 id="解疑"><a href="#解疑" class="headerlink" title="解疑"></a>解疑</h2><p>所以，链接报错的通常问题就是找不到定义，原因无非就是：</p>
<ul>
<li>未定义</li>
<li>在其他地方定义了，但是不具备外部链接属性</li>
<li>定义了，具备外部链接属性，但是链接顺序有问题</li>
</ul>
<p>由于在C++中，被const修饰的变量默认为内部链接属性，因为编译会找不到定义。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从一个编译问题，引出了很多内容，包括：</p>
<ul>
<li>作用域 —《<a href="https://www.yanbinghu.com/2019/05/08/43402.html">全局变量，静态全局变量，局部变量，静态局部变量</a>》</li>
<li>const关键字—《<a href="https://www.yanbinghu.com/2019/01/28/7442.html">const关键字到底该怎么用</a>》</li>
<li>extern关键字 </li>
<li>nm查看符号表</li>
</ul>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>daemon程序实现注意事项</title>
    <url>/2020/10/06/45761.html</url>
    <content><![CDATA[<p>之前在《<a href="https://www.yanbinghu.com/2019/12/06/39731.html">如何让程序真正地后台运行</a>》一文中提到了程序后台运行的写法，但是里面的示例程序在某些场景下是会有问题的，这里先不说什么问题，我们先看看这个磁盘满的问题是怎么产生的，通过这篇文章你将会学习到大量linux命令的实操使用。</p>
<a id="more"></a>
<h2 id="找到导致磁盘满的程序"><a href="#找到导致磁盘满的程序" class="headerlink" title="找到导致磁盘满的程序"></a>找到导致磁盘满的程序</h2><p>当发现磁盘占用比较多的时候，可以通过下面的命令，查看各个挂载路径的占用情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> df -h</span></span><br><span class="line">udev            3.9G     0  3.9G    0% /dev</span><br><span class="line">tmpfs           784M  2.0M  782M    1% /run</span><br><span class="line">/dev/sda11       19G  6.5G   12G   37% /</span><br><span class="line">tmpfs           3.9G   91M  3.8G    3% /dev/shm</span><br><span class="line">tmpfs           5.0M  4.0K  5.0M    1% /run/lock</span><br><span class="line">tmpfs           3.9G     0  3.9G    0% /sys/fs/cgroup</span><br><span class="line">/dev/sda12      9.4G   37M  8.8G    1% /tmp</span><br><span class="line">/dev/sda14      6.4G  168M  5.9G    3% /boot</span><br><span class="line">/dev/sda10       57G  2.0G   52G    4% /home</span><br><span class="line">/dev/sda1       256M   33M  224M   13% /boot/efi</span><br><span class="line">tmpfs           784M   16K  784M    1% /run/user/121</span><br><span class="line">tmpfs           784M   44K  784M    1% /run/user/1000</span><br></pre></td></tr></table></figure>
<p>当然我这里并没有哪个挂载路径的磁盘占用率比较高，这里假设home占用比较高，然后可以通过：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd /home</span><br><span class="line">$ du -h --max-depth=1</span><br><span class="line">1.9G	./shouwang</span><br><span class="line">16K	./lost+found</span><br><span class="line">1.9G	.</span><br></pre></td></tr></table></figure>
<p>这样可以逐层知道哪些目录有了不该有的大文件。</p>
<p>当然你也可以使用find直接找出大文件，比如查找当前目录下大于800M的文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find . -type f -size +800M</span><br></pre></td></tr></table></figure></p>
<p>find的用法可以参考《<a href="https://www.yanbinghu.com/2018/12/15/21083.html">find命令高级用法</a>》。</p>
<p>如果找到了该文件，并且确认是无用文件，那么就可以删除了。</p>
<p>但是如果<strong>仍然有程序打开了该文件，那么即便你删除了文件，其占用的磁盘空间也并不会释放</strong>，因为仍然它的”文件引用”不是0，文件并不会被删除。<br>在《<a href="https://www.yanbinghu.com/2020/05/10/50696.html">rm删除文件空间就释放了吗？</a>》一文中，有更加详细的解释。</p>
<p>所以你需要看一下，是否还有程序打开该文件，举个例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ lsof config.json</span><br><span class="line">COMMAND  PID     USER   FD   TYPE DEVICE SIZE/OFF    NODE NAME</span><br><span class="line">less    6750 shouwang    4r   REG   8,10      233 3411160 config.json</span><br></pre></td></tr></table></figure></p>
<p>从上面的结果，可以看到，是less程序打开了config.json文件，并且它的进程id是6750。</p>
<p>找到进程之后，根据实际情况决定是否需要停止程序，然后删除大文件。</p>
<h2 id="找不到大文件？"><a href="#找不到大文件？" class="headerlink" title="找不到大文件？"></a>找不到大文件？</h2><p>现实常常可能不如意，比如虽然可以通过df命令看到某些挂载路径磁盘占用率比较高，但是始终找不到大文件，那么你就要考虑，是不是大文件看似被删除了，但是还有程序打开。要找到这样的文件，其实也很简单，前面已经介绍过了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsof |grep deleted</span><br></pre></td></tr></table></figure></p>
<p>lsof能看到被打开的文件，而如果文件被删除了（比如使用rm命令），但是仍然有程序打开，则会是deleted状态，举个例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ touch test.txt</span><br><span class="line">$ less test.txt</span><br></pre></td></tr></table></figure></p>
<p>创建一个文件test.txt，并随意输入一些内容，然后使用less命令打，随后在另一个终端，删除该文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rm test.txt</span><br><span class="line">$ lsof |grep test.txt |grep deleted</span><br><span class="line">less      6989              shouwang    4r      REG               8,10       134    3541262 /home/shouwang/workspaces/shell/testdeleted/test.txt (deleted)</span><br></pre></td></tr></table></figure></p>
<p>可以看到打开该文件的进程id为6989，我们看一下这个程序打开的文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -al /proc/6989/fd</span><br><span class="line">dr-x------ 2 shouwang shouwang  0 10月  6 10:57 .</span><br><span class="line">dr-xr-xr-x 9 shouwang shouwang  0 10月  6 10:56 ..</span><br><span class="line">lrwx------ 1 shouwang shouwang 64 10月  6 10:57 0 -&gt; /dev/pts/1</span><br><span class="line">lrwx------ 1 shouwang shouwang 64 10月  6 10:57 1 -&gt; /dev/pts/1</span><br><span class="line">lrwx------ 1 shouwang shouwang 64 10月  6 10:57 2 -&gt; /dev/pts/1</span><br><span class="line">lr-x------ 1 shouwang shouwang 64 10月  6 10:57 3 -&gt; /dev/tty</span><br><span class="line">lr-x------ 1 shouwang shouwang 64 10月  6 10:57 4 -&gt; &apos;/home/shouwang/workspaces/shell/testdeleted/test.txt (deleted)&apos;</span><br><span class="line">$ du -h</span><br></pre></td></tr></table></figure></p>
<p>（关于proc虚拟文件系统，可以参考《<a href="https://www.yanbinghu.com/2018/11/18/43716.html">Linux中不可错过的信息宝库</a>》）。从上面也可以看到，文件描述符4的文件为test.txt，但是deleted状态。</p>
<p>停止这个进程，你会发现所占用的磁盘空间会被释放。</p>
<h2 id="不完善的daemon实现"><a href="#不完善的daemon实现" class="headerlink" title="不完善的daemon实现"></a>不完善的daemon实现</h2><p>通常在终端启动一个程序后，文件描述符0，1，2通常对应标准输入，标准输出，标准错误。从前面的例子中也能窥见一二，它打开的是/dev/pts/1，其实就是当前终端。更多信息可以参考《<a href="https://www.yanbinghu.com/2018/10/26/9186.html">如何理解Linux shell中“2&gt;&amp;1”</a>》。</p>
<p>回到开始的问题，之前例子中daemonize的参考实现如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="comment">/*实现仅供参考，可根据实际情况调整*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daemonize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*清除文件权限掩码*/</span></span><br><span class="line">	umask(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*父进程退出*/</span></span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">if</span>((pid=fork()) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*for 出错*/</span></span><br><span class="line">		perror(<span class="string">"fork error"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> != pid)<span class="comment">/*父进程*/</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"father exit\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*子进程，成为组长进程，并且摆脱终端*/</span></span><br><span class="line">	setsid();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*修改工作目录*/</span></span><br><span class="line">	<span class="keyword">if</span>(chdir(<span class="string">"/"</span>) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"change dir failed"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rl</span>;</span></span><br><span class="line">	<span class="comment">/*先获取文件描述符最大值*/</span></span><br><span class="line">	<span class="keyword">if</span>(getrlimit(RLIMIT_NOFILE,&amp;rl) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"get file decription failed"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果无限制，则设置为1024*/</span></span><br><span class="line">	<span class="keyword">if</span>(rl.rlim_max == RLIM_INFINITY)</span><br><span class="line">		rl.rlim_max = <span class="number">1024</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*为了使得终端有输出，保留了文件描述符0，1，2;实际上父进程可能没有打开2以上的文件描述符*/</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">3</span>;i &lt; rl.rlim_max;i++)</span><br><span class="line">		close(i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> == daemonize())</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">"daemonize ok\n"</span>);</span><br><span class="line">		    sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"daemonize failed\n"</span>);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里注意到，daemonize函数最后关闭了2以上的文件描述符。</p>
<p>在其中一个终端运行上面的例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o daemon daemon.c  #编译</span><br><span class="line">$ ./daemon   #运行</span><br><span class="line">$ ls -al /proc/`pidof daemon`/fd  #查看打开的文件</span><br><span class="line">dr-x------ 2 shouwang shouwang  0 10月  6 11:26 .</span><br><span class="line">dr-xr-xr-x 9 shouwang shouwang  0 10月  6 11:26 ..</span><br><span class="line">lrwx------ 1 shouwang shouwang 64 10月  6 11:26 0 -&gt; /dev/pts/4</span><br><span class="line">lrwx------ 1 shouwang shouwang 64 10月  6 11:26 1 -&gt; /dev/pts/4</span><br><span class="line">lrwx------ 1 shouwang shouwang 64 10月  6 11:26 2 -&gt; /dev/pts/4</span><br></pre></td></tr></table></figure></p>
<p>可以看到0，1，2打开的是程序所在的终端，这时关闭该终端，在另外一个终端执行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$  ls -al /proc/`pidof daemon`/fd </span><br><span class="line">lrwx------ 1 shouwang shouwang 64 10月  6 11:26 0 -&gt; &apos;/dev/pts/4 (deleted)&apos;</span><br><span class="line">lrwx------ 1 shouwang shouwang 64 10月  6 11:26 1 -&gt; &apos;/dev/pts/4 (deleted)&apos;</span><br><span class="line">lrwx------ 1 shouwang shouwang 64 10月  6 11:26 2 -&gt; &apos;/dev/pts/4 (deleted)&apos;</span><br></pre></td></tr></table></figure></p>
<p>发现0，1，2都是deleted状态了，因为关闭前面启动程序的终端后，也相当于删除了它标准输入输出和标准错误指向的文件。</p>
<p>实际上，到这里，都没有任何问题，程序中的printf打印最多无法打印出来而已。</p>
<p>但是，如果程序不是终端启动的呢？或者说没有终端的环境,比如crontab启动，at命令启动：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ at now &lt;&lt;&lt; “./daemon&quot;</span><br></pre></td></tr></table></figure></p>
<p>at命令表示当前时间执行daemon程序。<br>再看看它打开的文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -l /proc/`pidof daemon`/fd</span><br><span class="line">lr-x------ 1 shouwang shouwang 64 10月  6 11:42 0 -&gt; &apos;/var/spool/cron/atjobs/a00001019765fe (deleted)&apos;</span><br><span class="line">lrwx------ 1 shouwang shouwang 64 10月  6 11:42 1 -&gt; &apos;/var/spool/cron/atspool/a00001019765fe (deleted)&apos;</span><br><span class="line">lrwx------ 1 shouwang shouwang 64 10月  6 11:42 2 -&gt; &apos;/var/spool/cron/atspool/a00001019765fe (deleted)&apos;</span><br></pre></td></tr></table></figure></p>
<p>看见没有，你会发现它打开了一些奇怪的文件。</p>
<h2 id="为什么会有这些奇怪的文件？"><a href="#为什么会有这些奇怪的文件？" class="headerlink" title="为什么会有这些奇怪的文件？"></a>为什么会有这些奇怪的文件？</h2><p>很明显，我们自己写的程序中并没有打开这样的文件，但是从文件名可以推断，它看能是cron程序打开的。那么怎么会变成daemon程序打开了呢？</p>
<p>这要从fork说起，之前在《<a href="https://www.yanbinghu.com/2019/08/11/28423.html">如何创建子进程？</a>》中说到过，fork出来的子进程会继承父进程的文件描述符，我们的daemon实现已经将2以上的描述符关闭了，但是并没有关闭0，1，2，而由于daemon程序自己实际上没有打开任何文件，0，1，2是空着的，实际上就变成了打开的是父进程曾经打开的文件。</p>
<p>但是由于printf持续向标准输出打印信息，即不断向描述符1打开的文件写入内容，而该文件又是deleted状态，最终可能会导致磁盘空间占用不断增大，但是又找不到实际的大文件。</p>
<p>为了验证我们的想法，可以看下前面的文件内容到底是什么：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tail -5  /proc/`pidof daemon`/fd/1</span><br><span class="line">daemonize ok</span><br><span class="line">daemonize ok</span><br><span class="line">daemonize ok</span><br><span class="line">daemonize ok</span><br><span class="line">daemonize ok</span><br></pre></td></tr></table></figure></p>
<p>看到了吗，这既是我们程序的打印！<strong>竟然打印到一个毫无相关的文件中了</strong>。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>从上面的例子可以看到，要想实现一个线上可用的daemon程序，还必须重定向标准输入，标准输出和标准错误，比例：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* redirect stdin, stdout, and stderr to /dev/null */</span></span><br><span class="line">open(<span class="string">"/dev/null"</span>, O_RDONLY);</span><br><span class="line">open(<span class="string">"/dev/null"</span>, O_RDWR);</span><br><span class="line">open(<span class="string">"/dev/null"</span>, O_RDWR);</span><br></pre></td></tr></table></figure></p>
<p>如果我们不关心这些输入输出，则重定向到/dev/null，相当于丢弃该内容，关于/dev/null，这里有更多的介绍《<a href="https://www.yanbinghu.com/2019/11/20/49894.html">linux下这些特殊的文件</a>》。</p>
<p>是否要重定向标准输入输出，完全取决于你的实际应用场景，比如某些情况你可能就是需要将标准输出指向父进程的文件，则可以不需要重定向。当然了，<strong>至于实现，更推荐的做法是调用daemon函数</strong>：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daemon</span><span class="params">(<span class="keyword">int</span> nochdir, <span class="keyword">int</span> noclose)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要涉及以下内容：</p>
<ul>
<li>查看各挂载路径空间占用情况 </li>
<li>查看目录空间占用情况</li>
<li>如何创建子进程—《<a href="https://www.yanbinghu.com/2019/08/11/28423.html">如何创建子进程？</a>》</li>
<li>标准输入，输出和标准错误—《<a href="https://www.yanbinghu.com/2018/10/26/9186.html">如何理解Linux shell中”2&gt;&amp;1”</a>》</li>
<li>查看进程打开文件信息—《<a href="https://www.yanbinghu.com/2019/03/05/61180.html">如何查看linux中文件打开情况</a>》</li>
<li>查找大文件—《<a href="https://www.yanbinghu.com/2018/12/15/21083.html">find命令高级用法</a>》</li>
<li>/dev/null特殊文件的用法 —《<a href="https://www.yanbinghu.com/2019/11/20/49894.html">linux下这些特殊的文件</a>》</li>
<li>查找被删除但仍有进程占用的文件</li>
<li>编写daemon程序注意事项</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>makefile入门</title>
    <url>/2019/12/29/53040.html</url>
    <content><![CDATA[<p>作为Linux下的C/C++开发者，没接触过makefile一定说不过去，通常构建大型的C/C++项目都离不开makefile，也许你使用的是cmake或者其他类似的工具，但它们的本质都是类似的。</p>
<p>作为一个轻度使用者，应读者要求，斗胆介绍一下makefile，不过与普通的makfile教程不同的是，本文准备从另外一个角度来介绍。如有不妥之处，欢迎指出。<br><a id="more"></a></p>
<h2 id="makefie到底是什么"><a href="#makefie到底是什么" class="headerlink" title="makefie到底是什么"></a>makefie到底是什么</h2><p>在Linux下，对于下面这个简单的程序<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="built_in">pow</span>(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"10^4 = %d"</span>,c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们通常使用gcc就可以编译得到想要的程序了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o main main.c -lm</span><br></pre></td></tr></table></figure></p>
<p>（如果不理解为什么要加-lm，请参考《<a href="https://www.yanbinghu.com/2018/10/06/46212.html">一个奇怪的链接问题</a>》）。</p>
<p>对于单个文件的简单程序，一条命令就可以直接搞定了（编译+连接），但是如果是一个复杂的工程，可能有成千上万个文件，然后需要链接大量的动态或静态库。试想一下，你还想一条一条命令执行吗？<strong>懒惰的基因是刻在程序员骨子里的。</strong></p>
<p>因此你可能会想，那我写个脚本好了。嗯，听起来好多了。</p>
<p>文件多就多，你告诉我要编译哪里的文件，我遍历一下就好了，你再告诉我要链接哪些库，我一一帮你链接上就好了。</p>
<p>然而到这里又会想，既然编译链接都是这么类似的过程，能不能给它们写一些通用的规则，搞得这么复杂干嘛？然后按照规则去执行就好了。</p>
<p>而makefile就是这样的一个规则文件，make是规则的解释执行者。可以类比shell脚本和bash解释程序的关系。</p>
<p>所以，makefile并不仅仅用于编译链接，只不过它非常适合用于编译链接。</p>
<h2 id="makefile什么样？"><a href="#makefile什么样？" class="headerlink" title="makefile什么样？"></a>makefile什么样？</h2><p>它最重要的规则语法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;target&gt; : &lt;prerequisites&gt; </span><br><span class="line">[tab]  &lt;commands&gt;</span><br></pre></td></tr></table></figure></p>
<p>咋一看，就这么个玩意？但是什么意思？</p>
<ul>
<li>target 要生成的目标文件名称</li>
<li><prerequisites> 要依赖的文件</prerequisites></li>
<li>[tab] 对，就是tab键，初学者很容易忽略这个问题，请用tab</li>
<li><commands> 要执行的指令</commands></li>
</ul>
<p>关键内容就这些，但是要细讲会有很多内容，本文仅举个简单的例子。假设要将前面的main.c复制名为pow.c的文件。<br>那么我们可以得到：</p>
<ul>
<li>target: pow.c 目标名称</li>
<li>prerequisites：main.c，即得到pow.c需要有main.c</li>
<li>commands：cp main.c pow.c</li>
</ul>
<p>因此我们得到我们的makefile文件内容如下：<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">pow.c:main.c</span></span><br><span class="line">	cp main.c pow.c</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm pow.c</span><br></pre></td></tr></table></figure></p>
<p>假设当前目录下没有main.c文件，然后在当前目录下执行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ make pow.c</span><br><span class="line">make: *** No rule to make target `main.c&apos;, needed by `pow.c&apos;.  Stop.</span><br></pre></td></tr></table></figure></p>
<p>我们发现会报错，因为你要依赖的文件找不到，而且也没有其他规则能够生成它。</p>
<p>现在把main.c放在当前目录下后继续执行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ make </span><br><span class="line">cp main.c pow.c</span><br></pre></td></tr></table></figure></p>
<p>看见没有，执行完make命令之后，我们的pow.c文件终于有了。</p>
<p>而执行下面的命令后：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ make clean</span><br><span class="line">rm pow.c</span><br></pre></td></tr></table></figure></p>
<p>你就会发现pow.c被删除了。</p>
<p>如果当前目录有clean文件会发生什么？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ make clean</span><br><span class="line">make: `clean&apos; is up to date.</span><br></pre></td></tr></table></figure></p>
<p>至于原因，后面会讲到。</p>
<p>这里注意，如果你的makefile文件的文件名不是makefile，那么就需要指定具体名字，例如假设前面的文件名为test.txt：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ make -f test.txt</span><br></pre></td></tr></table></figure></p>
<p>以上例子介绍了makefile使用的基本流程，生成目标，清除目标。然而实际上这里面的门道还有很多，例如伪目标，自动推导，隐晦规则，变量定义。本文作为认识性的文章暂时不具体介绍。</p>
<p>总结来说就是，给规则，按照规则生成目标。</p>
<h2 id="makefile做了什么？"><a href="#makefile做了什么？" class="headerlink" title="makefile做了什么？"></a>makefile做了什么？</h2><p>网上有很多教程介绍如何编写makefile的，很多也非常不错。不过本文换个角度来说。</p>
<p>既然我们要学makefile，那么就需要知道构建C/C++项目的时候，它应该做什么？然后再去学习如何编写makefile。</p>
<p>实际上它主要做的事情也很清楚，那就是编译和链接。这个在《<a href="https://www.yanbinghu.com/2018/10/10/27133.html">helo程序是如何编程可执行文件的</a>》中已经有所介绍，还不了解的朋友可以简单了解一下。那么放到makefile中具体要做什么呢？</p>
<ul>
<li>将源代码文件编译成可重定位目标文件.o（参考《<a href="https://www.yanbinghu.com/2019/06/27/47343.html">静态库和动态库的区别</a>》）</li>
<li>设置编译器选项，例如是否开启优化，传递宏，打开警告等</li>
<li>链接，将静态库或动态库与目标文件链接</li>
</ul>
<p>所以问题就变成了，如何利用makefile的语法规则快速的将成千上万的.c编译成.o，并且正确链接到需要的库。</p>
<p>而如果用makefile应该怎么写才能得到我们的程序呢？为了帮助说明，我们把前面的编译命令拆分为两条：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -g -Wall -c main.c -o main.o</span><br><span class="line">$ gcc -o main main.o -lm</span><br></pre></td></tr></table></figure></p>
<h4 id="设置编译器"><a href="#设置编译器" class="headerlink" title="设置编译器"></a>设置编译器</h4><p>由于我们使用的是gcc编译器（套件），因此可以像下面这样写：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CC=gcc</span><br></pre></td></tr></table></figure></p>
<p>为了扩展性考虑，常常将编译器定义为某个变量，后面使用的时候就会方便很多。</p>
<h4 id="设置编译选项"><a href="#设置编译选项" class="headerlink" title="设置编译选项"></a>设置编译选项</h4><p>比如我们要设置-g选项用来调试，设置-Wall选项来输出更多警告信息。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CFLAGS=-g -Wall</span><br></pre></td></tr></table></figure></p>
<h4 id="设置链接库"><a href="#设置链接库" class="headerlink" title="设置链接库"></a>设置链接库</h4><p>我们这里只用到了libm.so库<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LIBS=-lm</span><br></pre></td></tr></table></figure></p>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>我们的目标文件是main.o依赖main.c，该规则应该是这样的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OBJ=main.o</span><br><span class="line">$(OBJ):main.c</span><br><span class="line">	$(CC) $(CFLAGS) -c main.c -o $(OBJ)</span><br></pre></td></tr></table></figure></p>
<p>这样就得到了我们的目标文件。</p>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>接下来就需要将目标文件和库文件链接在一起了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TARGET=main</span><br><span class="line">$(target):main.o</span><br><span class="line">	$(CC) $(CFLAGS) -o $(TARGET) $(OBJ) $(LIBS)</span><br></pre></td></tr></table></figure></p>
<p>而为了使用make clean，即通常用于清除这些中间文件，因此需要加一个伪目标clean：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.PHONY:clean</span><br><span class="line">clean:</span><br><span class="line">	rm $(OBJ) $(TARGET)</span><br></pre></td></tr></table></figure></p>
<p>伪目标的意思是，它不是一个真正的要生成的目标文件，.PHONY:clean说明了clean是一个伪目标。在这种情况下，即使当前目录下有clean文件，它也仍然会执行后面的指令。</p>
<p>否则如果当前目录下有clean文件，将不会执行rm动作，而认为目标文件已经是最新的了。</p>
<h4 id="完整内容"><a href="#完整内容" class="headerlink" title="完整内容"></a>完整内容</h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">CFLAGS=-g -Wall</span><br><span class="line">LIBS=-lm</span><br><span class="line">OBJ=main.o</span><br><span class="line"><span class="variable">$(OBJ)</span>:main.c</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c main.c -o <span class="variable">$(OBJ)</span></span><br><span class="line">TARGET=main</span><br><span class="line"><span class="variable">$(TARGET)</span>:main.o</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJ)</span> <span class="variable">$(LIBS)</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm <span class="variable">$(OBJ)</span> <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<p>可以看到，makefile文件中有三个目标，分别是main.o，main和clean，其中clean是一个伪目标。</p>
<p>注意，由于第一个目标是main.o，因此你单单执行make的时候，它只是会生成main.o而已，如果你再执行一次会发现它提示你说main.o已经是最新的了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">gcc -g -Wall -c main.c -o main.o</span><br><span class="line">$ make</span><br><span class="line">make: `main.o&apos; is up to date.</span><br></pre></td></tr></table></figure></p>
<p>为了得到main，我们执行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ make main</span><br><span class="line">gcc -g -Wall -c main.c -o main.o</span><br><span class="line">gcc -g -Wall -o main main.o -lm</span><br><span class="line">$ ls </span><br><span class="line">main  main.c  main.o  makefile</span><br></pre></td></tr></table></figure></p>
<p>当然你也可以调整目标顺序。这里的目标文件main依赖的是main.o，它开始会去找main.o，发现这个文件也没有，就会看是不是有规则会生成main.o，欸，你还别说，真有。main.o又依赖main.c，也有，最终按照规则就会先生成main.o，然后生成mian。</p>
<p>如果要清除这些目标文件，那么可以执行make clean：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ make clean</span><br><span class="line">rm main.o main</span><br><span class="line">$ ls </span><br><span class="line">main.c  makefile</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了两部分内容。</p>
<h4 id="makefile是什么东西"><a href="#makefile是什么东西" class="headerlink" title="makefile是什么东西"></a>makefile是什么东西</h4><p>它是一个规则文件，里面按照某种语法写好了，然后使用make来解释执行，就像shell脚本要用bash解释运行一样。通常会用makefile来构建C/C++项目。</p>
<h4 id="构建C-C-项目的makefile做了什么"><a href="#构建C-C-项目的makefile做了什么" class="headerlink" title="构建C/C++项目的makefile做了什么"></a>构建C/C++项目的makefile做了什么</h4><p>makefile主要做下面的事情（以C程序为例）</p>
<ul>
<li>用变量保存各种设置项，例如编译选项，编译器，宏，包含的头文件等</li>
<li>把.c编译成.o</li>
<li>把.o与库进行链接</li>
<li>清除生成的文件</li>
<li>安装程序</li>
</ul>
<p>其中最关键的事情就是编译链接，即想办法把.c变成.o（可重定位目标文件）;.o+.so（动态库）+.a（静态库）变成可执行文件。</p>
<p>对于文本提到的例子，看起来实在有些笨拙，一条指令搞定，却要写这么多行的makefile，但是它却指出了通常编写makefile的基本思路。</p>
<p>对于一个复杂的项目而言，makefile还有很多东西可介绍，例如如何设置变量，如何交叉编译，如何多个目录编译，如何自动推导，如何分支选择等等。这些都是后话了。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程一定更快吗</title>
    <url>/2019/12/25/46016.html</url>
    <content><![CDATA[<p>在《<a href="https://www.yanbinghu.com/2019/12/23/52416.html">多线程排序</a>》中介绍了多线程排序，似乎看起来多线程快了很多，然而多线程就一定更快吗？<br><a id="more"></a></p>
<h2 id="为什么多线程就不一定快？"><a href="#为什么多线程就不一定快？" class="headerlink" title="为什么多线程就不一定快？"></a>为什么多线程就不一定快？</h2><p>还是拿《<a href="https://www.yanbinghu.com/2019/12/23/52416.html">多线程排序</a>》中的程序举例，下面是各个线程数量的排序结果:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>线程数</th>
<th>时间/s</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2.393644</td>
</tr>
<tr>
<td>2</td>
<td>1.367392</td>
</tr>
<tr>
<td>3</td>
<td>1.386448</td>
</tr>
<tr>
<td>4</td>
<td>1.036919</td>
</tr>
<tr>
<td>5</td>
<td>1.097992</td>
</tr>
<tr>
<td>6</td>
<td>1.218000</td>
</tr>
<tr>
<td>7</td>
<td>1.184615</td>
</tr>
<tr>
<td>8</td>
<td>1.176258</td>
</tr>
</tbody>
</table>
</div>
<p>以上结果可能不准确，但是体现了一些变化趋势，即并不是线程数量越多越快，也不是单线程最快，而是线程数为4的时候最快。</p>
<p>为什么呢？</p>
<p>原因在于我的机器只有4个逻辑CPU，因此4是最合适的。为了不解释太多术语，简单解释一下。一个CPU就像一条流水线，会执行一系列指令，当你很多指定拆成4份（4线程）的时候，它是正好最合适的，少的时候，有一个闲着；而多了，就会存在抢占的情况。举个简单的例子，假设有4个水管可以出水，你现在去接水，那么你在每个水管下放一个桶去接水，自然要比只在一个水管下去接水要快的，但是如果你的水桶数量多于水管数，为了每个水桶都要有水，你在这个过程中就需要去切换水桶，每个水桶换一下，才能都接得上，<strong>而换的这个过程就像线程的上下文切换带来的开销</strong>。</p>
<p>因此，<strong>并不是线程越多越快，最合适的才最快。</strong></p>
<h2 id="单线程有时候反而更快"><a href="#单线程有时候反而更快" class="headerlink" title="单线程有时候反而更快"></a>单线程有时候反而更快</h2><p>说到这你可能更会奇怪了，为什么单线程有时候反而会更快呢？还是拿接水为例，假设虽然有4个水管，但是你只有一个桶，因此你一个人从这个水管里一直接水是最快的，而如果你拿两个桶，这个接一点，又换一下，那个接一点，又换一下，中间显然有中断，相同时间内单个桶接的比较多；这就是单核CPU妄图使用多线程提高效率或者每个线程都需要竞争同一把锁而实际可能会导致更慢的缘故。</p>
<p>举个绑核的例子：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> taskset -c 1 taskset -c 1 ./multiThread 4</span></span><br><span class="line">thread num:4</span><br><span class="line">time 2.378558</span><br></pre></td></tr></table></figure></p>
<p>我使用taskset将程序绑定在一个CPU上运行，可以看其时间足足是不绑核的时候的两倍有余。</p>
<p>什么叫都需要竞争呢？举个极端的例子，我们修改前面的工作线程代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*比较线程，采用快速排序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">workThread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    SortInfo *sortInfo = (SortInfo*)arg;</span><br><span class="line">    <span class="keyword">long</span> idx = sortInfo-&gt;startIdx;</span><br><span class="line">    <span class="keyword">long</span> num = sortInfo-&gt;num;</span><br><span class="line">    qsort(&amp;nums[idx],num,<span class="keyword">sizeof</span>(<span class="keyword">long</span>),compare);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    pthread_barrier_wait(&amp;b);</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的例子比较极端，在排序的时候都给它们加上了锁（关于锁，后面会有文章进行更加详细的介绍。），即哪个线程拿到了锁，就可以继续工作，没有拿到的继续等待。使用完成后再释放。<br>在这样的情况下，看看4线程还有效果吗？<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./multiThread 4</span></span><br><span class="line">thread num:4</span><br><span class="line">time 2.480588</span><br></pre></td></tr></table></figure></p>
<p>是最快的时候两倍多的时间！而且还比单个线程的时候要慢！！！</p>
<p>而另外一种情况，比如说从队列中取出数据，然后进行耗时处理，那么对取出数据的操作进行加锁是可行的，多线程的情况仍然能提高处理速度。但如果你仅仅是读取数据，那么单线程的情况可能会比多线程要快，<strong>因为它避免了线程上下文切换的开销</strong>。</p>
<h4 id="扩展介绍-绑核"><a href="#扩展介绍-绑核" class="headerlink" title="扩展介绍-绑核"></a>扩展介绍-绑核</h4><p>为什么要绑核？</p>
<ul>
<li>充分利用CPU，减少CPU之间上下文切换</li>
<li>指定程序运行在指定CPU，便于区分</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> taskset -c 1 ./proName</span></span><br></pre></td></tr></table></figure>
<p>将proName绑定在第二个核。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> taskset -c 1-3  ./proName</span></span><br></pre></td></tr></table></figure></p>
<p>绑定运行在第二个到第四个核。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> taskset -p 3569</span></span><br><span class="line">pid 3569's current affinity mask: f</span><br></pre></td></tr></table></figure>
<p>查看进程3569当前运行在哪个核上。</p>
<p>mask f转为二进制即为1111，因此四个核都有运行。</p>
<p>当然除了命令行，还有函数接口可以使用，这里就不再扩展了。</p>
<h2 id="如何查看机器的CPU数量"><a href="#如何查看机器的CPU数量" class="headerlink" title="如何查看机器的CPU数量"></a>如何查看机器的CPU数量</h2><p>物理CPU个数，就是你实际CPU的个数：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/cpuinfo | grep <span class="string">"physical id"</span> | sort -u | wc -l </span></span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<p>CPU物理核数，就是你的一个CPU上有多少个核心，现在很多CPU都是多核：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/cpuinfo | grep <span class="string">"core id"</span> | sort -u | wc -l</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>
<p> CPU逻辑核数，一颗物理CPU可以有多个物理内核，加上超线程技术，会让CPU看起来有很多个：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat /proc/cpuinfo | grep &quot;processor&quot; | sort -u | wc -l</span><br><span class="line">4</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>线程上下文切换是有开销的，如果它的收益不能超过它的开销，那么使用多线程来提高效率将得不偿失</strong>。因此不要盲目推崇多线程。如果为了提高效率采用多线程，那么线程中最多应为逻辑CPU数。也就是说如果你的程序绑在一个核上或者你只有一个CPU一个核，那么采用多线程只能提高同时处理的能力，而不能提高处理效率。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程排序</title>
    <url>/2019/12/23/52416.html</url>
    <content><![CDATA[<p>在《<a href="https://www.yanbinghu.com/2019/12/17/19410.html">系统编程-多线程</a>》中已经了解了多线程的一些特点，其中包括快！那么今天就来看看如何利用多线程来排序。<br><a id="more"></a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们的思路是这样的：</p>
<ul>
<li>假设有N个线程，则将数组数M据分为N组</li>
<li>每个线程对其中的一组数据使用库函数提供的快速排序算法</li>
<li>所有线程排序完成后，将每组排序好的数组合并</li>
</ul>
<p>举个例子，使用4个线程对11个数据进行排序：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12,10,4,7,9,6,8,1,5,16,11</span><br></pre></td></tr></table></figure></p>
<p>由于4不能被10整除，因此，前面三个线程，每个负责排序10%（4-1）= 3三个数，最后一个线程负责排序最后两个数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>线程0</th>
<th>线程1</th>
<th>线程2</th>
<th>线程3</th>
</tr>
</thead>
<tbody>
<tr>
<td>12,10,4</td>
<td>7,9,6</td>
<td>8,1,5</td>
<td>16,11</td>
</tr>
</tbody>
</table>
</div>
<p>假设这4个线程都完成了自己的工作后，内容如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>线程0</th>
<th>线程1</th>
<th>线程2</th>
<th>线程3</th>
</tr>
</thead>
<tbody>
<tr>
<td>4,10,12</td>
<td>6,7,9</td>
<td>1,5,8</td>
<td>11,16</td>
</tr>
</tbody>
</table>
</div>
<p>最后由主线程将已经排好的每组进行合并：</p>
<ul>
<li>比较每组的第一个，选出最小的一个，这里是线程2的1，放到新数组的下标0处</li>
<li>将1放到新的数组最开始的位置，线程的下次计较的内容后移，即下次比较时，比较线程2的第二个数。</li>
<li>循环比较</li>
</ul>
<p>最终可以得到合并的数据：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 4 5 6 7 8 9 10 11 12 16</span><br></pre></td></tr></table></figure></p>
<h2 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h2><p>通过上面的分析，我们需要多个线程进行排序后，一起交给主线程合并，因此需要有方法等待所有线程完成事情之后，再退出。<br>在《<a href="https://www.yanbinghu.com/2019/12/17/19410.html">系统编程-多线程</a>》中介绍了pthread_join，今天我们使用pthread_barrier_wait。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_destroy</span><span class="params">(<span class="keyword">pthread_barrier_t</span> *barrier)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_init</span><span class="params">(<span class="keyword">pthread_barrier_t</span> *<span class="keyword">restrict</span> barrier,</span></span></span><br><span class="line">const pthread_barrierattr_t *restrict attr, unsigned count)；</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_wait</span><span class="params">(<span class="keyword">pthread_barrier_t</span> *barrier)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>在解释之前说明一下基本原理，pthread_barrier_wait等待某一个条件达到（计数到达），一旦达到后就会继续往后执行。当然了，如果你希望各个线程完成它自己的工作，主线程再进行合并动作，则你等待的数量可以再加一个。：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//https://www.yanbinghu.com</span></span><br><span class="line"><span class="comment">//barrier.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pthread_barrier_t</span> b;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">workThread</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread %d\n"</span>,*(<span class="keyword">int</span>*)arg);</span><br><span class="line">    pthread_barrier_wait(&amp;b);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> threadNum = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="comment">/*计数为创建线程数+1*/</span></span><br><span class="line">    pthread_barrier_init(&amp;b,<span class="literal">NULL</span>,threadNum + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="comment">/*创建多个线程*/</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; threadNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        err = pthread_create(&amp;tid,<span class="literal">NULL</span>,workThread,(<span class="keyword">void</span>*)&amp;i);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> != err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"create thread failed\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"tid:%ld\n"</span>,tid);</span><br><span class="line">        usleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_barrier_wait(&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"all thread finished\n"</span>);</span><br><span class="line">    <span class="comment">/*销毁*/</span></span><br><span class="line">    pthread_barrier_destroy(&amp;b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，pthread_barrier_init用来初始化相关资源，而pthread_barrier_destroy用来销毁相关资源。<br>编译运行：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -o barrier barrier.c  -lpthread</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./barrier</span></span><br><span class="line">tid:140323085256448</span><br><span class="line">thread 0</span><br><span class="line">tid:140323076863744</span><br><span class="line">thread 1</span><br><span class="line">tid:140323068471040</span><br><span class="line">thread 2</span><br><span class="line">tid:140323060078336</span><br><span class="line">thread 3</span><br><span class="line">all thread finished</span><br></pre></td></tr></table></figure></p>
<h2 id="比较函数"><a href="#比较函数" class="headerlink" title="比较函数"></a>比较函数</h2><p>为了使用qsort函数，我们需要实现自己的比较函数，参考《<a href="https://www.yanbinghu.com/2019/01/03/3593.html">高级指针话题-函数指针</a>》：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//https:www.yanbinghu.com</span></span><br><span class="line"><span class="comment">/*比较函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* num1, <span class="keyword">const</span> <span class="keyword">void</span>* num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> l1 = *(<span class="keyword">long</span>*)num1;</span><br><span class="line">    <span class="keyword">long</span> l2 = *(<span class="keyword">long</span>*)num2;</span><br><span class="line">    <span class="keyword">if</span>(l1 == l2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l1 &lt; l2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>对于每个线程完成它自己的任务之后，需要合并所有内容，关于合并的逻辑前面已经举例了，这里不再多介绍。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//https://www.yanbinghu.com</span></span><br><span class="line"><span class="comment">/*要排序的数组信息*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SortInfo_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> startIdx; <span class="comment">//数组启始下标</span></span><br><span class="line">    <span class="keyword">long</span> num;<span class="comment">//要排序的数量</span></span><br><span class="line">&#125;SortInfo;</span><br><span class="line"><span class="comment">/*合并线程已经排序好的内容*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(SortInfo *sortInfos,<span class="keyword">size_t</span> threadNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> idx[threadNum];</span><br><span class="line">    <span class="built_in">memset</span>(idx,<span class="number">0</span>,threadNum);</span><br><span class="line">    <span class="keyword">long</span> i,minidx,sidx,num;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; threadNum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        idx[i] = sortInfos[i].startIdx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(sidx = <span class="number">0</span>;sidx &lt; NUM;sidx++)</span><br><span class="line">    &#123;</span><br><span class="line">        num = LONG_MAX;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; threadNum;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(idx[i] &lt; (sortInfos[i].startIdx + sortInfos[i].num) &amp;&amp; (nums[idx[i]] &lt; num))</span><br><span class="line">            &#123;</span><br><span class="line">                num = nums[idx[i]];</span><br><span class="line">                minidx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        snums[sidx] = nums[idx[minidx]];</span><br><span class="line">        idx[minidx]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h2><p>关于生成方法，参考《<a href="https://www.yanbinghu.com/2019/12/22/6131.html">随机数生成的N种姿势</a>》。</p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">https://www.yanbinghu.com</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 8000000L</span></span><br><span class="line"><span class="keyword">long</span> nums[NUM];</span><br><span class="line"><span class="keyword">long</span> snums[NUM];</span><br><span class="line"><span class="keyword">pthread_barrier_t</span> b;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">/*比较函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* num1, <span class="keyword">const</span> <span class="keyword">void</span>* num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> l1 = *(<span class="keyword">long</span>*)num1;</span><br><span class="line">    <span class="keyword">long</span> l2 = *(<span class="keyword">long</span>*)num2;</span><br><span class="line">    <span class="keyword">if</span>(l1 == l2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l1 &lt; l2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*要排序的数组信息*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SortInfo_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> startIdx; <span class="comment">//数组启始下标</span></span><br><span class="line">    <span class="keyword">long</span> num;<span class="comment">//要排序的数量</span></span><br><span class="line">&#125;SortInfo;</span><br><span class="line"><span class="comment">/*比较线程，采用快速排序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">workThread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    SortInfo *sortInfo = (SortInfo*)arg;</span><br><span class="line">    <span class="keyword">long</span> idx = sortInfo-&gt;startIdx;</span><br><span class="line">    <span class="keyword">long</span> num = sortInfo-&gt;num;</span><br><span class="line">    qsort(&amp;nums[idx],num,<span class="keyword">sizeof</span>(<span class="keyword">long</span>),compare);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    pthread_barrier_wait(&amp;b);</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*合并线程已经排序好的内容*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(SortInfo *sortInfos,<span class="keyword">size_t</span> threadNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> idx[threadNum];</span><br><span class="line">    <span class="built_in">memset</span>(idx,<span class="number">0</span>,threadNum);</span><br><span class="line">    <span class="keyword">long</span> i,minidx,sidx,num;</span><br><span class="line">    <span class="comment">/*记录索引信息*/</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; threadNum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        idx[i] = sortInfos[i].startIdx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*遍历各个数据，已经比较过后，比较下标增加*/</span></span><br><span class="line">    <span class="keyword">for</span>(sidx = <span class="number">0</span>;sidx &lt; NUM;sidx++)</span><br><span class="line">    &#123;</span><br><span class="line">        num = LONG_MAX;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; threadNum;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(idx[i] &lt; (sortInfos[i].startIdx + sortInfos[i].num) &amp;&amp; (nums[idx[i]] &lt; num))</span><br><span class="line">            &#123;</span><br><span class="line">                num = nums[idx[i]];</span><br><span class="line">                minidx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        snums[sidx] = nums[idx[minidx]];</span><br><span class="line">        idx[minidx]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*记录耗费时间*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">start</span>,<span class="title">end</span>;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> startusec,endusec;</span><br><span class="line">    <span class="keyword">double</span> elapsed;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;<span class="comment">/*线程id*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> perThreadNum;</span><br><span class="line">    <span class="keyword">long</span> lastThreadNum;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*获取线程数量，默认为1*/</span></span><br><span class="line">    <span class="keyword">size_t</span> threadNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">1</span>)</span><br><span class="line">        threadNum = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == threadNum)</span><br><span class="line">        threadNum = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread num:%zu\n"</span>,threadNum);</span><br><span class="line">    SortInfo *sortInfos = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SortInfo)*threadNum);</span><br><span class="line">    <span class="built_in">memset</span>(sortInfos,<span class="number">0</span>,<span class="keyword">sizeof</span>(SortInfo)*threadNum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*生成随机数组*/</span></span><br><span class="line">    srandom(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; NUM;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[i] = random();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*如果不能整除，调整最后一个线程处理的数据量*/</span></span><br><span class="line">    <span class="keyword">long</span> PER_THREAD_NUM = NUM / threadNum;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> != NUM % threadNum)</span><br><span class="line">    &#123;</span><br><span class="line">        perThreadNum = NUM / (threadNum - <span class="number">1</span>);</span><br><span class="line">        lastThreadNum = NUM % (threadNum - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        perThreadNum = PER_THREAD_NUM;</span><br><span class="line">        lastThreadNum = PER_THREAD_NUM; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;start,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_barrier_init(&amp;b,<span class="literal">NULL</span>,threadNum + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/*创建线程，并进行排序，传入要排序的部分*/</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; threadNum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sortInfos[i].startIdx = i*perThreadNum;</span><br><span class="line">        sortInfos[i].num = perThreadNum;</span><br><span class="line">        <span class="keyword">if</span>(i == threadNum - <span class="number">1</span>)</span><br><span class="line">           sortInfos[i].num = lastThreadNum; </span><br><span class="line">        err = pthread_create(&amp;tid,<span class="literal">NULL</span>,workThread,(<span class="keyword">void</span>*)(&amp;sortInfos[i]));</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> != err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"create failed\n"</span>);</span><br><span class="line">            <span class="built_in">free</span>(sortInfos);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_barrier_wait(&amp;b);</span><br><span class="line">    pthread_barrier_destroy(&amp;b);</span><br><span class="line">    <span class="comment">/*合并*/</span></span><br><span class="line">    merge(&amp;sortInfos[<span class="number">0</span>],threadNum);</span><br><span class="line">    gettimeofday(&amp;end,<span class="literal">NULL</span>);</span><br><span class="line">    startusec = start.tv_sec * <span class="number">1000000</span> + start.tv_usec;</span><br><span class="line">    endusec = end.tv_sec * <span class="number">1000000</span> + end.tv_usec;</span><br><span class="line">    elapsed = (<span class="keyword">double</span>)(endusec - startusec)/<span class="number">1000000.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"time %f\n"</span>,elapsed);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NUM;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf("%ld\n",snums[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(sortInfos);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或阅读原文查看。</p>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>对800W数据进行排序，排序时间：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ threadSort 1</span><br><span class="line">thread num:1</span><br><span class="line">time 2.369488</span><br></pre></td></tr></table></figure></p>
<p>使用4个线程时：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ threadSort <span class="number">4</span></span><br><span class="line">thread num:<span class="number">4</span></span><br><span class="line">time <span class="number">1.029097</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到速度提升是比较明显的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以看到使用4线程排序要比单个线程排序快很多，不过以上实现仅供参考，本文例子可能也存在不妥之处，请根据实际数据情况选择合适的排序算法。但是，多线程就一定快吗？敬请关注下一篇。</p>
<p>参考：《unix环境高级编程》</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言生成随机数</title>
    <url>/2019/12/22/6131.html</url>
    <content><![CDATA[<p>首先需要说明的是，计算机中生成的随机数严格来说都是伪随机，即非真正的随机数，真正随机数的随机样本不可重现。那么我们来看看代码中有哪些方式可以生成随机数。<br><a id="more"></a></p>
<h2 id="rand"><a href="#rand" class="headerlink" title="rand"></a>rand</h2><p>rand函数声明如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>rand函数返回[0,RAND_MAX）范围的随机整数，在我的机器上，RAND_MAX为2147483647。<br>使用示例：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">rand.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,rand());</span><br><span class="line">        i++;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o rand rand.c</span><br><span class="line">./rand</span><br><span class="line">1804289383 846930886 1681692777 1714636915 1957747793</span><br></pre></td></tr></table></figure></p>
<p>多运行几次，你就会惊喜地发现，每次运行的结果都是一样的！！！这还玩个毛线？</p>
<h2 id="srand"><a href="#srand" class="headerlink" title="srand"></a>srand</h2><p>别急，rand虽然每次运行的结果都是一样的，那是因为它的种子默认为1。每一个种子会有一串看似随机的序列，每次取下一个出来，整体都近乎是随机分布的，但是如果你的种子每次都是一样的，那么每次运行可能得到的结果也是一样的。我们需要利用srand给它一个种子。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">srand</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seed)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>为了保证我们每次的得到的随机数不一样，我们必须在每次调用时，都确保种子不一样，因此通常会选择使用时间作为种子。注意这只是通常的种子选择，你可以根据实际使用需求进行选择。</p>
<p>于是我们在使用之前设置好种子，使用示例：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">rand.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));<span class="comment">//设置随机种子，注意只需要设置一次即可</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">5</span>)<span class="comment">//生成5个随机数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,rand());</span><br><span class="line">        i++;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在好了，每次运行生成的都不一样了。但是还有一个问题，如果这种方式在多线程下使用，也是不可取的，因为rand不是可重入函数。它的每次调用都会修改一些隐藏的属性，因此在多线程中并不会使用它。</p>
<h2 id="rand-r"><a href="#rand-r" class="headerlink" title="rand_r"></a>rand_r</h2><p>为了在多线程下使用，我们使用rand_r，使用方式和rand是一样的：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand_r</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> *seedp)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>使用示例：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seed = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">5</span>)<span class="comment">//生成5个随机数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,rand_r(&amp;seed));</span><br><span class="line">        i++;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>多线程中，多个线程可能几乎同时调用，那它们的种子可能也一样，如果想不一样，还可以将种子设置成和线程id有关。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> seed  = time(<span class="literal">NULL</span>)^pthread_self();</span><br></pre></td></tr></table></figure></p>
<h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><p>通过前面的例子可以发现，rand生成的整数范围是有限的，为了生成更大范围，可以使用random：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">random</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">srandom</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seed)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>random返回的类型为long int，因此在一定程度上，它生成的范围要大得多。另外与rand类似，需要使用srandom函数设置种子。具体的例子就不再放出了。</p>
<h2 id="生成指定范围随机数"><a href="#生成指定范围随机数" class="headerlink" title="生成指定范围随机数"></a>生成指定范围随机数</h2><p>前面的例子都是生成[1,RAND_MAX]之间的数，如果要生成指定区间的随机数呢？假设a和b不超过int范围以及它们的差值不超过rand的生成范围。</p>
<h4 id="a-b"><a href="#a-b" class="headerlink" title="[a,b)"></a>[a,b)</h4><p>左闭右开区间，即包含a，不包含：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(rand() % (b - a)) + a;</span><br></pre></td></tr></table></figure></p>
<h4 id="a-b-1"><a href="#a-b-1" class="headerlink" title="[a,b]"></a>[a,b]</h4><p>左闭右闭，即包含a和b：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(rand() % (b - a + <span class="number">1</span>)) + a;</span><br></pre></td></tr></table></figure></p>
<h4 id="a-b-2"><a href="#a-b-2" class="headerlink" title="(a,b]"></a>(a,b]</h4><p>左开右闭，即不包含a，包含b：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(rand() % (b-a)) + a + <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="0到1之间的浮点数"><a href="#0到1之间的浮点数" class="headerlink" title="0到1之间的浮点数"></a>0到1之间的浮点数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rand()/(<span class="keyword">double</span>)RAND_MAX;</span><br></pre></td></tr></table></figure>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>生成[2,10)之间的随机数5个：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));<span class="comment">//设置随机种子，注意只需要设置一次即可</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">5</span>)<span class="comment">//生成5个随机数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,( rand() % ( b - a ) )+ a);</span><br><span class="line">        i++;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>记住，通过这些方法生成的都是伪随机数，而一个好的随机算法，它的随机性很强，可能需要根据使用场景去设计具体的算法。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>系统编程-文件读写</title>
    <url>/2019/12/19/8355.html</url>
    <content><![CDATA[<p>在《<a href="https://www.yanbinghu.com/2019/12/11/54424.html">系统编程-文件IO</a>》中简单介绍了文件I/O的基本流程，无论选项或者参数多么变化多端，其流程大抵相同，不过是获取文件描述符，用描述符进行操作，关闭描述符，三步而已。那么文件读写又是怎样的流程？需要注意什么？<br><a id="more"></a></p>
<h2 id="write-read"><a href="#write-read" class="headerlink" title="write/read"></a>write/read</h2><p>在说明这些常见出错之前，就必须先了解其基本用法了。需要注意的是，write/read是不带缓冲的，调用一次，写一次。与fwrite/fread有区别，另外write/read为系统调用，频繁地系统调用将会增加开销，可参考《<a href="https://www.yanbinghu.com/2018/05/28/26708.html">库函数和系统调用的区别</a>》。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>参数解释：</p>
<ul>
<li>fd  文件描述符，这个应该不用多做解释</li>
<li>buf 要写入的内容，或者读出内容存储的buf，合适的大小非常关键</li>
<li>count 读或写的内容大小</li>
</ul>
<p>这里有两点需要注意一下。</p>
<p>返回值为ssize_t类型，因为它的返回值可以为负，表示出错，有趣的是这样一来使得其能表示的读写字节范围少了近一半。<br>返回大于0，表示读或写入对应的字节数。对于read，返回0表示到文件结尾。</p>
<p>另外，我们还注意到，write函数的第二个参数由const修饰。为什么要使用const来修饰？</p>
<p>很显然，在写的过程中，write函数不应该对buf的内容进行修改，它仅仅是从buf中读取罢了。这里在编码时常用的设计，如果不希望该函数修改其内容，则加上const限定符。const详细说明参考《<a href="https://www.yanbinghu.com/2019/01/28/7442.html">const关键字到底该怎么用？</a>》。</p>
<p>那么返回的读写大小，和参数里的count大小有何区别？前者是真实读写的字节数，而后者是期望读写的字节数。举个简单的例子，文件中有16字节内容，而你尝试读64字节，自然最终只会读到16字节。</p>
<h2 id="正常读写"><a href="#正常读写" class="headerlink" title="正常读写"></a>正常读写</h2><p>正常读写的例子如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//博客：https://www.yanbinghu.com</span></span><br><span class="line"><span class="comment">//file.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> writeBuf[] = <span class="string">"https://www.yanbinghu.com"</span>;</span><br><span class="line">    <span class="keyword">char</span> readBuf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">/*可读可写，不存在时创建，有内容时截断*/</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"test.txt"</span>,O_RDWR | O_CREAT | O_TRUNC);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*写内容*/</span></span><br><span class="line">    <span class="keyword">ssize_t</span> wLen = write(fd,writeBuf,<span class="keyword">sizeof</span>(writeBuf));</span><br><span class="line">    <span class="keyword">if</span>(wLen &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"write failed"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"write len:%ld\n"</span>,wLen);</span><br><span class="line">    <span class="keyword">ssize_t</span> rLen = read(fd,readBuf,<span class="keyword">sizeof</span>(readBuf));</span><br><span class="line">    <span class="keyword">if</span>(rLen &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"read failed"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    readBuf[<span class="keyword">sizeof</span>(readBuf)<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"read content:%s\n"</span>,readBuf);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行，然后你就会惊喜地发现，结果并不是如你想地那样：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -o writeFile file.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./writeFile</span></span><br><span class="line">write len:26</span><br><span class="line">read content:</span><br></pre></td></tr></table></figure></p>
<p>我们查看文件可以看到内容已经写进去了，但是读取出来地内容却是空！</p>
<p>这是为何？<br>理解这个问题需要理解文件描述符和偏移量。</p>
<h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>文件描述符虽然只是一个整型值，但它只是一个索引值，它指向了该进程打开文件的记录表。还记得常说的“一切皆文件”吗？实际上，即使你每打开一个TCP链接，都会有一个对应的文件描述符。这个记录表中包含了很多与文件相关地信息，例如文件偏移量，inode，状态标志等等。</p>
<p>而你每一次进行读写，都会影响所谓地文件偏移量。</p>
<p>因此你在第一次进行写之后，文件偏移量类似于下面这样：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><a href="https://www.yanbinghu.com\0">https://www.yanbinghu.com\0</a></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>&uarr;</td>
</tr>
</tbody>
</table>
</div>
<p>那么你进行第一次读的时候，文件偏移已经到文件的末尾了（此时函数返回值为0），所以你肯定读不出任何内容，因此你需要移动偏移指针。</p>
<h4 id="设置偏移量"><a href="#设置偏移量" class="headerlink" title="设置偏移量"></a>设置偏移量</h4><p>为了读取写入后的内容，我们必须要设置偏移量，设置成像下面这样：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><a href="https://www.yanbinghu.com\0">https://www.yanbinghu.com\0</a></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>&uarr;</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>有人可能会好奇，这最后为什么还有一个\0？很显然，它被自动加上了，具体原因可以参考《<a href="https://www.yanbinghu.com/2019/08/19/18180.html">NULL,0,’0’你真的分清了吗</a>》。</p>
<p>还有人会问，你怎么看出有一个\0？用od命令看一下就知道了。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> od -c test.txt</span></span><br><span class="line">0000000   h   t   t   p   s   :   /   /   w   w   w   .   y   a   n   b</span><br><span class="line">0000020   i   n   g   h   u   .   c   o   m  \0</span><br><span class="line">0000032</span><br></pre></td></tr></table></figure></p>
<p>现在看到了吧。</p>
<p>为了设置偏移量，我们需要用到函数lseek：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">lseek</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>成功返回新的文件偏移量，出错返回-1。</p>
<p>有必要对参数进行解释</p>
<ul>
<li>offset 相对于whence的偏移量</li>
<li>whence 相对位置</li>
</ul>
<p>其中whence有三个值</p>
<ul>
<li>SEEK_SET  文件开始处</li>
<li>SEEK_CUR  当前位置</li>
<li>SEEK_END   文件末尾</li>
</ul>
<p>举个例子，假设当前offset为-4，whence为SEEK_CUR，那么当写完内容，并设置该选项后的文件偏移位置如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><a href="https://www.yanbinghu" target="_blank" rel="noopener">https://www.yanbinghu</a>.</th>
<th>com</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>&uarr;</td>
</tr>
</tbody>
</table>
</div>
<p>注意，offset是可以为负的。</p>
<p>说白了可以设置偏移位置，而设置可以相对三个位置，开头，当前和结尾。</p>
<h4 id="读取写入的内容"><a href="#读取写入的内容" class="headerlink" title="读取写入的内容"></a>读取写入的内容</h4><p>好了，为了读取到我们写入的内容，我们已经知道怎么做了，就是设置偏移量在文件开头，即在读之前加上下面的语句：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lseek(fd, 0, SEEK_SET);//注意检查返回值</span><br></pre></td></tr></table></figure></p>
<p>然后再次编译运行：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">write len:<span class="number">26</span></span><br><span class="line">read content:https:<span class="comment">//www.yanbinghu.com</span></span><br></pre></td></tr></table></figure></p>
<p>如你所愿！</p>
<h2 id="常见报错"><a href="#常见报错" class="headerlink" title="常见报错"></a>常见报错</h2><p>使用不当或者出错的时候会有错误信息，这在编码的时候就需要注意检查。</p>
<h4 id="Bad-file-descriptor"><a href="#Bad-file-descriptor" class="headerlink" title="Bad file descriptor"></a>Bad file descriptor</h4><p>通常使用了一个并不合法的文件描述符，例如，该文件描述符已经关闭。通常你可以通过下面的命令来观察文件描述符的打开情况：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -al /proc/`pidof procName`/fd/</span><br></pre></td></tr></table></figure></p>
<p>这里的procName是你正在运行的程序名。</p>
<p>也有可能是你打开模式不对，例如，以只读方式打开，却尝试写。</p>
<h4 id="Interrupted-system-call"><a href="#Interrupted-system-call" class="headerlink" title="Interrupted system call"></a>Interrupted system call</h4><p>通常是在读写过程中被中断，常见的如对socket进行读写时，链接被意外中断，或者读写时，进程被中断等等。</p>
<h4 id="File-exists"><a href="#File-exists" class="headerlink" title="File exists"></a>File exists</h4><p>通常在你想创建一个文件，但是文件已经存在的情况。</p>
<h4 id="No-such-file-or-directory"><a href="#No-such-file-or-directory" class="headerlink" title="No such file or directory"></a>No such file or directory</h4><p>就如字面意思，通常是文件或者目录不存在，也许你使用了O_CREATE标志，但是如果你的目录不存在，文件也无法创建成功。</p>
<p>还有一种情况是，你已经打开了该文件，程序执行过程中，该文件又被人删除了，删除后又创建了一个文件名一样的文件，这样的情况下，也有可能会提示该错误。</p>
<h4 id="Too-many-open-fileswrite"><a href="#Too-many-open-fileswrite" class="headerlink" title="Too many open fileswrite"></a>Too many open fileswrite</h4><p>进程打开的文件过多。一个进程打开的文件数量是有限的，具体可以通过：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ulimit -n</span><br><span class="line">65535</span><br></pre></td></tr></table></figure></p>
<p>至于当前已经打开了多少，可以这样统计：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -l /proc/`pidof proName`/fd/ |wc -l</span><br></pre></td></tr></table></figure></p>
<p>proName为你的进程名。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一些常见错误中很多涉及到网络的读写，这里暂时没有提及。</p>
<p>一般情况，不会用同一个文件描述符对文件进行既读又写，一旦出现这样的场景时，需要注意偏移量的设置。虽然本文的I/O函数不带缓冲，但是读写时，选择合适的buf大小也非常关键。</p>
<p>另外编程中也有以下建议：</p>
<ul>
<li>检查接口的返回值，处理出错场景</li>
<li>对于不期望被修改内容的参数，添加const限定符</li>
<li>善用man手册</li>
</ul>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>系统编程-多线程(1)</title>
    <url>/2019/12/17/19410.html</url>
    <content><![CDATA[<p>多线程，作为一个开发者，这个名词应该不陌生。我在《<a href="https://www.yanbinghu.com/2018/09/07/47517.html">对进程和线程的一些总结</a>》中也有介绍，这里就不详述。<br><a id="more"></a></p>
<h2 id="为什么要用多线程"><a href="#为什么要用多线程" class="headerlink" title="为什么要用多线程"></a>为什么要用多线程</h2><p>很显然，多线程能够同时执行多个任务。举个例子，你打开某视频播放器，点击下载某个视频，然后你发现这个时候一直在下载，其他啥都干不了，那你肯定骂*。所以在这种情况下，可以使用多线程，让下载任务继续，同时也能继续其他操作。</p>
<p>作为一个包工头，一堆砖要搬，但是就一个人，可是你只能搬这么多，怎么办？多找几个人一起搬呗，但是其他人就也需要付工钱，没关系，能早点干完也就行了，反正总体工钱差不多。</p>
<p>同样的，如果有一个任务特别耗时，而这个任务可以拆分为多个任务，那么就可以让每个线程去执行一个任务，这样任务就可以更快地完成了。</p>
<h2 id="代价"><a href="#代价" class="headerlink" title="代价"></a>代价</h2><p>听起来都很好，但是多线程是有代价的。由于它们“同时”进行任务，那么它们任务的有序性就很难保障，而且一旦任务相关，它们之间可能还会竞争某些公共资源，造成死锁等问题。</p>
<h2 id="绑核"><a href="#绑核" class="headerlink" title="绑核"></a>绑核</h2><p>通过下面的命令可将进程proName程序绑在1核运行：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">taskset -c <span class="number">1</span> ./proName</span><br></pre></td></tr></table></figure></p>
<p>而如果只绑定了一个核，那么同一时刻，只有一个线程在运行，而线程之间的切换又会消耗资源，那么这种情况下反而会导致性能降低。</p>
<p>另外一种情况，就是设置的线程数大于总的逻辑CPU数：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ cat /proc/cpuinfo| grep <span class="string">"processor"</span>| wc -l</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure></p>
<p>这样的情况下，设置更多的线程并不会提高处理速度。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>优点：</p>
<ul>
<li>更快，加快处理任务</li>
<li>更强，同时处理多任务</li>
</ul>
<p>缺点：</p>
<ul>
<li>难控制，编程困难</li>
<li>不当使用降低性能，线程切换</li>
<li>bug难定位，资源竞争</li>
</ul>
<h2 id="如何创建多线程"><a href="#如何创建多线程" class="headerlink" title="如何创建多线程"></a>如何创建多线程</h2><p>普通的进程通常只有一个线程，称为主线程。</p>
<p>创建线程需要使用下面的函数：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">void</span> *(*start_routine) (<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>参数有必要做一下说明</p>
<ul>
<li>thread 线程ID指针，创建成功时，会保存在此</li>
<li>attr 线程属性，控制线程的一些行为</li>
<li>start_routine 线程运行起始地址，是一个函数指针</li>
<li>arg 函数的参数，只有一个参数，因此多个参数需要打包在一起</li>
</ul>
<p>创建成功时，返回0，否则出错。<br>看到了吗，到处都有void*的身影（参考《<a href="https://www.yanbinghu.com/2019/12/15/19682.html">void*是什么玩意</a>》）。</p>
<p>使用时注意包含头文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br></pre></td></tr></table></figure></p>
<p>，并且在链接时加上-lpthread，因此它不在libc库中。在《<a href="https://www.yanbinghu.com/2018/10/06/46212.html">一个奇怪的链接问题</a>》中提到，对于非glibc库中的库函数，都需要显式链接对应的库。</p>
<p>试着写一个简单的多线程程序，简单起见，我们暂时不设置任何属性，将attr字段设置为NULL：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">myThread</span><span class="params">(<span class="keyword">void</span> *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"thread run,value is %d\n"</span>,*(<span class="keyword">int</span>*)id);</span><br><span class="line">	<span class="comment">//return NULL; 这种方式也可以退出线程</span></span><br><span class="line">	pthread_exit((<span class="keyword">void</span>*)<span class="number">0</span>);<span class="comment">//退出线程</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid ;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> status = pthread_create(&amp;tid,<span class="literal">NULL</span>,myThread,(<span class="keyword">void</span>*)&amp;i);</span><br><span class="line">	<span class="keyword">if</span>(status &lt; <span class="number">0</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"crete failed\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main func finished\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -o main main.c -lpthread</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./main</span></span><br><span class="line">main func finished</span><br></pre></td></tr></table></figure></p>
<p>发现运行的结果并不如我们预期那样，就好像线程没有执行一样。</p>
<p>原因在于，如果主线程退出了，那么其他线程也会退出。所谓，皮之不存，毛将焉附，所有线程都共同使用很多资源，相关内容也可以从《<a href="https://www.yanbinghu.com/2018/09/07/47517.html">对进程和线程的一些总结</a>》中了解到。<br>如何改进呢？我们可以等线程执行完啊，于是，在主线程退出前sleep:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid ;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> status = pthread_create(&amp;tid,<span class="literal">NULL</span>,myThread,(<span class="keyword">void</span>*)&amp;i);</span><br><span class="line">	<span class="keyword">if</span>(status &lt; <span class="number">0</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"crete failed\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main func finished\n"</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就好了（注意添加头文件<figure class="highlight plain"><figcaption><span><unistd.h>```）。</unistd.h></span></figcaption><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">main func finished</span><br><span class="line">thread run,value is 10</span><br></pre></td></tr></table></figure></p>
<p>但是你会发现，<figure class="highlight plain"><figcaption><span>func finished```可能会先打印。这也就呼应了文章标题。</span></figcaption><table><tr><td class="code"><pre><span class="line">但是转念一想，如果线程执行的时间超过一秒呢，难道就要sleep更长时间吗？而很多时候甚至根本不知道线程要执行多长时间，那怎么办呢？</span><br><span class="line"></span><br><span class="line">还可以使用：</span><br><span class="line">```c</span><br><span class="line">int pthread_join(pthread_t thread, void **retval);</span><br></pre></td></tr></table></figure></p>
<p>thread是前面获得的线程id，而retval包含了线程的返回信息，假设我们完全不关心线程的退出状态，那么可以设置为NULL。</p>
<p>修改代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid ;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> status = pthread_create(&amp;tid,<span class="literal">NULL</span>,myThread,(<span class="keyword">void</span>*)&amp;i);</span><br><span class="line">	<span class="keyword">if</span>(status &lt; <span class="number">0</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"crete failed\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main func finished\n"</span>);</span><br><span class="line">    pthread_join(tid,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种情况同样可以达到目的，pthread_join，会阻塞程序，直到线程退出（前提是线程为非分离线程）。</p>
<h2 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h2><p>以下几种情况下，线程会终止</p>
<ul>
<li>线程函数返回</li>
<li>调用pthread_exit，主线程调用无碍</li>
<li>调用pthread_cancel</li>
<li>调用exit，或者主线程退出，所有线程终止<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2>假如修改下面的代码：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> status = pthread_create(&amp;tid,<span class="literal">NULL</span>,myThread,(<span class="keyword">void</span>*)&amp;i);</span><br><span class="line">	<span class="keyword">if</span>(status &lt; <span class="number">0</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"crete failed\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	i = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main func finished\n"</span>);</span><br><span class="line">	pthread_join(tid,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在创建线程后，修改i的值，你会发现在线程中打印的不会是10，而是6。</p>
<p>也就是说，创建线程的时候，传入的参数必须确保其使用这个参数时，参数没有被修改，否则的话，拿到的将是错误的值，</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文通过一些小例子，简单介绍了线程概念，对于绑核，多线程同步等问题均一笔带过，将在后面的文章中继续介绍。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>void*到底是什么玩意？</title>
    <url>/2019/12/15/19682.html</url>
    <content><![CDATA[<p>说到C就不得不提指针，而一提到指针，有一个是比较特殊的，那就是void*。</p>
<p>void*到底是怎样的存在？</p>
<a id="more"></a>
<h2 id="指针类型的含义"><a href="#指针类型的含义" class="headerlink" title="指针类型的含义"></a>指针类型的含义</h2><p>在说明void*之前，先了解一下普通指针类型的含义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">0x01020304</span>,<span class="number">2019</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *b = a;</span><br><span class="line">    <span class="keyword">char</span> *c = (<span class="keyword">char</span>*)&amp;a[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b+1:%d\n"</span>,*(b+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c+1:%d\n"</span>,*(c+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的输出结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b+1:2019</span><br><span class="line">c+1:3</span><br></pre></td></tr></table></figure></p>
<p>对于上面的结果，也许你并不感到意外。如果你的疑问是为什么不是2而是3，那么建议你看看《<a href="https://www.yanbinghu.com/2018/10/02/25450.html">理一理字节序的事</a>》。同样是指针类型，b和c有什么区别？<br>一个是指向整型的指针，一个是指向char型的指针，当它们执行算术运算时，它们的步长就是对应类型占用空间大小。<br>即<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">b + <span class="number">1</span> <span class="comment">//移动sizeof(int)字节</span></span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>04</th>
<th>03</th>
<th>02</th>
<th>01</th>
<th>2019</th>
</tr>
</thead>
<tbody>
<tr>
<td>字节0</td>
<td>字节1</td>
<td>字节2</td>
<td>字节3</td>
<td>字节4~7</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&uarr;</td>
</tr>
</tbody>
</table>
</div>
<p>指针移动4个字节后，指向的就是2019了，解引用自然得到2019。</p>
<p>而对于c<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">c + <span class="number">1</span> <span class="comment">//移动sizeof(char)字节</span></span><br></pre></td></tr></table></figure></p>
<p>它的指向如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>04</th>
<th>03</th>
<th>02</th>
<th>01</th>
<th>2019</th>
</tr>
</thead>
<tbody>
<tr>
<td>字节0</td>
<td>字节1</td>
<td>字节2</td>
<td>字节3</td>
<td>字节4~7</td>
</tr>
<tr>
<td></td>
<td>&uarr;</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>解引用之后，自然得到3。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>各种类型之间没有本质区别，只是解释内存中的数据方式不同。</p>
<p>例如，对于int型指针b，解引用时，会解析4字节，算术运算时，也是以该类型占用空间大小为单位，所以b+1，移动4字节，解引用，处理4字节内容，得到2019。</p>
<p>对于char型指针c，解引用时，会解析1个字节，算术运算时，也是以sizeof(char)为单位，所以c+1，移动一字节，解引用，处理1字节，得到03。</p>
<p>所以像下面这样的操作：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = &#123;<span class="number">01</span>,<span class="number">02</span>,<span class="number">03</span>,<span class="number">04</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *b = (<span class="keyword">int</span>*)a+<span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果你试图解引用b，即*b，就可能遇到无法预料的问题，因为将会访问非法内存位置。</p>
<p>a+2，移动sizeof(char)字节，指向03，此时按照int类型指针解引用，由于int类型解引用会处理4字节内存，但是后面已经没有属于数组a的合法内容了，因此可能出错。</p>
<h2 id="指针占用空间大小"><a href="#指针占用空间大小" class="headerlink" title="指针占用空间大小"></a>指针占用空间大小</h2><p>正由于它们没有本质区别，它们占用空间大小在同一个程序中都是固定的，对于32位程序，占用4字节空间，64位占用8字节，而正因如此，64位程序理论能使用的内存是足够大的，而32位程序理论上能使用的不过4G（2^（4*8bit)），再加上内核空间的使用，真正能用到的可能就3G左右。</p>
<p>如果你的系统是64位的，那么默认情况下，编译出来的程序也是64位的。如果你想编译为32位，可以使用-m32参数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -m32 -o main main.c</span><br></pre></td></tr></table></figure></p>
<p>如何确定是多少位的程序：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ readelf -h main</span><br><span class="line">Class:                             ELF32</span><br></pre></td></tr></table></figure></p>
<p>上面的ELF32，表明了它是32位程序。或者可以看Machine字段：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Machine:                           Intel 80386</span><br></pre></td></tr></table></figure></p>
<h2 id="void"><a href="#void" class="headerlink" title="void*"></a>void*</h2><p>说回void*，前面说了，指针的类型不过是解释数据的方式不同罢了，这样的道理也可用于很多场合的强制类型转换，例如将int类型指针转换为char型指针，并不会改变内存的实际内容，只是修改了解释方式而已。而void <em>是一种无类型指针，任何类型指针都可以转为void\</em>，它无条件接受各种类型。</p>
<p>而既然是无类型指针，那么就不要尝试做下面的事情：</p>
<ul>
<li>解引用</li>
<li>算术运算</li>
</ul>
<p>由于不知道其解引用操作的内存大小，以及算术运算操作的大小，因此它的结果是未知的。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *b = &amp;a;</span><br><span class="line">    <span class="keyword">void</span> *c = b;</span><br><span class="line">    *c;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译警告如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">warning: dereferencing ‘void *’ pointer</span><br></pre></td></tr></table></figure></p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>既然如此，那么void*有什么用呢？</p>
<p>实际上我们在很多接口中都会发现它们的参数类型都是void*,例如:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>为何要如此设计？因为对于这种通用型接口，你不知道用户的数据类型是什么，但是你必须能够处理用户的各种类型数据，因而会使用void*。void*能包容地接受各种类型的指针。</p>
<p>也就是说，如果你期望接口能够接受任何类型的参数，你可以使用void*类型。</p>
<p>但是在具体使用的时候，你必须转换为具体的指针类型。例如，你传入接口的是int*，那么你在使用的时候就应该按照int*使用。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>使用void*需要特别注意的是，你必须清楚原始传入的是什么类型，然后转换成对应类型。例如，你准备使用库函数qsort进行排序：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">void</span> *base,<span class="keyword">size_t</span> nmemb,<span class="keyword">size_t</span> size , <span class="keyword">int</span>(*compar)(<span class="keyword">const</span> <span class="keyword">void</span> *,<span class="keyword">const</span> <span class="keyword">void</span> *))</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>它的第三个参数就是比较函数，它接受的参数都是const void*，如果你的比较对象是一个结构体类型，那么你自己在实现compar函数的时候，也必须是转换为该结构体类型使用。</p>
<p>举个例子，你要实现学生信息按照成绩比较：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student_tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[STU_NAME_LEN];  <span class="comment">//学生姓名</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> id;          <span class="comment">//学生学号</span></span><br><span class="line">    <span class="keyword">int</span> score;                <span class="comment">//学生成绩</span></span><br><span class="line">&#125;<span class="keyword">student_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">studentCompare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *stu1,<span class="keyword">const</span> <span class="keyword">void</span> *stu2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="comment">/*强转成需要比较的数据结构*/</span></span><br><span class="line">    <span class="keyword">student_t</span> *value1 = (<span class="keyword">student_t</span>*)stu1;</span><br><span class="line">    <span class="keyword">student_t</span> *value2 = (<span class="keyword">student_t</span>*)stu2;</span><br><span class="line">    <span class="keyword">return</span> value1-&gt;score-value2-&gt;score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在将其传入<code>studentCompare</code>函数后，必须转换为其对应的类型进行处理。<br>更多函数指针相关内容可以参考《<a href="https://www.yanbinghu.com/2019/01/03/3593.html">高级指针话题-函数指针</a>》。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>void*很强大，但是一定要在合适的时候使用；同时强转很逆天，但是一定要注意前后的类型是否真的能正确转换。</p>
<p>通俗地说void*：</p>
<ul>
<li>这里有一片内存数据，我也不知道什么类型，给你了，你自己想怎么用怎么用吧，不过要用对奥！</li>
<li>我这里什么类型都能处理，你给我一片内存数据就可以了</li>
</ul>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>系统编程-文件I/O操作</title>
    <url>/2019/12/11/54424.html</url>
    <content><![CDATA[<p>我们都听过Linux下一切皆文件，实际上无论是普通的文件读写，还是网络IO读写，它们都有着类似的操作过程。本文通过基本文件IO操作，来了解Linux“一切文件”的读写。当然过程中穿插着很多其他内容。<br><a id="more"></a></p>
<h2 id="文件I-O过程"><a href="#文件I-O过程" class="headerlink" title="文件I/O过程"></a>文件I/O过程</h2><p>在介绍具体的函数使用之前，我必须说明一下文件I/O的基本过程。它们类似过程如下：</p>
<ul>
<li>以某种模式打开文件，获取一个文件描述符</li>
<li>对文件进行读写</li>
<li>不需要时，关闭文件描述符</li>
</ul>
<p>文件描述符是什么？你可以认为是一个对文件进行操作的凭据，你只有通过它才能对文件进行读写。它是一个非负整数。通常0是标准输入，1是标准输出，2是标准错误（参考《》）。正是有了它们，你的简单程序才可以从控制台读入数据，输出日志，输出错误打印等等。</p>
<p>记得很小的时候，家里连压水的工具都没有，需要用水的时候，都是用一个小点的桶从井里打水。</p>
<p>类比文件I/O操作，打开井盖，拿到绑着绳子的水桶，就像是打开文件，获取文件描述符；而打水的过程，就像对文件进行读写；最后需要的时候，又把桶放回去，并盖上井盖；而这就像关闭文件描述符。</p>
<p>当然了，如果嫌弃里面的小桶打水太慢，有的人可能会用一担大桶用来装水，装满一担后，再挑走使用。而这个过程就像使用了缓冲。（参考《<a href="https://www.yanbinghu.com/2019/12/01/27836.html">不可不知的三种缓冲</a>》）。</p>
<p>说了这么多废话，文件I/O到底怎么操作呢？本文介绍的是不带缓冲的I/O函数。</p>
<h2 id="打开文件，获取文件描述符"><a href="#打开文件，获取文件描述符" class="headerlink" title="打开文件，获取文件描述符"></a>打开文件，获取文件描述符</h2><p>主要函数：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>参数解释：</p>
<ul>
<li>pathname 文件名</li>
<li>flags 打开选项</li>
</ul>
<p>这里的文件名应该不用过多解释，但是flags需要做一些说明，<br>它须指定以下五个中的一个：</p>
<ul>
<li>O_RDONLY  只读</li>
<li>O_WRONLY  只写</li>
<li>O_RDWR    可读可写</li>
<li>O_EXEC   执行打开</li>
<li>O_SEARCH  搜索打开（针对目录）</li>
</ul>
<p>而下面的选项是可选的：</p>
<ul>
<li>O_APPEND 写时追加到文件末尾</li>
<li>O_CREAT  文件不存在时创建，且必须指定文件访问权限位</li>
<li>O_TRUNC    文件存在时，且以只写，或者读写方式打开，则截断长度为0</li>
<li>……</li>
</ul>
<p>当打开成功时返回文件描述符，否则返回-1，并且设置errno。</p>
<h2 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h2><p>读写操作主要有两个函数：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unisdt.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf,<span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf,<span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>参数说明：</p>
<ul>
<li>fd 文件描述符</li>
<li>buf 要读写的内容</li>
<li>nbytes 读写的内容大小</li>
</ul>
<p>这里的fd就是前面拿到的文件描述符。篇幅有限， 本文暂不涉及具体的读写介绍。</p>
<h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><p>调用close函数即可，它的参数是前面打开的时候获得的文件描述符<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int close(int fd);</span><br></pre></td></tr></table></figure></p>
<p>成功返回0，失败则返回-1，并且会设置errno。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>以上都太过理论化了，那么理论结合实际来看看，究竟是怎样的。</p>
<h4 id="打开一个不存在的文件"><a href="#打开一个不存在的文件" class="headerlink" title="打开一个不存在的文件"></a>打开一个不存在的文件</h4><p>这是最简单的情况，现在假设，当前目录下没有test.txt<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"test.txt"</span>,O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == fd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//perror("open failed:");</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"open failed:%s\n"</span>, strerror(errno)); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"open ok\n"</span>);</span><br><span class="line">    <span class="keyword">char</span> test[] = <span class="string">"wechat:shouwangxiansheng\n"</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> len = write(fd,test,<span class="keyword">sizeof</span>(test));</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == len)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"write failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行报错：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">open failed: No such file <span class="keyword">or</span> directory</span><br></pre></td></tr></table></figure></p>
<p>还记得前面说的，如果出错就会设置errno吗？当open返回-1（很多系统接口类似）时，就会设置errno，这个时候就可以调用perror接口打印对应的错误信息。便于我们定位问题。即：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perror(&quot;open failed:&quot;);</span><br><span class="line">printf(&quot;open failed:%s\n&quot;, strerror(errno));</span><br></pre></td></tr></table></figure></p>
<p>上面两种方式都可以打印出错误信息，区别在于，前者输出到标准错误，后者输出到标准输出。</p>
<p>还记得在《<a href="https://www.yanbinghu.com/2019/12/01/27836.html">不可不知的三种缓冲</a>》中说的吗？标准错误通常是不带缓冲的。</p>
<h4 id="打开一个文件，不存在时创建"><a href="#打开一个文件，不存在时创建" class="headerlink" title="打开一个文件，不存在时创建"></a>打开一个文件，不存在时创建</h4><p>既然不存在时，会打开失败，那么不存在就创建好了，这就用到了O_CREATE标志。因此修改open函数那一行：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"test.txt"</span>,O_WRONLY | O_CREAT);</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open ok</span><br></pre></td></tr></table></figure></p>
<p>并且会在test.txt发现写入的内容。</p>
<p>注意到，多个标志使用|构成flags参数。</p>
<h4 id="打开一个文件，存在时截断"><a href="#打开一个文件，存在时截断" class="headerlink" title="打开一个文件，存在时截断"></a>打开一个文件，存在时截断</h4><p>好了，前面已经实现了文件不存在时，创建，存在时也可以正常打开，如果存在时，又不想要原先的内容？那就需要用到O_TRUNC标志。<br>修改open行如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"test.txt"</span>,O_RDONLY | O_CREAT | O_TRUNC);</span><br></pre></td></tr></table></figure></p>
<p>现在假设test.txt文件存在，且里面有内容，再次运行后，发现打开文件正常，且内容只有新加入的，而没有之前存在的。</p>
<h4 id="在打开的文件后追加内容"><a href="#在打开的文件后追加内容" class="headerlink" title="在打开的文件后追加内容"></a>在打开的文件后追加内容</h4><p>如果想在打开的文件后追加内容，那么可以使用O_APPEND标志：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int fd = open(&quot;test.txt&quot;,O_RDONLY | O_CREAT | O_APPEND);</span><br></pre></td></tr></table></figure></p>
<p>这样如果原来test.txt中有内容，则可以往文件中追加内容。</p>
<h4 id="只读打开的文件进行写操作"><a href="#只读打开的文件进行写操作" class="headerlink" title="只读打开的文件进行写操作"></a>只读打开的文件进行写操作</h4><p>前面提到了5个打开标志，如果以只读方式尝试写会怎样？<br>修改open行：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"test.txt"</span>,O_RDONLY);</span><br></pre></td></tr></table></figure></p>
<p>你会发现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open ok</span><br><span class="line">write failed: Bad file descriptor</span><br></pre></td></tr></table></figure></p>
<p>以只读方式打开，却尝试写，自然是会写失败了。因此对应的操作要设置对应的标志位，否则会失败。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是文件I/O的基本操作。关键就三个步骤：</p>
<ul>
<li>以某种模式打开</li>
<li>操作</li>
<li>关闭</li>
</ul>
<p>错误处理原则：<br>返回-1，则出错，会设置errno，可通过perror或者strerror打印错误信息。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>如何让程序真正地后台运行？</title>
    <url>/2019/12/06/39731.html</url>
    <content><![CDATA[<p>如何实现一个守护进程？如何让程序在后台运行?这是后台开发面试常问的一道题，那么守护进程到底是什么？又该如何实现？<br><a id="more"></a></p>
<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p>守护进程通常生存期长，很多是在系统启动时启动，系统退出时才关闭。它们的特点通常没有控制终端，后台运行。</p>
<p>有人可能会会心一笑，后台运行程序，我知道呀。还有两种方式呢<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./hello &amp;</span><br></pre></td></tr></table></figure></p>
<p>看，多么简单。但是运行之后，你试着关闭当前终端，你会发现程序会停止运行，因为一旦关闭终端，程序会收到一个信号SIGHUP，而收到该信号默认的动作就是程序退出。</p>
<p>没关系啊，我还有招：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nohup ./hello &amp; #注意这里&amp;是必要的，否则不会变成后台进程</span><br><span class="line">$ jobs</span><br><span class="line">[1]+  Running                 nohup ./hello &amp;</span><br></pre></td></tr></table></figure></p>
<p>我使用nohup命令总可以了吧？</p>
<p>挺好的，nohup会忽略SIGHUP命令，并有了&amp;的加持，即便终端关了，也能继续执行。但它的终端输出还会记录默认还在nohup.out文件中，同时，如果将huponexit关闭，它同样难逃命运：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ shopt -s huponexit  #shopt -u huponexit 设置为off</span><br><span class="line">$ shopt |grep onexit</span><br><span class="line">huponexit       on</span><br></pre></td></tr></table></figure></p>
<p>一旦终端退出（ctrl+D）后，nohup也救不了。</p>
<p>下面要介绍的守护进程一一种完全脱离终端，有着自己的会话。<br>如果你在你的Linux系统中执行下面的命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ps -elf</span><br></pre></td></tr></table></figure></p>
<p>就会发现一些进程的tty列是？，当然这并不是说明它们是守护进程，而那些用[]括起来的，是内核守护进程</p>
<p>想象一下，如果没有任何人登录的服务器上面的运行程序，难道每次执行的时候都要使用nuhup+&amp;？况且，一旦系统的huponexit选项是打开的，这种方式仍然无法避免终端关闭程序就退出的命运！</p>
<p>那么就需要实现用户守护进程了，或者说daemon化。</p>
<h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><p>其实现过程基本遵循以下原则：</p>
<ul>
<li>调用umask设置文件模式，通常设置为0。为了便于后续创建文件，不使用继承而来的父进程的设置，需要设置新的权限掩码。</li>
<li>调用fork，创建子进程，并且父进程退出</li>
<li>调用setdid创建新的会话（一个或多个进程组的集合），由于当前进程不是一个进程组的组长，因此会创建一个新的会话，却成为组长进程，同时没有控制终端。</li>
<li>将当前工作目录切换为根目录。同样的，其工作目录可能是从父进程继承而来的，可以自己另立山头。</li>
<li>关闭不需要的文件描述符。同样的，可能从父进程继承了一些打开的文件描述符，而这些描述符可能再也不需要，因此可以关闭。</li>
<li>重定向标准输出，标准输入和标准错误到/dev/null（相关阅读：）</li>
</ul>
<p>实际上，从上面的描述可以发现，这些规则都有几乎相同的目标，那就是不想成为富二代，摆脱父亲的控制。（在<a href="https://www.yanbinghu.com/2019/08/11/28423.html">fork的介绍</a>中，我们说到，儿子从父亲那里继承了很多东西）</p>
<ul>
<li>重新设置权限掩码，避免受父进程影响</li>
<li>创建新的会话，脱离终端</li>
<li>使用新的工作目录</li>
<li>关闭不需要的文件描述符</li>
<li>关闭标准输入，标准输出和标准错误</li>
</ul>
<p>所以通过这些也可以明白，有些规则并不是完全强制的，可根据实际程序的情况进行设置，不过按照常规做法是一个比较好的选择。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>参考代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*实现仅供参考，可根据实际情况调整*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daemonize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*清除文件权限掩码*/</span></span><br><span class="line">	umask(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*父进程退出*/</span></span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">if</span>((pid=fork()) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*for 出错*/</span></span><br><span class="line">		perror(<span class="string">"fork error"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> != pid)<span class="comment">/*父进程*/</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"father exit\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*子进程，成为组长进程，并且摆脱终端*/</span></span><br><span class="line">	setsid();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*修改工作目录*/</span></span><br><span class="line">	<span class="keyword">if</span>(chdir(<span class="string">"/"</span>) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"change dir failed"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rl</span>;</span></span><br><span class="line">	<span class="comment">/*先获取文件描述符最大值*/</span></span><br><span class="line">	<span class="keyword">if</span>(getrlimit(RLIMIT_NOFILE,&amp;rl) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"get file decription failed"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果无限制，则设置为1024*/</span></span><br><span class="line">	<span class="keyword">if</span>(rl.rlim_max == RLIM_INFINITY)</span><br><span class="line">		rl.rlim_max = <span class="number">1024</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*为了使得终端有输出，保留了文件描述符0，1，2;实际上父进程可能没有打开2以上的文件描述符*/</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">3</span>;i &lt; rl.rlim_max;i++)</span><br><span class="line">		close(i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> == daemonize())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"daemonize ok\n"</span>);</span><br><span class="line">		sleep(<span class="number">20</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"daemonize failed\n"</span>);</span><br><span class="line">		sleep(<span class="number">20</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行，你就会发现，它已经可以欢脱地运行啦。</p>
<p>代码中有几个点，需要关注一下。为了保留printf的输出，我在daemonize函数中，并没有关闭所有的文件描述符，0，1，2可以参考《<a href="https://www.yanbinghu.com/2018/10/26/9186.html">如何理解Linux shell中“2&gt;&amp;1”</a>》，当然了，如果想让printf的输出保存到文件，也有方法，可以参考《<a href="https://www.yanbinghu.com/2019/11/21/44978.html">优雅地保存printf的打印</a>》，这里就不再赘述了。</p>
<h2 id="实际实现"><a href="#实际实现" class="headerlink" title="实际实现"></a>实际实现</h2><p>实际上，已经有一个接口可以帮我们做这些事情：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int daemon(int nochdir, int noclose);</span><br></pre></td></tr></table></figure></p>
<p>即daemon函数，它有两个参数</p>
<ul>
<li>nochdir 为0时，表示修改其根目录为/，否则不变</li>
<li>noclose，为0时，表示将标准输入，标准输出，标准错误重定向到/dev/null。</li>
</ul>
<p>简单例子：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> == daemon(<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"daemon ok\n"</span>);</span><br><span class="line">		sleep(<span class="number">20</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"daemon failed\n"</span>);</span><br><span class="line">		sleep(<span class="number">20</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你还要实现单例化，可以参考《<a href="https://www.yanbinghu.com/2019/11/28/46317.html">如何实现单例运行</a>》，使得同时只有一个该进程运行。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就进程后台运行以及是守护进程实现的介绍，关键点有</p>
<ul>
<li>创建子进程，父进程退出</li>
<li>创建新的会话，脱离终端</li>
</ul>
<p>附上daemon的源码：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daemon</span><span class="params">(nochdir, noclose)</span></span></span><br><span class="line">	int nochdir, noclose;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (fork()) </span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">		<span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		_exit(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (setsid() == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!nochdir)</span><br><span class="line">		(<span class="keyword">void</span>)chdir(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!noclose &amp;&amp; (fd = open(_PATH_DEVNULL, O_RDWR, <span class="number">0</span>)) != <span class="number">-1</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		(<span class="keyword">void</span>)dup2(fd, STDIN_FILENO);</span><br><span class="line">		(<span class="keyword">void</span>)dup2(fd, STDOUT_FILENO);</span><br><span class="line">		(<span class="keyword">void</span>)dup2(fd, STDERR_FILENO);</span><br><span class="line">		<span class="keyword">if</span> (fd &gt; <span class="number">2</span>)</span><br><span class="line">			(<span class="keyword">void</span>)close (fd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11-shared_ptr详解</title>
    <url>/2019/12/05/33986.html</url>
    <content><![CDATA[<p>《<a href="https://www.yanbinghu.com/2019/11/07/11278.html">C++11 unique_ptr</a>》说到，如果有可能就使用unique_ptr，然后很多时候对象是需要共享的，因此shared_ptr也就会用得很多。shared_ptr允许多个指针指向同一个对象，当指向对象的最后一个shared_ptr销毁时，该对象也就会自动销毁。</p>
<a id="more"></a>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>它的很多操作与unique_ptr类似。例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp;<span class="comment">//声明一个指向int类型的智能指针</span></span><br><span class="line">sp.reset(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>));</span><br><span class="line"><span class="keyword">auto</span> sp1 = make_shared&lt;<span class="built_in">string</span>&gt;(<span class="string">"hello"</span>);<span class="comment">//sp1是一个智能指针</span></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span> <span class="title">sp2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>);</span></span></span><br></pre></td></tr></table></figure></p>
<p>而make_shared方式是推荐的一种，它使用一次分配，比较安全。</p>
<h2 id="那些操作会改变计数"><a href="#那些操作会改变计数" class="headerlink" title="那些操作会改变计数"></a>那些操作会改变计数</h2><p>我们都知道，当引用计数为0时，shared_ptr所管理的对象自动销毁，那么那些情况会影响引用计数呢？</p>
<h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto sp = make_shared&lt;int&gt;(1024);//sp的引用计数为1</span><br></pre></td></tr></table></figure></p>
<p>再比如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto sp1 = make_shared&lt;string&gt;(&quot;obj1&quot;);</span><br><span class="line">auto sp2 = make_shared&lt;string&gt;(&quot;obj2&quot;);</span><br><span class="line">auto sp1 = sp2;</span><br></pre></td></tr></table></figure></p>
<p>该操作会减少sp1的引用计数，增加sp2的引用计数。有的人可能不理解，为什么这样还会减少sp1的引用计数？</p>
<p>试想一下，sp1指向对象obj1，sp2指向对象obj2，那么赋值之后，sp1也会指向obj2，那就是说指向obj1的就少了，指向obj2的就会多，如果此时没有其他shared_ptr指向obj1，那么obj1将会销毁。</p>
<h4 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h4><p>例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> sp2 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">1024</span>);</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sp1</span><span class="params">(sp2)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>该操作会使得sp1和sp2都指向同一个对象。</p>
<p>而关于拷贝比较容易忽略的就是作为参数传入函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> sp2 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">1024</span>);</span><br><span class="line">func(sp2);<span class="comment">//func的执行会增加其引用计数</span></span><br></pre></td></tr></table></figure></p>
<p>可以看一个具体的例子：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号编程珠玑</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func0</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"fun0:"</span>&lt;&lt;sp.use_count()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; &amp;sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"fun1:"</span>&lt;&lt;sp.use_count()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sp = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">1024</span>);</span><br><span class="line">    func0(sp);</span><br><span class="line">    func1(sp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其运行输出结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun0:2                                                    </span><br><span class="line">fun1:1</span><br></pre></td></tr></table></figure></p>
<p>很显然，fun0，拷贝了shard_ptr sp，而fun1，并没有拷贝，因此前者会增加引用计数，而后者并不影响。关于参数传值的问题，可以参考《<a href="https://www.yanbinghu.com/2019/06/20/53981.html">传值与传指针</a>》和《令人疑惑的引用和指针》。</p>
<h4 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h4><p>调用reset会减少计数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sp.reset()</span><br></pre></td></tr></table></figure></p>
<p>而如果sp是唯一指向该对象的，则该对象被销毁。</p>
<h2 id="应当注意使用的方式"><a href="#应当注意使用的方式" class="headerlink" title="应当注意使用的方式"></a>应当注意使用的方式</h2><p>虽然shared_ptr能很大程度避免内存泄漏，但是使用不当，仍然可能导致意外发生。</p>
<h4 id="存放于容器中的shared-ptr"><a href="#存放于容器中的shared-ptr" class="headerlink" title="存放于容器中的shared_ptr"></a>存放于容器中的shared_ptr</h4><p>如果你的容器中存放的时shared_ptr，而你后面又不再需要它时，记得使用erase删除那些不要的元素，否则由于引用计数一直存在，其对象将始终得不到销毁，除非容器本身销毁。</p>
<h4 id="不要使用多个裸指针初始化多个shared-ptr"><a href="#不要使用多个裸指针初始化多个shared-ptr" class="headerlink" title="不要使用多个裸指针初始化多个shared_ptr"></a>不要使用多个裸指针初始化多个shared_ptr</h4><p>注意，下面方式是不该使用的：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *p = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">sp1</span><span class="params">(p)</span></span>;</span><br><span class="line">    <span class="comment">/*不要这样做！！*/</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">sp2</span><span class="params">(p)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样会导致两个shared_ptr管理同一个对象，当其中一个被销毁时，其管理的对象会被销毁，而另外一个销毁时，对象会二次销毁，然而实际上，对象已经不在了，最终造成严重后果。</p>
<p>而与这种情况类似的，就是使用get()获取裸指针，然后去初始化另外一个shared_ptr，或者delete get返回的指针：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sp = <span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">"wechat:shouwangxiansheng"</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *p = sp.get();</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">sp2</span><span class="params">(p)</span></span>;<span class="comment">/*不要这样做!!*/</span></span><br><span class="line">    <span class="keyword">delete</span> p;<span class="comment">/*不要这样做*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="如果对象不是new分配的，请传递删除器"><a href="#如果对象不是new分配的，请传递删除器" class="headerlink" title="如果对象不是new分配的，请传递删除器"></a>如果对象不是new分配的，请传递删除器</h4><p>与unique_ptr类似，它可以指定删除器，默认是使用delete。例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myClose</span><span class="params">(<span class="keyword">int</span> *fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    close(*fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> socketFd = <span class="number">10</span>;<span class="comment">//just for example</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">up</span><span class="params">(&amp;socketFd,myClose)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="与unique-ptr的区别"><a href="#与unique-ptr的区别" class="headerlink" title="与unique_ptr的区别"></a>与unique_ptr的区别</h2><p>首先最明显的区别自然是它们一个是专享对象，一个是共享对象。而正是由于共享，包括要维护引用计数等，它带来的开销相比于unique_ptr来说要大。</p>
<p>另外，shared_ptr无法直接处理数组，因为它使用delete来销毁对象，而对于数组，需要用delete[]。因此，需要指定删除器：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">/来源：公众号【编程珠玑】</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sp = <span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">"wechat:shouwangxiansheng"</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *p = sp.get();</span><br><span class="line">    <span class="comment">//std::shared_ptr&lt;int&gt; sp1(new int[10]);//不能这样</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>],[](<span class="keyword">int</span> *p)&#123;<span class="keyword">delete</span>[] p;&#125;)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>示例中使用了lambda表达式。</p>
<p>不过一般来说，好好的容器不用，为什么要用动态数组呢？</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是shared_ptr基本内容，一般来说，规范使用shared_ptr能很大程度避免内存泄露。注意，shared_ptr提供，*，-&gt;操作，不直接提供指针运算和[]。</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>更改默认缓冲类型</title>
    <url>/2019/12/03/1372.html</url>
    <content><![CDATA[<p>在上一篇《<a href="https://www.yanbinghu.com/2019/12/01/27836.html">不可不知的缓冲类型</a>》中说到了三种缓冲类型，看起来很简单对不对？今天我们看看如何修改这些默认的缓冲类型，以及在实际中可能遇到哪些问题。<br><a id="more"></a></p>
<h2 id="更改缓冲类型"><a href="#更改缓冲类型" class="headerlink" title="更改缓冲类型"></a>更改缓冲类型</h2><p>在上一篇中说到了一些默认的缓冲类型，例如：</p>
<ul>
<li>指向终端设备的流是行缓冲的</li>
<li>标准错误是不带缓冲的</li>
<li>指向文件的流是全缓冲的</li>
<li>……</li>
</ul>
<p>那么这些默认的缓冲类型如何修改？</p>
<p>有几个函数可以用来更改缓冲类型：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE *stream, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuffer</span><span class="params">(FILE *stream, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setlinebuf</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE *stream,<span class="keyword">char</span> *buf, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>参数说明如下：</p>
<ul>
<li>stream FILE *类型，文件指针</li>
<li>buf 缓冲区指针</li>
<li>mode 缓冲模式，包括_IOFBF（全缓冲），_IOLBF（行缓冲），_IONBF（不带缓冲）</li>
<li>size 缓冲区大小</li>
</ul>
<p>这里有四个相关函数，作用类似，只是修改范围不一。<br>setbuf函数中，如果buf设置为NULL，则缓冲关闭；否则指向长度为BUFSIZ长度的缓冲区，并且是行缓冲。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//网址：https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"bianchengzhuji"</span>);</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过设置stdout（标准输出）的第二个参数为NULL，将其变成了不带缓冲，因此你运行后发现，printf的打印会立即显示在终端。</p>
<p>当然你也可以通过setvbuf，如：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//网址：https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"bianchengzhuji"</span>);</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里设置为不带缓冲，则会忽略buf和size参数。设置为全缓冲或者行缓冲的时候。并且buf为NULL，会使用合适长度的系统buffer，否则使用用户自定义buffer。</p>
<p>缓冲区的设置就介绍到这里。</p>
<h2 id="fputs没有及时输出"><a href="#fputs没有及时输出" class="headerlink" title="fputs没有及时输出"></a>fputs没有及时输出</h2><p>其实在有了前面的基础之后，很多问题就迎刃而解了。<br>看看下面的例子：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//网址：https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//setbuf(stdout,NULL);</span></span><br><span class="line">    fputc(<span class="string">'a'</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>比如你就想输出一个字符，就打印到终端，但是按照上面的方法，字符并不会被及时输出到终端，因此它默认是行缓冲的。打开注释行，设置为不带缓冲就可以了。</p>
<h2 id="printf打印的日志没有输出"><a href="#printf打印的日志没有输出" class="headerlink" title="printf打印的日志没有输出"></a>printf打印的日志没有输出</h2><p>不知道你有没有遇到过这样的情况，准备调试某一个bug，发现每次运行到某个地方，打印就结束了，然后就挂了，让你误以为程序执行到打印的地方就结束了，然而有可能程序执行到后面，只是由于打印是行缓冲的，导致部分打印没有出来，很可能就是你没有加上换行符打印而已。</p>
<p>这时候你可以设置为不带缓冲，或者关键位置fflush，或者打印记得加上换行符。</p>
<p>当然你还可以用GDB，参考《<a href="https://www.yanbinghu.com/2019/04/20/41283.html">GDB调试指南</a>》。</p>
<h2 id="fflush之后文件还是丢失了"><a href="#fflush之后文件还是丢失了" class="headerlink" title="fflush之后文件还是丢失了"></a>fflush之后文件还是丢失了</h2><p>看完前面的内容之后，是不是觉得豁然开朗了？别高兴的太早。</p>
<p>以上措施并不是万事大吉。</p>
<p>你可能会踩到什么坑？</p>
<ul>
<li>文件内容写完后，fflush了，内容也有了，然后完成后，系统马上复位，复位起来后，文件内容还是丢失了</li>
<li>解压一个压缩包，解压成功，系统复位后，还是发现文件大小为0，文件丢失了</li>
</ul>
<p>如果你目前还没有遇到过这样的问题，那么你就需要格外注意了。</p>
<p>虽然前面fflush等措施将缓冲区的内容进行了I/O操作，但是操作系统还需要将文件系统的buffer写入磁盘，因此，如果此时直接复位会导致文件丢失！</p>
<p>怎么办呢？可以使用</p>
<ul>
<li>fsync/sync函数</li>
<li>sync命令</li>
</ul>
<p>以上函数或者命令强制将文件系统的buffer写入磁盘，但是根据内容大小不一而需要不一样的时间。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>理解缓冲区的概念会让你在编程中受益无穷。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>三种缓冲类型</title>
    <url>/2019/12/01/27836.html</url>
    <content><![CDATA[<p>今天来说说缓冲的事。也许你已经听说过三种缓冲模式，但是今天要讲的不止这些。<br><a id="more"></a></p>
<h2 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h2><p>为了减少使用read和write调用的次数，标准IO库提供了缓冲，有人可能会问，为什么要减少它们的调用次数？很明显read和write是系统调用，它们花费的时间将会更多，本文不展开描述，可以参考《<a href="https://www.yanbinghu.com/2018/05/28/26708.html">库函数和系统调用</a>》。那么有哪三种缓冲类型呢？</p>
<h2 id="全缓冲"><a href="#全缓冲" class="headerlink" title="全缓冲"></a>全缓冲</h2><p>在全缓冲的情况下，在填满标准I/O缓冲区后，才进行实际的I/O操作。写磁盘文件通常就是全缓冲的。举个例子：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">博客：https://www.yanbinghu.com</span></span><br><span class="line"><span class="comment">buff.c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*以可读可写的方式打开*/</span></span><br><span class="line">    FILE *fp = fopen(<span class="string">"./test.txt"</span>,<span class="string">"w+"</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == fp)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open file failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*写入内容*/</span></span><br><span class="line">    <span class="keyword">char</span> buf[] = <span class="string">"wechat:shouwangxiansheng\n"</span>;</span><br><span class="line">    fwrite(buf,<span class="keyword">sizeof</span>(<span class="keyword">char</span>),<span class="keyword">sizeof</span>(buf),fp);</span><br><span class="line">    <span class="comment">//fflush(fp);</span></span><br><span class="line">    <span class="comment">/*sleep一段时间，以便观察*/</span></span><br><span class="line">    sleep(<span class="number">20</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们编译并运行：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -o buff buff.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./buff</span></span><br></pre></td></tr></table></figure></p>
<p>此时观察test.txt：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat test.txt</span><br></pre></td></tr></table></figure></p>
<p>发现它的内容是空。</p>
<p>原因在于它默认是全缓冲的，因此在将内容写入文件后，并没有直接存在文件中，当程序关闭文件或者程序运行完成退出后，再次查看：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat test.txt</span><br><span class="line">wechat:shouwangxiansheng</span><br></pre></td></tr></table></figure></p>
<p>发现文件已经有了内容。</p>
<p>除了等待程序运行完成，还可以使用fflush函数，它可以将缓冲区中的内容写入到磁盘中（终端驱动设备表示丢弃缓冲区的数据）。</p>
<p>所以将fwrite下面一行的注释去掉后，就可以发现，写入之后，就可以直接在文件中看到内容了。</p>
<p>所以当你在写一个文件，但是查看文件却没有任何写入内容时，不要一直怀疑自己的代码。</p>
<h2 id="行缓冲"><a href="#行缓冲" class="headerlink" title="行缓冲"></a>行缓冲</h2><p>行缓冲指的是当遇到换行符时，或者缓冲区已经满了（一般1024字节），标准I/O库执行I/O操作。同样举个例子：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">博客：https://www.yanbinghu.com</span></span><br><span class="line"><span class="comment">lineBuff.c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wechat:shouwangxiansheng"</span>);</span><br><span class="line">	sleep(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行上面的程序：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o lineBuff lineBuff.c</span><br><span class="line">$ ./lineBuff</span><br></pre></td></tr></table></figure></p>
<p>你会发现，printf执行完了之后，内容并没有马上输出到终端，而是在程序运行完之后才输出。</p>
<p>聪明的你当然也知道，要想打印完后直接输出到终端，只需要改成下面这样就可以了：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"wechat:shouwangxiansheng\n"</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="不带缓冲"><a href="#不带缓冲" class="headerlink" title="不带缓冲"></a>不带缓冲</h2><p>这个从字面就可以理解其意思了。同样举个例子：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">博客：https://www.yanbinghu.com</span></span><br><span class="line"><span class="comment">noBuff.c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"wechat:shouwangxiansheng"</span>);</span><br><span class="line">	sleep(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行你就会发现，运行完fprintf语句后，内容直接输出在终端，而不需要等到换行。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的一些例子，我们也发现了这样一些规律：</p>
<ul>
<li>通常磁盘上的文件是全缓冲区的</li>
<li>标准输入和标准输入通常是行缓冲的</li>
<li>指向终端设备的流通常是行缓冲，而指向文件时，则是全缓冲</li>
<li>为了尽可能显示错误信息，标准错误是不带缓冲的</li>
</ul>
<p>当然这还没有完，下一篇将带你踩更多的坑。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>单例运行-C语言实现</title>
    <url>/2019/11/28/46317.html</url>
    <content><![CDATA[<p>有些程序我们希望在一台机器上只有一个实例在运行，我在windows下也遇到过很多类似这样的程序，如QQ，它只允许同时运行一个。那么我们在Linux该如何实现这样的单例运行的程序呢？<br><a id="more"></a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>实现这样的程序方法很多，但是总体思路都是类似的：</p>
<ul>
<li>1.启动程序，检测标志，判断是否有同样的程序运行，是则2，否则3</li>
<li>2.程序退出</li>
<li>3.程序启动，并设置标志，以便下次启动时检测</li>
</ul>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>按照这种思路，实现的方法有很多种，例如使用ps等命令获取该进程的进程数，大于0 表示已有运行；启动后写一个临时文件，如果下次启动时发现有该文件，则直接退出；创建一个文件并加锁，退出时删除文件，新的程序启动时试图加锁，如果失败，则说明已有实例运行……</p>
<p>除了上面说到的这些，可能还有一些其他的实际做法，但是本文介绍一种实用并且也是非常通用的做法，即文件锁的方法。</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>程序在启动后，打开一个program.pid文件（无则创建），然后试图去设置文件锁（如果还不理解锁的概念，可以简单理解为，一旦a写锁定了，b就无法进一步写操作了，除非a释放锁），如果设置成功，就将该程序的进程ID写入该文件；如果加锁失败，那么说明已经有另外一个实例在运行了，则退出此次启动。而当前已经运行的程序如果退出了，该文件会自动解除锁定。</p>
<p>实际上，我们观察一下/var/run/目录下，有很多类似这样的文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -l /var/run/*.pid</span><br><span class="line">-rw-r--r-- 1 root root 5 11月 24 08:19 /var/run/acpid.pid</span><br><span class="line">-rw-r--r-- 1 root root 5 11月 24 08:19 /var/run/atd.pid</span><br><span class="line">-rw-r--r-- 1 root root 5 11月 24 08:19 /var/run/crond.pid</span><br><span class="line">-rw-r--r-- 1 root root 5 11月 24 09:08 /var/run/dhclient-wlp3s0.pid</span><br><span class="line">-rw-r--r-- 1 root root 4 11月 24 08:19 /var/run/docker.pid</span><br></pre></td></tr></table></figure></p>
<p>不过这个位置通常只有root用户能够写入。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在看代码实现之前，先看下文件锁（记录锁）和fcntl函数。<br>flock结构至少包含以下字段：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flock</span> &#123;</span></span><br><span class="line">    short l_type; <span class="comment">/*锁类型 F_RDLCK,F_WRLCK, F_UNLCK*/</span></span><br><span class="line">    short l_whence;  <span class="comment">/* 偏移开始的位置 SEEK_SET, SEEK_CUR, SEEK_END */</span></span><br><span class="line">    <span class="keyword">off_t</span> l_start;   <span class="comment">/* 开始锁定区域*/</span></span><br><span class="line">    <span class="keyword">off_t</span> l_len;     <span class="comment">/* 锁定字节数 */</span></span><br><span class="line">    <span class="keyword">pid_t</span> l_pid;     <span class="comment">/* 记录锁的进程ID*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>从结构体成员可以看到，它不仅可以锁整个文件，还可以锁某个区域，但是本文仅用于锁定整个文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* arg */</span></span></span></span><br></pre></td></tr></table></figure>
<p>fcntl函数的cmd选项也很多，本文只用到F_SETLK（或F_SETLKW，），即设置锁。<br>结合以上两者，参考代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//博客：https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROC_NAME <span class="meta-string">"single_instance"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PID_FILE_PATH <span class="meta-string">"/var/run/"</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lockFile</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *procname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*判断是否已经有实例在运行*/</span></span><br><span class="line">    <span class="keyword">if</span>(isRunning(PROC_NAME))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"run ok\n"</span>);</span><br><span class="line">    sleep(<span class="number">20</span>);<span class="comment">//避免程序立即退出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*锁文件还可以使用flock，目的是类似的。不过是它是BSD系统调用，并且某些版本不支持NFS，出于移植性考虑，使用fcntl*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lockFile</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">fl</span>;</span></span><br><span class="line">    fl.l_type   = F_WRLCK;<span class="comment">//设置写锁</span></span><br><span class="line">    fl.l_start  = <span class="number">0</span>;</span><br><span class="line">    fl.l_whence = SEEK_SET;</span><br><span class="line">    fl.l_len    = <span class="number">0</span>;</span><br><span class="line">    fl.l_pid = <span class="number">-1</span>;<span class="comment">//锁定文件，设置为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(fcntl(fd, F_SETLK, &amp;fl));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *procname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(filename, <span class="string">"%s%s.pid"</span>,PID_FILE_PATH,procname);</span><br><span class="line">    <span class="keyword">int</span> fd = open(filename, O_CREAT|O_RDWR );<span class="comment">//可读可写，不存在时创建</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"open file %s failed!\n"</span>, filename);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == lockFile(fd)) <span class="comment">/*尝试加锁*/</span></span><br><span class="line">    &#123;                                                  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s is already running\n"</span>, procname);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        ftruncate(fd, <span class="number">0</span>);<span class="comment">/*截断文件，重新写入pid*/</span></span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">"%ld"</span>, (<span class="keyword">long</span>)getpid());</span><br><span class="line">        write(fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o single_instance single_instance.c</span><br><span class="line">$ ./single_instance  #注意root权限运行，或者调整pid文件位置</span><br><span class="line">run ok</span><br></pre></td></tr></table></figure>
<p>查看pid文件目录下已经有了pidfile：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -al /var/run/single_instance.pid</span><br><span class="line">-rw-r--r-- 1 root root 6 11月 24 11:36 /var/run/single_instance.pid</span><br></pre></td></tr></table></figure></p>
<p>在另外一个终端再次尝试运行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./single_instance</span><br><span class="line">single_instance is already running</span><br></pre></td></tr></table></figure></p>
<p>如果你想控制同一个目录下的bin文件只能运行一个，那么可以设置pid文件的位置为当前目录。</p>
<p>这种方式有什么特点呢：</p>
<ul>
<li>简单可靠</li>
<li>可读可见，相比于信号量或共享内存，它更容易观察</li>
<li>无性能要求，启动时加锁，结束释放。</li>
<li>一旦出现异常没有释放，也可以手动删除文件</li>
</ul>
<p>当然对于BSD系统，还可以使用下面的接口来完成：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">pidfh</span> *</span></span><br><span class="line"><span class="class">     <span class="title">pidfile_open</span>(<span class="title">const</span> <span class="title">char</span> *<span class="title">path</span>, <span class="title">mode_t</span> <span class="title">mode</span>, <span class="title">pid_t</span> *<span class="title">pidptr</span>);</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pidfile_write</span><span class="params">(struct pidfh *pfh)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pidfile_close</span><span class="params">(struct pidfh *pfh)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pidfile_remove</span><span class="params">(struct pidfh *pfh)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>本文就不过多介绍了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单例运行的基本原理是类似的，而pid文件是一种常见的单例运行的方式，很多知名的开源组件都是使用类似的方式。对于shell脚本，还可以使用flock命令进行类似的操作。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>dd命令详解--磁盘读写测试</title>
    <url>/2019/11/25/51682.html</url>
    <content><![CDATA[<p>有时候需要测试磁盘读写速度，或者临时读写文件，不想临时写代码？有没有测试使用的命令？当然有！<br><a id="more"></a></p>
<h2 id="dd命令"><a href="#dd命令" class="headerlink" title="dd命令"></a>dd命令</h2><p>dd命令可以用于文件的拷贝或者内容转换。常见操作选项如下：</p>
<ul>
<li>bs=BYTES  一次读写字节数</li>
<li>ibs=BYTES 一次读的字节数</li>
<li>obs=BYTES 一次写的字节数</li>
<li>cbs=BYTES 一次转换的字节数</li>
<li>count=N 读写次数</li>
<li>of=FILE  将内容写到FILE，默认写入标准输出</li>
<li>if=FILE  从FILE中读取，默认从标准输入读取</li>
<li>conv=CONVS 转换标志</li>
</ul>
<p>更多选项可查看man手册。</p>
<p>来看一些实例。</p>
<h2 id="将文件的内容进行大小写转换"><a href="#将文件的内容进行大小写转换" class="headerlink" title="将文件的内容进行大小写转换"></a>将文件的内容进行大小写转换</h2><p>加入文件test.txt中有以下内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shouwangxiansheng</span><br></pre></td></tr></table></figure></p>
<p>现在要将内容转换为大写：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ dd if=test.txt of=utest.txt conv=ucase</span><br><span class="line">0+1 records in</span><br><span class="line">0+1 records out</span><br><span class="line">18 bytes copied, 0.0123523 s, 1.5 kB/s</span><br></pre></td></tr></table></figure></p>
<p>执行完成后，再看看utest.txt中的内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOUWANGXIANSHEN</span><br></pre></td></tr></table></figure></p>
<p>看到没，已经将所有内容转换为大写了。<br>当然还有其他方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat test.txt | tr &apos;a-z&apos; &apos;A-Z&apos; &gt; utest.txt</span><br></pre></td></tr></table></figure></p>
<p>解释一下，conv=ucase，表示转换操作是转换为大写，你还可以使用：</p>
<ul>
<li>lcase 转换为小写</li>
<li>ucase 转换为大写</li>
<li>swab 相邻字节交换</li>
</ul>
<h2 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h2><p>例如将test.txt文件内容拷贝到test0.txt文件，每次拷贝1024字节：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ dd if=test.txt of=test0.txt bs=1024</span><br></pre></td></tr></table></figure></p>
<p>读取指定次数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$  dd if=a of=b bs=1024 count=10 #读取10次</span><br></pre></td></tr></table></figure></p>
<p>跳过指定块大小开始读取：<br>假设ibs=1，那么，每次读取1字节，而skip=4，则会从第五个字节开始读取：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dd if=test.txt of=test0.txt ibs=1 skip=4</span><br></pre></td></tr></table></figure></p>
<p>得到内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$cat test0.txt</span><br><span class="line">wangxiansheng</span><br></pre></td></tr></table></figure></p>
<p>那如果要从指定位置开始写呢？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dd if=test.txt of=test0.txt obs=1 seek=5</span><br></pre></td></tr></table></figure></p>
<p>这些写入的内容就会从test0.txt的第六个字节开始写，而会保留前面的5个字节。</p>
<p>注意，由于这里我设置了ibs或者obs为1，所以skip和seek的单位都是字节，但是如果前面设置的是如1M，那么跳过的就是N兆了。</p>
<h2 id="生成随机文件"><a href="#生成随机文件" class="headerlink" title="生成随机文件"></a>生成随机文件</h2><p>还记得在《<a href="https://www.yanbinghu.com/2019/11/20/49894.html">Linux字符设备文件</a>》中提到的特殊字符文件吗？结合dd命令，我们可以生成一些随机内容的文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ dd if=/dev/urandom of=temp.txt count=2</span><br></pre></td></tr></table></figure></p>
<p>执行之后就会读取2个块大小的数据到temp.txt中。</p>
<h2 id="磁盘读写测试"><a href="#磁盘读写测试" class="headerlink" title="磁盘读写测试"></a>磁盘读写测试</h2><p>由于dd命令每次执行完成后都会显示其速度，因此可以利用它来测试当前的磁盘读写情况。<br>这里还有一个选项oflag=FLAGS用来设置一些读写方式，FLAG常见选项有：</p>
<ul>
<li>direct 使用直接IO</li>
<li>nonblock 使用非阻塞IO</li>
<li>noatime 不更新访问时间</li>
<li>nocache  丢弃缓存</li>
<li>sync   读写一次就写到磁盘</li>
<li>fsync 最后要写到磁盘</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ dd if=/dev/urandom of=testfile count=100 oflag=sync</span><br><span class="line">100+0 records in</span><br><span class="line">100+0 records out</span><br><span class="line">51200 bytes (51 kB, 50 KiB) copied, 0.0011526 s, 44.4 MB/s</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>dd命令可用于文件拷贝，文件内容大小写转换，磁盘读写测试等。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>printf打印保存在文件中</title>
    <url>/2019/11/21/44978.html</url>
    <content><![CDATA[<p>我们都知道，一般使用printf的打印都会直接打印在终端，如果想要存储在文件里呢？我想你可能想到的是重定向。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ program &gt; result.txt</span><br></pre></td></tr></table></figure></p>
<p>这样printf的输出就存储在result.txt中了。相关内容可以参考《<a href="https://www.yanbinghu.com/2018/10/26/9186.html">如何理解Linux shell中“2&gt;&amp;1”</a>》。<br><a id="more"></a><br>当然了，如果你既想打印在终端，又想保存在文件，还可以使用tee命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">program | tee result.txt</span><br></pre></td></tr></table></figure></p>
<p>注：program为你运行的程序。</p>
<p>不过文本介绍了不是通过命令行的方式，而是通过代码实现。</p>
<h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><p>你可能会想，那不用printf，直接将打印写入到文件不就可以了？类似于下面这样：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号编程珠玑 网站：https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">"log.txt"</span>,<span class="string">"w+"</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == fp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"open failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(fp,<span class="string">"test content %d\n"</span>,a);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不过这需要将原先的printf改用fprintf，修改了最原始的代码。但是本文并不是说明如何实现一个logging功能，而是​如何将printf的原始打印保存在文件中。​</p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>实际上，我们的程序在运行起来后，都会有三个文件描述符：</p>
<ul>
<li>0  标准输入</li>
<li>1  标准输出</li>
<li>2  标准错误</li>
</ul>
<p>一般标准输出都是都直接输出到终端。</p>
<p>我们可以用一个程序简单观察一下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sleep(<span class="number">20</span>);<span class="comment">//为了避免立即退出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假设编译出来的程序为test：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o test test.c</span><br><span class="line">$ ./test &amp;</span><br><span class="line">$ ls -l /proc/`pidof test`/fd</span><br></pre></td></tr></table></figure></p>
<p>这里关于proc文件系统可以参考《<a href="https://www.yanbinghu.com/2018/11/18/43716.html">Linux中不可错过的信息宝库</a>》，pidof test用于获取test进程id，其fd目录可以看到打开的文件描述符，关于文件打开可以参考《查看文件打开的多种方式》。<br>其输出结果如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lrwx------ <span class="number">1</span> root root <span class="number">64</span> Nov <span class="number">16</span> <span class="number">16</span>:<span class="number">26</span> <span class="number">0</span> -&gt; /dev/pts/<span class="number">0</span></span><br><span class="line">lrwx------ <span class="number">1</span> root root <span class="number">64</span> Nov <span class="number">16</span> <span class="number">16</span>:<span class="number">26</span> <span class="number">1</span> -&gt; /dev/pts/<span class="number">0</span></span><br><span class="line">lrwx------ <span class="number">1</span> root root <span class="number">64</span> Nov <span class="number">16</span> <span class="number">16</span>:<span class="number">26</span> <span class="number">2</span> -&gt; /dev/pts/<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>看到了吗，0，1，2都重定向到了/dev/pts/0，其实就是当前终端（参考《》）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tty</span><br><span class="line">/dev/pts/0</span><br></pre></td></tr></table></figure></p>
<p>所以如果我们要将printf的打印保存到文件中，实际上就让它重定向到这个文件就可以了。这里我们用到freopen函数：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *mode, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>参数说明：</p>
<ul>
<li>path：需要重定向到的文件名或文件路径。</li>
<li>mode：代表文件访问权限的字符串。例如，”r”表示“只读访问”、”w”表示“只写访问”、”a”表示“追加写入”。</li>
<li>stream：需要被重定向的文件流。</li>
</ul>
<p>那么要完成前面的任务也就很简单了：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp = freopen(<span class="string">"test.log"</span>,<span class="string">"w+"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == fp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"reopen failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"bianchengzhuji\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"shouwangxiansheng\n"</span>);</span><br><span class="line">    sleep(<span class="number">20</span>);<span class="comment">//便于观察</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重新编译后运行查看其打开的文件描述符：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lrwx------ <span class="number">1</span> root root <span class="number">64</span> Nov <span class="number">16</span> <span class="number">16</span>:<span class="number">34</span> <span class="number">0</span> -&gt; /dev/pts/<span class="number">0</span></span><br><span class="line">lrwx------ <span class="number">1</span> root root <span class="number">64</span> Nov <span class="number">16</span> <span class="number">16</span>:<span class="number">34</span> <span class="number">1</span> -&gt; /data/workspaces/test.<span class="built_in">log</span></span><br><span class="line">lrwx------ <span class="number">1</span> root root <span class="number">64</span> Nov <span class="number">16</span> <span class="number">16</span>:<span class="number">34</span> <span class="number">2</span> -&gt; /dev/pts/<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>看到了吗，它现在重定向到test.log了，并且终端也没有printf的打印。随后我们也在文件test.log中看到了下面的内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bianchengzhuji</span><br></pre></td></tr></table></figure></p>
<p>有人可能会有下面的疑问：</p>
<ul>
<li>怎么恢复？</li>
<li>为什么要这样做？</li>
</ul>
<p>首先来看怎么恢复，实际上恢复的原理是类似的，既然最开始它从定向到了/dev/pts/0，那么我们只需要重定向回去就可以了，但是在不同的终端，它的tty名字可能不同，因此需要使用ttyname函数获取原先stdout的tty名字：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int ttyname_r(int fd, char *buf, size_t buflen);</span><br></pre></td></tr></table></figure></p>
<p>又可以重新定向到/dev/pts/0了：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ttyName[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ttyname_r(<span class="built_in">stdin</span>,ttyName,<span class="number">128</span>);</span><br><span class="line">    FILE *fp = freopen(<span class="string">"test.log"</span>,<span class="string">"w+"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == fp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"reopen failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"bianchengzhuji\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"shouwangxiansheng\n"</span>);</span><br><span class="line">    sleep(<span class="number">20</span>);</span><br><span class="line">    freopen(ttyName,<span class="string">"w+"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"std out to %s\n"</span>,ttyName);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终运行会发现两个结果：</p>
<ul>
<li>std out to 打印到终端</li>
<li>打开的文件描述符1被重定向到/dev/pts/0</li>
</ul>
<p>除了上面这种方式，还有一种方式是使用dup2：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int dup2(int oldfd, int newfd);</span><br></pre></td></tr></table></figure></p>
<p>它是用来复制文件描述符的，会使得newfd成为oldfd的副本.所以与上面看到不同的是，标准输出和往fd写入的内容，都会存储在文件test.log中：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"test.log"</span>,O_WRONLY|O_CREAT);</span><br><span class="line">    dup2(fd,<span class="number">1</span>);<span class="comment">//1代表标准输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"bianchengzhuji\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"shouwangxiansheng\n"</span>);</span><br><span class="line">    sleep(<span class="number">20</span>);</span><br><span class="line">	close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>观察的结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lrwx------ 1 root root 64 Nov 17 17:03 0 -&gt; /dev/pts/0</span><br><span class="line">l-wx------ 1 root root 64 Nov 17 17:03 1 -&gt; /data/workspaces/test.log</span><br><span class="line">lrwx------ 1 root root 64 Nov 17 17:03 2 -&gt; /dev/pts/0</span><br><span class="line">l-wx------ 1 root root 64 Nov 17 17:03 3 -&gt; /data/workspaces/test.log</span><br></pre></td></tr></table></figure></p>
<p>这种情况适合于将标准输出的内容和其他写文件的内容一并保存到文件中。</p>
<h2 id="如何关闭printf打印"><a href="#如何关闭printf打印" class="headerlink" title="如何关闭printf打印"></a>如何关闭printf打印</h2><p>实际上非常简单，进程启动后，只需要关闭文件描述符1（标准输出）,2（标准错误）​即可。什么情况下会需要呢？有些后台进程有自己的日志记录方式，而不想让printf的信息打印在终端，因此可能会关闭​。​</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文本旨在通过将printf的打印存储在文件中来介绍重定向，以及0，1，2文件描述符。如果你不想保留标准输出，可以将其重定向到/dev/null，如果想保留，且单独保留到特定文件，可以使用freopen，如果想保留，且和其他内容保留到同一文件，使用dup2。如果一行代码都不想动，使用命令行重定向。如果你完全不关心，当我啥都没说。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>linux字符设备文件</title>
    <url>/2019/11/20/49894.html</url>
    <content><![CDATA[<p>我们都知道Linux下一切皆文件，<br><a id="more"></a><br>主要有</p>
<ul>
<li>- 普通文件</li>
<li>d    目录</li>
<li>l 符号链接</li>
<li>s    套接字</li>
<li>b    块设备</li>
<li>c    字符设备</li>
<li>p    管道</li>
</ul>
<p>这么几种文件。<br>这里的前缀字符可以通过ls命令观察到：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -l test.log</span><br><span class="line">-rw-r--r-- 1 root root 33 Nov 17 17:03 test.log</span><br></pre></td></tr></table></figure></p>
<p>它的结果最前面是-，因此它是普通文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -al /dev/null</span><br><span class="line">crw-rw-rw- 1 root root 1, 3 Sep 11 20:33 /dev/null</span><br></pre></td></tr></table></figure></p>
<p>它的结果最前面是c，因此它是字符设备。</p>
<p>文件简单介绍几种字符设备文件，它能在我们功能测试的时候提供很好的帮助。</p>
<h2 id="dev-null"><a href="#dev-null" class="headerlink" title="/dev/null"></a>/dev/null</h2><p>/dev/null 可无限接收数据，你可以认为是一个黑洞，因此如果我们需要丢弃某些终端输出，可以重定向到这里：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &quot;shouwangxiansheng&quot; &gt; /dev/null</span><br></pre></td></tr></table></figure></p>
<p>所以如果你有不需要的数据可以尽情的往这里写。</p>
<h2 id="dev-full"><a href="#dev-full" class="headerlink" title="/dev/full"></a>/dev/full</h2><p>它在读取时会读取到连续的NUL（零值）字节流，而在写入的时候，会返回磁盘空间已满的结果，</p>
<p>后者在测试你的程序的时候会有帮助，即测试磁盘满的场景：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &quot;bianchengzhuji&quot; &gt; /dev/full</span><br><span class="line">-bash: echo: write error: No space left on device</span><br></pre></td></tr></table></figure></p>
<h2 id="dev-zero"><a href="#dev-zero" class="headerlink" title="/dev/zero"></a>/dev/zero</h2><p>和/dev/null类似，向其中写入时会丢弃所有数据，但是读取时，会产生NUL（零值）字节流。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat /dev/zero |od -x </span><br><span class="line">0000000 0000 0000 0000 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure></p>
<h2 id="dev-random"><a href="#dev-random" class="headerlink" title="/dev/random"></a>/dev/random</h2><p>/dev/random可以提供随机数据流，它保证数据的随机性，但是读取时会造成等待，例如<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat /dev/random | od -x</span><br><span class="line">0000000 2b07 daac 42f4 e1fd fb62 2098 870e e0af</span><br><span class="line">0000020 3022 2099 e5da 4e1c d6db 548b a979 1217</span><br><span class="line">0000040 3777 bb6a 957d 1279 ab29 e8a4 6a36 ecca</span><br><span class="line">0000060 39ec 2285 126c 30ea ea67 1526 5e4a 2dd9</span><br></pre></td></tr></table></figure></p>
<p>稍过会才会出现数据，为了便于查看，我们利用od命令查看其十六进制内容。</p>
<h2 id="dev-urandom"><a href="#dev-urandom" class="headerlink" title="/dev/urandom"></a>/dev/urandom</h2><p>从名字就可以看出来，是用来产生随机数据的。它的产生速度很快，但是数据的随机性不如/dev/random<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /dev/urandom | od -x</span><br><span class="line">0547560 f43e 696a 8936 2b27 36c8 4446 2802 1d47</span><br><span class="line">0547600 b8af 249d aae9 edbf 8971 b1d1 0c73 3e2d</span><br><span class="line">0547620 237b 9a81 6348 cb2a 1972 4486 028a 3573</span><br><span class="line">0547640 1690 c388 64e1 aec1 d5f4 1964 bbb9 192f</span><br><span class="line">0547660 f242 7194 51ba 62a3 fc13 ff53 fb50 e3d8</span><br><span class="line">0547700 ef32 3658 b335 75ee 62de 4096 6468 c979</span><br><span class="line">0547720 01b9 c233 878d 12fc 5cfa 5691 89e1 e1f9</span><br></pre></td></tr></table></figure></p>
<h2 id="dev-pts"><a href="#dev-pts" class="headerlink" title="/dev/pts"></a>/dev/pts</h2><p>/dev/pts是远程登陆(telnet,ssh等)后创建的控制台设备文件所在的目录。有什么用呢？举个例子，你打开一个终端，获取到当前的pts：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tty</span><br><span class="line">/dev/pts/0</span><br></pre></td></tr></table></figure></p>
<p>然后你又打开一个，输入：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &quot;hahahaha&quot;&gt;/dev/pts/0</span><br></pre></td></tr></table></figure></p>
<p>你就会发现内容被打印到前面一个终端了。</p>
<p>通常我们运行一个程序，其printf的打印都会打印在当前终端。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际上在/dev下还有非常多的特殊文件，但是不一一介绍。以上特殊文件在一定场合下能帮助我们开发或者测试。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>sizeof,strlen,数组,字符串整在一起的那些坑</title>
    <url>/2019/11/17/7085.html</url>
    <content><![CDATA[<p>对于初学者来说，sizeof，strlen，数组，字符串整在一起是痛苦的，它总能在某些莫名其妙的时候整一个措手不及。本文看看它们在一起能挖什么坑。<br><a id="more"></a></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>在说明这些问题之前，先看一段代码，看看你是否都理解了。(注：以下代码结果为编译为64位程序后运行结果)<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testArr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lu %lu\n"</span>, <span class="keyword">sizeof</span>(str), <span class="built_in">strlen</span>(str));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*test 0*/</span></span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"test0 %lu %lu\n\n"</span>, <span class="keyword">sizeof</span>(str), <span class="built_in">strlen</span>(str)); <span class="comment">//6 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*test 1*/</span></span><br><span class="line">    <span class="keyword">char</span> str1[<span class="number">8</span>] = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"test1 %lu %lu\n\n"</span>, <span class="keyword">sizeof</span>(str1), <span class="built_in">strlen</span>(str1)); <span class="comment">//8 5</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**test 2*/</span></span><br><span class="line">    <span class="keyword">char</span> str2[] = &#123;<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"test2 %lu %lu\n\n"</span>, <span class="keyword">sizeof</span>(str2), <span class="built_in">strlen</span>(str2)); <span class="comment">//5 10</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**test 3*/</span></span><br><span class="line">    <span class="keyword">char</span> *str3 = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"test3 %lu %lu\n\n"</span>, <span class="keyword">sizeof</span>(str3), <span class="built_in">strlen</span>(str3)); <span class="comment">//8 5</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*test 4*/</span></span><br><span class="line">    <span class="keyword">char</span> str4[] = <span class="string">"hello"</span>;</span><br><span class="line">    testArr(str4);<span class="comment">//8 5</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*test 5*/</span></span><br><span class="line">    <span class="keyword">char</span> str5[] = <span class="string">"hell\0o"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"test5 %lu %lu\n"</span>, <span class="keyword">sizeof</span>(str5), <span class="built_in">strlen</span>(str5)); <span class="comment">//7 4</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*test 6*/</span></span><br><span class="line">    <span class="keyword">char</span> str6[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"test6 %lu %lu\n\n"</span>, <span class="keyword">sizeof</span>(str6), <span class="built_in">strlen</span>(str6)); <span class="comment">//10 0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*test 7*/</span></span><br><span class="line">    <span class="keyword">char</span> str7[<span class="number">5</span>] = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"test7 %lu %lu\n\n"</span>, <span class="keyword">sizeof</span>(str7), <span class="built_in">strlen</span>(str7)); <span class="comment">//5 10</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*test 8*/</span></span><br><span class="line">    <span class="keyword">char</span> str8[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">strncpy</span>(str8,<span class="string">"hello"</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,str8);<span class="comment">//hellohello</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>特别注意观察test2和test7。<br>在解释这些测试之前，先复习以下sizeof，strlen以及数组的内容。</p>
<h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2><p>首先需要明确的是，sizeof是操作符，即它并不是函数，它的作用对象是数据类型，因此，它作用于变量时，也是对其类型进行操作。得到的结果是该数据类型占用空间大小，即size_t类型。<br>例如：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">int</span>);<span class="comment">//得到4</span></span><br><span class="line"><span class="keyword">sizeof</span>(test);<span class="comment">//4字节对齐时，得到8</span></span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，它在计算数据类型占用空间大小时，会考虑字节对齐，关于字节对齐，可以参考《<a href="https://www.yanbinghu.com/2018/09/15/43741.html">理一理字节对齐的那些事</a>》。<br>另外sizeof的时间复杂度是O(1)。</p>
<h2 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h2><p>strlen是函数<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>它用于计算字符串的长度。它的计算原则是：<br>从参数s所指向的内存开始向下计数，直到内存中的内容是0（即’\0’）（参考《<a href="https://www.yanbinghu.com/2019/08/19/18180.html">NULL，0，你真的分得清吗</a>》）为止。<br>例如：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *p = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lu\n"</span>,<span class="built_in">strlen</span>(p));<span class="comment">//得到5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里字符串hello的长度就是5，但是占用空间是多少呢？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sizeof(&quot;hello&quot;);//得到6</span><br></pre></td></tr></table></figure></p>
<p>是6，而不是5。<br>注：strlen的时间复杂度为O（N）。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>关于数组，更多内容可以参考《<a href="https://www.yanbinghu.com/2018/10/23/2660.html">数组之谜</a>》</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串是以’\0’结尾的字符数组。</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>实际上了解以上内容之后，很多问题迎刃而解。</p>
<h4 id="test0"><a href="#test0" class="headerlink" title="test0"></a>test0</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"test0 %lu %lu\n\n"</span>, <span class="keyword">sizeof</span>(str), <span class="built_in">strlen</span>(str)); <span class="comment">//6 5</span></span><br></pre></td></tr></table></figure>
<p>上面的初始化方法等价于下面的方式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char str[] = &#123;&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;,&apos;\0&apos;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>它实际上就是一个字符数组，只不过上面这种赋值方式会在末尾加上’\0’。</p>
<p>既然如此，那么用sizeof求得占用空间大小也就很明显了是6。而strlen是遇到’\0’，就结束，因此其求得长度为5。</p>
<h4 id="test1"><a href="#test1" class="headerlink" title="test1"></a>test1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*test 1*/</span><br><span class="line">char str1[8] = &quot;hello&quot;;</span><br><span class="line">printf(&quot;test1 %lu %lu\n\n&quot;, sizeof(str1), strlen(str1)); //8 5</span><br></pre></td></tr></table></figure>
<p>test1类似，只不过它占用空间是8，而长度仍然是5。</p>
<h4 id="test2"><a href="#test2" class="headerlink" title="test2"></a>test2</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**test 2*/</span><br><span class="line">char str2[] = &#123;&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;&#125;;</span><br><span class="line">printf(&quot;test2 %lu %lu\n\n&quot;, sizeof(str2), strlen(str2)); //5 10</span><br></pre></td></tr></table></figure>
<p>sizeof求str2的大小很明显是5，而为啥那么strlen得到的是10呢？还记得strlen的原则吗，遇到’\0’则结束，但是，’\0’在哪里？至少我在str2中没有看到，所以你可能看到的结果是10，也可能是另外一个莫名其妙的值，甚至可能导致程序崩溃。</p>
<h4 id="test3"><a href="#test3" class="headerlink" title="test3"></a>test3</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**test 3*/</span><br><span class="line">char *str3 = &quot;hello&quot;;//最后有一个”隐形“的&apos;\0&apos;</span><br><span class="line">printf(&quot;test3 %lu %lu\n\n&quot;, sizeof(str3), strlen(str3)); //8 5</span><br></pre></td></tr></table></figure>
<p>为什么前者是8？很显然，str3并不是一个数组，而是一个字符指针，既然是指针类型，自然占着指针的大小，而64位程序中，它的大小就是你看到的8。后者还是从str3指向的地址开始，直到遇到’\0’，即得到长度5。</p>
<h4 id="test4"><a href="#test4" class="headerlink" title="test4"></a>test4</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*test 4*/</span><br><span class="line">char str4[] = &quot;hello&quot;;</span><br><span class="line">testArr(str4);//8 5</span><br></pre></td></tr></table></figure>
<p>这在《<a href="https://www.yanbinghu.com/2018/10/23/2660.html">数组之谜</a>》中也提到过，当数组作为参数时，实际上只是一个指针，所以用sizeof计算时，会得到8。</p>
<h4 id="test5"><a href="#test5" class="headerlink" title="test5"></a>test5</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*test 5*/</span><br><span class="line">char str5[] = &quot;hell\0o&quot;;</span><br><span class="line">printf(&quot;test5 %lu %lu\n&quot;, sizeof(str5), strlen(str5)); //7 4</span><br></pre></td></tr></table></figure>
<p>同理，str5的初始化等价于下面：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char str5[] = &#123;&apos;h&apos;,&apos;e&apos;.&apos;l&apos;,&apos;l&apos;,&apos;\0&apos;,&apos;o&apos;,&apos;\0&apos;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>所以不用解释你也明白，sizeof得到的结果是7。而strlen遇到第一个’\0’就停止继续计算了，因此得到4。</p>
<h4 id="test6"><a href="#test6" class="headerlink" title="test6"></a>test6</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*test 6*/</span><br><span class="line">char str6[10] = &#123;0&#125;;</span><br><span class="line">printf(&quot;test6 %lu %lu\n\n&quot;, sizeof(str6), strlen(str6)); //10 0</span><br></pre></td></tr></table></figure>
<p>相信这个也好理解，占用空间10，但是由于都是0，因此strlen得到长度位0。</p>
<h4 id="test7"><a href="#test7" class="headerlink" title="test7"></a>test7</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*test 7*/</span><br><span class="line">char str7[5] = &quot;hello&quot;;</span><br><span class="line">printf(&quot;test7 %lu %lu\n\n&quot;, sizeof(str7), strlen(str7)); //5 10</span><br></pre></td></tr></table></figure>
<p>这也是非常危险的，占用空间是5，它没有空间容纳最后的’\0’,y因此导致strlen计算的结果和test2一样，可能会是任意值。</p>
<h4 id="test8"><a href="#test8" class="headerlink" title="test8"></a>test8</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*test 8*/</span><br><span class="line">char str8[5] = &#123;0&#125;;</span><br><span class="line">strncpy(str8,&quot;hello&quot;,5);</span><br><span class="line">printf(&quot;%s\n&quot;,str8);//hellohello</span><br></pre></td></tr></table></figure>
<p>这里在实际编程中最容易遇到的问题之一，数组大小位5，但是拷贝了5个字节大小的数据。如果你把它当成字符数组使用也没什么问题，但是由于它最后没有空间去容纳’\0’,因此你使用strlen，或者使用printf去打印的时候，可能发生难以预料的结果。</p>
<p>所以你可能会在你的项目代码中看到类似这样的写法，将字符数组的最后一个位置赋值为0：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str8[4] = &apos;\0&apos;;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文本关键点如下：</p>
<ul>
<li>sizeof计算类型占用空间大小，时间复杂度O(1)</li>
<li>sizeof计算大小时会考虑字节对齐</li>
<li>strlen计算字符串长度，时间复杂度O(N)</li>
<li>strlen作用对象是字符串（以’\0’结尾）</li>
<li>strlen遇到’\0’作罢，如果没有遇到，则不可预料</li>
<li>格外小心数组作为参数</li>
</ul>
<p>另外注意下面两种方式hello存储的区域不一致：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char str[] = &quot;hello&quot;;</span><br><span class="line">char *str2 = &quot;hello&quot;;//存储在数据区，只读</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>有限状态机+函数指针-C语言实现</title>
    <url>/2019/11/14/38034.html</url>
    <content><![CDATA[<p>有读者在后台留言说用c写一篇有限状态机的推文，正好之前也用过，就分享一下吧。<br><a id="more"></a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>先举一个简单的例子，假设是这样的，一个小孩有两种状态，睡眠，清醒。睡的时候可能会撒尿，微笑，撒尿之后会转为清醒状态，而清醒的时候可能会笑，会吃，吃完之后会转会睡眠状态<br>用C语言实现，一般写法可能是这样的：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">enum</span> KID_STATUS</span><br><span class="line">&#123;</span><br><span class="line">    SLEEP = <span class="number">0</span>,</span><br><span class="line">    WAKE = <span class="number">1</span>,</span><br><span class="line">    INVALID = <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum</span> KID_ACTION</span><br><span class="line">&#123;</span><br><span class="line">    SMILE = <span class="number">0</span>,</span><br><span class="line">    EAT = <span class="number">1</span>,</span><br><span class="line">    PEE = <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*孩子当前状态*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> nowStatus = WAKE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*孩子行为*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smile</span><span class="params">(<span class="keyword">int</span> status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"kid smile\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eat</span><span class="params">(<span class="keyword">int</span> status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"kid eat\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> SLEEP;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pee</span><span class="params">(<span class="keyword">int</span> status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"kid pee\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> WAKE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*孩子产生某个行为*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">int</span> action)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nextStatus;</span><br><span class="line">    <span class="comment">/*醒着时的行为*/</span></span><br><span class="line">    <span class="keyword">if</span>(WAKE == nowStatus)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(action)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> SMILE:</span><br><span class="line">            &#123;</span><br><span class="line">                nextStatus = smile(nowStatus);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> EAT:</span><br><span class="line">            &#123;</span><br><span class="line">                nextStatus = eat(nowStatus);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> PEE:</span><br><span class="line">            &#123;</span><br><span class="line">                nextStatus = pee(nowStatus);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"unknow action when wake %d\n"</span>,action);</span><br><span class="line">                nextStatus = nowStatus;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*睡着时的行为*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(SLEEP == nowStatus)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(action)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> SMILE:</span><br><span class="line">            &#123;</span><br><span class="line">                nextStatus = smile(nowStatus);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            casePEE:</span><br><span class="line">            &#123;</span><br><span class="line">                nextStatus = pee(nowStatus);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"unknow action when sleep %d\n"</span>,action);</span><br><span class="line">                nextStatus = nowStatus;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"unknow action\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nowStatus = nextStatus;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"next status is %d\n"</span>,nowStatus);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nowStatus = SLEEP;</span><br><span class="line">    execute(EAT);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码的意图就非常明显了，首先判断当前所在状态， 然后找到其中的行为，最后执行。<br>但是这段代码有以下几个特点：</p>
<ul>
<li>新加一种行为需要修改execute函数</li>
<li>新加一种行为需要增加更多分支代码</li>
<li>新加一种状态，需要新增一个大的分支</li>
<li>哪些状态有哪些行为不是很明显</li>
</ul>
<h2 id="换一种写法"><a href="#换一种写法" class="headerlink" title="换一种写法"></a>换一种写法</h2><p>在《<a href="https://www.yanbinghu.com/2019/01/03/3593.html">高级指针话题-函数指针</a>》中介绍了函数指针，以及在《<a href="https://www.yanbinghu.com/2019/01/20/6807.html">编程技巧-跳转表</a>》介绍了函数跳转表。这里我们把代码调整一下，看看结合跳转表和状态机，能写出什么样的代码。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】地址：https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">enum</span> KID_STATUS</span><br><span class="line">&#123;</span><br><span class="line">    SLEEP = <span class="number">0</span>,</span><br><span class="line">    WAKE = <span class="number">1</span>,</span><br><span class="line">    INVALID = <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum</span> KID_ACTION</span><br><span class="line">&#123;</span><br><span class="line">    SMILE = <span class="number">0</span>,</span><br><span class="line">    EAT = <span class="number">1</span>,</span><br><span class="line">    PEE = <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*孩子当前状态*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> nowStatus = WAKE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*孩子行为*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smile</span><span class="params">(<span class="keyword">int</span> status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"kid smile\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eat</span><span class="params">(<span class="keyword">int</span> status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"kid eat\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> SLEEP;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pee</span><span class="params">(<span class="keyword">int</span> status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"kid pee\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> WAKE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*Handler)</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">//函数指针</span></span><br><span class="line"><span class="comment">/*用于处理某种状态的行为*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Act_Handler</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> action;</span><br><span class="line">    Handler handler;</span><br><span class="line">&#125;Act_Handler;</span><br><span class="line"><span class="comment">/*某种状态的处理集*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stat_Handler</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">int</span> actNum;</span><br><span class="line">    Act_Handler *actHandler;</span><br><span class="line">&#125;Stat_Handler;</span><br><span class="line"><span class="comment">/*sleep状态行为处理*/</span></span><br><span class="line">Act_Handler sleepHandler[] = </span><br><span class="line">&#123;</span><br><span class="line">    &#123;SMILE,smile&#125;,</span><br><span class="line">    &#123;PEE,pee&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*wake状态行为处理*/</span></span><br><span class="line">Act_Handler wakeHandler[] = </span><br><span class="line">&#123;</span><br><span class="line">    &#123;SMILE,smile&#125;,</span><br><span class="line">    &#123;PEE,pee&#125;,</span><br><span class="line">    &#123;EAT,eat&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*状态处理*/</span></span><br><span class="line"><span class="keyword">static</span> Stat_Handler statHandler[] = </span><br><span class="line">&#123;</span><br><span class="line">    &#123;SLEEP,<span class="keyword">sizeof</span>(sleepHandler)/<span class="keyword">sizeof</span>(Act_Handler),sleepHandler&#125;,</span><br><span class="line">    &#123;WAKE,<span class="keyword">sizeof</span>(wakeHandler)/<span class="keyword">sizeof</span>(Act_Handler),wakeHandler&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> statSize = <span class="keyword">sizeof</span>(statHandler)/ <span class="keyword">sizeof</span>(Stat_Handler);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">int</span> action)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nowStatus &gt;= statSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"unknow status\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"now status is %d,action %d\n"</span>,nowStatus,action);</span><br><span class="line">    <span class="keyword">int</span> nextStatus = nowStatus;</span><br><span class="line">    Act_Handler *actHandler = statHandler[nowStatus].actHandler;</span><br><span class="line">    <span class="keyword">int</span> actNum = statHandler[nowStatus].actNum;</span><br><span class="line">    <span class="keyword">int</span> actIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*遍历指定状态下的行为集，找到对应的行为*/</span></span><br><span class="line">    <span class="keyword">for</span>(actIdx = <span class="number">0</span>;actIdx &lt; actNum;actIdx++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(actHandler[actIdx].action == action)</span><br><span class="line">        &#123;</span><br><span class="line">            nextStatus = (actHandler[actIdx].handler)(action);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(actIdx == actNum)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"did find action %d in status %d\n"</span>,action,nowStatus);</span><br><span class="line">    &#125;</span><br><span class="line">    nowStatus = nextStatus;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"next status is %d\n"</span>,nowStatus);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nowStatus = WAKE;</span><br><span class="line">    execute(EAT);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里简单说明一下execute函数中的执行流程。</p>
<ul>
<li>判断当前状态合法性</li>
<li>在数组中找到对应状态的行为处理集</li>
<li>在处理集中找到对应的行为</li>
<li>处理结束</li>
</ul>
<p>这种方式有什么特点呢？可以看到，在需要新加一个动作的时候，只需要在sleepHandler或者wakeHandler中添加，完全不影响execute函数的改动。你甚至可以将不同状态分在不同的文件中管理，使得结构更加清晰明朗。</p>
<p>另外一方面，某种状态下，能执行哪些动作，非常清晰。</p>
<p>不过这样的写法对于初学者来说不太友好，但是不影响你添加新的内容。</p>
<p>有的读者可能会堪虑，在寻找行为的时候，for循环会不会很慢？首先这和case差别不大，通常不会有性能问题，其次除了使用数组，还可以考虑其他数据结构，例如哈希，我在《<a href="https://www.yanbinghu.com/2019/11/12/47658.html">工作中用不到算法，为什么还要学算法？</a>》中也提到了，数据结构和算法能更好地帮我们解决问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文代码较多，建议在实际环境中运行调试。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>工作中几乎用不到算法，为什么还要学算法？</title>
    <url>/2019/11/12/47658.html</url>
    <content><![CDATA[<p>不知道你有没有发现，非算法类的岗位，工作之后几乎没有用到什么算法，为什么还要学算法？本文谈谈自己的看法，不供参考。<br><a id="more"></a></p>
<h2 id="从用人者角度"><a href="#从用人者角度" class="headerlink" title="从用人者角度"></a>从用人者角度</h2><p>毋庸置疑，面试是用来筛选候选人的，在这个僧多粥少的时候，就需要提高筛选条件，例如最常见的学历，不是说学历一般的人不好，而是总体来说，学历好的人里面挑选到合适的概率比较大而已，这就是现实。而面试题中，算法相比于其他记忆型的题目，就能很好的体现一个人的逻辑和思路，因而也是一个很好的筛选条件。当然像操作系统，网络，Linux等都是很多公司喜欢考察的点。</p>
<p>所以为了面试还是需要准备学习算法的。</p>
<h2 id="从个人角度"><a href="#从个人角度" class="headerlink" title="从个人角度"></a>从个人角度</h2><p>进去的第一家公司基本用不上什么算法（血的教训，在学校的时候一定要好好准备），甚至用不上网络编程，基本就是简单纯C开发，因为那些东西早就封装好了（由另外一个组负责开发维护），只需要调用即可。包括后来去面试，主要面试了两类公司，一类是传统通信技术类，一类是互联网公司，前者关注项目本身，以及基本的技术技能更多一些，而后者考察的方面通常比较多，包括操作系统，数据库，算法，网络等知识。</p>
<p>那么面完之后是不是真的就完全没用了呢？确实，大多数时候根本用不上。你写的可能多是业务代码，是业务流程的设计，代码实现可能只是很小的一环。而且现有算法实现一搜一大把，基本不太可能要你自己去实现什么快排，跳表，快排，红黑树之类的算法，但是学习算法有好处。</p>
<p>例如，你可能要根据你的业务排序需求来选择是用稳定排序还是非稳定排序；你可能会根据插入和删除数据的频率来选择使用array list还是link list；你可能为了处理top K问题采用堆相关算法；可能为了某种情况下的快速查找而使用哈希；你可能在设计你的业务数据结构时引用了基本数据结构的思想。</p>
<p>好了，我编不下去了，你看着办给自己解释一下吧。</p>
<h2 id="常见的数据结构与算法"><a href="#常见的数据结构与算法" class="headerlink" title="常见的数据结构与算法"></a>常见的数据结构与算法</h2><p>最基本的数据结构和算法包括：</p>
<ul>
<li><a href="https://www.yanbinghu.com/2019/02/21/28355.html">排序算法</a></li>
<li><a href="https://www.yanbinghu.com/2019/01/07/16863.html">递归</a></li>
<li>链表</li>
<li><a href="https://www.yanbinghu.com/2018/10/23/2660.html">数组</a></li>
<li><a href="https://www.yanbinghu.com/2019/03/28/13055.html">队列</a></li>
<li><a href="https://www.yanbinghu.com/2019/03/16/31765.html">栈</a></li>
<li><a href="https://www.yanbinghu.com/2019/05/17/36705.html">优先队列</a></li>
<li><a href="https://www.yanbinghu.com/2019/05/04/61373.html">哈希（散列）</a></li>
<li><a href="https://www.yanbinghu.com/2019/04/07/55964.html">二叉树，B树，B+树，红黑树</a></li>
<li><a href="https://www.yanbinghu.com/2018/12/08/34927.html">bitmap</a></li>
<li>跳表</li>
<li><a href="https://www.yanbinghu.com/2018/12/25/10757.html">二分法</a></li>
<li>动态规划</li>
<li>贪心算法</li>
<li>……</li>
</ul>
<p>更多内容可查看公众号【编程珠玑】菜单栏的数据结构与算法部分。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通常我们不需要自己实现这些算法，不过我觉得从中了解以下几点非常重要</p>
<ul>
<li>时间和空间复杂度的概念</li>
<li>各类数据结构或算法的效率</li>
<li>各类数据结构或算法的复杂度</li>
<li>各类数据结构或者算法的适用场景</li>
<li>常见的如vector，map，set等容器背后的数据结构是什么，它们的查找或者插入效率如何</li>
<li>从现有数据结构和算法中获得思路</li>
<li>根据现有问题选择合适的数据结构和算法</li>
</ul>
<p>不像Java，C++，Python之流，C库中可能没有上面提到的数据结构或者算法的实现，因而C语言也是加深对它们理解的不二选择。</p>
<p>一切为了更好地解决实际问题。</p>
<p>以上就是本人对算法的浅薄认识，欢迎补充。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>程序员</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11-unique_ptr详解</title>
    <url>/2019/11/07/11278.html</url>
    <content><![CDATA[<p>在《<a href="https://www.yanbinghu.com/2019/11/05/17350.html">拥抱智能指针，告别内存泄露</a>》中说到了内存泄漏问题，也提到了C++中的智能指针基本原理，今天就来说说类模板unique_ptr。<br>在此之前，先回答读者的一个提问：C语言中该怎么办？有几点建议：</p>
<ul>
<li>编写时尽量遵循函数内申请，函数内释放的原则</li>
<li>注意成对编写malloc和free</li>
<li>使用静态扫描工具，如《pclint检查》</li>
<li>使用内存检测工具，如valgrind</li>
</ul>
<p>相关阅读《<a href="https://www.yanbinghu.com/2018/12/16/20648.html">常见内存问题</a>》。</p>
<a id="more"></a>
<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>一个unique_ptr独享它指向的对象。也就是说，同时只有一个unique_ptr指向同一个对象，当这个unique_ptr被销毁时，指向的对象也随即被销毁。使用它需要包含下面的头文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;memory&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>常见方式有：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up;<span class="comment">//可以指向int的unique_ptr，不过是空的</span></span><br><span class="line">up = <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">12</span>));</span><br></pre></td></tr></table></figure></p>
<p>此时它是一个空的unique_ptr，即没有指向任何对象。<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//unique_ptr&lt;T&gt;</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">up1</span><span class="params">(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"bianchengzhuji"</span>))</span></span>;</span><br><span class="line">std::unique_ptr&lt;int[]&gt; up2(new int[10]);//数组需要特别注意</span><br></pre></td></tr></table></figure></p>
<p>也可以指向一个new出来的对象。</p>
<p>你也可以结合上面两种方式，如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">std::unique_ptr&lt;int&gt; up;//声明空的unique_ptr</span><br><span class="line">int *p= new int(1111);</span><br><span class="line">up.reset(p);//令up指向新的对象，p为内置指针</span><br></pre></td></tr></table></figure></p>
<p>通常来说，在销毁对象的时候，都是使用delete来销毁，但是也可以使用指定的方式进行销毁。举个简单的例子，假如你打开了一个连接，获取到了一个文件描述符，现在你想通过unique_ptr来管理，希望在不需要的时候，能够借助unique_ptr帮忙关闭它。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//来源：公众号【编程珠玑】</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">void myClose(int *fd)</span><br><span class="line">&#123;</span><br><span class="line">    close(*fd);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int socketFd = 10;//just for example</span><br><span class="line">    std::unique_ptr&lt;int,decltype(myClose)*&gt; up(&amp;socketFd,myClose);</span><br><span class="line">    /*下面是另外两种写法，后面一种是使用lambda表达式*/</span><br><span class="line">    //std::unique_ptr&lt;int,void(*)(int*)&gt; up(&amp;socketFd,myClose);</span><br><span class="line">    //std::unique_ptr&lt;int,void(*)(int*)&gt; ip(&amp;socketFd,[](int *fd)&#123;close(*fd);&#125;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它的用法如下：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">std::unique_ptr&lt;T,D&gt; up(t,d);</span><br><span class="line">std::unique_ptr&lt;T,D&gt; up(d);//空的unique_ptr</span><br></pre></td></tr></table></figure></p>
<p>含义分别如下：</p>
<ul>
<li>T unique_ptr管理的对象类型</li>
<li>D 删除器类型</li>
<li>t unique_ptr管理的对象</li>
<li>d 删除器函数/function对象等，用于释放对象指针</li>
</ul>
<p>这里使用了decltype(myClose)*用于获取myClose函数的类型，*表明它是一个指针类型，即函数指针，它传入参数是int*。你也可以使用注释中的方式。关于函数指针，可参考《》。</p>
<p>即便后面执行出现异常时，这个socket连接也能够正确关闭。</p>
<p>后面我们也可以看到，与shared_ptr不同，unique_ptr在编译时绑定删除器，避免了运行时开销。</p>
<h4 id="释放指向的对象"><a href="#释放指向的对象" class="headerlink" title="释放指向的对象"></a>释放指向的对象</h4><p>一般来说，unique_ptr被销毁时（如离开作用域），对象也就自动释放了，也可以通过其他方式下显示释放对象。如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">up = <span class="literal">nullptr</span>;<span class="comment">//置为空，释放up指向的对象</span></span><br><span class="line">up.release();<span class="comment">//放弃控制权，返回裸指针，并将up置为空</span></span><br><span class="line">up.reset();<span class="comment">//释放up指向的对象</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到release和reset的区别在于，前者会释放控制权，返回裸指针，你还可以继续使用。而后者直接释放了指向对象。</p>
<h4 id="unique-ptr不支持普通的拷贝和赋值"><a href="#unique-ptr不支持普通的拷贝和赋值" class="headerlink" title="unique_ptr不支持普通的拷贝和赋值"></a>unique_ptr不支持普通的拷贝和赋值</h4><p>需要特别注意的是，由于unique_ptr“独有”的特点，它不允许进行普通的拷贝或赋值，例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up0;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">up1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1111</span>))</span></span>;</span><br><span class="line">up0 = up1 <span class="comment">//错误，不可赋值</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up2(up1);<span class="comment">//错误，不支持拷贝</span></span><br></pre></td></tr></table></figure></p>
<p>总之记住，既然unique_ptr是独享对象，那么任何可能被共享的操作都是不允许的，但是可以移动。</p>
<h4 id="移动unique-ptr的对象"><a href="#移动unique-ptr的对象" class="headerlink" title="移动unique_ptr的对象"></a>移动unique_ptr的对象</h4><p>虽然unique_ptr独享对象，但是也可以移动，即转移控制权。如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">std::unique_ptr&lt;int&gt; up1(new int(42));</span><br><span class="line">std::unique_ptr&lt;int&gt; up2(up1.release());</span><br></pre></td></tr></table></figure></p>
<p>up2接受up1 release之后的指针，或者：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">std::unique_ptr&lt;int&gt; up1(new int(42));</span><br><span class="line">std::unique_ptr&lt;int&gt; up2;</span><br><span class="line">up2.reset(up1.release());</span><br></pre></td></tr></table></figure></p>
<p>或者使用move：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">up1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">up2</span><span class="params">(<span class="built_in">std</span>::move(up1))</span></span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="在函数中的使用"><a href="#在函数中的使用" class="headerlink" title="在函数中的使用"></a>在函数中的使用</h4><p>还记得在《<a href="https://www.yanbinghu.com/2019/06/20/53981.html">传值和传指针有什么区别？</a>》讲的吗？既然unique_ptr独享对象，那么就无法直接作为参数，应该怎么办呢？</p>
<h4 id="作为参数"><a href="#作为参数" class="headerlink" title="作为参数"></a>作为参数</h4><p>如果函数以unique_ptr作为参数呢？如果像下面这样直接把unique_ptr作为参数肯定就报错了，因为它不允许被复制：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *p = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line">    test(up);<span class="comment">//试图传入unique_ptr，编译报错</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;*up&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码编译将直接报错。</p>
<p>当然我们可以向函数中传递普通指针，使用get函数就可以获取，如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *p = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line">    test(up.get());<span class="comment">//传入裸指针作为参数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;*up&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//输出10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者使用引用作为参数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *p = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line">    test(up);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;*up&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//输出10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然如果<strong>外部不再需要使用</strong>了，那么你完全可以转移，将对象交给你调用的函数管理，这里可以使用move函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *p = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line">    test(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt;(up.release()));</span><br><span class="line">    <span class="comment">//test(std::move(up));//这种方式也可以</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="作为返回值"><a href="#作为返回值" class="headerlink" title="作为返回值"></a>作为返回值</h4><p>unique_ptr可以作为参数返回：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">test</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="keyword">int</span>(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up = test(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//std::shared_ptr&lt;int&gt; up = test(10);</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;*up&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你还可以把unique_ptr转换为shared_ptr使用，如注释行所示。</p>
<h2 id="为什么优先选用unique-ptr"><a href="#为什么优先选用unique-ptr" class="headerlink" title="为什么优先选用unique_ptr"></a>为什么优先选用unique_ptr</h2><p>回到标题的问题，问什么优先选用unique_ptr。</p>
<ul>
<li>避免内存泄露</li>
<li>避免更大开销</li>
</ul>
<p>第一点相信很好理解，自动管理，不需要时即释放，甚至可以防止下面这样的情况：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1111</span>);</span><br><span class="line"><span class="comment">/*do something*/</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure></p>
<p>如果在do something的时候，出现了异常，退出了，那delete就永远没有执行的机会，就会造成内存泄露，而如果使用unique_ptr就不会有这样的困扰了。</p>
<p>第二点为何这么说？因为相比于shared_ptr，它的开销更小，甚至可以说和裸指针相当，它不需要维护引用计数的原子操作等等。</p>
<p>所以说，如果有可能，优先选用unique_ptr。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了unique<em>ptr的基本使用情况和使用场景，它能够有效地避免内存泄露并且效率可控，因此如果能够满足需求，则优先选择unique</em>\ptr。</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11关键字-auto</title>
    <url>/2019/11/07/4818.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>你以为我说的自动变量类型auto吗？非也，我们知道C语言中其实也有auto关键字，它和早期C++中的auto关键字一样，它修饰局部变量，表示自动存储期（更多内容也可以阅读《<a href="https://www.yanbinghu.com/2019/05/08/43402.html">全局变量，静态全局变量，局部变量，静态局部变量</a>》）不过由于默认就是这种，因此我们其实常常见不到这样的写法：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> <span class="keyword">int</span> a =<span class="number">10</span>;</span><br></pre></td></tr></table></figure></p>
<p>本文要介绍的并不是上面的auto，而是C++11中引入的auto关键字。<br><a id="more"></a></p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>看看下面的代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = vec.begin();it != vec.end();++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于it的类型，你自己能快速写出来吗？我反正是写不出来。</p>
<p>再看auto版本：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;int&gt; vec&#123;1,2,3,4,5&#125;;</span><br><span class="line">    for(auto it = vec.begin();it != vec.end();++it)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;*it&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>是不是简洁了许多？</p>
<p>没错，今天就是介绍自动类型推导关键字auto。</p>
<h2 id="auto的作用"><a href="#auto的作用" class="headerlink" title="auto的作用"></a>auto的作用</h2><p>说实在的，程序员有时候就是“懒”，可能连个表达式的类型都不想写，auto就是这样一个关键字，它让编译器替我们去分析表达式的类型。</p>
<p>当然了，分析的前提是auto定义的变量有初值，如果连值都没有，怎么可能知道它是什么类型？</p>
<h2 id="auto用法"><a href="#auto用法" class="headerlink" title="auto用法"></a>auto用法</h2><h4 id="普通类型推导"><a href="#普通类型推导" class="headerlink" title="普通类型推导"></a>普通类型推导</h4><p>例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto i = 10;//i为int类型</span><br><span class="line">auto d = 10.2//d 为double类型</span><br><span class="line">auto f = 10.2f//f为float类型</span><br></pre></td></tr></table></figure></p>
<h4 id="const关键字修饰的类型推导"><a href="#const关键字修饰的类型推导" class="headerlink" title="const关键字修饰的类型推导"></a>const关键字修饰的类型推导</h4><p>通常auto会忽略掉顶层const（本身是常量，如int *cosnt p），而会保留底层const（指向的对象是常量，如const int* p）。关于const的更多内容可以参考《》<br>举个例子顶层const的例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int ci = 10;</span><br><span class="line">auto aci = ci;//忽略顶层const，推导ci是int，所以aci类型是int</span><br><span class="line">const auto ca = ci//推导ci是int，但是前面有const，所以ca是const int</span><br></pre></td></tr></table></figure></p>
<p>再说一个底层const的例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int arr[] = &#123;11&#125;;</span><br><span class="line">auto p = arr;//arr 是const int *,这是底层const，推导后，保留底层const，所以p是 const int*</span><br></pre></td></tr></table></figure></p>
<p>arr数组名被当成指针是，是const int*类型，或者说是int const*，它指向的对象是只读的，因此是底层const，保留，最终p的类型也是int const *。</p>
<p>当然auto还可以设置引用类型，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int ci = 10;</span><br><span class="line">auto &amp;cp = ci;//cp是一个整型常量引</span><br></pre></td></tr></table></figure></p>
<p>如果是字面值，则必须加上const：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const auto &amp;ref = 10;//10是字面值，常量引用才能绑定字面值</span><br></pre></td></tr></table></figure></p>
<h2 id="想一想"><a href="#想一想" class="headerlink" title="想一想"></a>想一想</h2><p>想想下面推导的size类型是什么？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">std::vector&lt;int&gt; vec;</span><br><span class="line">auto size = vec.size();</span><br></pre></td></tr></table></figure></p>
<p>没错，它是std::vector<int>::size_type。<br>要你写下来你肯定不愿意。</int></p>
<p>下面这段程序帮你查看真正类型的名称，<strong>仅供参考</strong>：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cxxabi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>     status;</span><br><span class="line">    <span class="keyword">char</span>   *realname;</span><br><span class="line">    <span class="keyword">auto</span> type = <span class="number">1.1</span>;</span><br><span class="line">    realname = abi::__cxa_demangle(<span class="keyword">typeid</span>(type).name(), <span class="number">0</span>, <span class="number">0</span>, &amp;status);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(type).name() &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; realname &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">free</span>(realname);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>乍一看，好像挺简单的那么一回事，不过使用auto最好注意类型推导规则，不是很明确的规则不建议以代码可读性为代价而简化代码。</p>
<p>当然了，它也有以下特点：</p>
<ul>
<li>可能使得代码可读性差</li>
<li>某些情况auto得到的类型可能不是你想要的</li>
</ul>
<p>因此一定要合理使用。</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>拥抱智能指针，告别内存泄露</title>
    <url>/2019/11/05/17350.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们都知道，当申请的内存在不用时忘记释放，导致内存泄漏。长期来看，内存泄漏的危害是巨大的，它导致可用内存越来越少，甚至拖慢系统，最终进程可能被OOM（out of memory）机制杀死。<br><a id="more"></a></p>
<h2 id="C与C-中的内存泄漏"><a href="#C与C-中的内存泄漏" class="headerlink" title="C与C++中的内存泄漏"></a>C与C++中的内存泄漏</h2><p>在C语言中，我们用malloc申请内存，free释放内存；在C++中，也可以使用它们，不过对于自定义类型，常常会使用new申请，delete来释放。它们都有同样的问题，一旦申请了，但是忘了释放，就会造成内存泄漏，而已经释放了又仍然去访问它，则造成更加直接的严重后果。<br>一个简单的例子：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="built_in">malloc</span>(<span class="number">1024</span>);</span><br><span class="line">        <span class="built_in">snprintf</span>(p,<span class="number">1024</span>,<span class="string">"%6d\n"</span>,i);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个很明显的内存泄漏的例子，malloc申请内存后，从来没有释放过，编译运行一段时间后，可能被直接被kill。有兴趣也可以通过top命令观察其内存变化。</p>
<p>也就是说，C/C++中自己用的内存，要自己记得还回去。</p>
<p>而即便有的时候，你记得delete了，但是中间出现异常，导致delete没法执行，同样导致内存泄漏，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test test = new Test();</span><br><span class="line">/*do some thing*/</span><br><span class="line">delete test;</span><br></pre></td></tr></table></figure></p>
<p>如果在执行某些操作的时候抛出异常，就可能导致delete无法执行到，从而导致内存泄漏。</p>
<h2 id="Java程序员的幸福"><a href="#Java程序员的幸福" class="headerlink" title="Java程序员的幸福"></a>Java程序员的幸福</h2><p>Java程序运行在Java虚拟机上，它有一套垃圾回收（GC）机制，它会定期地回收那些不再被使用的内存，可以有效的防止内存泄露（但不能避免，Java中同样存在内存泄漏）。</p>
<p>但是另外一方面，由于垃圾回收并不是立即的，时机也不是确定的，同时回收机制本身可能比较复杂，会占用空间和时间开销，毕竟C/C++注重效率。</p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>为了既能最大程度的避免内存泄漏又能兼顾效率，C++11标准引入了智能指针shared_ptr和unique_ptr。</p>
<p>本文不详细介绍它们的用法，本文旨在通俗地说明它的场景，帮助你理解。</p>
<h4 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h4><p>通常来说，动态申请了一片内存之后，可能会在多个地方会用到，对于裸指针，你需要自己记住在什么地方释放内存，不能在有别的地方还在使用的时候，你就释放，也不能忘记释放。如果是这样，为什么不在有人用的时候，就增加引用计数，而不用的时候（离开作用域或者生命周期外）就较少引用计数呢，如果引用计数为0，则自动释放内存。</p>
<p>举个通俗的例子，假设一个房间里有自动感应灯光。有人在的时候，灯亮了（申请使用内存），再来一个人，这个灯还是亮着，人数增加，而这两个人走掉的时候，房间空了，感应不到人（引用计数为0）的时候，灯就可以自动灭了（自动释放内存），这样也就最大程度地利用了灯光。</p>
<p>不过它的实现要考虑的因素很多，例如如何原子地增加引用计数。所以它在一定程度上比裸指针开销要大。</p>
<h4 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h4><p>与shared_ptr不同，unique_ptr专属某个对象资源。也就是说，如果某个对象有一个专属管理，它不能被复制，那么当这个专属管理不再使用的时候，就可以自动释放内存了。</p>
<p>同样一个通俗的例子，我们现在在很多洗手间都可以看到自动感应的水龙头，一个水龙头通常只供一个人使用（申请并占用资源），而当这个人离开的时候，水龙头自动关闭（自动释放内存）。</p>
<p>而对于老式的水龙头，一旦忘了关了（好像一般也不会忘），就会一直浪费水。</p>
<h4 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h4><p>还有一种情况，对于某些对象，如它可能作为缓存。它有的时候，我就用一下，没有的时候就不用，也不负责去管理资源的释放资源，岂不美哉？</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C++新引入的智能指针在使用得当的情况下，可告别内存泄漏。具体用法，我们在后面的文章进行介绍。</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux自主安装C++man手册</title>
    <url>/2019/11/03/59238.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Linux编写或者编译C代码的时候，直接使用man命令就可以查看该函数的使用手册，非常方便，如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">man 3 sleep</span><br></pre></td></tr></table></figure></p>
<p>但是一般却没有C++的函数手册，怎么把C++的帮助手册也装在机器上呢？</p>
<p>本文借助C++手册的安装，说明如何自助安装man手册。<br><a id="more"></a></p>
<h2 id="man原理"><a href="#man原理" class="headerlink" title="man原理"></a>man原理</h2><p>如果你还不习惯使用man命令或者不清楚man命令的作用，那么建议你先看看这篇《<a href="https://www.yanbinghu.com/2018/12/04/41455.html">速查手册-man</a>》。</p>
<h2 id="安装C-手册"><a href="#安装C-手册" class="headerlink" title="安装C++手册"></a>安装C++手册</h2><p>主要步骤如下：</p>
<ul>
<li>下载手册</li>
<li>安装手册</li>
<li>使用手册</li>
</ul>
<h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>安装的第一步自然是先下载手册。<br>可以先进入下面一个镜像网站：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://gcc.gnu.org/mirrors.html</span><br></pre></td></tr></table></figure></p>
<p>进入之后发现有很多站点，随意进入一个，假设进入：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://mirror.linux-ia64.org/gnu/gcc</span><br></pre></td></tr></table></figure></p>
<p>找到libstdc++/doxygen，即可选择下载你需要的手册。注意选择带有man的压缩包，如我选择下载的是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">libstdc++-api.20140403.man.tar.bz2</span><br></pre></td></tr></table></figure></p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>所谓安装也不过是将下载好的手册文件解压到指定位置。还记得在《<a href="https://www.yanbinghu.com/2018/12/04/41455.html">速查手册-man</a>》介绍各个手册的区别吗？由于我们的是库函数手册，因此最好把它放在3处。</p>
<p>于是，我们解压：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tar -xvf libstdc++-api.20140403.man.tar.bz2</span><br></pre></td></tr></table></figure></p>
<p>解压后的文件会在libstdc++-api.20140403.man下，为了避免和其他的手册文件混在一起，我们重新创建一个目录：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir -p /usr/local/cpp/man  #可能需要root权限执行</span><br></pre></td></tr></table></figure></p>
<p>此时将其拷贝到上面的目录下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cp -rf ./libstdc++-api.20140403.man/man3 /usr/local/cpp/man/</span><br></pre></td></tr></table></figure></p>
<p>但是我们发现此时仍然找不到手册：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ man std::cout</span><br><span class="line">No manual entry for std::cout</span><br></pre></td></tr></table></figure></p>
<p>原因也很简单，这和我们执行普通命令类似（参考《<a href="https://www.yanbinghu.com/2019/10/07/14442.html">为什么执行</a>》），那我们在哪里添加的呢？<br>我们可以通过man命令查看man手册的FILES部分：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ man man</span><br><span class="line">FILES</span><br><span class="line">       /etc/man_db.conf</span><br><span class="line">              man-db configuration file.</span><br></pre></td></tr></table></figure></p>
<p>所以对于我的机器来说，我需要在/etc/man_db.conf中添加路径<br>找到MANDATORY_MANPATH相关行，添加新行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MANDATORY_MANPATH           /usr/local/cpp/man</span><br></pre></td></tr></table></figure></p>
<p>这样就可以了。</p>
<p>我们来试一下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ man std::count</span><br><span class="line">No manual entry for std::count</span><br></pre></td></tr></table></figure></p>
<p>为什么还是没有呢？，你查看一下/usr/local/cpp/man/man3下的文件都是什么名字就明白了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls /usr/local/cpp/man/man3/* |more</span><br><span class="line">std::iostream.3</span><br></pre></td></tr></table></figure></p>
<p>原来还要带上命名空间和头文件的名字，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ man std::map</span><br></pre></td></tr></table></figure></p>
<p>然后再使用搜索功能：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ /size()</span><br></pre></td></tr></table></figure></p>
<p>看起来好像也没那么方便啊……<br>这里说明一下，C++中有命名空间的概念，包括不同的类中可能有相同名称的成员函数，因此直接查看某个函数的手册，也是很难准确找到的。</p>
<p>突然觉得下载一个html或者pdf的手册好像也挺方便的了，可自行体验。</p>
<h2 id="在线手册"><a href="#在线手册" class="headerlink" title="在线手册"></a>在线手册</h2><p>在线手册的好处就是，它能比较清晰地看到各个版本的C++相关特性。这里主要推荐两个<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://en.cppreference.com/ 英文</span><br><span class="line">https://zh.cppreference.com/ 中文</span><br><span class="line">www.cplusplus.com</span><br></pre></td></tr></table></figure></p>
<p>从中搜索就可以啦。</p>
<p>对于linux命令和C库函数，基本使用man进行查看，但是对于C++,不管你用不用，反正我是用在线的。</p>
<p>当然了，如果你使用chrome浏览器的话，还可以配置一下，地址栏输入C即可直接搜索。</p>
<p>设置方法：<br>找到设置-管理搜索引擎，添加内容</p>
<p>中文版：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://zh.cppreference.com/mwiki/index.php?title=Special:%E6%90%9C%E7%B4%A2&amp;search=%s</span><br></pre></td></tr></table></figure></p>
<p>英文版：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://en.cppreference.com/mwiki/index.php?title=Special:Search&amp;search=%s</span><br></pre></td></tr></table></figure></p>
<p>添加内容如下图：<br><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E5%AE%89%E8%A3%85man%E6%89%8B%E5%86%8C/1.jpg" alt></p>
<p>如果你已经在这两个网站搜索过，你还可以在其他搜索引擎中看到这样的内容：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E5%AE%89%E8%A3%85man%E6%89%8B%E5%86%8C/3.jpg" alt></p>
<p>这个时候你只需要编辑里面的关键字，设置成自己喜欢的就可以了，如C。</p>
<p>添加之后，在chrome地址栏输入c，按tab键，即可出现：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E5%AE%89%E8%A3%85man%E6%89%8B%E5%86%8C/2.jpg" alt></p>
<h2 id="手边手册"><a href="#手边手册" class="headerlink" title="手边手册"></a>手边手册</h2><p>要么就是买一本大头手册《C++标准库》。</p>
<p>当然也可以在公众号【编程珠玑】后台回复【C++标准库】获取电子版，仅供学习交流。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文旨在引导如何自助安装手册，其步骤也简洁明了：</p>
<ul>
<li>下载手册</li>
<li>解压手册</li>
<li>放到特定位置</li>
<li>让man能够找到</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的const与C中的const有何差别？</title>
    <url>/2019/10/31/51504.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在《<a href="https://www.yanbinghu.com/2019/01/28/7442.html">cosnt关键字到底该怎么用</a>》一文中介绍了C语言中的const关键字，本文说说C++中的const关键字，它的大部分特点和C语言中的类似，所以本文主要针对不同之处。<br><a id="more"></a></p>
<h2 id="修饰普通变量—只读"><a href="#修饰普通变量—只读" class="headerlink" title="修饰普通变量—只读"></a>修饰普通变量—只读</h2><p>在C语言，虽然表面是不允许被修改，但是看下面的代码：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">    *p = <span class="number">11</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d\n"</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它的输出结果是<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a=11</span><br></pre></td></tr></table></figure></p>
<p>所以C语言里，表面上它是只读的，然而你违规操作仍然能改变。但是，千万不要写这样的代码！！！另外它们的作用也是一样的，​声明一个只读变量，不希望被修改，一旦被修改，编译器将会报错。​</p>
<p>与C语言中const关键字不同的是，C++中使用const关键字定义的b变量的值在被改变时会被检测。<br>看一个例子就明白了：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">    *p = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译报错如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main.cpp: In function ‘int main()’:</span><br><span class="line">main.cpp:5:14: error: invalid conversion from ‘const int*’ to ‘int*’ [-fpermissive]</span><br><span class="line">     int *p = &amp;a;</span><br></pre></td></tr></table></figure></p>
<p>再次强调：在实际中千万不要写这样的代码，这里只是为了说明问题。</p>
<p>我们常常看到传递const char*参数，像这样：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test(const char* str);</span><br></pre></td></tr></table></figure></p>
<p>却似乎从来没有见到过const int作为参数的函数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test(const int val);</span><br></pre></td></tr></table></figure></p>
<p>为何？因为前者传递指针的副本，指针指向不会被改变，但可以改变指向的内容；但是int类型参数，它也是传递副本，但是永远不会被函数改变，自然也没有必要加const。更多解释可以参考《<a href="https://www.yanbinghu.com/2019/06/20/53981.html">传值和传指针</a>》。</p>
<p>同样的，修饰函数返回值时，修饰内置类型与不加const修饰是一样的，但对于自定义类型，不能对返回值进行修改，即返回的是常量。</p>
<h2 id="作用在成员函数-不改变成员变量"><a href="#作用在成员函数-不改变成员变量" class="headerlink" title="作用在成员函数-不改变成员变量"></a>作用在成员函数-不改变成员变量</h2><p>举个例子：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        a = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    test.printA();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类test中有一个成员变量a，并且有一个成员函数printA，现在假设你的设计是printA函数不会改变任何成员变量，那么你可以在printA函数后加上const关键字，这样一旦函内部尝试修改成员变量，都会报错：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main.cpp: In member function ‘void Test::printA() const’:</span><br><span class="line">main.cpp:9:13: error: assignment of member ‘Test::a’ in read-only object</span><br><span class="line">         a = 10;</span><br></pre></td></tr></table></figure></p>
<p>正因如此，const修饰成员函数不与static关键字同用，因为static修饰的静态成员函数不能实例化，也就没有实例的成员变量一说，自然不存在修改成员变量。<br>即下面的声明是非法的：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="修饰类成员变量—构造函数中初始化"><a href="#修饰类成员变量—构造函数中初始化" class="headerlink" title="修饰类成员变量—构造函数中初始化"></a>修饰类成员变量—构造函数中初始化</h2><p>与修饰普通变量不同的是，修饰类成员变量还可以在构造函数中初始化。如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test(<span class="keyword">int</span> val):a(val)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">test</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="修饰引用"><a href="#修饰引用" class="headerlink" title="修饰引用"></a>修饰引用</h2><p>例如，有一个常量<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int a = 10;</span><br></pre></td></tr></table></figure></p>
<p>你不能再这样定义它的引用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int &amp;ref = a;</span><br></pre></td></tr></table></figure></p>
<p>而需要定义对常量的引用，即：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int &amp;ref = a;</span><br></pre></td></tr></table></figure></p>
<p>为什么呢？因为不能直接为a赋值，也不能间接赋值，所以自然不能定义普通引用去间接改变它。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于const关键字在C和C++中的区别，想必到这里你已经清楚了。</p>
<p>如果你对下面的问题还不清楚，建议阅读《<a href="https://www.yanbinghu.com/2019/01/28/7442.html">cosnt关键字到底该怎么用</a>》</p>
<p>你能分清下面的声明区别吗？<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p; </span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * <span class="keyword">const</span> p;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊对Python的看法</title>
    <url>/2019/10/27/11092.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近年来以及最近想必大家总能看到Python的身影，</p>
<p>有的是频繁报道Python制霸编程语言排行榜，有的是总能看到各种Python的培训课程，作为主要使用其他语言的你，恐怕心里很难不会有悸动。那么应该如何看到Python？<br><a id="more"></a></p>
<h2 id="说说排行榜"><a href="#说说排行榜" class="headerlink" title="说说排行榜"></a>说说排行榜</h2><p>TIOBE 编程语言排行榜说明的是编程语言的流行程度，它主要根据搜索引擎中被搜索的频次来进行排名。<br>近几年排名如下：<br><a href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="noopener">https://www.tiobe.com/tiobe-index/</a></p>
<p>个人感觉有点像高考报名大家都说哪个专业火差不多，主要突出的是某种语言的“火热”程度，而非好与不好。近年来，Python的排名确实不断上升，但你是否该学习它，肯定不是看这个排名，所以不要被这个排名忽悠，而要看看它的什么特点让它如此火热，它的这些特点能否吸引你？</p>
<h2 id="Python应用领域"><a href="#Python应用领域" class="headerlink" title="Python应用领域"></a>Python应用领域</h2><p>通常一门语言都有它“擅长”的领域，选择合适的工具做适合它的事情是非常重要的。<br>可以说的Python的特点很多，比如：</p>
<ul>
<li>简单容易上手—提升学习开发效率</li>
<li>丰富的库—更大程度避免重复造轮子</li>
<li>跨平台</li>
</ul>
<p>而由于这些特点，它通常在应用在以下领域：</p>
<ul>
<li>网络爬虫</li>
<li>人工智能</li>
<li>web开发</li>
<li>系统运维</li>
<li>自动化测试</li>
<li>数据分析</li>
<li>云计算</li>
<li>…</li>
</ul>
<p>这些领域，如爬虫，人工智能，web开发用其他语言可不可以？完全可以，但是Python有着极高的开发效率以及丰富的库支持，你只需要专注你的事情本身即可。</p>
<p>但是人工智能，云计算等底层用的是什么？有效率问题时，用的又是什么？高并发的时候用的是什么？不过话又说回来，你有多少时候需要考虑这些呢？</p>
<p>总归一句话，每一种语言有它适合的领域，另外也和公司本身的技术积累有关。</p>
<h2 id="要不要学Python"><a href="#要不要学Python" class="headerlink" title="要不要学Python"></a>要不要学Python</h2><p>当然要！无论你是嵌入式还是后台开发，个人认为Python都是值得学的，即使你是非开发类工作，也建议你学一学。</p>
<p>写一个小工具使用Python会比你使用C/C++快得多。而Python也可以快速帮你处理各种繁琐的数据。</p>
<p>记得刚去公司的时候，部门里用Python的极少，但是慢慢地，几乎组里每个人都用Python做一些事情，当然不是因为事情杂，而是它在做一些小工具或者做一些自动化测试的时候非常方便。</p>
<h2 id="学什么语言好"><a href="#学什么语言好" class="headerlink" title="学什么语言好"></a>学什么语言好</h2><p>我觉得问这个问题之前，先定义什么叫好？学起来简单，容易上手，工作好找，钱还多叫好？我也想知道。所以当有人强调Python多么火，又是多么简单，工作多么高薪的时候，你一定要先喝杯凉水冷静一下。</p>
<p><strong>不过某种语言处于时代的浪潮，行业的浪潮还是有可能的，但是又有多少人能预测到浪潮的到来，又真的能站在浪潮之巅呢</strong>？</p>
<p>所以这个问题我也不知道，不过我觉得可以从以下几个方面考虑：</p>
<ul>
<li>准备进入的行业，金融？通信？电商？</li>
<li>了解语言的适用场景，如底层开发，后台，web开发，大数据等等</li>
<li>了解语言的特点，如上手难易程度</li>
<li>了解自身的基础情况，如是科班还是非科班，基础如何？</li>
<li>岗位的需求量</li>
<li>岗位的需求难度</li>
</ul>
<p>作为一个<strong>普通人</strong>，那种既简单轻松，又有高回报的，想想就好了，想到了也告诉我们。</p>
<p>实际上上面这些就像计算机中经常见到的时间换空间或者空间换时间，有时候就是两难全。</p>
<p>对于我个人来说，如果让我大学时重新来一次，大概会更加关注操作系统，基本算法，计算机网络等内容，而不倾向于某种具体语言。</p>
<p>而如果说非要加一门语言，那么也是基于C/C++，而非其他语言，因为C/C++似乎和这些基本原理更“亲”。</p>
<h2 id="怎么学"><a href="#怎么学" class="headerlink" title="怎么学"></a>怎么学</h2><p>已会其他语言，相信你已经知道该如何学习了。这里有一个简明Python教程，适合快速浏览语法。地址：<a href="https://bop.mol.uno/" target="_blank" rel="noopener">https://bop.mol.uno/</a></p>
<p>对于纯小白，想用Python提高工作效率的，可以看看《python编程快速上手 让繁琐工作自动化》这本书，里面讲解非常细致到位，当然也可以根据自己的情况通过视频教程或者培训课程进行学习。</p>
<p>这里作为一个Python小白，就不多说，欢迎学习Python的朋友补充。</p>
<h2 id="语言只是其中的一部分"><a href="#语言只是其中的一部分" class="headerlink" title="语言只是其中的一部分"></a>语言只是其中的一部分</h2><p>语言的使用虽然是工作中关键的部分，但却是很小的一部分，尤其是当你已经熟悉语言本身之后，你的瓶颈可能不是语言本身，而是像网络，操作系统等基本问题和设计模式，方法论等更进一步的内容。</p>
<p>但是不建议：</p>
<ul>
<li>什么都会，但没有一门熟悉的语言</li>
<li>只专注语言本身</li>
<li>只接触一种语言</li>
</ul>
<p>记得别忘了你的主用语言修炼，如C,C++。</p>
<h2 id="不局限于技术"><a href="#不局限于技术" class="headerlink" title="不局限于技术"></a>不局限于技术</h2><p>作为一个技术人，很多时候对技术过于执着而忽略了其它方面的扩展，自己就是如此，其实多接触其它方面，多与人交流，能扩展自己的思维，一定程度上对自己技术之路也是有帮助的。这方面自己做得不太好，与君共勉吧。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>反正也是随便说说，回头看一下，好像有点乱了，按照习惯，还是总结一下吧。</p>
<ul>
<li>Python值得位开发者学习，快速上手，提高效率</li>
<li>了解语言的基本特点和其使用场景</li>
<li>内心不要拒绝其他语言</li>
<li>不要觉得XXX就是好</li>
<li>不过当我用学C++的时候，真实感受到，C语言果然简洁！</li>
<li>人生苦短</li>
</ul>
<p>以上是一个普通的Linux/C/C++开发者的看法，鉴于经验以及见识有限，以上均为个人观点，不供参考，欢迎留言分享自己的观点。</p>
]]></content>
      <categories>
        <category>程序员</category>
      </categories>
      <tags>
        <tag>程序员</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux终止进程的N中方式</title>
    <url>/2019/10/22/19713.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>你是如何终止你的程序的？在《<a href="https://www.yanbinghu.com/2019/10/20/1802.html">killall为什么找不到你的进程</a>》一文中提到了几个杀死进程的方法，本文来总结一下有哪些方法可以终止进程。<br><a id="more"></a></p>
<h2 id="ctrl-c"><a href="#ctrl-c" class="headerlink" title="ctrl+c"></a>ctrl+c</h2><p>没错，这应该是你最常用到的方法了，当前终端非后台运行一个程序后，使用ctrl+c<br>即可终止当前程序。</p>
<h2 id="ctrl-z"><a href="#ctrl-z" class="headerlink" title="ctrl+z"></a>ctrl+z</h2><p>这种方式不算完全终止，更像是暂停，因为它可以通过fg或者bg继续执行。<br>举个例子，代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行到一定程序后，按下ctrl+z：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o test test.c</span><br><span class="line">$ ./test</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">^Z</span><br><span class="line">[1]+  Stopped                 ./hello</span><br><span class="line">root@ubuntu16:c$ fg</span><br><span class="line">./hello</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">root@ubuntu16:c$</span><br></pre></td></tr></table></figure></p>
<p>在ctrl+z之后，再输入fg或者bg，你会发现它接着上次的地方继续运行。</p>
<h2 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h2><p>这是最常见也是最常用的了，虽然它名为kill，但实际上它可以给进程发送各种类型的信号，其中信号9就是比较常用的，即用来终止进程。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kill -9 pid</span><br></pre></td></tr></table></figure></p>
<p>kill用于给进程发信号，上面的命令表示给进程id为pid的程序发送9信号。<br>常见信号如下：</p>
<ul>
<li>HUP     1    终端断线</li>
<li>INT       2    中断（同 Ctrl + C）</li>
<li>QUIT    3    退出（同 Ctrl + \）</li>
<li>TERM    15    终止</li>
<li>KILL      9    强制终止</li>
<li>CONT   18    继续（与STOP相反， fg/bg命令）</li>
</ul>
<p>可以看到信号KILL就是强制终止程序。</p>
<p>你也可以通过这样来查看这些数字的意义：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kill -l 9</span><br><span class="line">KILL</span><br><span class="line">$ kill -l</span><br><span class="line"> 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP</span><br><span class="line"> 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1</span><br><span class="line">11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM</span><br></pre></td></tr></table></figure></p>
<h2 id="killall"><a href="#killall" class="headerlink" title="killall"></a>killall</h2><p>killall进程杀死进程，它在某些情况下会失效，具体可以参考《<a href="https://www.yanbinghu.com/2019/10/20/1802.html">killall为什么找不到你的进程</a>》<br>它还支持杀死一定时间的进程，例如杀死运行超过30分钟的hello进程：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ killall -o 30m hello</span><br></pre></td></tr></table></figure></p>
<p>其中-o表示older-than，当然你还可以用-y，表示yonger-than。<br>m表示分钟，还有其他的时间刻度：</p>
<ul>
<li>s    秒</li>
<li>m    分钟</li>
<li>h    小时</li>
<li>d    天</li>
<li>w    周</li>
<li>M    月</li>
<li>y    年</li>
</ul>
<p>它除了可以根据名字还可以根据正则表达式来杀死进程。使用-r参数即可。</p>
<h2 id="pkill"><a href="#pkill" class="headerlink" title="pkill"></a>pkill</h2><p>pkill也可以根据进程名杀死进程，它和killall有点类似。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pkill hello</span><br></pre></td></tr></table></figure></p>
<p>由于你可能起了多个hello程序，所以为了杀死最旧的进程，你可以这样做：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pkill -o hello #oldest</span><br></pre></td></tr></table></figure></p>
<p>或者杀死最新的进程：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pkill -n hello #newest</span><br></pre></td></tr></table></figure></p>
<p>或者计算运行的hello程序的数量：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pkill -c hello</span><br></pre></td></tr></table></figure></p>
<h2 id="如何查找进程id"><a href="#如何查找进程id" class="headerlink" title="如何查找进程id"></a>如何查找进程id</h2><p>上面提到的有些命令需要根据pid进行操作，如何获取pid呢？也有几种常见的方法。</p>
<h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>这是最常见的的了，可以参考《<a href="https://www.yanbinghu.com/2018/04/06/53515.html">ps命令实例详解</a>》</p>
<h4 id="pidof"><a href="#pidof" class="headerlink" title="pidof"></a>pidof</h4><p>pidof可以直接获取某个进程的进程id，也比较准确：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pidof hello</span><br><span class="line">7584</span><br></pre></td></tr></table></figure></p>
<p>结合kill可以这样用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kill -9 `pidof hello`</span><br></pre></td></tr></table></figure></p>
<p>是不是一气呵成？ </p>
<h4 id="pgrep"><a href="#pgrep" class="headerlink" title="pgrep"></a>pgrep</h4><p>它同样可以通过名字直接获取到进程id：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pgrep hello</span><br><span class="line">19971</span><br><span class="line">24770</span><br></pre></td></tr></table></figure></p>
<h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>top 的结果中也可以看到各个进程的进程id。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文仅对一些常见终止进程方式进行简单介绍，更多用法可以参考对应手册。<br>但是这些操作都有着同样的本质，那就是给进程发送信号，而进程通常对这个信号的处理是终止程序或者被迫终止。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么有时候killall找不到进程？</title>
    <url>/2019/10/20/1802.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Linux下有很多命令用于杀死进程，它们可以用于不同的场景，例如通过进程名杀死进程，通过pid杀死进程。这些方法我不准备一一列举，本文想说明的一个问题是，为什么明明通过ps找到了进程，但是通过killall却说找不到呢？你说你没有遇到过这样的问题？那你更要注意了！<br><a id="more"></a></p>
<h2 id="killall简介"><a href="#killall简介" class="headerlink" title="killall简介"></a>killall简介</h2><p>与kill不同的是，killall可以根据进程名来杀死进程，不像kill，可能先需要使用ps（可以参考《<a href="https://www.yanbinghu.com/2018/04/06/53515.html">ps命令实例详解</a>》）找到进程id，然后发送信号，就像下面这样：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ps -ef|grep hello</span><br><span class="line">root      15530  6335  0 14:55 pts/4    00:00:00 ./hello</span><br><span class="line">$ kill -9 15530</span><br></pre></td></tr></table></figure></p>
<p>这样进程就被我们杀死了，我们可以直接使用killall：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ killall hello</span><br></pre></td></tr></table></figure></p>
<p>是不是觉得方便多了？</p>
<p>而且由于killall是根据名称杀死进程，因此如果当前运行着大量的hello程序，那么可以一次性杀死所有hello程序。</p>
<p>除此之外，它还有很多参数，例如忽略大小写，根据模式匹配进程名，杀死某个时间的进程等等，这里就不详解介绍了，有兴趣的可以查看man killall手册。</p>
<p>今天这里想要说明的是一种killall失效的情况。</p>
<h2 id="killall失效了？"><a href="#killall失效了？" class="headerlink" title="killall失效了？"></a>killall失效了？</h2><p>我写了一个自己的hello程序，然后尝试使用killall杀死正在运行的hello程序。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$  killall hello</span><br><span class="line">hello: no process found</span><br></pre></td></tr></table></figure></p>
<p>什么？竟然说找不到？一个ps丢过来：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ps -ef|grep hello</span><br><span class="line">root      15765  6335  0 15:05 pts/4    00:00:00 ./hello</span><br></pre></td></tr></table></figure></p>
<p>所以killall你到底行不行？</p>
<h2 id="为何"><a href="#为何" class="headerlink" title="为何"></a>为何</h2><p>为了找出killall失效的原因，我们必须知道它到底是如何通过进程名找到进程的。<br>这个时候就需要祭出我们的神器strace了，看看killall杀死一个普通进程到底做了哪些事情：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ strace killall hello</span><br><span class="line">open(&quot;/proc/100/cmdline&quot;, O_RDONLY)     = 3</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0444, st_size=0, ...&#125;) = 0</span><br><span class="line">read(3, &quot;&quot;, 1024)                       = 0</span><br><span class="line">close(3)                                = 0</span><br><span class="line">open(&quot;/proc/104/stat&quot;, O_RDONLY)        = 3</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0444, st_size=0, ...&#125;) = 0</span><br><span class="line">read(3, &quot;104 (ipv6_addrconf) I 2 0 0 0 -1&quot;..., 1024) = 161</span><br><span class="line">close(3)                                = 0</span><br><span class="line">open(&quot;/proc/113/stat&quot;, O_RDONLY)        = 3</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0444, st_size=0, ...&#125;) = 0</span><br><span class="line">read(3, &quot;113 (kstrp) I 2 0 0 0 -1 6923888&quot;..., 1024) = 153</span><br><span class="line">close(3)                                = 0</span><br><span class="line">open(&quot;/proc/137/stat&quot;, O_RDONLY)        = 3</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0444, st_size=0, ...&#125;) = 0</span><br><span class="line">read(3, &quot;137 (charger_manager) I 2 0 0 0 &quot;..., 1024) = 163</span><br><span class="line">close(3)                                = 0</span><br><span class="line">open(&quot;/proc/137/cmdline&quot;, O_RDONLY)     = 3</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0444, st_size=0, ...&#125;) = 0</span><br><span class="line">read(3, &quot;&quot;, 1024)                       = 0</span><br></pre></td></tr></table></figure></p>
<p>打印结果很多，我只提取了部分，可以看到的是，killall会去proc文件系统（proc文件系统可以参考《<a href="https://www.yanbinghu.com/2018/11/18/43716.html">Linux中不可错过的信息宝库</a>》）下查找各个进程id下的stat文件和cmdline，stat文件是怎样的呢？我们随便找一个看看：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat /proc/16131/stat </span><br><span class="line">16131 (hello) S 6335 16131 6335 34820 16131 1077936128 70 0 0 0 0 0 0 0 20 0 1 0 2465163 4321280 194 18446744073709551615 4194304 4196092 140734969955328 0 0 0 0 0 0 1 0 0 17 0 0 0 0 0 0 6295056 6295608 19099648 140734969962804 140734969962812 140734969962812 140734969966576 0</span><br></pre></td></tr></table></figure></p>
<p>我们不要被这么多内容吓到了，可以明显看到的是，里面有hello啊。至此我们可以猜测，killall命令会去读取进程在proc文件系统中的stat文件里的名字。那么如果这么名字和你要杀死的进程对不上不就找不到了吗？</p>
<p>至此，想必你已经明白前面问题的原因了。</p>
<h2 id="如何给自挖坑"><a href="#如何给自挖坑" class="headerlink" title="如何给自挖坑"></a>如何给自挖坑</h2><p>那么怎样修改stat中显示的名字呢？我们可以使用prcl函数，话不多少，直接看示例代码：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//作者：守望先生</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    prctl(PR_SET_NAME,<span class="string">"bianchengzhuji"</span>); </span><br><span class="line">    sleep(<span class="number">100</span>);<span class="comment">//防止进程立即退出，便于观察</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个时候再编译运行程序查看stat和status中的名字：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o hello hello.c</span><br><span class="line">$ cat /proc/pid/stat  #这里的pid换成示例的进程id</span><br><span class="line">16441 (bianchengzhuji) S 6335 16441 6335 34820 16441 1077936128 69 0 0 0 0 0 0 0 20 0 1 0 2535513 4321280 156 18446744073709551615 4194304 4196188 140724949606512 0 0 0 0 0 0 1 0 0 17 3 0 0 0 0 0 6295056 6295616 31719424 140724949614900 140724949614908 140724949614908 140724949618672 0</span><br><span class="line">$ more /proc/pid/status</span><br><span class="line">Name:	bianchengzhuji</span><br><span class="line">Umask:	0002</span><br><span class="line">State:	S (sleeping)</span><br><span class="line">Tgid:	16441</span><br><span class="line">Ngid:	0</span><br><span class="line">Pid:	16441</span><br><span class="line">PPid:	6335</span><br></pre></td></tr></table></figure></p>
<p>是不是发现名字变了呢？虽然进程名还是hello，但是killall已经找不到它了，不过：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ killall bianchengzhuji</span><br></pre></td></tr></table></figure></p>
<p>还是可以的。</p>
<p>为什么会出现这种情况呢？<br>想象一下，你们公司内部不想重复造轮子，搞了一套开发框架，main函数在框架里写好了，通过库的形式给你们使用，可能名字早就定好了。</p>
<p>但是，这里需要特别注意的是，<strong>如果名字超过了15个字符，在stat和status文件中看到的将会看到被截断的名字</strong>。</p>
<h2 id="玩点刺激的"><a href="#玩点刺激的" class="headerlink" title="玩点刺激的"></a>玩点刺激的</h2><p>既然看到这里了，不如再玩点刺激的。</p>
<p>看看下面的代码：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">strncpy</span>(argv[<span class="number">0</span>],<span class="string">"bianchengzhuji"</span>,<span class="keyword">sizeof</span>(<span class="string">"bianchengzhuji"</span>));</span><br><span class="line">    sleep(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>是不是发现和前面例子的main函数不一样？参考这里（《<a href="https://www.yanbinghu.com/2018/10/13/3168.html">C语言的main到底该怎么写</a>》）<br>这个时候你去编译运行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o hello hello.c</span><br><span class="line">$ ./hello</span><br></pre></td></tr></table></figure></p>
<p>然后尝试使用ps去查找进程：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ps -ef|grep hello</span><br><span class="line">root      17831 17818  0 16:09 pts/26   00:00:00 grep --color=auto hello</span><br></pre></td></tr></table></figure></p>
<p>然后你就会惊喜的发现找不到hello进程。<br>但是使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ps -ef|grep shouwangxiansheng</span><br><span class="line">root      17938  6335  0 16:12 pts/4    00:00:00 shouwangxiansheng</span><br><span class="line">root      17954 17924  0 16:12 pts/27   00:00:00 grep --color=auto shouwangxiansheng</span><br><span class="line">hyb@ub</span><br></pre></td></tr></table></figure></p>
<p>就可以找到。</p>
<p>这种情况下直接改变了程序的命令名，因此ps之类的找不到。<br>这个时候看命令名是什么呢？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat /proc/17938/cmdline</span><br><span class="line">shouwangxiansheng</span><br></pre></td></tr></table></figure></p>
<p>不过这个时候killall还是可以找到它！也就是你可以使用killall hello杀死它。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你发现你的程序无法通过killall 进程名的方式杀死的话，不妨看看proc文件系统中这个进程的stat文件或者status文件中的名。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux split拆分大文件</title>
    <url>/2019/10/16/47861.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>没设置好日志大小最大值，导致日志文件过大，普通编辑器根本没法打开或者特别卡，怎么办？拆分呗。<br><a id="more"></a></p>
<h2 id="如何拆分"><a href="#如何拆分" class="headerlink" title="如何拆分"></a>如何拆分</h2><p>split命令上场。</p>
<h4 id="按照行数拆分"><a href="#按照行数拆分" class="headerlink" title="按照行数拆分"></a>按照行数拆分</h4><p>假设文件test.txt有n多行，每2行拆分为一个文件，使用-l参数即可：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ split -l 2 test.txt </span><br><span class="line">$ ls -al</span><br><span class="line">-rw-r--r-- 1 root root 32 Aug 31 16:55 test.txt</span><br><span class="line">-rw-r--r-- 1 root root 20 Aug 31 16:55 xaa</span><br><span class="line">-rw-r--r-- 1 root root 12 Aug 31 16:55 xab</span><br></pre></td></tr></table></figure></p>
<p>仔细一看，拆分后的文件名难以描述啊。</p>
<p>能不能好好命名一下呢？</p>
<h4 id="规范命名"><a href="#规范命名" class="headerlink" title="规范命名"></a>规范命名</h4><p>使用-d参数可以用数字作为新的文件后缀：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ split -l 2 test.txt -d</span><br><span class="line">$ ls</span><br><span class="line">test.txt  x00  x01  x02</span><br></pre></td></tr></table></figure></p>
<p>还可以用-a指定后缀数字的长度（默认是2）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ split -l 2 test.txt -d -a 4</span><br><span class="line">$ ls</span><br><span class="line">test.txt  x0000  x0001  x0002</span><br></pre></td></tr></table></figure></p>
<p>不过开头的x实在看不顺序，我们还可以指定前缀，比如指定前缀为test：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ split -l 2 test.txt -d -a 4 test</span><br><span class="line">$ ls</span><br><span class="line">test0000  test0001  test0002  test.txt</span><br></pre></td></tr></table></figure></p>
<p>而且你还可以从指定数字下标开始，使用—numeric-suffixes，例如从0004开始：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ split --numeric-suffixes=4 test.txt -a 4 -l 2</span><br><span class="line">test.txt  x0004  x0005</span><br></pre></td></tr></table></figure></p>
<h4 id="按照大小拆分"><a href="#按照大小拆分" class="headerlink" title="按照大小拆分"></a>按照大小拆分</h4><p>使用-b参数来按照大小来拆分，单位为字节：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ split -b 10 test.txt</span><br></pre></td></tr></table></figure></p>
<p>当然还可以使用k（千字节），m（兆）。即：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ split -b 10k test.txt</span><br></pre></td></tr></table></figure></p>
<h4 id="分割成指定数量文件"><a href="#分割成指定数量文件" class="headerlink" title="分割成指定数量文件"></a>分割成指定数量文件</h4><p>使用-n参数即可，比如无论大小，行数，拆分为3个文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ split -n 4 test.txt</span><br><span class="line">$ test.txt  xaa  xab  xac  xad</span><br></pre></td></tr></table></figure></p>
<h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><p>当然了，打的日志文件可以不用那种创建临时文件打开的方式（如vim打开一个文件会创建一个临时文件），而可以使用类似more，tail等命令查看部分内容。更多查看方式可以参考《<a href="https://www.yanbinghu.com/2018/10/05/61779.html">Linux常用命令-文本查看篇</a>》。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>几个命令了解ELF文件的秘密</title>
    <url>/2019/10/13/54745.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Linux中，可执行文件的格式是ELF格式，而有一些命令可以帮助我们了解它们更多的“秘密”,以此来帮助我们解决问题。​<br><a id="more"></a></p>
<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>我们的示例程序如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//hello.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"hello shouwangxiansheng\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o hello hello.c</span><br></pre></td></tr></table></figure></p>
<p>得到hello可执行文件。</p>
<h2 id="查看文件类型"><a href="#查看文件类型" class="headerlink" title="查看文件类型"></a>查看文件类型</h2><p>file命令可以用来查看文件类型：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ file hello</span><br><span class="line">hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 2.6.32, BuildID[sha1]=8f1de0f59bdfe9aaff85ade6898173aa436b296a, not stripped</span><br></pre></td></tr></table></figure></p>
<p>从结果中，我们可以知道，它是ELF可执行文件，且是64位程序，有动态链接，最后的not stripped也表明了它保留了符号表信息或者调试信息。</p>
<p>如果不是可执行文件，它的信息是怎样的呢？举个例子：​<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ file hello.c</span><br><span class="line">hello.c: C source, UTF-8 Unicode text</span><br></pre></td></tr></table></figure></p>
<p>看到了吧。</p>
<h2 id="查看ELF头"><a href="#查看ELF头" class="headerlink" title="查看ELF头"></a>查看ELF头</h2><p>readelf用于查看ELF文件，而：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ readelf -h hello</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&apos;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              EXEC (Executable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">(略)</span><br></pre></td></tr></table></figure></p>
<p>可以看到它是EXEC，即可执行文件，且小端程序，运行于X86-64。在交叉编译的时候，这个文件头的信息也非常有用。例如你在x86的机器上交叉编译出powerpc的可执行文件，在powerpc上却不被识别，不能运行，不如用readelf看看它的Machine字段，是不是没有​编译好。</p>
<h2 id="查找ELF文件中的字符串"><a href="#查找ELF文件中的字符串" class="headerlink" title="查找ELF文件中的字符串"></a>查找ELF文件中的字符串</h2><p>例如，你在文件中写入了版本号或者特殊字符串，可以通过strings命令搜索到：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ strings hello|grep shouwang</span><br><span class="line">hello shouwangxiansheng</span><br></pre></td></tr></table></figure></p>
<h2 id="查看ELF文件各段大小"><a href="#查看ELF文件各段大小" class="headerlink" title="查看ELF文件各段大小"></a>查看ELF文件各段大小</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ size hello</span><br><span class="line">   text	   data	    bss	    dec	    hex	filename</span><br><span class="line">   1210	    552	      8	   1770	    6ea	hello</span><br></pre></td></tr></table></figure>
<p>这里可以看到代码段，数据段各自占多少，必要时候还可以根据需要优化代码，减少磁盘空间占用。</p>
<h2 id="查看链接的动态库"><a href="#查看链接的动态库" class="headerlink" title="查看链接的动态库"></a>查看链接的动态库</h2><p>运行时出现找不到动态库？不如看看它链接了哪些库吧：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ldd hello</span><br><span class="line">	linux-vdso.so.1 =&gt;  (0x00007ffd16386000)</span><br><span class="line">	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f507e083000)</span><br><span class="line">	/lib64/ld-linux-x86-64.so.2 (0x00007f507e44d000)</span><br></pre></td></tr></table></figure></p>
<p>可以看到它链接的动态库是/lib/x86_64-linux-gnu/libc.so.6，而如果该文件不存在，则运行时将会出错。这里也可以参考《<a href="https://www.yanbinghu.com/2019/07/18/38654.html">动态库的制作和使用</a>》。</p>
<h2 id="查看符号表"><a href="#查看符号表" class="headerlink" title="查看符号表"></a>查看符号表</h2><p>新加的函数或者全局变量不知道有没有编译进去？如何看看符号表里有没有吧（前提是符号表没有被去掉）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nm hello |grep main  #符号表中查找main函数</span><br><span class="line">                 U __libc_start_main@@GLIBC_2.2.5</span><br><span class="line">0000000000400526 T main</span><br></pre></td></tr></table></figure></p>
<p>如果没有找到或者前面是U，没有地址，表明在这个elf文件中没有定义这个函数。</p>
<p>链接出问题的时候很有用奥。</p>
<h2 id="为ELF文件瘦身"><a href="#为ELF文件瘦身" class="headerlink" title="为ELF文件瘦身"></a>为ELF文件瘦身</h2><p>前面通过file查看文件时，看到有not stripped的字样，由于它里面包含了一些符号表信息，因为文件会稍大，如果去掉，二进制文件将会变小，但是里面的符号表信息也就没有了，将会影响问题定位。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -lh hello  #瘦身前</span><br><span class="line">-rwxrwxr-x 1 root root 8.4K</span><br><span class="line">$ strip hello</span><br><span class="line">$ ls -lh hello #瘦身后</span><br><span class="line">-rwxrwxr-x 1 root root 6.2K</span><br></pre></td></tr></table></figure></p>
<p>可以看到，瘦身后二进制文件变得更小。当可执行文件越大时，瘦身效果就会更明显了。当然放心，这不会影响程序的正常运行，只是对调试和问题定位有影响。</p>
<p>这个时候再看符号表：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nm hello</span><br><span class="line">nm: hello: no symbols</span><br></pre></td></tr></table></figure></p>
<h2 id="打印文件校验和"><a href="#打印文件校验和" class="headerlink" title="打印文件校验和"></a>打印文件校验和</h2><p>二进制文件传输过程中有没有被损坏或者是否是同一个版本，看看校验和以及程序块计数吧：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sum hello</span><br><span class="line">33513     7</span><br></pre></td></tr></table></figure></p>
<p>当然你也可以使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ md5sum hello</span><br><span class="line">521efed706c3b485dd3b5e96e48b138a  hello</span><br></pre></td></tr></table></figure></p>
<p>来比对md5值。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ELF文件中隐藏了丰富的信息，只要使用得当，将会帮助我们更好地进行开发或者问题的定位。</p>
<p>相关阅读：</p>
<ul>
<li><a href="https://www.yanbinghu.com/2018/09/26/61877.html">Linux常用命令-开发调试篇</a></li>
<li><a href="https://www.yanbinghu.com/2019/06/27/47343.html">静态库和动态库</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>《深入理解计算机系统》-必读好书</title>
    <url>/2019/10/07/24990.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>标题有点夸张了，但是这是我个人强烈推荐的一本书。最开始是在图书馆借的，后来粗略看了第一遍之后，果断入手了，中文版原价是139元，这本书就是大名鼎鼎的CSAPP（Computer Systems: A Programmer’s Perspective ），中文版被翻译成了《<a href="https://book.douban.com/subject/26912767/" target="_blank" rel="noopener">深入理解计算机系统</a>》。<br><a id="more"></a></p>
<h2 id="为什么推荐"><a href="#为什么推荐" class="headerlink" title="为什么推荐"></a>为什么推荐</h2><p>目前其中文版的评分为<strong>9.8分</strong>，可见其优秀程度。那么这本书有哪些特点呢？在我个人看来，主要有以下几个方面：</p>
<ul>
<li>有深度，但又点到为止。</li>
<li>实践性强</li>
<li>易读，注意这里易读不是简单，而是读起来非常顺畅</li>
<li>第三版印刷质量良心</li>
<li>硬件、系统、软件系统结合，构成一整个框架，让你对计算机有一个整体的认识</li>
</ul>
<h2 id="讲了什么"><a href="#讲了什么" class="headerlink" title="讲了什么"></a>讲了什么</h2><p>那么这本书到底讲了什么呢？</p>
<p>作为一个程序员，你平常所接触到的东西在计算机中处于什么样的位置？你对整个计算机系统有整体的认识吗？本书阐述了一些计算机系统的核心概念。以下问题你能回答吗：</p>
<ul>
<li>一个hello world从本文内容到运行打印出来hello world经历了哪些过程？</li>
<li>在计算机中，信息是如何表示的？</li>
<li>程序的机器级表示又是怎么样的？</li>
<li>处理器又是如何处理这些指令的？</li>
<li>程序性能应该从哪些角度来优化？</li>
<li>存储器的存储结构是怎样的？</li>
<li>链接是什么？为什么它那么重要？</li>
<li>异常，中断又是怎么回事？</li>
<li>虚拟内存是如何工作的？</li>
<li>文件是如何访问的</li>
<li>网络编程需要注意什么？</li>
<li>并发程序的编写有什么技巧？</li>
</ul>
<p>没错，本书从计算机的底层，循循善诱，一步步往上介绍，虽然不会面面俱到，但让你对整个计算机体系有一个整体的概念。</p>
<p>如果你不能回答以上问题，那么看完本书，至少让你知道：</p>
<ul>
<li>一个程序需要经历预处理，编译，汇编，链接这样的过程，了解进程，线程，虚拟内存，堆，栈，文件，并行和并发等概念。</li>
<li>二进制又是如何构建出现代计算体系，各种数据类型又是如何存储，为什么会有大小端等问题？prinf为什么总遇到一些奇怪的数值问题？</li>
<li>计算机执行指令的过程是怎样的，它们又是如何操纵数据的，那些算术或逻辑操作，条件控制又是如何处理的</li>
<li>处理器执行指令有什么特点，根据执行特点我们可以如何写出性能良好的程序</li>
<li>局部性原理是什么？为什么利用它能够写出性能优异的程序？实际中又该如何写才能极大提高性能？</li>
<li>高速缓存有什么用，命中缓存和不命中缓存有什么差别？</li>
<li>你的多个.c编译后是如何组织在一起的？静态库和动态库有什么区别？elf文件又是什么？</li>
<li>进程是如何创建出来的？什么是上下文切换？信号又是什么？</li>
<li>程序的地址空间是怎样的？内存映射，动态内存分配，垃圾回收都是怎么回事？C程序要注意哪些内存问题？</li>
<li>如何读写文件，重定向是怎么回事？</li>
<li>如何编写网络程序？</li>
<li>并发编程又有哪些实现方式，都有什么特点？</li>
</ul>
<p>除了知道上面这些内容，你还可以通过每个章节后面的习题进行提高，最后也提供习题的答案。而书中也还有很多地方会给你一些提示，同时里面也会告诉你一些小技巧，如命令行输入man ascii可以得到一张ascii表。</p>
<h2 id="适合哪些人"><a href="#适合哪些人" class="headerlink" title="适合哪些人"></a>适合哪些人</h2><p>本书并不适合初学者，而在阅读本书时，最好有一定的Linux/C/C++基础，书中的很多例子也都是C语言实现的。同时，如果你完全没有听过前面提到的各种概念，那么你阅读起来可能也会比较困难，尤其是机器级表示和处理器体系结构章节，对于没有学习过汇编的人来说会相当困难。不过私以为可先关注其他章节。</p>
<p>而看这些有什么用呢？说实话，我也说不出来，不过相信你在遇到一些奇奇怪怪的问题的时候会想起它里面的内容，例如</p>
<ul>
<li>挂死</li>
<li>无大文件，磁盘占满</li>
<li>内存耗尽</li>
<li>链接出错</li>
<li>……</li>
</ul>
<p>但是可以肯定的是，你在不同的阶段去读它，都会有收获。</p>
<h2 id="如何阅读"><a href="#如何阅读" class="headerlink" title="如何阅读"></a>如何阅读</h2><p>看前言。看书，做题，编写并运行程序。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你想成为一个更加优秀的程序员，那么这本书你不应该错过。不过如果想要完全搞懂每个章节的内容，那么你还需要阅读其他相关书籍进行补充，它并不能面面俱到。不过对于了解整个计算机体系来说，它非常优秀了。</p>
<p>不说了，吹吹灰，感觉还没有吹够。</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么执行自己的程序时需要加上点斜杠</title>
    <url>/2019/10/07/14442.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Linux中，我们执行内置命令时，直接输入命令名称即可，如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mv a b #将a重命名为b</span><br></pre></td></tr></table></figure></p>
<p>而在执行自己写好的程序时，却要带上./，例如：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hello</span></span><br><span class="line">hello: command not found</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./hello</span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p>
<p>这是为什么呢？它们有什么区别呢？</p>
<a id="more"></a>
<h2 id="shell是如何运行程序的"><a href="#shell是如何运行程序的" class="headerlink" title="shell是如何运行程序的"></a>shell是如何运行程序的</h2><p>在说明清楚问题之前，我们必须了解shell是如何运行程序的。首先我们必须要清楚的是，执行一条Linux命令，本质是在运行一个程序，如执行ls命令，它执行的是ls程序。那么在shell中输入一条命令，到底发生了什么？他会经历哪几个查找过程？<br>如果不给出相对路径，或者绝对路径，那么它会经历下面的查找过程。</p>
<h4 id="alias中查找"><a href="#alias中查找" class="headerlink" title="alias中查找"></a>alias中查找</h4><p>alias命令可用来设置命令别名，而单独输入alias可以查看到已设置的别名：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">alias</span></span></span><br><span class="line">alias egrep='egrep --color=auto'</span><br><span class="line">alias fgrep='fgrep --color=auto'</span><br><span class="line">alias grep='grep --color=auto'</span><br><span class="line">alias l='ls -CF'</span><br><span class="line">alias la='ls -A'</span><br><span class="line">alias ll='ls -alF'</span><br><span class="line">alias ls='ls --color=auto'</span><br></pre></td></tr></table></figure></p>
<p>如果这里没有找到你执行的命令，那么就会接下去查找。如果找到了，那么就会执行下去。</p>
<h4 id="内置命令中查找"><a href="#内置命令中查找" class="headerlink" title="内置命令中查找"></a>内置命令中查找</h4><p>不同的shell包含一些不同的内置命令，通常不需要shell到磁盘中去搜索。通过help命令可以看到有哪些内置命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ help</span><br></pre></td></tr></table></figure></p>
<p>通过type 命令可以查看命令类型：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ type echo</span><br><span class="line">echo is a shell builtin</span><br></pre></td></tr></table></figure></p>
<p>如果是内置命令，则会直接执行，否则继续查找。</p>
<h4 id="PATH中查找"><a href="#PATH中查找" class="headerlink" title="PATH中查找"></a>PATH中查找</h4><p>以ls为例，在shell输入ls时，首先它会从$PATH环境变量去查找，$PATH内容是什么呢，我们看看：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$PATH</span></span></span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games</span><br></pre></td></tr></table></figure></p>
<p>所以它会在这些路径下去寻找ls程序，按照路径找到的第一个ls程序就会被执行。使用whereis也能确定ls的位置：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> whereis ls</span></span><br><span class="line">ls: /bin/ls /usr/share/man/man1/ls.1.g</span><br></pre></td></tr></table></figure></p>
<p>既然它是在bin目录下，那么我把ls从bin目录下移走是不是就找不到了呢？是的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mv /bin/ls /temp/ls_bak  #测试完后记得改回来奥</span><br></pre></td></tr></table></figure></p>
<p>现在再来执行ls命令看看：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls </span></span><br><span class="line">The program 'ls' is currently not installed. You can install it by typing:</span><br><span class="line">apt install coreutils</span><br></pre></td></tr></table></figure></p>
<p>没错，它会提示你没有安装这个程序。</p>
<p>所以你现在明白为什么你第一次安装jdk或者python的时候要设置环境变量了吧？不设置的话行不行？</p>
<p>行。这个时候你就需要指定路径了。怎么指定路径？无非就是那么几种，相对路径，绝对路径等等。<br>比如：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /temp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./ls_bak</span></span><br></pre></td></tr></table></figure></p>
<p>或者：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ /temp/ls_bak</span><br></pre></td></tr></table></figure></p>
<p>是不是发现和运行自己的普通程序方式没什么差别呢？</p>
<p>到这里，如果还没有找到你要执行的命令，那么就会报错。</p>
<h4 id="确定解释程序"><a href="#确定解释程序" class="headerlink" title="确定解释程序"></a>确定解释程序</h4><p>在找到程序之后呢，需要确定解释程序。什么意思呢？<br>shell通常可以执行两种程序，一种是二进制程序，一种是脚本程序。</p>
<p>而一旦发现要执行的程序文件是文本文件，且文本未指定解释程序，那么就会默认当成shell脚本来执行。例如，假设有test.txt内容如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -e "hello world"</span><br></pre></td></tr></table></figure></p>
<p>赋予执行权限并执行：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod +x test.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./test.txt</span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p>
<p>当然了，我们通常会在shell脚本程序的来头带上下面这句：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br></pre></td></tr></table></figure></p>
<p>这是告诉shell，你要用bash程序来解释执行test.txt。作为一位调皮的开发者，如果开头改成下面这样呢？<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/python</span></span><br></pre></td></tr></table></figure></p>
<p>再次执行之后结果如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./test.txt</span></span><br><span class="line">  File "./test.txt", line 2</span><br><span class="line">    echo -e "hello world"</span><br><span class="line">                        ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure></p>
<p>是的，它被当成python脚本来执行了，自然就会报错了。</p>
<p>那么如果是二进制程序呢？就会使用execl族函数去创建一个新的进程来运行新的程序了。</p>
<p>小结一下前面的内容，就是说，如果是文本程序，且开头没有指定解释程序，则按照shell脚本处理，如果指定了解释程序，则使用解释程序来解释运行；对于二进制程序，则直接创建新的进程即可。</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>前面我们也已经看到了运行方式，设置环境变量或者使用相对路径，绝对路径即可。不过对于shell脚本，你还可以像下面这样执行：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sh test.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> . test.txt</span></span><br></pre></td></tr></table></figure></p>
<p>即便test.txt没有执行权限，也能够正常执行。</p>
<p>什么？你说为什么txt也能执行？注意，Linux下的文件后缀不过是为了方便识别文件类型罢了，以.txt结尾，并不代表一定是文本。当然在这里它确实是，而且还是ASCII text executable：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> file test.txt</span></span><br><span class="line">test.txt: Bourne-Again shell script, ASCII text executable</span><br><span class="line"><span class="meta">$</span><span class="bash"> file hello</span></span><br><span class="line">hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 2.6.32, BuildID[sha1]=8ae48f0f84912dec98511581c876aa042824efdb, not stripped</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>来源：公众号【编程珠玑】<br>id：shouwangxiansheng</p>
</blockquote>
<h2 id="扩展一下"><a href="#扩展一下" class="headerlink" title="扩展一下"></a>扩展一下</h2><p>那么如果让我们自己的程序也能够像Linux内置命令一样输入即可被识别呢？</p>
<h4 id="将程序放到PATH路径下"><a href="#将程序放到PATH路径下" class="headerlink" title="将程序放到PATH路径下"></a>将程序放到PATH路径下</h4><p>第一种方法就是将我们自己的程序放到PATH中的路径中去，这样在shell输入hello时，也能找到，例如我们将其放在/bin目录下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hello</span></span><br><span class="line">hello world</span><br><span class="line"><span class="meta">$</span><span class="bash"> whereis hello</span></span><br><span class="line">hello: /bin/hello</span><br></pre></td></tr></table></figure></p>
<p>也就是说，如果你的程序安装在了PATH指定的路径，就需要配置PATH环境变量，在命令行输入就可以直接找到了。</p>
<h4 id="设置PATH环境变量"><a href="#设置PATH环境变量" class="headerlink" title="设置PATH环境变量"></a>设置PATH环境变量</h4><p>那么如果想在指定的目录能够直接运行呢？很简单，那就是添加环境变量，例如将当前路径加入到PATH中：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> PATH=<span class="variable">$PATH</span>:./   <span class="comment">#这种方式只在当前shell有效，所有shell生效可修改/etc/profile文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hello</span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p>
<h4 id="设置别名"><a href="#设置别名" class="headerlink" title="设置别名"></a>设置别名</h4><p>例如：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">alias</span> hello=<span class="string">"/temp/hello"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hello</span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p>
<p>以上三种方法都可以达到目的。</p>
<h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><p>那么假设我写了一个自己的printf程序，当执行printf的时候，到底执行的是哪一个呢？<br>实际上它的查找顺序可以可以通过type -a来查看：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">type</span> -a <span class="built_in">printf</span></span></span><br><span class="line">printf is aliased to `printf "hello\n"'</span><br><span class="line">printf is a shell builtin</span><br><span class="line">printf is /usr/bin/printf</span><br><span class="line">printf is ./printf</span><br></pre></td></tr></table></figure></p>
<p>这里就可以很清楚地看到查找顺序了。也就是说，如果你输入printf，它执行的是：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">printf</span></span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure></p>
<p>而如果删除别名：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unalias printf</span><br></pre></td></tr></table></figure></p>
<p>它执行的将会是内置命令printf。<br>以此类推。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>说到这里，想必标题的问题以及下面的问题你都清楚了：</p>
<ul>
<li>安装Python或者Jdk程序为什么要设置PATH环境变量？如果不设置，该如何运行？</li>
<li>除了./方式运行自己的程序还有什么方式？</li>
<li>如果让自己的程序能够像内置命令一样被识别？</li>
<li>如何查看文件类型？</li>
<li>执行一条命令，如何确定是哪里的命令被执行</li>
</ul>
<p>本文涉及命令：</p>
<ul>
<li>mv 移动/重命名</li>
<li>file 查看文件信息</li>
<li>whereis 查看命令或者手册位置</li>
<li>type 查看命令类别​</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell速查表</title>
    <url>/2019/09/22/55007.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不知道你是否在为突然想实现某个功能的小脚本而苦苦寻找答案，这里有一份“圣经”用来查看各种仅使用内置bash命令实现各种常用的功能和鲜为人知的用法。<br><a id="more"></a></p>
<h2 id="为什么要写脚本？"><a href="#为什么要写脚本？" class="headerlink" title="为什么要写脚本？"></a>为什么要写脚本？</h2><p>无论是作为Linux应用开发还是运维，编写shell脚本都是一个最基本的技能，而使用shell能够简洁快速地解决很多问题，提高效率。什么你还不会？那么建议你花点时间学一下，毕竟花不了你太多时间就可以让它给你干活。你也可以参考这里了解一下最基本的用法《<a href="https://www.yanbinghu.com/2019/05/07/53959.html">这些必备的shell知识你都会了吗？</a>》</p>
<h2 id="为什么要使用内置bash来实现？"><a href="#为什么要使用内置bash来实现？" class="headerlink" title="为什么要使用内置bash来实现？"></a>为什么要使用内置bash来实现？</h2><p>使用内置的bash命令可以避免一些依赖，不至于你的脚本迁移到另外一个系统还需要装一些依赖，另外一方面，使用这些内置命令常常也会更加高效。</p>
<h2 id="这份”圣经“是怎样的？"><a href="#这份”圣经“是怎样的？" class="headerlink" title="这份”圣经“是怎样的？"></a>这份”圣经“是怎样的？</h2><p>实际上它是github上地一个星标项目，地址如下：<br><a href="https://github.com/dylanaraps/pure-bash-bible" target="_blank" rel="noopener">https://github.com/dylanaraps/pure-bash-bible</a><br>目前星标近20k，它列出了一些常用的功能，有哪些呢，我们可以看看。</p>
<ul>
<li>字符串<ul>
<li>去掉字符串首尾的空格</li>
<li>去掉字符串中的空格并用空格分割</li>
<li>在字符串中使用正则表达式</li>
<li>分割字符串</li>
<li>字符串大小写转换</li>
<li>字符串反转</li>
<li>检查字符串中是否包含某个子串</li>
<li>检查字符串是否以某个子串结尾</li>
<li>……</li>
</ul>
</li>
<li>数组<ul>
<li>反转数组</li>
<li>去除数组中重复元素</li>
<li>随机排列数组元素</li>
<li>……</li>
</ul>
</li>
<li>循环<ul>
<li>以数值作为循环条件</li>
<li>以数值变量作为循环条件</li>
<li>以数组作为循环条件</li>
<li>遍历文件内容</li>
<li>遍历文件和目录</li>
<li>……</li>
</ul>
</li>
<li><p>文件处理</p>
<ul>
<li>将文件内容读取到字符串中</li>
<li>将文件内容以行为单位读取到数组中</li>
<li>读取文件的前n行</li>
<li>读取文件的最后n行</li>
<li>创建空文件</li>
<li>……</li>
</ul>
</li>
<li><p>文件路径</p>
<ul>
<li>获取全路径中的目录名</li>
<li>获取全路径中的文件名</li>
</ul>
</li>
</ul>
<p>注意，这里仅仅是目录的一小部分，原项目中还有很多内容，包括一些内置变量的获取，系统信息的获取，一些常用语法，常见表达式，基本运算等等。</p>
<h2 id="内容是什么样子的呢？"><a href="#内容是什么样子的呢？" class="headerlink" title="内容是什么样子的呢？"></a>内容是什么样子的呢？</h2><p>举个例子，如何去掉字符串首尾的元素，它给了一个shell函数：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">trim_string() &#123;</span><br><span class="line">    # Usage: trim_string "   example   string    "</span><br><span class="line">    : "$&#123;1#"$&#123;1%%[![:space:]]*&#125;"&#125;"</span><br><span class="line">    : "$&#123;_%"$&#123;_##*[![:space:]]&#125;"&#125;"</span><br><span class="line">    printf '%s\n' "$_"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么在shell脚本中就可以这样调用：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">trim_string "    Hello,  World    "</span><br><span class="line"><span class="meta">#</span>会打印这个结果：Hello,  World</span><br></pre></td></tr></table></figure></p>
<p>而又例如在介绍循环的时候，告诉你一些常见的循环方式：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> Loop from 0-100 (no variable support).</span><br><span class="line">for i in &#123;0..100&#125;; do</span><br><span class="line">    printf '%s\n' "$i"</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">VAR=50</span><br><span class="line">for ((i=0;i&lt;=VAR;i++)); do</span><br><span class="line">    printf '%s\n' "$i"</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>又或者：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for element in &quot;$&#123;arr[@]&#125;&quot;; do</span><br><span class="line">    printf &apos;%s\n&apos; &quot;$element&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>总之作为基础学习的手册也是非常不错了，一些常用的语法在这里都能看到。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际上里面很多相关功能也有一些bash命令可以直接实现，但是大部分内容作为一个速查的渠道还是不错的，有兴趣的可以去查看：</p>
<p><a href="https://github.com/dylanaraps/pure-bash-bible" target="_blank" rel="noopener">https://github.com/dylanaraps/pure-bash-bible</a></p>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面试题万字长文-基础篇</title>
    <url>/2019/09/19/23258.html</url>
    <content><![CDATA[<p>来源：牛客网<br>地址：<a href="http://1t.click/arsc" target="_blank" rel="noopener">http://1t.click/arsc</a><br>编辑：公众号【编程珠玑】<br>秋招火热，来看看这些面试题。答案仅供参考！<br><a id="more"></a></p>
<h4 id="说一下static关键字的作用"><a href="#说一下static关键字的作用" class="headerlink" title="说一下static关键字的作用"></a>说一下static关键字的作用</h4><p>参考回答：</p>
<ol>
<li>全局静态变量<br>在全局变量前加上关键字static，全局变量就定义成一个全局静态变量.</li>
</ol>
<p>静态存储区，在整个程序运行期间一直存在。</p>
<p>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；</p>
<p>作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p>
<ol>
<li>局部静态变量</li>
</ol>
<p>在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。</p>
<p>内存中的位置：静态存储区</p>
<p>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；</p>
<p>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</p>
<ol>
<li>静态函数</li>
</ol>
<p>在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。</p>
<p>函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；</p>
<p>warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；</p>
<ol>
<li>类的静态成员</li>
</ol>
<p>在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用</p>
<ol>
<li>类的静态函数</li>
</ol>
<p>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。</p>
<p>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);</p>
<h4 id="说一下C-和C的区别"><a href="#说一下C-和C的区别" class="headerlink" title="说一下C++和C的区别"></a>说一下C++和C的区别</h4><p>参考回答：<br>设计思想上：<br>C++是面向对象的语言，而C是面向过程的结构化编程语言</p>
<p>语法上：</p>
<p>C++具有封装、继承和多态三种特性</p>
<p>C++相比C，增加多许多类型安全的功能，比如强制类型转换、</p>
<p>C++支持范式编程，比如模板类、函数模板等</p>
<h4 id="说一说c-中四种cast转换"><a href="#说一说c-中四种cast转换" class="headerlink" title="说一说c++中四种cast转换"></a>说一说c++中四种cast转换</h4><p>参考回答：<br>C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast<br>1、const_cast</p>
<p>用于将const变量转为非const</p>
<p>2、static_cast</p>
<p>用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；</p>
<p>3、dynamic_cast</p>
<p>用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。</p>
<p>向上转换：指的是子类向基类的转换</p>
<p>向下转换：指的是基类向子类的转换</p>
<p>它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。</p>
<p>4、reinterpret_cast</p>
<p>几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；</p>
<p>5、为什么不使用C的强制转换？</p>
<p>C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</p>
<h4 id="请说一下C-C-中指针和引用的区别？"><a href="#请说一下C-C-中指针和引用的区别？" class="headerlink" title="请说一下C/C++ 中指针和引用的区别？"></a>请说一下C/C++ 中指针和引用的区别？</h4><p>参考回答或参考文章《<a href="https://www.yanbinghu.com/2018/11/15/44287.html">令人疑惑的引用和指针</a>》：<br>1.指针有自己的一块空间，而引用只是一个别名；<br>2.使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</p>
<p>3.指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；</p>
<p>4.作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；</p>
<p>5.可以有const指针，但是没有const引用；</p>
<p>6.指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；</p>
<p>7.指针可以有多级指针（**p），而引用止于一级；</p>
<p>8.指针和引用使用++运算符的意义不一样；</p>
<p>9.如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</p>
<h4 id="给定三角形ABC和一点P-x-y-z-，判断点P是否在ABC内，给出思路并手写代码"><a href="#给定三角形ABC和一点P-x-y-z-，判断点P是否在ABC内，给出思路并手写代码" class="headerlink" title="给定三角形ABC和一点P(x,y,z)，判断点P是否在ABC内，给出思路并手写代码"></a>给定三角形ABC和一点P(x,y,z)，判断点P是否在ABC内，给出思路并手写代码</h4><p>参考回答：<br>根据面积法，如果P在三角形ABC内，那么三角形ABP的面积+三角形BCP的面积+三角形ACP的面积应该等于三角形ABC的面积。算法如下：<br>面积<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ABS_FLOAT_0 0.0001</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point_float</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">float</span> x;</span><br><span class="line"><span class="keyword">float</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* @brief 计算三角形面积</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">GetTriangleSquar</span><span class="params">(<span class="keyword">const</span> point_float pt0, <span class="keyword">const</span> point_float pt1, <span class="keyword">const</span> point_float pt2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    point_float AB,   BC;</span><br><span class="line">    AB.x = pt1.x - pt0.x;</span><br><span class="line">    AB.y = pt1.y - pt0.y;</span><br><span class="line">    BC.x = pt2.x - pt1.x;</span><br><span class="line">    BC.y = pt2.y - pt1.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>((AB.x * BC.y - AB.y * BC.x)) / <span class="number">2.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* @brief 判断给定一点是否在三角形内或边上</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsInTriangle</span><span class="params">(<span class="keyword">const</span> point_float A, <span class="keyword">const</span> point_float B, <span class="keyword">const</span> point_float C, <span class="keyword">const</span> point_float D)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> SABC, SADB, SBDC, SADC;</span><br><span class="line">    SABC = GetTriangleSquar(A, B, C);</span><br><span class="line">    SADB = GetTriangleSquar(A, D, B);</span><br><span class="line">    SBDC = GetTriangleSquar(B, D, C);</span><br><span class="line">    SADC = GetTriangleSquar(A, D, C);</span><br><span class="line">    <span class="keyword">float</span> SumSuqar = SADB + SBDC + SADC;</span><br><span class="line">    <span class="keyword">if</span> ((-ABS_FLOAT_0 &lt; (SABC - SumSuqar)) &amp;&amp; ((SABC - SumSuqar) &lt; </span><br><span class="line">        ABS_FLOAT_0))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="请你说一下你理解的c-中的smart-pointer四个智能指针：-shared-ptr-unique-ptr-weak-ptr-auto-ptr"><a href="#请你说一下你理解的c-中的smart-pointer四个智能指针：-shared-ptr-unique-ptr-weak-ptr-auto-ptr" class="headerlink" title="请你说一下你理解的c++中的smart pointer四个智能指针： shared_ptr,unique_ptr,weak_ptr,auto_ptr"></a>请你说一下你理解的c++中的smart pointer四个智能指针： shared_ptr,unique_ptr,weak_ptr,auto_ptr</h4><p>参考回答：<br>C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被11弃用。<br>为什么要使用智能指针：</p>
<p>智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</p>
<ol>
<li>auto_ptr（c++98的方案，cpp11已经抛弃）</li>
</ol>
<p>采用所有权模式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt; <span class="built_in">string</span>&gt; <span class="title">p1</span> <span class="params">(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"I reigned lonely as a cloud.”));</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">auto_ptr&lt;string&gt; p2;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">p2 = p1; //auto_ptr不会报错.</span></span></span></span><br></pre></td></tr></table></figure>
<p>此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！</p>
<ol>
<li>unique_ptr（替换auto_ptr）</li>
</ol>
<p>unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。</p>
<p>采用所有权模式，还是上面那个例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">p3</span> <span class="params">(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"auto"</span>))</span></span>;   <span class="comment">//#4</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p4；                       <span class="comment">//#5</span></span><br><span class="line">p4 = p3;<span class="comment">//此时会报错！！</span></span><br></pre></td></tr></table></figure>
<p>编译器认为p4=p3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。</p>
<p>另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">pu1</span><span class="params">(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"hello world"</span>))</span></span>;</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu2;</span><br><span class="line">pu2 = pu1;                                      <span class="comment">// #1 not allowed</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu3;</span><br><span class="line">pu3 = <span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"You"</span>));   <span class="comment">// #2 allowed</span></span><br></pre></td></tr></table></figure></p>
<p>其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。</p>
<p>注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; ps1, ps2;</span><br><span class="line">ps1 = demo(<span class="string">"hello"</span>);</span><br><span class="line">ps2 = move(ps1);</span><br><span class="line">ps1 = demo(<span class="string">"alexia"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>shared_ptr</li>
</ol>
<p>shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。</p>
<p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。</p>
<p>成员函数：</p>
<p>use_count 返回引用计数的个数</p>
<p>unique 返回是否是独占所有权( use_count 为 1)</p>
<p>swap 交换两个 shared_ptr 对象(即交换所拥有的对象)</p>
<p>reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</p>
<p>get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的</int></p>
<ol>
<li>weak_ptr</li>
</ol>
<p>weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;B&gt; pb_;</span><br><span class="line">~A()</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">"A delete\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;A&gt; pa_;</span><br><span class="line">~B()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"B delete\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;B&gt; <span class="title">pb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">pa</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    pb-&gt;pa_ = pa;</span><br><span class="line">    pa-&gt;pb_ = pb;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pb.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pa.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak<em>ptr就可以了，我们把类A里面的shared_ptr pb</em>; 改为weak<em>ptr pb</em>; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。</p>
<p>注意的是我们不能通过weak<em>ptr直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，pa-&gt;pb</em>-&gt;print(); 英文pb<em>是一个weak_ptr，应该先把它转化为shared_ptr,如：shared_ptr p = pa-&gt;pb</em>.lock(); p-&gt;print();</p>
<h4 id="怎么判断一个数是二的倍数，怎么求一个数中有几个1，说一下你的思路并手写代码"><a href="#怎么判断一个数是二的倍数，怎么求一个数中有几个1，说一下你的思路并手写代码" class="headerlink" title="怎么判断一个数是二的倍数，怎么求一个数中有几个1，说一下你的思路并手写代码"></a>怎么判断一个数是二的倍数，怎么求一个数中有几个1，说一下你的思路并手写代码</h4><p>参考回答：<br>1、判断一个数是不是二的倍数，即判断该数二进制末位是不是0：<br>a % 2 == 0 或者a &amp; 0x0001 == 0。</p>
<p>2、求一个数中1的位数，可以直接逐位除十取余判断：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> _count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(x % <span class="number">10</span> == <span class="number">1</span>)</span><br><span class="line">         ++_count;</span><br><span class="line">    x /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fun(<span class="number">123321</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="请回答一下数组和指针的区别"><a href="#请回答一下数组和指针的区别" class="headerlink" title="请回答一下数组和指针的区别"></a>请回答一下数组和指针的区别</h4><p>参考文章《<a href="https://www.yanbinghu.com/2018/10/23/2660.html">数组之谜</a>》</p>
<h4 id="请你回答一下野指针是什么？"><a href="#请你回答一下野指针是什么？" class="headerlink" title="请你回答一下野指针是什么？"></a>请你回答一下野指针是什么？</h4><p>参考回答：<br>野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针</p>
<h4 id="请你介绍一下C-中的智能指针"><a href="#请你介绍一下C-中的智能指针" class="headerlink" title="请你介绍一下C++中的智能指针"></a>请你介绍一下C++中的智能指针</h4><p>参考回答：<br>智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。C++ 11中最常用的智能指针类型为shared_ptr,它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。该引用计数的内存在堆上分配。当新增一个时引用计数加1，当过期时引用计数减一。只有引用计数为0时，智能指针才会自动释放引用的内存资源。对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。可以通过make_shared函数或者通过构造函数传入普通指针。并可以通过get函数获得普通指针。</p>
<h4 id="请你回答一下智能指针有没有内存泄露的情况"><a href="#请你回答一下智能指针有没有内存泄露的情况" class="headerlink" title="请你回答一下智能指针有没有内存泄露的情况"></a>请你回答一下智能指针有没有内存泄露的情况</h4><p>参考回答：<br>当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。例如：</p>
<h4 id="请你来说一下智能指针的内存泄漏如何解决"><a href="#请你来说一下智能指针的内存泄漏如何解决" class="headerlink" title="请你来说一下智能指针的内存泄漏如何解决"></a>请你来说一下智能指针的内存泄漏如何解决</h4><p>参考回答：<br>为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。</p>
<h4 id="请你回答一下为什么析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数-考点-虚函数-析构函数"><a href="#请你回答一下为什么析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数-考点-虚函数-析构函数" class="headerlink" title="请你回答一下为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数 考点:虚函数 析构函数"></a>请你回答一下为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数 考点:虚函数 析构函数</h4><p>参考回答：<br>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p>
<p>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p>
<p>● 请你来说一下函数指针<br>参考文章《<a href="https://www.yanbinghu.com/2019/01/03/3593.html">函数指针</a>》</p>
<p>● 请你来说一下fork函数<br>参考文章《<a href="https://www.yanbinghu.com/2019/08/11/28423.html">fork函数详解</a>》</p>
<p>● 请你来说一下C++中析构函数的作用<br>参考回答：<br>析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。<br>析构函数名也应与类名相同，只是在函数名前面加一个位取反符~，例如~stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。</p>
<p>如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。</p>
<p>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。</p>
<p>类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。</p>
<h4 id="请你来说一下静态函数和虚函数的区别"><a href="#请你来说一下静态函数和虚函数的区别" class="headerlink" title="请你来说一下静态函数和虚函数的区别"></a>请你来说一下静态函数和虚函数的区别</h4><p>参考回答：<br>静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销</p>
<h4 id="请你来说一说重载和覆盖"><a href="#请你来说一说重载和覆盖" class="headerlink" title="请你来说一说重载和覆盖"></a>请你来说一说重载和覆盖</h4><p>参考回答：<br>重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中<br>重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写</p>
<h4 id="请你说一说strcpy和strlen"><a href="#请你说一说strcpy和strlen" class="headerlink" title="请你说一说strcpy和strlen"></a>请你说一说strcpy和strlen</h4><p>参考回答：<br>strcpy是字符串拷贝函数，原型：<br>char <em>strcpy(char</em> dest, const char *src);</p>
<p>从src逐字节拷贝到dest，直到遇到’\0’结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是strncpy函数。<br>strlen函数是计算字符串长度的函数，返回从开始到’\0’之间的字符个数。</p>
<h4 id="请你说一说你理解的虚函数和多态"><a href="#请你说一说你理解的虚函数和多态" class="headerlink" title="请你说一说你理解的虚函数和多态"></a>请你说一说你理解的虚函数和多态</h4><p>参考回答：<br>多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。<br>虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</p>
<h4 id="请你来回答一下-i和i-的区别"><a href="#请你来回答一下-i和i-的区别" class="headerlink" title="请你来回答一下++i和i++的区别"></a>请你来回答一下++i和i++的区别</h4><p>参考回答：<br>++i先自增1，再返回，i++先返回i,再自增1</p>
<h4 id="请你来说一说-i和i-的实现"><a href="#请你来说一说-i和i-的实现" class="headerlink" title="请你来说一说++i和i++的实现"></a>请你来说一说++i和i++的实现</h4><p>参考文章《<a href="https://www.yanbinghu.com/2019/09/09/58833.html">为什么说++i比i++效率高</a>》</p>
<h4 id="请你来写个函数在main函数执行前先运行"><a href="#请你来写个函数在main函数执行前先运行" class="headerlink" title="请你来写个函数在main函数执行前先运行"></a>请你来写个函数在main函数执行前先运行</h4><p>参考回答：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">__attribute((constructor))<span class="function"><span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"before main\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="以下四行代码的区别是什么？"><a href="#以下四行代码的区别是什么？" class="headerlink" title="以下四行代码的区别是什么？"></a>以下四行代码的区别是什么？</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * arr = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">char</span> * brr = <span class="string">"123"</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> crr[] = <span class="string">"123"</span>; </span><br><span class="line"><span class="keyword">char</span> drr[] = <span class="string">"123"</span>;</span><br></pre></td></tr></table></figure>
<p>参考回答：<br>const char * arr = “123”;<br>//字符串123保存在常量区，const本来是修饰arr指向的值不能通过arr去修改，但是字符串“123”在常量区，本来就不能改变，所以加不加const效果都一样</p>
<p>char * brr = “123”;</p>
<p>//字符串123保存在常量区，这个arr指针指向的是同一个位置，同样不能通过brr去修改”123”的值</p>
<p>const char crr[] = “123”;</p>
<p>//这里123本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区</p>
<p>char drr[] = “123”;</p>
<p>//字符串123保存在栈区，可以通过drr去修改</p>
<h4 id="请你来说一下C-里是怎么定义常量的？常量存放在内存的哪个位置？"><a href="#请你来说一下C-里是怎么定义常量的？常量存放在内存的哪个位置？" class="headerlink" title="请你来说一下C++里是怎么定义常量的？常量存放在内存的哪个位置？"></a>请你来说一下C++里是怎么定义常量的？常量存放在内存的哪个位置？</h4><p>参考回答：<br>常量在C++里的定义就是一个top-level const加上对象类型，常量定义必须初始化。对于局部对象，常量存放在栈区，对于全局对象，常量存放在全局/静态存储区。对于字面值常量，常量存放在常量存储区。<br>● 请你来回答一下const修饰成员函数的目的是什么？<br>参考回答：<br>const修饰的成员函数表明函数调用不会对对象做出任何更改，事实上，如果确认不会对对象做更改，就应该为函数加上const限定，这样无论const对象还是普通对象都可以调用该函数。</p>
<p>如果同时定义了两个函数，一个带const，一个不带，会有问题吗？<br>参考回答：<br>不会，这相当于函数的重载。</p>
<h4 id="请你来说一说隐式类型转换"><a href="#请你来说一说隐式类型转换" class="headerlink" title="请你来说一说隐式类型转换"></a>请你来说一说隐式类型转换</h4><p>参考回答：<br>首先，对于内置类型，低精度的变量给高精度变量赋值会发生隐式类型转换，其次，对于只存在单个参数的构造函数的对象构造来说，函数调用可以直接使用该参数传入，编译器会自动调用其构造函数生成临时对象。</p>
<h4 id="请你来说一说C-函数栈空间的最大值"><a href="#请你来说一说C-函数栈空间的最大值" class="headerlink" title="请你来说一说C++函数栈空间的最大值"></a>请你来说一说C++函数栈空间的最大值</h4><p>参考回答：<br>默认是1M，不过可以调整<br>● 请你来说一说extern“C”<br>参考文章《<a href="https://www.yanbinghu.com/2019/08/25/29412.html">C++是如何调用C接口的</a>》</p>
<h4 id="请你回答一下new-delete与malloc-free的区别是什么"><a href="#请你回答一下new-delete与malloc-free的区别是什么" class="headerlink" title="请你回答一下new/delete与malloc/free的区别是什么"></a>请你回答一下new/delete与malloc/free的区别是什么</h4><p>参考回答：<br>首先，new/delete是C++的关键字，而malloc/free是C语言的库函数，后者使用必须指明申请内存空间的大小，对于类类型的对象，后者不会调用构造函数和析构函数</p>
<h4 id="请你说说你了解的RTTI"><a href="#请你说说你了解的RTTI" class="headerlink" title="请你说说你了解的RTTI"></a>请你说说你了解的RTTI</h4><p>参考回答：<br>运行时类型检查，在C++层面主要体现在dynamic_cast和typeid,VS中虚函数表的-1位置存放了指向type_info的指针。对于存在虚函数的类型，typeid和dynamic_cast都会去查询type_info</p>
<h4 id="请你说说虚函数表具体是怎样实现运行时多态的"><a href="#请你说说虚函数表具体是怎样实现运行时多态的" class="headerlink" title="请你说说虚函数表具体是怎样实现运行时多态的?"></a>请你说说虚函数表具体是怎样实现运行时多态的?</h4><p>参考回答：<br>子类若重写父类虚函数，虚函数表中，该函数的地址会被替换，对于存在虚函数的类的对象，在VS中，对象的对象模型的头部存放指向虚函数表的指针，通过该机制实现多态。</p>
<h4 id="请你说说C语言是怎么进行函数调用的？"><a href="#请你说说C语言是怎么进行函数调用的？" class="headerlink" title="请你说说C语言是怎么进行函数调用的？"></a>请你说说C语言是怎么进行函数调用的？</h4><p>参考回答：<br>每一个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把返回地址压栈，然后把当前函数的esp指针压栈。</p>
<h4 id="请你说说C语言参数压栈顺序？"><a href="#请你说说C语言参数压栈顺序？" class="headerlink" title="请你说说C语言参数压栈顺序？"></a>请你说说C语言参数压栈顺序？</h4><p>参考文章《<a href="https://www.yanbinghu.com/2018/09/22/24370.html">变长参数探究</a>》</p>
<h4 id="请你说说C-如何处理返回值？"><a href="#请你说说C-如何处理返回值？" class="headerlink" title="请你说说C++如何处理返回值？"></a>请你说说C++如何处理返回值？</h4><p>参考回答：<br>生成一个临时变量，把它的引用作为函数参数传入函数内。</p>
<h4 id="请你回答一下C-中拷贝赋值函数的形参能否进行值传递？"><a href="#请你回答一下C-中拷贝赋值函数的形参能否进行值传递？" class="headerlink" title="请你回答一下C++中拷贝赋值函数的形参能否进行值传递？"></a>请你回答一下C++中拷贝赋值函数的形参能否进行值传递？</h4><p>参考回答：<br>不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数。。如此循环，无法完成拷贝，栈也会满。</p>
<h4 id="请你说一说select"><a href="#请你说一说select" class="headerlink" title="请你说一说select"></a>请你说一说select</h4><p>参考回答：<br>select在使用前，先将需要监控的描述符对应的bit位置1，然后将其传给select,当有任何一个事件发生时，select将会返回所有的描述符，需要在应用程序自己遍历去检查哪个描述符上有事件发生，效率很低，并且其不断在内核态和用户态进行描述符的拷贝，开销很大</p>
<h4 id="请你说说fork-wait-exec函数"><a href="#请你说说fork-wait-exec函数" class="headerlink" title="请你说说fork,wait,exec函数"></a>请你说说fork,wait,exec函数</h4><p>参考回答：<br>父进程产生子进程使用fork拷贝出来一个父进程的副本，此时只拷贝了父进程的页表，两个进程都读同一块内存，当有进程写的时候使用写实拷贝机制分配内存，exec函数可以加载一个elf文件去替换父进程，从此父进程和子进程就可以运行不同的程序了。fork从父进程返回子进程的pid，从子进程返回0.调用了wait的父进程将会发生阻塞，直到有子进程状态改变,执行成功返回0，错误返回-1。exec执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1</p>
<h4 id="请你回答一下静态函数和虚函数的区别"><a href="#请你回答一下静态函数和虚函数的区别" class="headerlink" title="请你回答一下静态函数和虚函数的区别"></a>请你回答一下静态函数和虚函数的区别</h4><p>参考回答：<br>静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销<br>● 请你说一说重载和覆盖<br>参考回答：<br>重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中<br>重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写</p>
<h4 id="请你来说一下map和set有什么区别，分别又是怎么实现的？"><a href="#请你来说一下map和set有什么区别，分别又是怎么实现的？" class="headerlink" title="请你来说一下map和set有什么区别，分别又是怎么实现的？"></a>请你来说一下map和set有什么区别，分别又是怎么实现的？</h4><p>参考回答：<br>map和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree）。由于 map 和set所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和set的操作行为，都只是转调 RB-tree 的操作行为。<br>map和set区别在于：</p>
<p>（1）map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。</p>
<p>（2）set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。</p>
<p>（3）map支持下标操作，set不支持下标操作。map可以用key做下标，map的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，因此下标运算符[ ]在map应用中需要慎用，const_map不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type类型没有默认值也不应该使用。如果find能解决需要，尽可能用find。</p>
<h4 id="请你来介绍一下STL的allocaotr"><a href="#请你来介绍一下STL的allocaotr" class="headerlink" title="请你来介绍一下STL的allocaotr"></a>请你来介绍一下STL的allocaotr</h4><p>参考回答：<br>STL的分配器用于封装STL容器在内存管理上的底层细节。在C++中，其内存配置和释放如下：<br>new运算分两个阶段：(1)调用::operator new配置内存;(2)调用对象构造函数构造对象内容</p>
<p>delete运算分两个阶段：(1)调用对象希构函数；(2)掉员工::operator delete释放内存</p>
<p>为了精密分工，STL allocator将两个阶段操作区分开来：内存配置有alloc::allocate()负责，内存释放由alloc::deallocate()负责；对象构造由::construct()负责，对象析构由::destroy()负责。</p>
<p>同时为了提升内存管理的效率，减少申请小内存造成的内存碎片问题，SGI STL采用了两级配置器，当分配的空间大小超过128B时，会使用第一级空间配置器；当分配的空间大小小于128B时，将使用第二级空间配置器。第一级空间配置器直接使用malloc()、realloc()、free()函数进行内存空间的分配和释放，而第二级空间配置器采用了内存池技术，通过空闲链表来管理内存。</p>
<h4 id="请你来说一说STL迭代器删除元素"><a href="#请你来说一说STL迭代器删除元素" class="headerlink" title="请你来说一说STL迭代器删除元素"></a>请你来说一说STL迭代器删除元素</h4><p>参考回答：<br>这个主要考察的是迭代器失效的问题。1.对于序列容器vector,deque来说，使用erase(itertor)后，后边的每个元素的迭代器都会失效，但是后边每个元素都会往前移动一个位置，但是erase会返回下一个有效的迭代器；2.对于关联容器map set来说，使用了erase(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的，不会影响到下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。3.对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator，因此上面两种正确的方法都可以使用。</p>
<h4 id="请你说一说STL中MAP数据存放形式"><a href="#请你说一说STL中MAP数据存放形式" class="headerlink" title="请你说一说STL中MAP数据存放形式"></a>请你说一说STL中MAP数据存放形式</h4><p>参考回答：<br>红黑树。unordered map底层结构是哈希表</p>
<h4 id="请你讲讲STL有什么基本组成"><a href="#请你讲讲STL有什么基本组成" class="headerlink" title="请你讲讲STL有什么基本组成"></a>请你讲讲STL有什么基本组成</h4><p>参考回答：<br>STL主要由：以下几部分组成：<br>容器迭代器仿函数算法分配器配接器<br>他们之间的关系：分配器给容器分配存储空间，算法通过迭代器获取容器中的内容，仿函数可以协助算法完成各种操作，配接器用来套接适配仿函数</p>
<h4 id="请你说说STL中map与unordered-map"><a href="#请你说说STL中map与unordered-map" class="headerlink" title="请你说说STL中map与unordered_map"></a>请你说说STL中map与unordered_map</h4><p>参考回答：<br>1、Map映射，map 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。不允许键值重复。<br>底层实现：红黑树</p>
<p>适用场景：有序键值对不重复映射</p>
<p>2、Multimap</p>
<p>多重映射。multimap 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。允许键值重复。</p>
<p>底层实现：红黑树</p>
<p>适用场景：有序键值对可重复映射</p>
<h4 id="请你说一说vector和list的区别，应用，越详细越好"><a href="#请你说一说vector和list的区别，应用，越详细越好" class="headerlink" title="请你说一说vector和list的区别，应用，越详细越好"></a>请你说一说vector和list的区别，应用，越详细越好</h4><p>1）Vector</p>
<p>连续存储的容器，动态数组，在堆上分配空间</p>
<p>底层实现：数组</p>
<p>两倍容量增长：</p>
<p>vector 增加（插入）新元素时，如果未超过当时的容量，则还有剩余空间，那么直接添加到最后（插入指定位置），然后调整迭代器。</p>
<p>如果没有剩余空间了，则会重新配置原有元素个数的两倍空间，然后将原空间元素通过复制的方式初始化新空间，再向新空间增加元素，最后析构并释放原空间，之前的迭代器会失效。</p>
<p>性能：</p>
<p>访问：O(1)</p>
<p>插入：在最后插入（空间够）：很快</p>
<p>在最后插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝。</p>
<p>在中间插入（空间够）：内存拷贝</p>
<p>在中间插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝。</p>
<p>删除：在最后删除：很快</p>
<p>在中间删除：内存拷贝</p>
<p>适用场景：经常随机访问，且不经常对非尾节点进行插入删除。</p>
<p>2、List</p>
<p>动态链表，在堆上分配空间，每插入一个元数都会分配空间，每删除一个元素都会释放空间。</p>
<p>底层：双向链表</p>
<p>性能：</p>
<p>访问：随机访问性能很差，只能快速访问头尾节点。</p>
<p>插入：很快，一般是常数开销</p>
<p>删除：很快，一般是常数开销</p>
<p>适用场景：经常插入删除大量数据</p>
<p>2、区别：</p>
<p>1）vector底层实现是数组；list是双向 链表。</p>
<p>2）vector支持随机访问，list不支持。</p>
<p>3）vector是顺序内存，list不是。</p>
<p>4）vector在中间节点进行插入删除会导致内存拷贝，list不会。</p>
<p>5）vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请。</p>
<p>6）vector随机访问性能好，插入删除性能差；list随机访问性能差，插入删除性能好。</p>
<p>3、应用</p>
<p>vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率，使用vector。</p>
<p>list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。</p>
<h4 id="请你来说一下STL中迭代器的作用，有指针为何还要迭代器"><a href="#请你来说一下STL中迭代器的作用，有指针为何还要迭代器" class="headerlink" title="请你来说一下STL中迭代器的作用，有指针为何还要迭代器"></a>请你来说一下STL中迭代器的作用，有指针为何还要迭代器</h4><p>参考回答：<br>1、迭代器<br>Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。</p>
<p>由于Iterator模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如STL的list、vector、stack等容器类及ostream_iterator等扩展iterator。</p>
<h4 id="迭代器和指针的区别"><a href="#迭代器和指针的区别" class="headerlink" title="迭代器和指针的区别"></a>迭代器和指针的区别</h4><p>迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，-&gt;、*、++、—等。迭代器封装了指针，是一个“可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的一种提升（lift），提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，—等操作。</p>
<p>迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用*取值后的值而不能直接输出其自身。</p>
<p>3、迭代器产生原因</p>
<p>Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。</p>
<h4 id="请你说一说epoll原理"><a href="#请你说一说epoll原理" class="headerlink" title="请你说一说epoll原理"></a>请你说一说epoll原理</h4><p>参考回答：<br>调用顺序：<br>int epoll_create(int size);</p>
<p>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</p>
<p>int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);</p>
<p>首先创建一个epoll对象，然后使用epoll_ctl对这个对象进行操作，把需要监控的描述添加进去，这些描述如将会以epoll_event结构体的形式组成一颗红黑树，接着阻塞在epoll_wait，进入大循环，当某个fd上有事件发生时，内核将会把其对应的结构体放入到一个链表中，返回有事件发生的链表。</p>
<p>● n个整数的无序数组，找到每个元素后面比它大的第一个数，要求时间复杂度为O(N)<br>参考回答：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findMax</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(num.size()==<span class="number">0</span>)<span class="keyword">return</span> num;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;res(num.size());</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line"><span class="keyword">while</span>(i&lt;num.size())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s.empty()||num[s.top()]&gt;=num[i])</span><br><span class="line">&#123;</span><br><span class="line">s.push(i++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">res[s.top()]=num[i];</span><br><span class="line">s.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!s.empty())</span><br><span class="line">&#123;</span><br><span class="line">res[s.top()]=INT_MAX;</span><br><span class="line">s.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;res.size(); i++)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;res[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="请你回答一下STL里resize和reserve的区别"><a href="#请你回答一下STL里resize和reserve的区别" class="headerlink" title="请你回答一下STL里resize和reserve的区别"></a>请你回答一下STL里resize和reserve的区别</h4><p>参考回答：<br>resize()：改变当前容器内含有元素的数量(size())，eg: vector<int>v; v.resize(len);v的size变为len,如果原来v的size小于len，那么容器新增（len-size）个元素，元素的值为默认为0.当v.push_back(3);之后，则是3是放在了v的末尾，即下标为len，此时容器是size为len+1；<br>reserve()：改变当前容器的最大容量（capacity）,它不会生成元素，只是确定这个容器允许放入多少对象，如果reserve(len)的值大于当前的capacity()，那么会重新分配一块能存len个对象的空间，然后把之前v.size()个对象通过copy construtor复制过来，销毁之前的内存；<br>测试代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    a.reserve(<span class="number">100</span>);</span><br><span class="line">    a.resize(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a.size()&lt;&lt;<span class="string">"  "</span>&lt;&lt;a.capacity()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//50  100</span></span><br><span class="line">    a.resize(<span class="number">150</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a.size()&lt;&lt;<span class="string">"  "</span>&lt;&lt;a.capacity()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//150  200</span></span><br><span class="line">    a.reserve(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a.size()&lt;&lt;<span class="string">"  "</span>&lt;&lt;a.capacity()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//150  200</span></span><br><span class="line">    a.resize(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a.size()&lt;&lt;<span class="string">"  "</span>&lt;&lt;a.capacity()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//50  200    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></int></p>
<h4 id="请你来说一下C-中类成员的访问权限"><a href="#请你来说一下C-中类成员的访问权限" class="headerlink" title="请你来说一下C++中类成员的访问权限"></a>请你来说一下C++中类成员的访问权限</h4><p>参考回答：<br>参考回答：C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员<br>● 请你来说一下C++中struct和class的区别<br>参考回答：<br>在C++中，可以用struct和class定义类，都可以继承。区别在于：structural的默认继承权限和默认访问权限是public，而class的默认继承权限和默认访问权限是private。<br>另外，class还可以定义模板类形参，比如template <class t, int i>。</class></p>
<h4 id="请你回答一下C-类内可以定义引用数据成员吗？"><a href="#请你回答一下C-类内可以定义引用数据成员吗？" class="headerlink" title="请你回答一下C++类内可以定义引用数据成员吗？"></a>请你回答一下C++类内可以定义引用数据成员吗？</h4><p>参考回答：<br>可以，必须通过成员函数初始化列表初始化。</p>
<h4 id="请你回答一下什么是右值引用，跟左值又有什么区别？"><a href="#请你回答一下什么是右值引用，跟左值又有什么区别？" class="headerlink" title="请你回答一下什么是右值引用，跟左值又有什么区别？"></a>请你回答一下什么是右值引用，跟左值又有什么区别？</h4><p>参考回答：<br>右值引用是C++11中引入的新特性 , 它实现了转移语义和精确传递。它的主要目的有两个方面：</p>
<ol>
<li><p>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</p>
</li>
<li><p>能够更简洁明确地定义泛型函数。</p>
</li>
</ol>
<p>左值和右值的概念：</p>
<p>左值：能对表达式取地址、或具名对象/变量。一般指表达式结束后依然存在的持久对象。</p>
<p>右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的临时对象。</p>
<p>右值引用和左值引用的区别：</p>
<ol>
<li><p>左值可以寻址，而右值不可以。</p>
</li>
<li><p>左值可以被赋值，右值不可以被赋值，可以用来给左值赋值。</p>
</li>
<li><p>左值可变,右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）。</p>
</li>
<li></li>
</ol>
<h4 id="请你来说一下一个C-源文件从文本到可执行文件经历的过程？"><a href="#请你来说一下一个C-源文件从文本到可执行文件经历的过程？" class="headerlink" title="请你来说一下一个C++源文件从文本到可执行文件经历的过程？"></a>请你来说一下一个C++源文件从文本到可执行文件经历的过程？</h4><p>参考文章《<a href="https://www.yanbinghu.com/2018/10/10/27133.html">hello程序是如何编译出来的</a>》：<br>对于C++源文件，从文本到可执行文件一般需要四个过程：<br>预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。</p>
<p>编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件</p>
<p>汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件</p>
<p>链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件</p>
<h4 id="请你来回答一下include头文件的顺序以及双引号””和尖括号-lt-gt-的区别？"><a href="#请你来回答一下include头文件的顺序以及双引号””和尖括号-lt-gt-的区别？" class="headerlink" title="请你来回答一下include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别？"></a>请你来回答一下include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别？</h4><p>参考回答：<br>Include头文件的顺序：对于include的头文件来说，如果在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误。<br>双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样。</p>
<p>对于使用双引号包含的头文件，查找头文件路径的顺序为：</p>
<p>当前头文件目录</p>
<p>编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）</p>
<p>系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</p>
<p>对于使用尖括号包含的头文件，查找头文件的路径顺序为：</p>
<p>编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）</p>
<p>系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</p>
<h4 id="请你回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？"><a href="#请你回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？" class="headerlink" title="请你回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？"></a>请你回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？</h4><p>参考回答：<br>Malloc函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。<br>当进行内存分配时，Malloc会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。</p>
<p>Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap在映射区分配。</p>
<h4 id="请你说一说C-的内存管理是怎样的？"><a href="#请你说一说C-的内存管理是怎样的？" class="headerlink" title="请你说一说C++的内存管理是怎样的？"></a>请你说一说C++的内存管理是怎样的？</h4><p>参考回答：<br>在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。<br>代码段:包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。</p>
<p>数据段：存储程序中已初始化的全局变量和静态变量</p>
<p>bss 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。</p>
<p>堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。</p>
<p>映射区:存储动态链接库以及调用mmap函数进行的文件映射</p>
<p>栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值</p>
<h4 id="请你来说一下C-C的内存分配"><a href="#请你来说一下C-C的内存分配" class="headerlink" title="请你来说一下C++/C的内存分配"></a>请你来说一下C++/C的内存分配</h4><p>参考回答：</p>
<p>32bitCPU可寻址4G线性空间，每个进程都有各自独立的4G逻辑地址，其中0~3G是用户态空间，3~4G是内核空间，不同进程相同的逻辑地址会映射到不同的物理地址中。其逻辑地址其划分如下：</p>
<p>各个段说明如下：</p>
<p>3G用户空间和1G内核空间</p>
<p>静态区域：</p>
<p>text segment(代码段):包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。</p>
<p>data segment(数据段)：存储程序中已初始化的全局变量和静态变量</p>
<p>bss segment：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0</p>
<p>动态区域：</p>
<p>heap（堆）： 当进程未调用malloc时是没有堆段的，只有调用malloc时采用分配一个堆，并且在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。分配小内存时使用该区域。  堆的起始地址由mm_struct 结构体中的start_brk标识，结束地址由brk标识。</p>
<p>memory mapping segment(映射区):存储动态链接库等文件映射、申请大内存（malloc时调用mmap函数）</p>
<p>stack（栈）：使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。在创建进程时会有一个最大栈大小，Linux可以通过ulimit命令指定。</p>
<h4 id="请你回答一下如何判断内存泄漏？"><a href="#请你回答一下如何判断内存泄漏？" class="headerlink" title="请你回答一下如何判断内存泄漏？"></a>请你回答一下如何判断内存泄漏？</h4><p>参考回答：<br>内存泄漏通常是由于调用了malloc/new等内存申请的操作，但是缺少了对应的free/delete。为了判断内存是否泄露，我们一方面可以使用linux环境下的内存泄漏检查工具Valgrind,另一方面我们在写代码时可以添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。</p>
<h4 id="请你来说一下什么时候会发生段错误"><a href="#请你来说一下什么时候会发生段错误" class="headerlink" title="请你来说一下什么时候会发生段错误"></a>请你来说一下什么时候会发生段错误</h4><p>参考回答：<br>段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况：<br>使用野指针</p>
<p>试图修改字符串常量的内容</p>
<h4 id="请你来回答一下什么是memory-leak，也就是内存泄漏"><a href="#请你来回答一下什么是memory-leak，也就是内存泄漏" class="headerlink" title="请你来回答一下什么是memory leak，也就是内存泄漏"></a>请你来回答一下什么是memory leak，也就是内存泄漏</h4><p>参考回答：<br>内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。<br>内存泄漏的分类：</p>
<ol>
<li><p>堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.</p>
</li>
<li><p>系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</p>
</li>
<li><p>没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。</p>
</li>
</ol>
<h4 id="请你来回答一下new和malloc的区别"><a href="#请你来回答一下new和malloc的区别" class="headerlink" title="请你来回答一下new和malloc的区别"></a>请你来回答一下new和malloc的区别</h4><p>参考回答：<br>1、new分配内存按照数据类型进行分配，malloc分配内存按照指定的大小分配；<br>2、new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化。</p>
<p>3、new不仅分配一段内存，而且会调用构造函数，malloc不会。</p>
<p>4、new分配的内存要用delete销毁，malloc要用free来销毁；delete销毁的时候会调用对象的析构函数，而free则不会。</p>
<p>5、new是一个操作符可以重载，malloc是一个库函数。</p>
<p>6、malloc分配的内存不够的时候，可以用realloc扩容。扩容的原理？new没用这样操作。</p>
<p>7、new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。</p>
<p>8、申请数组时： new[]一次分配所有内存，多次调用构造函数，搭配使用delete[]，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能sizeof(int) * n。</p>
<h4 id="请你来说一下共享内存相关api"><a href="#请你来说一下共享内存相关api" class="headerlink" title="请你来说一下共享内存相关api"></a>请你来说一下共享内存相关api</h4><p>参考回答：<br>Linux允许不同进程访问同一个逻辑内存，提供了一组API，头文件在sys/shm.h中。<br>1）新建共享内存shmget<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key,<span class="keyword">size_t</span> size,<span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>key：共享内存键值，可以理解为共享内存的唯一性标记。</p>
<p>size：共享内存大小</p>
<p>shmflag：创建进程和其他进程的读写权限标识。</p>
<p>返回值：相应的共享内存标识符，失败返回-1</p>
<p>2）连接共享内存到当前进程的地址空间shmat<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shm_id,<span class="keyword">const</span> <span class="keyword">void</span> *shm_addr,<span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>shm_id：共享内存标识符</p>
<p>shm_addr：指定共享内存连接到当前进程的地址，通常为0，表示由系统来选择。</p>
<p>shmflg：标志位</p>
<p>返回值：指向共享内存第一个字节的指针，失败返回-1</p>
<p>3）当前进程分离共享内存shmdt<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>4）控制共享内存shmctl</p>
<p>和信号量的semctl函数类似，控制共享内存<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shm_id,<span class="keyword">int</span> command,struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>shm_id：共享内存标识符</p>
<p>command: 有三个值</p>
<p>IPC_STAT:获取共享内存的状态，把共享内存的shmid_ds结构复制到buf中。</p>
<p>IPC_SET:设置共享内存的状态，把buf复制到共享内存的shmid_ds结构。</p>
<p>IPC_RMID:删除共享内存</p>
<p>buf：共享内存管理结构体。</p>
<h4 id="请你来说一下reactor模型组成"><a href="#请你来说一下reactor模型组成" class="headerlink" title="请你来说一下reactor模型组成"></a>请你来说一下reactor模型组成</h4><p>参考回答：<br>reactor模型要求主线程只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程，除此之外，主线程不做任何其他实质性的工作，读写数据、接受新的连接以及处理客户请求均在工作线程中完成。其模型组成如下：</p>
<p>1）Handle：即操作系统中的句柄，是对资源在操作系统层面上的一种抽象，它可以是打开的文件、一个连接(Socket)、Timer等。由于Reactor模式一般使用在网络编程中，因而这里一般指Socket Handle，即一个网络连接。</p>
<p>2）Synchronous Event Demultiplexer（同步事件复用器）：阻塞等待一系列的Handle中的事件到来，如果阻塞等待返回，即表示在返回的Handle中可以不阻塞的执行返回的事件类型。这个模块一般使用操作系统的select来实现。</p>
<p>3）Initiation Dispatcher：用于管理Event Handler，即EventHandler的容器，用以注册、移除EventHandler等；另外，它还作为Reactor模式的入口调用Synchronous Event Demultiplexer的select方法以阻塞等待事件返回，当阻塞等待返回时，根据事件发生的Handle将其分发给对应的Event Handler处理，即回调EventHandler中的handle_event()方法。</p>
<p>4）Event Handler：定义事件处理方法：handle_event()，以供InitiationDispatcher回调使用。</p>
<p>5）Concrete Event Handler：事件EventHandler接口，实现特定事件处理逻辑。</p>
<h4 id="请自己设计一下如何采用单线程的方式处理高并发"><a href="#请自己设计一下如何采用单线程的方式处理高并发" class="headerlink" title="请自己设计一下如何采用单线程的方式处理高并发"></a>请自己设计一下如何采用单线程的方式处理高并发</h4><p>参考回答：<br>在单线程模型中，可以采用I/O复用来提高单线程处理多个请求的能力，然后再采用事件驱动模型，基于异步回调来处理事件来</p>
<h4 id="请你说一说C-STL-的内存优化"><a href="#请你说一说C-STL-的内存优化" class="headerlink" title="请你说一说C++ STL 的内存优化"></a>请你说一说C++ STL 的内存优化</h4><p>参考回答：</p>
<p>1）二级配置器结构<br>STL内存管理使用二级内存配置器。<br>1、第一级配置器<br>第一级配置器以malloc()，free()，realloc()等C函数执行实际的内存配置、释放、重新配置等操作，并且能在内存需求不被满足的时候，调用一个指定的函数。<br>一级空间配置器分配的是大于128字节的空间<br>如果分配不成功，调用句柄释放一部分内存<br>如果还不能分配成功，抛出异常<br>2、第二级配置器<br>在STL的第二级配置器中多了一些机制，避免太多小区块造成的内存碎片，小额区块带来的不仅是内存碎片，配置时还有额外的负担。区块越小，额外负担所占比例就越大。<br>3、分配原则<br>如果要分配的区块大于128bytes，则移交给第一级配置器处理。<br>如果要分配的区块小于128bytes，则以内存池管理（memory pool），又称之次层配置（sub-allocation）：每次配置一大块内存，并维护对应的16个空闲链表（free-list）。下次若有相同大小的内存需求，则直接从free-list中取。如果有小额区块被释放，则由配置器回收到free-list中。<br>当用户申请的空间小于128字节时，将字节数扩展到8的倍数，然后在自由链表中查找对应大小的子链表<br>如果在自由链表查找不到或者块数不够，则向内存池进行申请，一般一次申请20块<br>如果内存池空间足够，则取出内存<br>如果不够分配20块，则分配最多的块数给自由链表，并且更新每次申请的块数<br>如果一块都无法提供，则把剩余的内存挂到自由链表，然后向系统heap申请空间，如果申请失败，则看看自由链表还有没有可用的块，如果也没有，则最后调用一级空间配置器<br>2）二级内存池<br>二级内存池采用了16个空闲链表，这里的16个空闲链表分别管理大小为8、16、24……120、128的数据块。这里空闲链表节点的设计十分巧妙，这里用了一个联合体既可以表示下一个空闲数据块（存在于空闲链表中）的地址，也可以表示已经被用户使用的数据块（不存在空闲链表中）的地址。</p>
<p>1、空间配置函数allocate<br>首先先要检查申请空间的大小，如果大于128字节就调用第一级配置器，小于128字节就检查对应的空闲链表，如果该空闲链表中有可用数据块，则直接拿来用（拿取空闲链表中的第一个可用数据块，然后把该空闲链表的地址设置为该数据块指向的下一个地址），如果没有可用数据块，则调用refill重新填充空间。<br>2、空间释放函数deallocate<br>首先先要检查释放数据块的大小，如果大于128字节就调用第一级配置器，小于128字节则根据数据块的大小来判断回收后的空间会被插入到哪个空闲链表。<br>3、重新填充空闲链表refill<br>在用allocate配置空间时，如果空闲链表中没有可用数据块，就会调用refill来重新填充空间，新的空间取自内存池。缺省取20个数据块，如果内存池空间不足，那么能取多少个节点就取多少个。<br>从内存池取空间给空闲链表用是chunk_alloc的工作，首先根据end_free-start_free来判断内存池中的剩余空间是否足以调出nobjs个大小为size的数据块出去，如果内存连一个数据块的空间都无法供应，需要用malloc取堆中申请内存。<br>假如山穷水尽，整个系统的堆空间都不够用了，malloc失败，那么chunk_alloc会从空闲链表中找是否有大的数据块，然后将该数据块的空间分给内存池（这个数据块会从链表中去除）。<br>3、总结：</p>
<ol>
<li>使用allocate向内存池请求size大小的内存空间，如果需要请求的内存大小大于128bytes，直接使用malloc。</li>
<li>如果需要的内存大小小于128bytes，allocate根据size找到最适合的自由链表。<br>a. 如果链表不为空，返回第一个node，链表头改为第二个node。<br>b. 如果链表为空，使用blockAlloc请求分配node。<br>x. 如果内存池中有大于一个node的空间，分配竟可能多的node(但是最多20个)，将一个node返回，其他的node添加到链表中。<br>y. 如果内存池只有一个node的空间，直接返回给用户。<br>z. 若果如果连一个node都没有，再次向操作系统请求分配内存。<br>①分配成功，再次进行b过程。<br>②分配失败，循环各个自由链表，寻找空间。<br>I. 找到空间，再次进行过程b。<br>II. 找不到空间，抛出异常。</li>
<li>用户调用deallocate释放内存空间，如果要求释放的内存空间大于128bytes，直接调用free。</li>
<li>否则按照其大小找到合适的自由链表，并将其插入。<h4 id="请你说说select，epoll的区别，原理，性能，限制都说一说"><a href="#请你说说select，epoll的区别，原理，性能，限制都说一说" class="headerlink" title="请你说说select，epoll的区别，原理，性能，限制都说一说"></a>请你说说select，epoll的区别，原理，性能，限制都说一说</h4>参考回答：<br>1）IO多路复用<br>IO复用模型在阻塞IO模型上多了一个select函数，select函数有一个参数是文件描述符集合，意思就是对这些的文件描述符进行循环监听，当某个文件描述符就绪的时候，就对这个文件描述符进行处理。</li>
</ol>
<p>这种IO模型是属于阻塞的IO。但是由于它可以对多个文件描述符进行阻塞监听，所以它的效率比阻塞IO模型高效。</p>
<p>IO多路复用就是我们说的select，poll，epoll。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p>
<p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<p>所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p>
<p>I/O多路复用和阻塞I/O其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p>
<p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p>
<p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>
<p>2、select</p>
<p>select：是最初解决IO阻塞问题的方法。用结构体fd_set来告诉内核监听多个文件描述符，该结构体被称为描述符集。由数组来维持哪些描述符被置位了。对结构体的操作封装在三个宏定义中。通过轮寻来查找是否有描述符要被处理。</p>
<p>存在的问题：</p>
<ol>
<li><p>内置数组的形式使得select的最大文件数受限与FD_SIZE；</p>
</li>
<li><p>每次调用select前都要重新初始化描述符集，将fd从用户态拷贝到内核态，每次调用select后，都需要将fd从内核态拷贝到用户态；</p>
</li>
<li><p>轮寻排查当文件描述符个数很多时，效率很低；</p>
</li>
</ol>
<p>3、poll</p>
<p>poll：通过一个可变长度的数组解决了select文件描述符受限的问题。数组中元素是结构体，该结构体保存描述符的信息，每增加一个文件描述符就向数组中加入一个结构体，结构体只需要拷贝一次到内核态。poll解决了select重复初始化的问题。轮寻排查的问题未解决。</p>
<p>4、epoll</p>
<p>epoll：轮寻排查所有文件描述符的效率不高，使服务器并发能力受限。因此，epoll采用只返回状态发生变化的文件描述符，便解决了轮寻的瓶颈。</p>
<p>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式</p>
<ol>
<li>LT模式</li>
</ol>
<p>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p>
<ol>
<li>ET模式</li>
</ol>
<p>ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p>
<p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<p>3、LT模式与ET模式的区别如下：<br>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。<br>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>
<h4 id="请问C-11有哪些新特性？"><a href="#请问C-11有哪些新特性？" class="headerlink" title="请问C++11有哪些新特性？"></a>请问C++11有哪些新特性？</h4><p>参考回答：<br>C++11 最常用的新特性如下：<br>auto关键字：编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类型的推导</p>
<p>nullptr关键字：nullptr是一种特殊类型的字面值，它可以被转换成任意其它的指针类型；而NULL一般被宏定义为0，在遇到重载时可能会出现问题。</p>
<p>智能指针：C++11新增了std::shared_ptr、std::weak_ptr等类型的智能指针，用于解决内存管理的问题。</p>
<p>初始化列表：使用初始化列表来对类进行初始化</p>
<p>右值引用：基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率</p>
<p>atomic原子操作用于多线程资源互斥操作</p>
<p>新增STL容器array以及tuple</p>
]]></content>
      <categories>
        <category>工作面试</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ primer-不适合入门</title>
    <url>/2019/09/15/58540.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一本合适的入门书能让你学习的时候信心倍增，如饥似渴，而一本不合适的入门书让你望而却步，怀疑人生。<br><a id="more"></a></p>
<h2 id="它很优秀"><a href="#它很优秀" class="headerlink" title="它很优秀"></a>它很优秀</h2><p>C++相对于其他语言来说，是一门较为复杂的语言，<strong>传言一年精通，三年熟悉，五年了解，十年用过</strong>。关于C++的言论实在太多，鉴于本人使用年限极短，不多做评价。那么我们来看看《C++ Primer》（注意，不是C++ primer plus）这本评分9.3分的书，它好在哪里？在我看来，这几个方面是非常不错的：</p>
<ul>
<li><strong>事无巨细</strong>，从基本类型到字符串，向量和数组，从基本语句到函数；从类到容器，从动态内存到拷贝控制，从面向对象到模板泛型，它几乎涵盖了C++的各个方面，这也是为什么它是一块大钻头的原因之一。</li>
<li><strong>告诉你编译器怎么想</strong>。例如在介绍类的时候，告诉你编译器先编译成员的声明，然后再编译成员的函数体。在书中，有很多地方都告诉了你，编译器是如何做的，除此之外还会告诉你为什么要这样做，让你知其然，更知其所以然。</li>
<li><strong>最佳实践建议</strong>。一般来说，一段代码，能用就可以了，但为了保证代码生命力的长久，你必须去了解最佳实践。例如建议你尽量使用标准库类型而不是数组类型；尽量避免使用内置数组和指针等。</li>
<li><strong>贴心的注意事项</strong>。同样在书中很多地方告诉你，应该如何避免一些不推荐的操作，例如在说到string的时候，特别说明了字符串字面值与string是不同的类型；在说到命名空间的时候，建议不应该在头文件中使用using声明。</li>
<li><strong>一章结尾小结和的术语表</strong>。看完这一章了？不如看看最后的小结，看看本章核心内容是什么？感受到C++的复杂了？看看本章的术语你都了解了没有。</li>
<li><strong>新特性</strong>。在第五版中，最后一部分列出了C++11的新特性的索引。可以方便快速的了解C++11的新特性。</li>
<li><strong>配套的习题和完整可运行代码</strong>，并且有多种版本。地址：<a href="http://www.informit.com/store/c-plus-plus-primer-9780321714114" target="_blank" rel="noopener">http://www.informit.com/store/c-plus-plus-primer-9780321714114</a></li>
<li><strong>可以当手册</strong>。当某个特性不是很清楚的时候，拿起来翻翻查看一下。</li>
</ul>
<h2 id="但不一定适合你"><a href="#但不一定适合你" class="headerlink" title="但不一定适合你"></a>但不一定适合你</h2><p>而正由于上面这些特点，它可能不适合初学者，其不适合的原因也非常明显：</p>
<ul>
<li>内容过多，让初学者望而却步，不知重点。在实践中，<strong>也不必全面地使用C++语言的各种特性</strong>。</li>
<li>虽然与书配套有完整的代码，但从书中内容来看，很难清楚书中代码该如何运行，可操作性对初学者来说难度比较大，也不利于快速上手。</li>
<li>部分内容过深，初学者看的时候不知所云，容易受挫，自我怀疑。很多内容在讲解的时候，假设你已经懂了相关的前置知识，然而你可能不懂这些前置知识，到底难以继续。</li>
<li>第一章从hello world到类，直接上命令行。作为新手的你，可能一脸懵逼。​</li>
<li><strong>近千页，容易变砖</strong>。</li>
</ul>
<p>就像《C程序设计语言》一样，C++ primer并不适合没有编程基础的初学者，但是绝对适合C++学习者一读再读。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>它很优秀，但不一定适合你。如果你有一定的编程基础，或者已经通过其他入门书籍学习了C++，那么建议你阅读。</p>
<h2 id="再说两句"><a href="#再说两句" class="headerlink" title="再说两句"></a>再说两句</h2><ul>
<li>如果你阅读了本书，觉得难，也不要怀疑，因为它不适合初学者</li>
<li>语言特性之外还有诸如编译链接，内存管理等诸多知识需要了解。</li>
<li>好不一定适合自己，具体情况具体分析。</li>
<li>以上纯属个人观点，仅供参考。</li>
</ul>
<p>不说了，显示器不够高了，垫一下。</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么说++i比i++效率高？</title>
    <url>/2019/09/09/58833.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不知道你是否听说过++i比i++快的说法，真的如此吗？<br><a id="more"></a></p>
<h2 id="i与i-的区别"><a href="#i与i-的区别" class="headerlink" title="++i与i++的区别"></a>++i与i++的区别</h2><p>这两个表达式从我们初学编程语言的时候就会接触到。<strong>前者是自增后取值，后者是取值后自增</strong>。<br>我们看一个简单的例子。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a++;<span class="comment">//int tmp = a;c=a;a = a + 1</span></span><br><span class="line">    <span class="keyword">int</span> d = ++b;<span class="comment">//b = b + 1;d = b;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c="</span>&lt;&lt;c&lt;&lt;<span class="string">";d="</span>&lt;&lt;d&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c=0;d=1</span><br></pre></td></tr></table></figure></p>
<p>对于这个结果我们并不感到意外。</p>
<p>另外我们还注意到另外一个有意思的现象：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】地址：https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *c = &amp;(a++);</span><br><span class="line">    <span class="keyword">int</span> *d = &amp;(++b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译后报错：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main.cpp:7:19: error: lvalue required as unary ‘&amp;’ operand</span><br><span class="line">     int *c = &amp;(a++);</span><br></pre></td></tr></table></figure></p>
<p>说&amp;作用于左值，也就是说a++的结果并非左值。但++b的结果是。</p>
<p>可简单理解左值和右值：</p>
<ul>
<li>左值，有名对象，可赋值</li>
<li>右值，临时对象，不可被赋值</li>
</ul>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>在《<a href="https://www.yanbinghu.com/2019/09/05/53807.html">运算符重载</a>》一文中已经说到了运算符的重载，通过前面的例子也发现了，对于内置类型，前置自增返回对象的引用，而后置自增返回对象的原值（但非左值）。<br>基于上述原则，一个前置版本和后置版本的常见实现如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】地址：https://www.yanbinghu.com</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test&amp; <span class="keyword">operator</span>++();<span class="comment">//前置自增</span></span><br><span class="line">    <span class="keyword">const</span> Test <span class="keyword">operator</span>++(<span class="keyword">int</span>);<span class="comment">//后置自增</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> curPos; <span class="comment">//当前位置</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*前置自增实现范式*/</span></span><br><span class="line">Test&amp; Test::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">    ++curPos;      <span class="comment">//自增</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">//取值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*后置自增实现范式，为了与前置区分开，多了一个int参数，但从来没用过*/</span></span><br><span class="line"><span class="keyword">const</span> Test Test::<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Test tmp = *<span class="keyword">this</span>;  <span class="comment">//取值</span></span><br><span class="line">    ++curPos;             <span class="comment">//自增</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>仔细观察后，我们发现前置自增，先自增，后返回原对象的对象；没有产生任何临时对象；而后置自增，先保存原对象，然后自增，最后返回该原临时对象，那么它就需要创建和销毁，这样一来，效率孰高孰低就很清楚了。</p>
<p>在不进行赋值的情况下，内置类型前置和后置自增的汇编都是一样的呢！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  i++;</span><br><span class="line">  <span class="comment">//++i;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>汇编:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push    rbp</span><br><span class="line">mov     rbp, rsp</span><br><span class="line">mov     DWORD PTR [rbp-4], 0</span><br><span class="line">add     DWORD PTR [rbp-4], 1</span><br><span class="line">nop</span><br><span class="line">pop     rbp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure></p>
<p>不过，赋值的情况下，并且不开启编译器优化，它们的汇编代码还是有差别的，有兴趣的可以试试。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于内置类型，前置和后置自增或者自减在编译器优化的情况下，两者并无多大差别，而对于自定义类型，如无特别需要，人们似乎更加偏爱前置自增或自减，因为后置自增常常会产生临时对象。</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么计算器计算10%+10%=0.11？</title>
    <url>/2019/09/09/31279.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近日，关于手机计算器10%+10%=0.11的事情火热，多个品牌的手机未能幸免，基本“阵亡”，同时还包括了windows10的自带标准计算器。你的手机阵亡了吗？</p>
<p>%10+10%按理应该等于0.2，为什么会出现这样的情况？<br>那么这是计算器的BUG？还是另有隐情？是程序员的不负责任，还是另有考虑？<br><a id="more"></a></p>
<h2 id="真实情况"><a href="#真实情况" class="headerlink" title="真实情况"></a>真实情况</h2><p>到底是怎么回事呢？实际上，这些计算器并不是为数学家和工程师准备的，但%的引入，却可以极大方便计算折扣，税率，小费等。比如一件100元的衣服，折扣20%：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100 - 20%</span><br><span class="line">80</span><br></pre></td></tr></table></figure></p>
<p>实际上它计算的是<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100 - (100*20%)</span><br></pre></td></tr></table></figure></p>
<p>早期计算器的按键比较少，没有括号，能显示的字符长度也有限，因此%在这种场景下能解决痛点，极大减少按键数量。</p>
<p>当然了国内我们通常见到的是打几折，不过国外的网站是这样的：<br><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/calc/off.jpg" alt="off"></p>
<p>折扣通常都会用类似10% off这样的表达。针对这种表达的计算方式也逐渐成为了一种”标准“，所以在我们的很多计算器中都有。</p>
<p>所以10%+10%实际上计算的是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10% + 10% * 10%</span><br><span class="line">= 0.11</span><br></pre></td></tr></table></figure></p>
<p>但是对于国内的用户来说，如果计算器没有括号你会怎么计算？你可能是会按照下面这样：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100 * 0.8</span><br><span class="line">= 80</span><br></pre></td></tr></table></figure></p>
<p>毕竟是受过九年义务教育的优秀青年，小数还不会么？</p>
<p>同时你也可以看到在微软自带的计算器（win+r,输入calc回车即可打开）中，标准型计算器有%：<br><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/calc/std.jpg" alt="std"></p>
<p>不过它计算10%+10%计算得出的值可能每次都不一样，我们稍后解释。</p>
<p>而科学型和程序员型中，压根没有%运算符，通常也不会用百分数直接计算，而是用小数。<br><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/calc/sci.jpg" alt="sci"></p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/calc/pro.jpg" alt="pro"></p>
<p>那么在标准计算器或者说这些简单功能的计算器中%到底是什么作用呢？</p>
<blockquote>
<p>来源：公众号【编程珠玑】<br>ID:shouwangxiansheng<br>​博客：<a href="https://www.yanbinghu.com">https://www.yanbinghu.com</a></p>
</blockquote>
<h2 id="从代码角度来看"><a href="#从代码角度来看" class="headerlink" title="从代码角度来看"></a>从代码角度来看</h2><p>作为一个程序员，自然要从代码的角度来看了。为此我在github上找到了微软开源的计算器项目，其地址为：<br><a href="https://github.com/microsoft/calculator/" target="_blank" rel="noopener">https://github.com/microsoft/calculator/</a></p>
<p>我找到关于%计算的部分，摘出了其中相关的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> IDC_PERCENT:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// If the operator is multiply/divide, we evaluate this as "X [op] (Y%)"</span></span><br><span class="line">    <span class="comment">// Otherwise, we evaluate it as "X [op] (X * Y%)"</span></span><br><span class="line">    <span class="keyword">if</span> (m_nOpCode == IDC_MUL || m_nOpCode == IDC_DIV)</span><br><span class="line">    &#123;</span><br><span class="line">        result = rat / <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        result = rat * (m_lastVal / <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释中也已经解释了（论一个好注释的重要性），当操作符是乘法或者除法的时候，与%相关的直接除以100再和另外的数操作（即我们通常认识的算法），否则就按照<strong>上一次结果</strong>的百分比来计算。<br>所以，如果你计算10%+10%，它是下面的过程：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">结果 操作</span><br><span class="line">0    初始值</span><br><span class="line">0    输入10%，计算0 + 10% * 0</span><br><span class="line">0    输入+10%，计算0 + 10 *0</span><br></pre></td></tr></table></figure></p>
<p>最终会得到0。只不过很多手机计算器中直接把第一个10%当成了0.1，这也就是我们看到一些手机计算器最终会得到0.11结果的原因。</p>
<p>但是如果你计算100 * 10%，它按照原始的方式计算，即计算得到10。</p>
<p><strong>所以这是有意为之，而并非什么bug</strong>！ 程序员不背这个锅。</p>
<p>另外我们都知道，%常用于取模运算，它是一个二元运算符，例如：<br>10%3 = 1</p>
<p>所以当你在Linux的命令行输入bc，然后输入10+10%，你会看到下面的结果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bc</span><br><span class="line">10+10%</span><br><span class="line">(standard_in) 3: syntax error</span><br><span class="line">10%3</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<p>没错，它会提示你语法错误，而不是帮你计算10的10%，因为这里的%并非计算百分数，而是用来取模的。所以在windows自带的程序员计算器和科学计算器中，有MOD，而没有%。</p>
<p>注：bc命令是Linux一个强大的计算器。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>%在某些场景方便计算，<strong>这不是bug，而是feature</strong>。</p>
<h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><ul>
<li>你觉得有必要使用这种计算方式吗？欢迎留言说出你的看法！</li>
<li>你的手机”阵亡“了吗？</li>
</ul>
]]></content>
      <categories>
        <category>程序员</category>
      </categories>
      <tags>
        <tag>程序员</tag>
      </tags>
  </entry>
  <entry>
    <title>C++运算符重载</title>
    <url>/2019/09/05/53807.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文要点：</p>
<ul>
<li>什么是运算符重载</li>
<li>为什么要重载运算符</li>
<li>哪些运算符不可以重载</li>
<li>哪些运算符不建议重载</li>
<li>应该遵循哪些原则</li>
<li>如何重载运算符</li>
</ul>
<a id="more"></a>
<h2 id="什么是运算符重载"><a href="#什么是运算符重载" class="headerlink" title="什么是运算符重载"></a>什么是运算符重载</h2><p>如果还不知道什么是重载，可以参考《<a href="https://www.yanbinghu.com/2018/11/27/34641.html">什么是函数重载</a>》和《<a href="https://www.yanbinghu.com/2019/01/01/6209.html">彻底理清重载函数匹配</a>》。<br>众所周知，运算符可直接作用于内置类型。例如，+可以用于将整型或者浮点型相加，如果是自定义的两个对象，你却不能直接进行相加，不过你可以通过重载运算符赋予这个运算符新的定义，</p>
<p>说白了，原先的<strong>很多运算符只能作用于内置类型，通过重载就可以赋予它们更多的含义</strong>，让它们可以作用于对象。<br><!--more--></p>
<h2 id="为什么要重载运算符"><a href="#为什么要重载运算符" class="headerlink" title="为什么要重载运算符"></a>为什么要重载运算符</h2><p>前面也已经说了，操作符的重载可以让运算符作用于类类型的对象，而对于有些作用于对象的运算符，也可以在不改变含义的情况下自定义操作，那么为什么要这么做呢？很显然，它能非常方便地操作对象又不能保持其操作的含义明确。</p>
<p>重载运算符让运算符有新的语义，但绝对不是改变它的语法。</p>
<h2 id="哪些运算符不可以重载"><a href="#哪些运算符不可以重载" class="headerlink" title="哪些运算符不可以重载"></a>哪些运算符不可以重载</h2><p>可重载地运算符很多，所以这里列出不能被重载的运算符：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">::    .*   .    ? :</span><br></pre></td></tr></table></figure></p>
<p>简单解释一下有何不妥：</p>
<ul>
<li>:: .* . 这三者的后部分作用于变量名，而不是某个具体值，仅访问而非操作，重载后语义将改变</li>
<li>?: 对于表达式exp0?exp1:exp2，重载后是执行exp1还是exp2，还是都执行？是不是和它的本意有差别？</li>
</ul>
<p>以上两点非准确说法，仅供参考，欢迎提供更多思路。</p>
<h2 id="如何重载"><a href="#如何重载" class="headerlink" title="如何重载"></a>如何重载</h2><p>运算符重载函数的函数名由operator后面跟着要重载的运算符组成。例如，我们有一个对象Water，要重载+运算符：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Water&amp; <span class="keyword">operator</span>+(Water &amp;b1,Water &amp;b2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*do something</span></span><br><span class="line"><span class="comment">    假设是将水的重量相加</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>后面我们就可以直接这样使用啦：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Water b1;</span><br><span class="line">Water b2;</span><br><span class="line">b1 + b2;</span><br></pre></td></tr></table></figure></p>
<p>这里b1+b2相当于下面的调用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">operator+(b1,b2);</span><br></pre></td></tr></table></figure></p>
<p>在运算符重载里面，要特别提一下++，即自增运算符，我们都知道自增运算符有前置和后置，但是它们作用的对象数量都是一个，该怎么区分呢？</p>
<p>为了区分这两种情况，C++为后置版本增加了一个额外的int类型参数。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后置版本</span></span><br><span class="line">Water Water::<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*do something*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前置版本</span></span><br><span class="line">Water&amp; Water::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*do something*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>来源：公众号【编程珠玑】，网址：<a href="https://www.yanbinghu.com">https://www.yanbinghu.com</a></p>
</blockquote>
<h2 id="应该遵循哪些原则"><a href="#应该遵循哪些原则" class="headerlink" title="应该遵循哪些原则"></a>应该遵循哪些原则</h2><p>重载的运算符本质来说是特殊的函数，因此<strong>它的参数数量应该和运算符作用的对象一样多</strong>，也就是说，一元运算符有一个参数，二元运算符有两个参数。</p>
<p>除此之外，最基本的要求是，<strong>重载的含义应该与运算符作用于内置类型时一样的含义</strong>。例如说，你不应该重载一个+，用于两个对象的的比较或者相减。另外也重载也能非常明显地体现其含义，比如前面例子中的Water的相加，就显得不是特别好，Water相加是什么意思？</p>
<p>还有就是不能重定义内置运算符，看下面的例子：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">operator</span>+(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a *<span class="number">2</span> + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译将会报错：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main.cpp:2:26: error: ‘int operator+(int, int)’ must have an argument of class or enumerated type</span><br><span class="line"> int operator+(int a,int b)</span><br><span class="line">                          ^</span><br></pre></td></tr></table></figure></p>
<p>提示说，其参数类型必须是类或者枚举类型。</p>
<p>实际上，一个运算符函数<strong>至少含有一个类类型或者枚举类型的参数</strong></p>
<h2 id="哪些不建议重载"><a href="#哪些不建议重载" class="headerlink" title="哪些不建议重载"></a>哪些不建议重载</h2><p>由于重载的运算符本质是函数，因此对于<strong>那些对作用对象求值顺序有要求的运算符应该尽量避免重载</strong>，例如逻辑运算符，逗号运算符等。</p>
<p>举例来说，||和&amp;&amp;具有短路属性：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a || b || c</span><br></pre></td></tr></table></figure></p>
<p>我们都知道，当表达式a为true时，b和c将不会被求值，<br>但是如果重载了||，并将它作用于重载对象，那它将不会有此性质，而是三个表达式都会求值。因此如果想要重载后的运算符也有短路性质，你是很难期望了。</p>
<p>注意，这里<strong>不建议并非不能重载</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>篇幅有限，本文不对具体的运算符重载进行详细介绍，但至少对运算符的重载有基本的概念，了解之后，再去了解更多的特定运算符重载原则。</p>
<p>最后：不要滥用运算符重载。</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>一句话帮你理解typedef的用法</title>
    <url>/2019/09/01/25828.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在C语言中typedef用来给复杂声明定义别名非常的方便，不过有时候typedef在复杂声明中不好理解。本文关键的一句话帮你理解ytpedef的用法。<br><a id="more"></a></p>
<h2 id="typedef常见应用场景"><a href="#typedef常见应用场景" class="headerlink" title="typedef常见应用场景"></a>typedef常见应用场景</h2><p>在这之前，我们来看看一些常见应用场景。</p>
<h4 id="场景一：为特定含义的类型取别名"><a href="#场景一：为特定含义的类型取别名" class="headerlink" title="场景一：为特定含义的类型取别名"></a>场景一：为特定含义的类型取别名</h4><p>例如，假设速度是整型值：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef int SpeedType;</span><br></pre></td></tr></table></figure></p>
<p>那么你就可以像下面这样使用了：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SpeedType;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SpeedType s = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"speed is %d m/s"</span>,s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在main函数中，你可以直接使用SpeedType作为一种类型来定义变量了。有人可能问了，为什么要这样，直接使用int不是更好吗？那么如果你的代码中很多地方都用到了这个，但是突然有一天不再使用int，而是使用long呢？是不是直接修改typedef部分就可以了？（当然打印的地方也需要变，可自定义打印函数），另外一方面，通过SpeedType这个名字就可以非常直接的读懂变量的含义。</p>
<p>事实上，size_t，socklen_t等类型都是类似的定义。</p>
<p>说到typedef，就需要提一下define了，define只是一个字符串简单替换。当然下面这样的例子你可能见过很多次了：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIONTER int*</span></span><br><span class="line">PIONTER a,b; <span class="comment">//等同于int* a,b;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>* POINTER1</span><br><span class="line">POINTER1 c,d;<span class="comment">//等同于int *c;int *d;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="为结构体取别名"><a href="#为结构体取别名" class="headerlink" title="为结构体取别名"></a>为结构体取别名</h4><p>这个也比较常见，不过有的人认为，为结构体取别名并不是一个明智的选择，因为它在使用的时候不能直观看到它是结构体类型了。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>那么你在声明变量的时候，需要带上struct，即像下面这样使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct info var;</span><br></pre></td></tr></table></figure></p>
<p>但是如果你用typedef取个别名呢？<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;Info;</span><br></pre></td></tr></table></figure></p>
<p>你就可以像下面这样使用了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Info var;</span><br></pre></td></tr></table></figure></p>
<h4 id="声明函数指针类型"><a href="#声明函数指针类型" class="headerlink" title="声明函数指针类型"></a>声明函数指针类型</h4><p>前面的都很好理解，那么来看看函数指针：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>*(*Fun)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure></p>
<p>这里将返回类型为void *，入参为int的函数类型命名为Fun，那么在其他地方，就可以像下面这样使用啦：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】，博客地址：https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>*(*Fun)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">test</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d\n"</span>,a,b);</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Fun myfun = test;<span class="comment">//这里的Fun已经是一种类型名了</span></span><br><span class="line">    myfun(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>是不是发现跟前面的不一样了呢？类型别名的位置飘忽不定，有的在最后，有的在中间。</p>
<p>关于函数指针应用方面的介绍这里不展开，有兴趣的可以参数《<a href="https://www.yanbinghu.com/2019/01/03/3593.html">高级指针话题-函数指针</a>》。</p>
<p>当然typedef的场景并不限于以上几种，这里仅仅是举例。</p>
<h2 id="一句话理解"><a href="#一句话理解" class="headerlink" title="一句话理解"></a>一句话理解</h2><p>我不知道你是不是已经完全理解了前面的场景，无论理解与否，这句话都能很好的帮助你再次理解前面的内容：<br><strong>typedef中声明的类型在变量名的位置出现</strong>。</p>
<p>什么意思呢，我们回头来看。我们是怎么声明int类型变量的？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int Typename;</span><br></pre></td></tr></table></figure></p>
<p>像上面这样，对不对？那么用typedef之后呢？把变量名的位置替换为别名：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Typename;</span><br></pre></td></tr></table></figure></p>
<p>好了，你现在已经把为int取别名为Typename。</p>
<p>再来看结构体，声明普通结构体变量：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span> <span class="title">Typename</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>用typedef取别名，别名取代变量名的位置：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">info</span> <span class="title">Typename</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>好了，你现在已经为struct info取别名为Typename。<br>当然这可能我们平常通常使用下面这种写法：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;Typename;</span><br></pre></td></tr></table></figure></p>
<p>再来看函数指针类型，我们平常是如何声明函数的？<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">function</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>那么使用typedef取别名呢？用别名取代函数名的位置即可：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *(*Fun)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure></p>
<p>不过这里需要注意用括号将这个别名括起来，并在前面加*号。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，相信你对typedef的使用有了更清晰的认识了。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>root用户也无法删除文件？</title>
    <url>/2019/09/01/6845.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在你的印象中，是不是root用户就可以为所欲为呢？随便一个rm -rf *，一波骚操作走人？可能没那么容易。<br><a id="more"></a></p>
<h2 id="来啊，删我啊！"><a href="#来啊，删我啊！" class="headerlink" title="来啊，删我啊！"></a>来啊，删我啊！</h2><p>先来个示例，创建一个文本文件test.txt<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ touch test.txt</span><br></pre></td></tr></table></figure></p>
<p>将其权限位修改为777<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ chmod 777 test.txt</span><br><span class="line">$ ls -al test.txt</span><br><span class="line">-rwxrwxrwx 1 root root 13 Aug 31 15:03 test.txt</span><br></pre></td></tr></table></figure></p>
<p>然后做一点暂时不告诉你的小操作。最后尝试删除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rm test.txt</span><br><span class="line">rm: cannot remove ‘test.txt’: Operation not permitted</span><br></pre></td></tr></table></figure>
<p>咦？root用户，777权限位，为什么还删不掉？</p>
<h2 id="i属性"><a href="#i属性" class="headerlink" title="i属性"></a>i属性</h2><p>那么我在中间做了一个什么操作呢？实际上只是执行了一条命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chattr +i test.txt</span><br></pre></td></tr></table></figure></p>
<p>就导致了前面我们看到的效果。Linux中的文件除了我们能看到的内容外，还有一些文件属性，其中，i属性用于防止文件被修改，重命名，删除。在执行前面的命令之后，我们可以通过下面的方式查看其属性：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ lsattr test.txt</span><br><span class="line">----i--------e-- test.txt</span><br></pre></td></tr></table></figure></p>
<p>如果想要移除该属性，只需要执行；<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chattr -i test.txt</span><br></pre></td></tr></table></figure></p>
<p>这个时候就可以删除啦。当然了，仅有超级用户可以对这个属性进行修改。所以说，root用户为所欲为还是可以的，不过得加点小操作。</p>
<blockquote>
<p>来源：公众号【编程珠玑】，博客：<a href="https://www.yanbinghu.com">https://www.yanbinghu.com</a></p>
</blockquote>
<h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><p>实际上除了前面说的i属性，还有其他属性，包括：</p>
<ul>
<li>a 只能以追加的方式打开文件写（适用于日志文件）</li>
<li>A 不更新文件的atime，即访问时间</li>
<li>d dump命令运行时，不进行备份操作</li>
<li>S 文件有更新时便写磁盘，等同于对文件使用sync</li>
</ul>
<p>还有其他属性就不一一列举了，有兴趣的可以参考man手册。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以如果你发现有的文件权限位是777，但是用root用户也没法删除，不如使用lsattr看看是不是有i属性。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么建议你用nullptr而不是NULL</title>
    <url>/2019/08/25/36794.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在C语言中，我们常常用NULL作为指针变量的初始值，而在C++中，却不建议你这么做。<br><a id="more"></a></p>
<h2 id="NULL是什么"><a href="#NULL是什么" class="headerlink" title="NULL是什么"></a>NULL是什么</h2><p>在《<a href="https://www.yanbinghu.com/2019/08/19/18180.html">NULL,0,’\0’,”0”,”\0”的区别</a>》一文中，我们已经知道了在C中NULL是什么，在C的头文件中，通常定义如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define NULL ((void*)0)</span><br></pre></td></tr></table></figure></p>
<p>但是在C++中，它是这样定义的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define NULL 0</span><br></pre></td></tr></table></figure></p>
<p>或者你可以在stddef.h看到完整的这段：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> NULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__cplusplus)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void *)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>也就是说，在C++中，NULL不过也是0罢了（C++11中，也可以是nullptr），把它当成空指针只是一个无可奈何的选择罢了。</p>
<p>那么为什么在C++和C中不一样呢？因为C++中不能将void *类型的指针<strong>隐式转换</strong>成其他指针类型，从下面的例子可以看出来：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//null.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> p[] = <span class="string">"12345"</span>;</span><br><span class="line">    <span class="keyword">int</span> *a = (<span class="keyword">void</span>*)p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ g+ -o null null.cpp</span><br><span class="line">null.cpp: In function &apos;int main()&apos;:</span><br><span class="line">null.cpp:5:17: error: invalid conversion from &apos;void*&apos; to &apos;int*&apos; [-fpermissive]</span><br><span class="line">  int *a = (void*)p;</span><br></pre></td></tr></table></figure></p>
<p>所以不能将NULL定义为(void*)0。</p>
<h2 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h2><p>nullptr并非整型类别，甚至也不是指针类型，但是能转换成任意指针类型。nullptr的实际类型是std:nullptr_t。</p>
<blockquote>
<p>来源：公众号【编程珠玑】，<a href="https://www.yanbinghu.com">https://www.yanbinghu.com</a></p>
</blockquote>
<h2 id="为什么该使用nullptr"><a href="#为什么该使用nullptr" class="headerlink" title="为什么该使用nullptr"></a>为什么该使用nullptr</h2><p>回到最开始的问题，为什么作为指针的语义，我们应该使用nullptr，而不是NULL。<br>请看下面的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】，https://www.yanbinghu.com</span></span><br><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"p is pointer "</span>&lt;&lt;p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"num is int "</span>&lt;&lt;num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    test(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ g++ -o test test.cpp</span><br><span class="line">main.cpp: In function ‘int main()’:</span><br><span class="line">main.cpp:16:14: error: call of overloaded ‘test(NULL)’ is ambiguous</span><br><span class="line">     test(NULL);</span><br></pre></td></tr></table></figure></p>
<p>很不幸，编译报错了，提示我们有二义性，按照《<a href="https://www.yanbinghu.com/2019/01/01/6209.html">重载函数匹配规则</a>》，两个都可以匹配，因此最终报错。</p>
<p>但是如果我们使用nullptr却不会：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test(nullptr);</span><br></pre></td></tr></table></figure></p>
<p>除了这点之外，在C++模板中它还有更好的表现。<br>看下面的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】，https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type1,<span class="keyword">typename</span> ptrType&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Type1 fun,ptrType ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*do something*/</span></span><br><span class="line">    fun(ptr);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"fun"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test(fun,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译报错了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main.cpp:8:8: error: invalid conversion from ‘long int’ to ‘int*’ [-fpermissive]</span><br><span class="line">     fun(ptr);</span><br></pre></td></tr></table></figure></p>
<p>很显然NULL被推导为long int，而不是空指针，因而导致函数类型不匹配而报错。</p>
<p>但是如果我们用nullptr就不会有上面的问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你想表示空指针，那么使用nullptr，而不是NULL。</p>
<p>注：nullptr在C++ 11中才出现。</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>C++调用C接口-extern &quot;C&quot;</title>
    <url>/2019/08/25/29412.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如何在C++代码中调用写好的C接口？你可能会奇怪，C++不是兼容C吗？直接调用不就可以了？这里我们先按下不表，先看看C++如何调用C代码接口。<br><a id="more"></a></p>
<h2 id="C-如何调用C接口"><a href="#C-如何调用C接口" class="headerlink" title="C++如何调用C接口"></a>C++如何调用C接口</h2><p>为什么会有这样的情况呢？想象一下，有些接口是用C实现的，并提供了库，那么C++中该如何使用呢？我们先不做任何区别对待，看看普通情况下会发生什么意想不到的事情。<br>首先提供一个C接口：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】 博客：https://www.yanbinghu.com</span></span><br><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"test.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCfun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am c fun\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了简化，我们在这里就不将它做成静态库或者动态库了，有兴趣的可以参考《<a href="https://www.yanbinghu.com/2019/07/10/23906.html">静态库制作</a>》自行尝试。我们在这里编译成C目标文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -c test.c</span><br></pre></td></tr></table></figure></p>
<p>另外提供一个头文件test.h：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCfun</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>我们的C++代码调用如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】 博客：https://www.yanbinghu.com</span></span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"test.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*调用C接口*/</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"start to call c function"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    testCfun();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"end to call c function"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ g++ -o main main.cpp test.o</span><br><span class="line">/tmp/ccmwVJqM.o: In function `main&apos;:</span><br><span class="line">main.cpp:(.text+0x21): undefined reference to `testCfun()&apos;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure></p>
<p>很不幸，最后的链接报错了，说找不到testCfun，但是我们确实定义了这个函数。为什么会找不到呢？现在你还会认为C++直接就可以调用C接口了吗？</p>
<h2 id="真相"><a href="#真相" class="headerlink" title="真相"></a>真相</h2><p>我们都知道，C++中函数支持重载，而C并不支持。C++为了支持函数重载，它在“生成”函数符号信息时，不能仅仅通过函数名，因为重载函数的函数名都是一样的，所以它还要根据入参，命名空间等信息来确定唯一的函数签名。或者说<strong>C++生成函数签名的方式与C不一致</strong>，所以即便是函数名一样，对于C和C++来说，它们最终的函数签名还是不一样。当然这里又是另外一回事了，我们不细说。我们看看两个文件里的函数符号有什么区别：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nm test.o|grep testCfun</span><br><span class="line">0000000000000000 T testCfun</span><br><span class="line">$ nm main.o|grep testCfun</span><br><span class="line">                U _Z8testCfunv</span><br></pre></td></tr></table></figure></p>
<p>所以它们两个能链接在一起才真是奇怪了呢！名字都不同，还怎么链接？</p>
<h2 id="如何处理"><a href="#如何处理" class="headerlink" title="如何处理"></a>如何处理</h2><p>那么如何处理呢？很显然，我们必须告诉链接器，这是一个C接口，而不是C++接口，所以需要加入 extern C，我们修改test.h<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCfun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里用extern “C”将testCfun接口包裹起来，告诉编译器，这里的是C接口哈，你要按C代码的方式处理。再次编译：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ g++ -o main main.cpp test.o</span><br><span class="line">$ ./main</span><br><span class="line">start to call c function</span><br><span class="line">I am c fun</span><br><span class="line">end to call c function</span><br></pre></td></tr></table></figure></p>
<p>看终端输出，完美！</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>虽然上面的C接口可以被C++正常调用了，但是如果这个C接口要被C代码调用呢？增加main.c内容如下<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"test.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*调用C接口*/</span></span><br><span class="line">    testCfun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o main main.c test.c</span><br><span class="line">In file included from main.c:2:0:</span><br><span class="line">test.h:2:8: error: expected identifier or &apos;(&apos; before string constant</span><br><span class="line"> extern &quot;C&quot;&#123;</span><br><span class="line">        ^</span><br><span class="line">In file included from test.c:2:0:</span><br><span class="line">test.h:2:8: error: expected identifier or &apos;(&apos; before string constant</span><br><span class="line"> extern &quot;C&quot;&#123;</span><br></pre></td></tr></table></figure></p>
<p>不出意外，又报错了，很显然，<strong>C语言中并没有extern “C”这样的写法</strong>，所以为了能使得test.c的代码既能被C++调用，也能被C调用，需要改写成下面这样：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCfun</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>这里通过__cplusplus宏来控制是否需要extern “C”，如果是C++编译器，那么extern “C”部分就会被预处理进去，这样test.c代码就可以既用于C++，也可以用于C啦。</p>
<p>赶快去你的C项目代码头文件中看看，是不是也有这样的代码段呢？</p>
<blockquote>
<p>来源：公众号【编程珠玑】 博客：<a href="https://www.yanbinghu.com">https://www.yanbinghu.com</a></p>
</blockquote>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>为什么我们在C++代码中可以直接调用一些标准C库函数呢？即使你在main函数中调用printf等函数，它也不会出现链接错误。因为库函数已经有了类似的处理了。</p>
<p>如果你还是不确定，你可以先预处理：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ g++ -E main.i main.cpp</span><br></pre></td></tr></table></figure></p>
<p>去生成的main.i文件中找一找，是不是有extern “C”。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C++支持重载，而C不支持，C++并不能直接调用C代码写好的接口，因此如果你的C代码想要能够被C调用，也想被C++调用，那么别忘了extern “C”。</p>
<p>推荐阅读：</p>
<ul>
<li>《<a href="https://www.yanbinghu.com/2018/11/27/34641.html">C++函数重载</a>》</li>
<li>《<a href="https://www.yanbinghu.com/2019/01/01/6209.html">彻底理解C++重载函数匹配</a>》</li>
<li>《<a href="https://www.yanbinghu.com/2019/07/10/23906.html">静态库制作</a>》</li>
</ul>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>链接</tag>
      </tags>
  </entry>
  <entry>
    <title>书籍推荐-C语言三剑客</title>
    <url>/2019/08/22/5097.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本期推荐C语言学习必读书籍-C语言三剑客。以下内容最好在读过《C primer plus》之类的基础书籍之后阅读。<br><a id="more"></a></p>
<h2 id="《C陷阱与缺陷》—评分8-9"><a href="#《C陷阱与缺陷》—评分8-9" class="headerlink" title="《C陷阱与缺陷》—评分8.9"></a><a href="https://book.douban.com/subject/2778632/" target="_blank" rel="noopener">《C陷阱与缺陷》</a>—评分8.9</h2><p>如书名一样，这本书从词法分析、语法语义、连接、库函数、预处理器、可移植性等方面介绍了C语言所谓的“缺陷”，但实际上无论是对于新手还是已经使用过很久C语言的开发者都值得一看，可以说是一本<strong>识坑指南</strong>。</p>
<p>当然里面很多点实际上已经可以用很多现代工具来检测，比如<strong>lint工具</strong>，编译器的强制检查等等，但是即便如此，也需要在你了解这些之后，才能真正意识到它们的存在。</p>
<p>本书适合新人阅读，从中了解在平常写代码的适合应该注意哪些问题。</p>
<h2 id="《C和指针》—评分9-0"><a href="#《C和指针》—评分9-0" class="headerlink" title="《C和指针》—评分9.0"></a><a href="https://book.douban.com/subject/3012360/" target="_blank" rel="noopener">《C和指针》</a>—评分9.0</h2><p>毋庸置疑，指针是C语言中最重要的概念，也是对初学者来说最难理解的一部分，而这本书恰恰就像是专门为你解决这个难题的。当然了，不要被书名误导了，虽然说的是C和指针，但实际上<strong>覆盖了语句、操作符、表达式、数组、指针、函数、字符串、结构和联合等几乎所有重要的C编程话题</strong>，不过相对于其他书籍，它在<strong>指针</strong>方面的介绍更加透彻。</p>
<p>另外对一些常用的基本数据结构也有很好的介绍，比如<strong>队列，栈，链表</strong>等。同时还对一些常用的<strong>标准库函数</strong>进行了介绍。</p>
<p>本书适合进阶学习，更加细致地了解C语言的各个特性。</p>
<h2 id="《C专家编程》—评分9-2"><a href="#《C专家编程》—评分9-2" class="headerlink" title="《C专家编程》—评分9.2"></a><a href="https://book.douban.com/subject/2377310/" target="_blank" rel="noopener">《C专家编程》</a>—评分9.2</h2><p>你知道K&amp;R C和ANSI C有什么区别吗？如果你不知道的话，可以看看本书。</p>
<p>C里面有哪些奇怪的语言特性？它在其他语言看来，就是bug！</p>
<p>如果你觉得对<strong>数组和指针</strong>的理解还不够深刻，没关系，这本《C专家编程》又不厌其烦的来进行讲。除此之外，对于一些<strong>复杂的声明</strong>，本书也做了非常多的讲解，以后无论多复杂的声明你应该能分辨了。在此之前，你能看懂下面的声明吗？<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*signal(<span class="keyword">int</span> sig,<span class="keyword">void</span>(*func)(<span class="keyword">int</span>)))(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure></p>
<p>除此之外，如果你之前从来不知道什么是<strong>链接</strong>，只是用IDE点击运行程序，那么链接部分能帮助你初步理解链接器到底做了什么，而你也会慢慢明白其重要性，这是构建大型程序必备的基础知识。</p>
<p>程序运行起来后，其<strong>内存布局</strong>又是怎样的？什么是<strong>堆栈</strong>？如果这些你还不知道，那么你真该抽时间好好学习学习了。</p>
<p>最后一章又从C的角度带你进行了一次C++之旅，C++真的有那么神秘吗？</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上三本书，就是今天的推荐，以上三本书的难易程度为《C陷阱和缺陷》&lt;《C和指针》&lt;《C专家编程》。即便如此，也建议你在具备一定基础之后再去阅读。如果你无法读懂，那么说明你还有很大的进步空间，我自己最开始的时候也是看不懂的。</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>NULL,0,&#39;\0&#39;的区别</title>
    <url>/2019/08/19/18180.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在C语言中，我们有时候看到NULL，有时候也看到’\0’，那它们之间有什么区别呢？<br><a id="more"></a></p>
<h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>本质来说，NULL，0，’\0’都是一样的，都是值0。是的，你没有听错。说到这本文差不多应该结束了。不过为了不被打，还是继续说一说。它们虽然值都是0，但是含义却是不一样的。</p>
<h2 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h2><p>虽然值是0，但是它的含义不一样，或者说它的类型不一样。NULL是指针类型，不过它是空指针，即值为0。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】 博客：https://www.yanbinghu.com</span></span><br><span class="line"><span class="comment">//null.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们编译它：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o null null.c</span><br><span class="line">null.c: In function ‘main’:</span><br><span class="line">null.c:14:10: warning: initialization makes integer from pointer without a cast [-Wint-conversion]</span><br><span class="line">  int a = NULL;</span><br><span class="line">          ^</span><br></pre></td></tr></table></figure></p>
<p>它给了我们一个警告，提示尝试将指针转换为整数。这也就正验证了我们前面的说法。</p>
<p>实际上NULL通常是如下定义：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL (void*)0</span></span><br></pre></td></tr></table></figure></p>
<p>所以，如果要给一个指针类型初始化，那么你给它一个NULL，使得能够明显的看到这是一个指正。</p>
<p>当然，在C++中，你更应该使用nullptr，而不是NULL。</p>
<h2 id="‘-0’"><a href="#‘-0’" class="headerlink" title="‘\0’"></a>‘\0’</h2><p>我们都知道\是转义符，用单引号包起来，再加转义，实际上就是0，只不过它表示的是字符。就向下面这样：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】 博客：https://www.yanbinghu.com</span></span><br><span class="line"><span class="comment">//nul.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">char</span> b = <span class="string">'0'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d,b = %d\n"</span>,a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o nul nul.c</span><br><span class="line">./nul</span><br><span class="line">a = 0,b = 48</span><br></pre></td></tr></table></figure></p>
<p>我们最常见到的就是它作为字符串的结束符。所以我们常常会看到下面这样的写法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char str[16];</span><br><span class="line">/*do something*/</span><br><span class="line">str[15] = &apos;\0&apos;;</span><br></pre></td></tr></table></figure></p>
<p>还记得printf是如何打印字符串，以及strcmp比较停止规则吗？是的，它们都以遇到’\0’结束。</p>
<p>注意，它和’0’完全不一样。通过打印就可以看到了，实际上’\0’的值就是0。</p>
<p>需要特别注意的是，如果’\0’的0后面跟八进制的数，则会被转义。所以<strong>‘\60’与’0’的值一致</strong>。</p>
<h2 id="0"><a href="#0" class="headerlink" title="0"></a>0</h2><p>这个不用多解释。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a = 0;</span><br></pre></td></tr></table></figure></p>
<h2 id="“0”"><a href="#“0”" class="headerlink" title="“0”"></a>“0”</h2><p>用双引号包裹的0是字符串，我们看不到的是它结尾还有一个’\0‘<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">"0"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sizeof str is %d,string len is %d\n"</span>,<span class="keyword">sizeof</span>(str),<span class="built_in">strlen</span>(str));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sizeof str is 2,string len is 1</span><br></pre></td></tr></table></figure></p>
<h2 id="“-0”"><a href="#“-0”" class="headerlink" title="“\0”"></a>“\0”</h2><p>这也是字符串，只不过是两个空字符。字符串长度为0。</p>
<h2 id="“-“"><a href="#“-“" class="headerlink" title="“ “"></a>“ “</h2><p>字符串。字符串长度为1，占用空间2字节，是一个空格加空字符。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里你应该明白了，它们的值可能一样，但赋予的含义却不一样，为了代码良好的可读性，你应该在恰当的时候使用合适的值。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>getopt-优雅地处理命令行参数</title>
    <url>/2019/08/17/57486.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在Linux用到的命令常常支持很多参数，那么如何写一个程序，也像Linux命令一样支持很多参数呢？有什么什么优雅的处理方法？<br><a id="more"></a></p>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>在介绍如何处理命令行参数之前，简单介绍一下命令行参数，已经了解的朋友可以跳过此小节。<br>我们用一段代码，打印传给程序的每一个参数<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//博客：https://www.yanbinghu.com</span></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; argc;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"the %d para is %s\n"</span>,i,argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中argc代表输入的参数个数，而argv中保存着参数具体的值，我们编译运行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o main main.c</span><br><span class="line">$ ./main 编程珠玑 C C++ Java 博客</span><br><span class="line">the 0 para is ./main</span><br><span class="line">the 1 para is 编程珠玑</span><br><span class="line">the 2 para is C</span><br><span class="line">the 3 para is C++</span><br><span class="line">the 4 para is Java</span><br><span class="line">the 5 para is 博客</span><br></pre></td></tr></table></figure></p>
<p>我们依次打印了程序的输入参数，其中特别注意的是，第一个（下标为0）的参数是程序本身。</p>
<h2 id="如何优雅地处理命令行参数"><a href="#如何优雅地处理命令行参数" class="headerlink" title="如何优雅地处理命令行参数"></a>如何优雅地处理命令行参数</h2><p>实际上我们通过getopt函数很容易实现。</p>
<h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p>getopt就可以非常方便地处理简单参数了，其声明如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> optind,opterr,optopt;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> *optarg;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getopt</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *<span class="keyword">const</span> argv[],<span class="keyword">const</span> <span class="keyword">char</span> *optstring)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h4><p>几个参数说明如下：</p>
<ul>
<li>argc 参数个数，可从main函数入口传入</li>
<li>argv 参数字符串数组，可从main函数入口传入</li>
<li>optstring 支持的选项字符串</li>
</ul>
<p>第一个和第二个参数我们很熟悉，它和main函数的参数是一样的：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>第三个参数是什么意思呢？指的是你支持的选项，假设你的程序支持-h,-a,-n选项，并且-n选项后面要跟具体参数，那么optstring可以是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">“han:”</span><br></pre></td></tr></table></figure></p>
<p>选项后面有一个冒号表示这个选项需要带参数。</p>
<p>它的返回值是int类型，如果出错，则返回-1，如果命令参数不识别，则返回’?‘。</p>
<h4 id="外部变量"><a href="#外部变量" class="headerlink" title="外部变量"></a>外部变量</h4><p>它有四个外部变量，含义分别如下：</p>
<ul>
<li>optind 存放下一个要处理的字符串在argv数组中的下标，从1开始</li>
<li>opterr 如果选项发生错误，getopt会打印出错消息，如果设置为0，则不打印。</li>
<li>optopt 如果选项处理发生错误，它会指向导致出错的选项字符串</li>
<li>optarg 如果一个选项需要参数，如前面提到的n参数，由于后面有:，所以它需要参数，处理到它时，optarg会指向这个参数。</li>
</ul>
<h4 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h4><p>我们仍然通过一个示例程序来看：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//博客：https://www.yanbinghu.com</span></span><br><span class="line"><span class="comment">//main1.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> optind,opterr,optopt;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> *optarg;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>; <span class="comment">//用于接收选项</span></span><br><span class="line">    <span class="comment">/*循环处理参数*/</span></span><br><span class="line">    <span class="keyword">while</span>(EOF != (c = getopt(argc,argv,<span class="string">"han:"</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//打印处理的参数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"start to process %d para\n"</span>,optind);</span><br><span class="line">        <span class="keyword">switch</span>(c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'h'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"we get option -h\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"we get option -a\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//-n选项必须要参数</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'n'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"we get option -n,para is %s\n"</span>,optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//表示选项不支持</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'?'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"unknow option:%c\n"</span>,optopt);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o main1 main1.c</span><br></pre></td></tr></table></figure></p>
<p>输入正常选项时，我们可以看到能正确获取到选项，获取到之后自然就可以做对应的动作了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./main1 -h -a</span><br><span class="line">start to process 2 para</span><br><span class="line">we get option -h</span><br><span class="line">start to process 3 para</span><br><span class="line">we get option -a</span><br></pre></td></tr></table></figure></p>
<p>如果输入的选项不支持，就会提示未知选项：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./main1 -u</span><br><span class="line">./main1: invalid option -- &apos;u&apos;</span><br><span class="line">start to process 2 para</span><br><span class="line">unknow option:u</span><br></pre></td></tr></table></figure></p>
<p>对于-n选项，我们需要参数，如果没有参数会怎样？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./main1 -n</span><br><span class="line">./main1: option requires an argument -- &apos;n&apos;</span><br><span class="line">start to process 2 para</span><br><span class="line">unknow option:n</span><br></pre></td></tr></table></figure></p>
<p>它会提示我们n选项需要参数，于是带上参数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./main1 -n</span><br><span class="line">start to process 3 para</span><br><span class="line">we get option -n,para is 2</span><br></pre></td></tr></table></figure></p>
<p>怎么样？是不是很简单？</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>但是不知道你有没有发现，上面的处理有个问题，那就是不支持长选项。</p>
<p>什么意思呢？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./main1 -ha</span><br><span class="line">start to process 1 para</span><br><span class="line">we get option -h</span><br><span class="line">start to process 2 para</span><br><span class="line">we get option -a</span><br></pre></td></tr></table></figure></p>
<p>这种情况下，-ha被当成了两个选项，而不是一个选项，选项名为ha。</p>
<p>那么这种情况应该如何处理呢？就需要用到后面的函数啦。</p>
<blockquote>
<p>来源：公众号【编程珠玑】<br>网站：<a href="https://www.yanbinghu.com">https://www.yanbinghu.com</a></p>
</blockquote>
<h2 id="长选项处理"><a href="#长选项处理" class="headerlink" title="长选项处理"></a>长选项处理</h2><p>为了应对前面说的这种情况，需要用到下面两个函数中的一个：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getopt_long</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[],</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> <span class="keyword">char</span> *optstring,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> struct option *longopts, <span class="keyword">int</span> *longindex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getopt_long_only</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[],</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> <span class="keyword">char</span> *optstring,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> struct option *longopts, <span class="keyword">int</span> *longindex)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>它们的第一个第二个参数和getopt一样，第三个参数是一个struct option指针：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">option</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span>         has_arg;</span><br><span class="line">    <span class="keyword">int</span>        *flag;</span><br><span class="line">    <span class="keyword">int</span>         val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其成员含义分别如下：</p>
<ul>
<li>name  长选项名称</li>
<li>has_arg 参数可选项，no_argument表示该选项后不带参，required_argument表示该选项后面带参数</li>
<li>*flag 匹配到选项后，如果flag是NULL，则返回val；如果不是NULL，则返回0，并且将val的值赋给flag指向的内存</li>
<li>val  匹配到选项后的返回值</li>
</ul>
<p>longindex表示<strong>长选项</strong>在longopts中的索引值。</p>
<p>那getopt_long和getopt_long_only有什么区别呢？<br>实际上主要功能是差不多的，只是前者一个-时被解析成短选项，—被解析成长选项，而后者都被解析为长选项，举个例子，-help在前者被解析为h,e,l,p四个选项，而在后者是和—help一样的效果，即被认为是长选项。在getopt_long_only中，optstring可以为“”。</p>
<p>我们来看一个示例程序：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//博客：https://www.yanbinghu.com</span></span><br><span class="line"><span class="comment">//main2.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> optind,opterr,optopt;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> *optargi;</span><br><span class="line"><span class="comment">//定义长选项</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">long_options</span>[] = </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    &#123;<span class="string">"help"</span>,no_argument,<span class="literal">NULL</span>,<span class="string">'h'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"verbose"</span>,no_argument,<span class="literal">NULL</span>,<span class="string">'v'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"number"</span>,required_argument,<span class="literal">NULL</span>,<span class="string">'n'</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>; <span class="comment">//用于接收选项</span></span><br><span class="line">    <span class="comment">/*循环处理参数*/</span></span><br><span class="line">    <span class="keyword">while</span>(EOF != (c = getopt_long(argc,argv,<span class="string">"hvn:"</span>,long_options,&amp;index)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'h'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"we get option -h，index %d\n"</span>,index);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'v'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"we get option -v，index %d\n"</span>,index);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//-n选项必须要参数</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'n'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"we get option -n,para is %s\n"</span>,optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//表示选项不支持</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'?'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"unknow option:%c\n"</span>,optopt);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o main2 main2.c</span><br><span class="line">$ ./main2 --verbose --help </span><br><span class="line">we get option -v，index 1</span><br><span class="line">we get option -h，index 0</span><br></pre></td></tr></table></figure></p>
<p>注意，为什么-v参数的index是0？因为只有长选项才会对应index。</p>
<p>可以看到，使用—跟长选项，单个-后面跟短选项，但是如果是下面这样呢？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./main2 -help </span><br><span class="line">we get option -h，index 0</span><br><span class="line">./main2: invalid option -- &apos;e&apos;</span><br><span class="line">unknow option:e</span><br><span class="line">./main2: invalid option -- &apos;l&apos;</span><br><span class="line">unknow option:l</span><br><span class="line">./main2: invalid option -- &apos;p&apos;</span><br><span class="line">unknow option:p</span><br></pre></td></tr></table></figure></p>
<p>在这里，由于使用的getopt_long，它对于单个-的字符串，里面每个字符都当成了一个选项，因此help对它来说，其实是四个选项，但是后三个不被识别。如果想要-help也被当成长选项，那么就需要用到getopt_long_only函数了。</p>
<p>最后，再完整的用一遍：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./main2 --help --verbose --number 10</span><br><span class="line">we get option -h，index 0</span><br><span class="line">we get option -v，index 1</span><br><span class="line">we get option -n,para is 10</span><br></pre></td></tr></table></figure></p>
<h2 id="扩展说明"><a href="#扩展说明" class="headerlink" title="扩展说明"></a>扩展说明</h2><p>其实在处理选项的时候，如果参数前面有-，比如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -bar</span><br></pre></td></tr></table></figure></p>
<p>这里的-bar会被当成一个选项，而不是文件名，因此想要把它当成文件名，而不是选项，需要采用下面这种方式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -- -bar</span><br></pre></td></tr></table></figure></p>
<p>具体可以参考《<a href="https://www.yanbinghu.com/2019/01/19/8873.html">linux中删除特殊名称文件的多种方式</a>》。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>想要优雅地处理命令行参数，今天介绍的几个函数是有必要掌握了，那么是不是很想自己尝试一下呢？更多细节等你去发现。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>给程序员的几点小建议</title>
    <url>/2019/08/15/46053.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>给程序员以及准程序员（学生党）的几点小建议。<br><a id="more"></a></p>
<h2 id="关注健康"><a href="#关注健康" class="headerlink" title="关注健康"></a>关注健康</h2><p>这一点我们虽然常常听前辈说到了，但是自己没经历过的时候时不知道的。无论你现在是学生还是已经工作了，身体健康是第一位的，身体是革命的本钱这句话可不是随便说的。所以抽时间锻炼，这确实很难做到，但至少善待你的：</p>
<ul>
<li>肩颈/腰椎—坐的时间长了站起来活动一下</li>
<li>眼睛—电脑看久了远眺一下</li>
<li>肝/头发—少熬夜，光头强并不是说光头就很强</li>
</ul>
<h2 id="好好学习"><a href="#好好学习" class="headerlink" title="好好学习"></a>好好学习</h2><p>如果你是学生，那么你的第一任务应该是学习，但不要仅限于课堂的学习，选好目标后多做扩展学习。血的教训。</p>
<h2 id="阅读书籍"><a href="#阅读书籍" class="headerlink" title="阅读书籍"></a>阅读书籍</h2><p>是否习惯了不会的东西网上一查，代码一复制，跑一下，ok，就提交了？作为技术人，我们可能常常会关注一些技术博客或论坛，但是这些内容不足的方面是：</p>
<ul>
<li>不够系统</li>
<li><strong>可能</strong>不专业</li>
<li>可能存在误导性</li>
</ul>
<p>因此我们需要选择阅读<strong>优质</strong>的书籍，来<strong>构建属于自己的知识体系</strong>，需要用的时候而临时查看网络文章获得的知识，常常会让你知其然，而不知其所以然。当然，并不是看博客文章不好，这些博主的优秀文章常常会结合实践或者自己的经验进行分享，也是一个<strong>非常好的学习和巩固途径</strong>。如果能在阅读之后自己做一些笔记并实践或者写一些博客分享自然是最好的。</p>
<p>除此之外，我们更应该关注技术之外的书籍，多了解一些其他领域的东西，<strong>避免形成思维定式</strong>。</p>
<h2 id="复盘总结"><a href="#复盘总结" class="headerlink" title="复盘总结"></a>复盘总结</h2><p>在平常学习或者工作中，可以记录自己的计划和完成情况，每过一段时间进行回顾，看看有哪些还可以改进，又有哪些已经卓有成效，值得后续借鉴？</p>
<h2 id="保持谦逊"><a href="#保持谦逊" class="headerlink" title="保持谦逊"></a>保持谦逊</h2><p>无论何时，保持谦逊，你再熟悉的领域，身边或网络上也有人比你做得更好，更何况在你不熟悉的领域。所谓，三人行必有我师焉，正是如此。</p>
<blockquote>
<p>来源：公众号【编程珠玑】，地址:<a href="https://www.yanbinghu.com">https://www.yanbinghu.com</a></p>
</blockquote>
<h2 id="编程是手段"><a href="#编程是手段" class="headerlink" title="编程是手段"></a>编程是手段</h2><p>虽然我们常常戏称自己为码农，但是心里<strong>至少</strong>应该朝着<strong>软件工程师</strong>的方向前进。编程（或者说写代码）只是你实现某个目标的一个手段（不可否认，这个手段非常重要），工作后可能会发现，真正写代码时间占据的比例可能并不是很大。写代码之外的构思，设计，沟通，落实等会越发凸显其重要性。</p>
<h2 id="编程不只是学一门语言"><a href="#编程不只是学一门语言" class="headerlink" title="编程不只是学一门语言"></a>编程不只是学一门语言</h2><p>虽然通常来说，编程工作会以某种语言为主，然而事实是，<strong>不同的语言有不同的应用场景，根据实际情况，选择合适的语言做它擅长的事情</strong>，没有所谓“最好”的语言，但要有你自己擅长的语言。除此之外，还有很多语言无关的基本功，例如操作系统原理，网络协议，Linux命令，编译，调试手段，开发工具等内容同样需要学习。</p>
<h2 id="善用搜索引擎"><a href="#善用搜索引擎" class="headerlink" title="善用搜索引擎"></a>善用搜索引擎</h2><p>无论是刚开始学编程还是已经工作，你会发现你遇到的99%的问题都有人已经遇到过。所以<strong>问问题之前，先问搜索引擎</strong>，问人时，也请注意礼仪。</p>
<h2 id="学会休息"><a href="#学会休息" class="headerlink" title="学会休息"></a>学会休息</h2><p>长时间定位问题没有任何进展和思路时，不如放下键盘，走动一下或者睡一觉，可能会有新的发现。</p>
<h2 id="不过于相信别人所谓的经验"><a href="#不过于相信别人所谓的经验" class="headerlink" title="不过于相信别人所谓的经验"></a>不过于相信别人所谓的经验</h2><p>你可能听说某某普通二本也能进大厂，又是当前某某语言火热，某某又轻松转行，此时一定要小心的看，结合自己的实际情况，仔细分析，哪些是自己可以借鉴的，哪些压根一个字都不能信。不要光看他说了什么话，还要看说这话之后，做了什么事。</p>
<h2 id="别光看，行动"><a href="#别光看，行动" class="headerlink" title="别光看，行动"></a>别光看，行动</h2><p>说我自己呢。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>以上纯属个人瞎说，不供参考。欢迎留言分享你的小建议。</p>
]]></content>
      <categories>
        <category>程序员</category>
      </categories>
      <tags>
        <tag>程序员</tag>
      </tags>
  </entry>
  <entry>
    <title>fork函数详解</title>
    <url>/2019/08/11/28423.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在《<a href="https://www.yanbinghu.com/2018/09/07/47517.html">对进程和线程的一些总结</a>》已经介绍了进程和线程的区别，但是在C/C++中如何创建进程呢？或者说如何编写多进程的程序呢？<br><a id="more"></a></p>
<h2 id="什么时候需要fork进程"><a href="#什么时候需要fork进程" class="headerlink" title="什么时候需要fork进程"></a>什么时候需要fork进程</h2><p>一种可能见到的场景是在服务器程序中，一个请求到来后，为了避免服务器阻塞，fork出一个子进程处理请求，父进程仍然继续等待请求到来。但这种方式无疑开销会稍大。</p>
<p>另一种最常见的就是执行一个不同的程序，例如我们在shell终端执行一条命令，实际上就是bash（或者其他）调用fork之后，在执行exec族函数。</p>
<h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>一个现有的进程可以通过fork函数来创建一个新的进程，这个进程通常称为子进程。fork函数原型如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>如果调用成功，它将返回两次，子进程返回值是0；父进程返回的是非0正值，表示子进程的进程id；如果调用失败将返回-1，并且置errno变量。</p>
<p>有的朋友可能常常会记不住返回0的时候到底是子进程还是父进程。这里教给大家一个方法。一个进程可以有多个子进程，但是一个子进程同一时刻最多只有一个父进程。子进程可以通过getppid获取父进程的进程id，但是父进程却没法获取，因此需要在fork后就得到子进程的进程id。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公众号【编程珠玑】，博客 https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">char</span> testVal[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	FILE *fp = fopen(<span class="string">"test.txt"</span>,<span class="string">"w"</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == fp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"open test.txt failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == (pid = fork()))<span class="comment">//等于-1时表明fork出错</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == pid)<span class="comment">//子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(testVal,<span class="number">128</span>,<span class="string">"I am child，father pid is %d\n"</span>,getppid());</span><br><span class="line">        <span class="built_in">fprintf</span>(fp,<span class="string">"%s"</span>,testVal);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//父进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(testVal,<span class="number">128</span>,<span class="string">"I am parent,child pid is %d\n"</span>,pid);</span><br><span class="line">        <span class="built_in">fprintf</span>(fp,<span class="string">"%s"</span>,testVal);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork over,testVal is %s"</span>,testVal);</span><br><span class="line">    <span class="comment">//为了避免马上退出sleep一段时间</span></span><br><span class="line">    sleep(<span class="number">100</span>);</span><br><span class="line">	fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>并在同目录下创建一个test.txt文件，运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fork over,testVal is I am parent,child pid is 13008</span><br><span class="line">fork over,testVal is I am child，father pid is 13007</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，不要对父进程先执行还是子进程先执行做任何假设，因为都有可能。所以，可能出现的运行结果并不一样。</p>
<h2 id="fork到底做了什么"><a href="#fork到底做了什么" class="headerlink" title="fork到底做了什么"></a>fork到底做了什么</h2><p>fork被调用后，子进程拥有父进程的副本，因此它拥有父进程的数据空间，堆栈等。但是由于fork之后通常会调用exec函数去执行与原进程不想关的程序，因此fork时直接拷贝父进程的副本显得没有必要。为了提高fork的效率，采用了一种<strong>写时复制</strong>的技术。即fork之后，子进程<strong>名义上</strong>拥有父进程的副本，但是实际上和父进程共用，只有当父子进程中有一个试图修改这些区域时，才会以页为单位创建一个真正的副本。</p>
<p>所以我们看到前面的示例程序中，父子进程都对testVal进程了修改，但是互不影响。因为它们修改了不同的区域。</p>
<h2 id="子进程继承了父进程哪些属性？"><a href="#子进程继承了父进程哪些属性？" class="headerlink" title="子进程继承了父进程哪些属性？"></a>子进程继承了父进程哪些属性？</h2><p>由于子进程是父进程的一个副本，所以父进程有的属性，子进程也都有，这些属性包括</p>
<ul>
<li>打开的文件描述符</li>
<li>会话ID</li>
<li>根目录</li>
<li>资源限制</li>
<li>工作目录</li>
<li>进程组ID</li>
<li>控制终端</li>
<li>环境</li>
<li>…</li>
</ul>
<p>我们运行前面的示例程序之后，重新打开一个终端，找到打开test.txt文件的进程：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ lsof test.txt</span><br><span class="line">fork    9919 root    3r   REG  252,1        0 396427 test.txt</span><br><span class="line">fork    9920 root    3r   REG  252,1        0 396427 test.txt</span><br></pre></td></tr></table></figure></p>
<p>lsof命令的用法可以参考《<a href="https://www.yanbinghu.com/2019/03/05/61180.html">如何查看Linux中文件打开情况</a>》</p>
<p>也可以观察进程打开的文件描述符：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -l /proc/9919/fd</span><br><span class="line">lrwx------ 1 root root 64 Aug 10 15:38 0 -&gt; /dev/pts/1</span><br><span class="line">lrwx------ 1 root root 64 Aug 10 15:38 1 -&gt; /dev/pts/1</span><br><span class="line">lrwx------ 1 root root 64 Aug 10 15:38 2 -&gt; /dev/pts/1</span><br><span class="line">lr-x------ 1 root root 64 Aug 10 15:38 3 -&gt; /data/workspaces/practices/c/test.txt</span><br></pre></td></tr></table></figure></p>
<p>为什么这里要特别说明打开的文件描述符呢？试想以下两点：</p>
<ul>
<li>父子进程对同一个文件进行写，将共享文件偏移</li>
<li>如果该描述符是一个socket描述符，父进程退出后，子进程仍然打开着，父进程再次启动，将会出现端口被占用的问题。</li>
</ul>
<p>所以如果父子进程的其中一个使用了fclose关闭了文件描述符，实际上还有另外一个进程打开了test.txt文件。</p>
<p>与前面testVal不同的是，如果父子进程都对文件进行写，并不会产生两个不同的文件，而是会对同一个文件进行写，因此运行后会在同一个文件里出现父子进程写的内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat test.txt</span><br><span class="line">I am parent,child pid is 13008</span><br><span class="line">I am child，father pid is 13007</span><br></pre></td></tr></table></figure></p>
<h2 id="父子进程有哪些不同？"><a href="#父子进程有哪些不同？" class="headerlink" title="父子进程有哪些不同？"></a>父子进程有哪些不同？</h2><ul>
<li>fork之后的返回值不同，进程ID也不同</li>
<li>子进程未处理信号设置为空</li>
<li>子进程不继承父进程设置的文件锁</li>
<li>一般子进程会执行与父进程不完全一样的代码流程</li>
<li>…</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>fork用于创建进程，但是需要注意的是，子进程继承了很多父进程的东西，如果子进程不需要可以进行修改或“丢弃”，例如子进程关闭父进程打开的文件描述符等等。理解了fork的写时复制思想，也就会明白，实际上fork的速度是非常快的。本文总结点如下：</p>
<ul>
<li>fork调用一次，返回两次</li>
<li>一个进程可以有多个子进程，但同一时刻最多只有一个父进程</li>
<li>子进程继承了父进程很多属性</li>
<li>父子进程执行的先后顺序不一定</li>
</ul>
<p>本文仅仅简单介绍了fork，实际上得到子进程之后，还需要对子进程的状态进行“监控”，否则会出现其他意想不到的问题。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C++构造函数详解</title>
    <url>/2019/08/11/25996.html</url>
    <content><![CDATA[<p>本文要点</p>
<ul>
<li>为什么需要构造函数</li>
<li>默认构造函数什么时候有</li>
<li>构造函数初始值有哪几种方式给出？</li>
<li>如何使用构造函数</li>
<li>什么是委托构造函数？</li>
<li>如何禁止拷贝形式的初始化？</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在C语言中使用堆栈中的变量时，常常需要给它赋初始值，用于避免使用到了不可预知的值。同样的，在C++中也需要有这样的动作，只是由于C++的对象可能比基本数据要复杂得多，因此使用了一系列的函数来完成这件事。这些函数就是构造函数。那么构造函数到底是怎样，又该如何使用呢？<br><a id="more"></a></p>
<h2 id="为什么需要构造函数"><a href="#为什么需要构造函数" class="headerlink" title="为什么需要构造函数"></a>为什么需要构造函数</h2><p>有的人可能会奇怪，发现自己写的代码即便没有初始化，也有正常的初始值，而且每次运行都是一样，而不是随机的，这是为什么呢？<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;<span class="comment">//没有初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>);<span class="comment">//一般来说每次运行结果都是随机值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先，各个编译器实现可能不一样，具体怎么不一样，有兴趣可以去了解，但是需要注意的，<strong>按照标准来做，而不依赖于特定编译器的特性行为，即养成初始化的好习惯</strong>。<strong>因此在C++也常常需要构造函数来控制对象的初始化。</strong></p>
<p>关于初始化也可以参考《<a href="https://www.yanbinghu.com/2018/11/13/9002.html">被遗忘的初始化</a>》。</p>
<h2 id="构造函数有什么特点"><a href="#构造函数有什么特点" class="headerlink" title="构造函数有什么特点"></a>构造函数有什么特点</h2><p>C++中的构造函数有哪些需要注意的呢？在《<a href="https://www.yanbinghu.com/2019/07/28/63773.html">C++类初识</a>》中已有所介绍，这里再稍微展开一下。</p>
<ul>
<li>构造函数没有返回值</li>
<li>构造函数名与类名相同</li>
<li>构造函数可以重载</li>
<li>构造函数不能被声明成const</li>
</ul>
<p>构造函数的返回值我们是拿不到的，因而其返回值对我们来说也是没有意义的。</p>
<p>一个类可以有多个构造函数，其函数名一致，形参不同，因而构造函数可以重载。</p>
<p>我们创建类的一个const对象的时候，需要等到构造函数执行完成，或者说只有初始化完成，才能有真正的const属性。如果构造函数被声明成const，那么它就不能修改成员变量，这样就没法完成初始化了。如下面的代码所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">     <span class="comment">/*do something*/</span>  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(test)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果将构造函数声明为const，将会出现编译错误：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: constructors may not be cv-qualified</span><br><span class="line">    Test() const</span><br></pre></td></tr></table></figure></p>
<p>提示构造函数不能被const修饰。</p>
<h2 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h2><p>如果没有定义任何构造函数，编译器会为我们提供无参的默认构造函数。但是有例外</p>
<ul>
<li>如果定义了自己的构造函数，编译器也不会提供默认构造函数。</li>
<li>如果<strong>类中某个成员它自己没有默认构造函数（无参构造函数），那么编译器也就不能合成默认构造函数</strong>。</li>
</ul>
<p>请看下面的示例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo(<span class="keyword">int</span> val):value(val)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Foo foo;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(test);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们定义了两个类，一个Foo，有一个构造函数，但是没有无参构造函数；一个Test，没有定义构造函数，准备让编译器生成默认的。但是不幸的是编译器报错了：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">no matching function <span class="keyword">for</span> call to ‘Foo::Foo()’</span><br></pre></td></tr></table></figure></p>
<p>也就是说，它试图去调用自己成员的无参构造函数，但是由于成员自己没有，所以报错了。</p>
<p>另外，从这个例子中我们也可以看到，由于Foo中已经定义了自己的构造函数，因此编译器不会为它生成默认的构造函数。</p>
<p>如何解决呢？只需要在Foo类中增加这么一句就可以使用默认构造函数了：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Foo()= <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="构造函数初始值"><a href="#构造函数初始值" class="headerlink" title="构造函数初始值"></a>构造函数初始值</h2><p>为了在构造函数中给成员赋初始值，可以用下面的方式：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公众号【编程珠玑】，博客 https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*为成员提供初始值*/</span></span><br><span class="line">    Test(<span class="keyword">const</span> <span class="built_in">string</span> &amp;n,<span class="keyword">int</span> a):name(n),age(a),month(a*<span class="number">12</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"name:"</span>&lt;&lt;name&lt;&lt;<span class="string">",age:"</span>&lt;&lt;age&lt;&lt;<span class="string">",month:"</span>&lt;&lt;month&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">test</span><span class="params">(<span class="string">"编程珠玑"</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">    test.printTest();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name:编程珠玑,age:5,month:60</span><br></pre></td></tr></table></figure></p>
<p>注意观察Test的构造函数，圆括号内和其他普通函数一样是入参，不过后面跟一个冒号，每个成员变量又用圆括号将初始值括起来。这种赋初始值的方式与下面这种方式的效果是相同的：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Test(<span class="keyword">const</span> <span class="built_in">string</span> &amp;n,<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    name = n;</span><br><span class="line">    age = a;</span><br><span class="line">    month = a *<span class="number">12</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但从深层次来说，它们是有区别的，我们将在后面看到。</p>
<p>除此之外，实际上还可以为构造函数提供默认实参。注意的是，为了和入参对应上，默认实参要从后面的实参开始提供，例如，我们可以为a提供默认实参，而n不提供，但是不能为n提供，而a不提供，因为a在其后：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公众号【编程珠玑】，博客 https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*这里为a提供了默认实参*/</span></span><br><span class="line">    Test(<span class="keyword">const</span> <span class="built_in">string</span> &amp;n,<span class="keyword">int</span> a = <span class="number">3</span>):name(n),age(a),month(a*<span class="number">12</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"name:"</span>&lt;&lt;name&lt;&lt;<span class="string">",age:"</span>&lt;&lt;age&lt;&lt;<span class="string">",month:"</span>&lt;&lt;month&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">test</span><span class="params">(<span class="string">"编程珠玑"</span>)</span></span>;</span><br><span class="line">    test.printTest();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name:编程珠玑,age:3,month:36</span><br></pre></td></tr></table></figure></p>
<p>在这里我们为a提供了默认实参值0，因此只传入一个参数也可以构造Test对象。</p>
<h2 id="初始化const和引用成员"><a href="#初始化const和引用成员" class="headerlink" title="初始化const和引用成员"></a>初始化const和引用成员</h2><p>不知道你是否还记得，对于const类型或者是引用类型，我们必须给它初始化，因此<strong>对于有const或者引用的成员变量，必须在构造函数中给它初始化，注意是初始化，而不是赋值</strong>。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/*没有对const和引用类型初始化，会报错*/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">string</span> &amp;name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里没有初始化，会报错，下面这里使用了赋值形式的初始化，同样报错：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">string</span> &amp;name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test(<span class="keyword">int</span> a,<span class="built_in">string</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        age = a;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可行的做法如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">string</span> &amp;name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test(<span class="keyword">int</span> a,<span class="built_in">string</span> n):age(a),name(n)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>来源：公众号【编程珠玑】<br>博客：<a href="https://www.yanbinghu.com">https://www.yanbinghu.com</a></p>
</blockquote>
<h2 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h2><p>C++11中提供的委托构造函数说白了就是构造函数使用其他定义好的构造函数执行自己的初始化过程。例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test(<span class="keyword">const</span> <span class="built_in">string</span> &amp;n,<span class="keyword">int</span> a):name(n),age(a),month(a*<span class="number">12</span>)&#123;&#125;</span><br><span class="line">    <span class="comment">/*委托构造函数*/</span></span><br><span class="line">    Test(<span class="keyword">const</span> <span class="built_in">string</span> &amp;n):Test(n,<span class="number">0</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只有一个入参n的构造函数通过有两个入参的构造函数来完成初始化过程。</p>
<h2 id="使用构造函数"><a href="#使用构造函数" class="headerlink" title="使用构造函数"></a>使用构造函数</h2><p>在前面我们已经看到了构造函数的使用方式。对于有参构造函数，使用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类名 变量名(实参);</span><br></pre></td></tr></table></figure></p>
<p>的方式，例如前面看到的：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Test <span class="title">test</span><span class="params">(<span class="string">"编程珠玑"</span>,<span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>而对于默认构造函数，或者说无参构造函数则不能这样：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Test <span class="title">test</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>由于这种构造函数无参，这会被编译器认为是一个函数的声明，因此要用下面的方式：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Test test;</span><br></pre></td></tr></table></figure></p>
<h2 id="禁止拷贝形式的初始化"><a href="#禁止拷贝形式的初始化" class="headerlink" title="禁止拷贝形式的初始化"></a>禁止拷贝形式的初始化</h2><p>在没有其他限制的情况下，对于<strong>只有一个实参的构造函数而言，可以使用拷贝形式的初始化</strong>，即在初始化test的时候，可以直接将name赋给它而完成初始化：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公众号【编程珠玑】，博客 https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test(<span class="keyword">const</span> <span class="built_in">string</span> &amp;n,<span class="keyword">int</span> a = <span class="number">0</span>):name(n),age(a),month(a*<span class="number">12</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"name:"</span>&lt;&lt;name&lt;&lt;<span class="string">",age:"</span>&lt;&lt;age&lt;&lt;<span class="string">",month:"</span>&lt;&lt;month&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> name = <span class="string">"编程珠玑"</span>;</span><br><span class="line">    <span class="comment">/*拷贝形式的初始化*/</span></span><br><span class="line">    Test test = name;</span><br><span class="line">    test.printTest();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而如果要禁止这种形式的初始化，可以使用explicit关键字声明构造函数：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">explicit Test(const string &amp;n,int a = 0):name(n),age(a),month(a*12)&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是需要注意的是，<strong>explicit关键字只允许在类内的构造函数声明处</strong>，如果构造函数在类外声明，则是不允许的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于构造函数的内容还有很多，在介绍继承，多态，拷贝，移动等内容后再展开，本文总结如下：</p>
<ul>
<li>构造函数没有返回值</li>
<li>构造函数名与类名相同</li>
<li>构造函数可以重载</li>
<li>构造函数不能被声明成const</li>
<li>对于只有一个实参的构造函数而言，可以使用拷贝形式的初始化</li>
<li>类中某个成员它自己没有默认构造函数（无参构造函数），那么编译器也就<strong>无法</strong>合成默认构造函数</li>
<li>如果定义了自己的构造函数，编译器将<strong>不会</strong>合成默认构造函数</li>
<li>对于有const或者引用的成员变量，必须在构造函数中给它初始化</li>
</ul>
<p>参考：《C++ primer》</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>字节对齐不慎引发的挂死问题</title>
    <url>/2019/08/04/11325.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前程序是32位的，切到64位之后，一些隐藏的问题就暴露了。这不，一个由字节对齐导致的挂死问题就出来了。<br><a id="more"></a></p>
<h2 id="字节对齐和64位"><a href="#字节对齐和64位" class="headerlink" title="字节对齐和64位"></a>字节对齐和64位</h2><p>关于字节对齐，可参考《<a href="https://www.yanbinghu.com/2018/09/15/43741.html">理一理字节对齐的那些事</a>》，而之前也分享过另一个切64位之后出现的问题，有兴趣的可以查看《<a href="https://www.yanbinghu.com/2019/06/25/47531.html">记64位地址截断引发的挂死问题</a>》。</p>
<h2 id="本文背景"><a href="#本文背景" class="headerlink" title="本文背景"></a>本文背景</h2><p>本文出现的场景是，系统需要解析JSON文件，但是出现部分功能解析正常，部分挂死，并且32位程序正常，而64位程序挂死。鉴于原系统比较复杂，本文将会简化其过程，来看看到底是什么导致了挂死。<br>本文示例代码主要引自《<a href="http://www.yanbinghu.com/2019/08/04/21364.html">一个超轻量级的JSON解析器</a>》。</p>
<h2 id="简化后示例代码"><a href="#简化后示例代码" class="headerlink" title="简化后示例代码"></a>简化后示例代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"cJSON.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*省略部分代码，完整代码可查看附录部分*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *filename = <span class="string">"./test.json"</span>;</span><br><span class="line">    cJSON *pJson = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON *pTemp = <span class="literal">NULL</span>;</span><br><span class="line">    pJson = prepare_parse_json(filename);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pJson)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parse json failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*获取name值*/</span></span><br><span class="line">    pTemp = cJSON_GetObjectItem(pJson,<span class="string">"name"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"name is %s\n"</span>,pTemp-&gt;valuestring);</span><br><span class="line">    <span class="comment">/*获取site值*/</span></span><br><span class="line">    pTemp = cJSON_GetObjectItem(pJson,<span class="string">"site"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"site is %s\n"</span>,pTemp-&gt;valuestring);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*获取age值*/</span></span><br><span class="line">    pTemp = cJSON_GetObjectItem(pJson,<span class="string">"age"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"age is %d\n"</span>,pTemp-&gt;valueint);</span><br><span class="line">    <span class="comment">/*记得释放相关内存*/</span></span><br><span class="line">    cJSON_Delete(pJson);</span><br><span class="line">    pJson = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -L. -o parseJson parseJson.c -lcjson</span><br><span class="line">$ ./parseJson</span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure></p>
<p>在实际中我们通过GDB观察发现，在解析JSON内部查看JSON数据是完好的，但是调用完解析JSON之后，再去访问使用就不对了，并且我们发现，在不同的功能模块中，调用结果不一样，大部分模块调用并没有任何问题，而只有某个功能模块调用出现问题。</p>
<h2 id="真相"><a href="#真相" class="headerlink" title="真相"></a>真相</h2><p>到底是什么导致的呢？<br>问题的根源在于下面这几行代码：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"cJSON.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure></p>
<p>另外补充，cJSON结构体如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> &#123;</span>  <span class="comment">//cJSON结构体</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span>*<span class="title">next</span>,*<span class="title">prev</span>;</span>           <span class="comment">/*后驱节点和前驱节点*/</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> *<span class="title">child</span>;</span>                   <span class="comment">/*孩子节点*/</span></span><br><span class="line">       <span class="keyword">int</span> type;                                     <span class="comment">/* 键的类型*/</span></span><br><span class="line">       <span class="keyword">char</span> *valuestring;                       <span class="comment">/*字符串值*/</span></span><br><span class="line">       <span class="keyword">int</span> valueint;                                <span class="comment">/* 整数值*/</span></span><br><span class="line">       <span class="keyword">double</span> valuedouble;                    <span class="comment">/* 浮点数值*/</span></span><br><span class="line">       <span class="keyword">char</span> *<span class="built_in">string</span>;                               <span class="comment">/* 键的名字*/</span></span><br><span class="line">&#125; cJSON;</span><br></pre></td></tr></table></figure></p>
<p>#pragma指令说明了按一字节对齐，而cJSON的头文件也在其中，那么就会导致里面的cJSON结构体按照1字节对齐，最终其结构体大小为56个字节而已经编译好的cjson库可并非如此，因此对于64位程序，它还是按照8字节对齐，结构体大小为64字节，而对于32位程序，按照4字节对齐，也是56字节。</p>
<p><strong>同一个结构体的大小竟然在不同的代码中大小不一样！</strong></p>
<p>最终也就出现了我们遇到的情况，64位程序由于库中申请结构体内存大小与外部调用不一样，最终导致挂死，而32位程序解析JSON正常。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>幸运的是，本文示例中能够很明显的能看到问题所在，但在实际项目中，如果头文件管理不规范，并且项目的产品多样，通过编译宏来隔开使用的头文件，就很难发现这样的问题。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>什么情况下需要1字节对齐呢？</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>本文完整代码：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"cJSON.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">get_file_size</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filepath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*check input para*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == filepath)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">filestat</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;filestat,<span class="number">0</span>,<span class="keyword">sizeof</span>(struct stat));</span><br><span class="line">    <span class="comment">/*get file information*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == stat(filepath,&amp;filestat))</span><br><span class="line">        <span class="keyword">return</span> filestat.st_size;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">read_file_to_buf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filepath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*check input para*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == filepath)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*get file size*/</span></span><br><span class="line">    <span class="keyword">size_t</span> size = get_file_size(filepath);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == size)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*malloc memory*/</span></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(size+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == buf)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0</span>,size+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*read string from file*/</span></span><br><span class="line">    FILE *fp = fopen(filepath,<span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">size_t</span> readSize = fread(buf,<span class="number">1</span>,size,fp);</span><br><span class="line">    <span class="keyword">if</span>(readSize != size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*read error*/</span></span><br><span class="line">        <span class="built_in">free</span>(buf);</span><br><span class="line">        buf = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buf[size] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">cJSON *<span class="title">prepare_parse_json</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*check input para*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == filePath)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"input para is NULL\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*read file content to buffer*/</span></span><br><span class="line">    <span class="keyword">char</span> *buf = read_file_to_buf(filePath);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == buf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"read file to buf failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*parse JSON*/</span></span><br><span class="line">    cJSON *pTemp = cJSON_Parse(buf);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">    buf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> pTemp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%u\n"</span>,<span class="keyword">sizeof</span>(cJSON));</span><br><span class="line">    <span class="keyword">char</span> *filename = <span class="string">"./test.json"</span>;</span><br><span class="line">    cJSON *pJson = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON *pTemp = <span class="literal">NULL</span>;</span><br><span class="line">    pJson = prepare_parse_json(filename);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pJson)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parse json failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*获取name值*/</span></span><br><span class="line">    pTemp = cJSON_GetObjectItem(pJson,<span class="string">"name"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"name is %s\n"</span>,pTemp-&gt;valuestring);</span><br><span class="line">    <span class="comment">/*获取site值*/</span></span><br><span class="line">    pTemp = cJSON_GetObjectItem(pJson,<span class="string">"site"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"site is %s\n"</span>,pTemp-&gt;valuestring);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*获取age值*/</span></span><br><span class="line">    pTemp = cJSON_GetObjectItem(pJson,<span class="string">"age"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"age is %d\n"</span>,pTemp-&gt;valueint);</span><br><span class="line">    <span class="comment">/*记得释放相关内存*/</span></span><br><span class="line">    cJSON_Delete(pJson);</span><br><span class="line">    pJson = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>cJSON解析和生成JSON文件</title>
    <url>/2019/08/04/21364.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>众所周知，JSON是一种轻量级的数据格式，应用广泛。在C/C++应用中也常常作为配置文件或者数据的存储，因此JSON文件的生成和解析是必备知识。<br><a id="more"></a></p>
<h2 id="cJSON"><a href="#cJSON" class="headerlink" title="cJSON"></a>cJSON</h2><p>cJSON是使用ANSI C编写的<strong>超轻量级</strong>的JSON解析器，因此在C中也常常是不二之选。<br>github 地址：<a href="https://github.com/DaveGamble/cJSON" target="_blank" rel="noopener">https://github.com/DaveGamble/cJSON</a></p>
<p>下载到本地后，进行编译：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ make</span><br></pre></td></tr></table></figure></p>
<p>执行完成后即可在当前目录下得到libcjson.a和libcjson.so。</p>
<p>当然你也可以只下载cJSON.c和cJSON.h自己编译成静态库或动态库，可参考前期文章《<a href="https://www.yanbinghu.com/2019/07/10/23906.html">如何制作静态库</a>》和《<a href="https://www.yanbinghu.com/2019/07/18/38654.html">动态库的制作和两种使用方式</a>》。编译后的.a保留调试信息也只有不过43k。</p>
<h2 id="关键数据结构"><a href="#关键数据结构" class="headerlink" title="关键数据结构"></a>关键数据结构</h2><p>cJSON的关键数据结构如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> &#123;</span>  <span class="comment">//cJSON结构体</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span>*<span class="title">next</span>,*<span class="title">prev</span>;</span>           <span class="comment">/*后驱节点和前驱节点*/</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> *<span class="title">child</span>;</span>                   <span class="comment">/*孩子节点*/</span></span><br><span class="line">       <span class="keyword">int</span> type;                                     <span class="comment">/* 键的类型*/</span></span><br><span class="line">       <span class="keyword">char</span> *valuestring;                       <span class="comment">/*字符串值*/</span></span><br><span class="line">       <span class="keyword">int</span> valueint;                                <span class="comment">/* 整数值*/</span></span><br><span class="line">       <span class="keyword">double</span> valuedouble;                    <span class="comment">/* 浮点数值*/</span></span><br><span class="line">       <span class="keyword">char</span> *<span class="built_in">string</span>;                               <span class="comment">/* 键的名字*/</span></span><br><span class="line">&#125; cJSON;</span><br></pre></td></tr></table></figure></p>
<p>json是一种组织良好的数据格式，因而JSON中的内容解析后，都可以通过以上数据结构进行处理。<br>例如，对于下面的json内容：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"编程珠玑"</span>,</span><br><span class="line">    <span class="attr">"site"</span>:<span class="string">"https://www.yanbinghu.com"</span>,</span><br><span class="line">    <span class="attr">"age"</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解析后，site将会是name的next节点，并且它的键类型是字符串。</p>
<h2 id="常用接口函数"><a href="#常用接口函数" class="headerlink" title="常用接口函数"></a>常用接口函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">cJSON *<span class="title">cJSON_Parse</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *value)</span></span>;</span><br></pre></td></tr></table></figure>
<p>用于将字符串解析成json对象，若失败则返回NULL。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">cJSON *<span class="title">cJSON_GetObjectItem</span><span class="params">(cJSON *object,<span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>用于获取json对象中的某个节点，若失败，返回NULL，成功则返回该节点对象。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>   <span class="title">cJSON_Delete</span><span class="params">(cJSON *c)</span></span>;</span><br></pre></td></tr></table></figure>
<p>用于释放json对象相关内存。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char *cJSON_Print(const cJSON *item);</span><br></pre></td></tr></table></figure>
<p>用于将JSON对象转换成字符串，记得最后释放相关内存。</p>
<h2 id="JSON文件解析准备"><a href="#JSON文件解析准备" class="headerlink" title="JSON文件解析准备"></a>JSON文件解析准备</h2><p>解析JSON文件可大致分为以下几个步骤：</p>
<ul>
<li>获取文件大小</li>
<li>将JSON文件内容读取到buffer</li>
<li>通过cJSON接口解析buffer中的字符串</li>
<li>获取JSON指定字段</li>
</ul>
<p>为了将JSON文件的内容读取到buffer，需要知道文件的大小：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//https://www.yanbinghu.com</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">get_file_size</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filepath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*check input para*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == filepath)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">filestat</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;filestat,<span class="number">0</span>,<span class="keyword">sizeof</span>(struct stat));</span><br><span class="line">    <span class="comment">/*get file information*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == stat(filepath,&amp;filestat))</span><br><span class="line">        <span class="keyword">return</span> filestat.st_size;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后申请一段内存，将文件中的文本读取到buffer中：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//https://www.yanbinghu.com</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">read_file_to_buf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filepath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*check input para*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == filepath)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*get file size*/</span></span><br><span class="line">    <span class="keyword">size_t</span> size = get_file_size(filepath);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == size)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*malloc memory*/</span></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(size+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == buf)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0</span>,size+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*read string from file*/</span></span><br><span class="line">    FILE *fp = fopen(filepath,<span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">size_t</span> readSize = fread(buf,<span class="number">1</span>,size,fp);</span><br><span class="line">    <span class="keyword">if</span>(readSize != size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*read error*/</span></span><br><span class="line">        <span class="built_in">free</span>(buf);</span><br><span class="line">        buf = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buf[size] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再根据前面提到的解析流程，我们的JSON预解析函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">cJSON *<span class="title">prepare_parse_json</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*check input para*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == filePath)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"input para is NULL\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*read file content to buffer*/</span></span><br><span class="line">    <span class="keyword">char</span> *buf = read_file_to_buf(filePath);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == buf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"read file to buf failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*parse JSON*/</span></span><br><span class="line">    cJSON *pTemp = cJSON_Parse(buf);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">    buf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> pTemp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>来源：公众号【编程珠玑】<br>网站：<a href="https://www.yanbinghu.com">https://www.yanbinghu.com</a></p>
</blockquote>
<h2 id="解析JSON文件"><a href="#解析JSON文件" class="headerlink" title="解析JSON文件"></a>解析JSON文件</h2><p>假设我们的JSON文件内容如下：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"编程珠玑"</span>,</span><br><span class="line">    <span class="attr">"site"</span>:<span class="string">"https://www.yanbinghu.com"</span>,</span><br><span class="line">    <span class="attr">"age"</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>按照我们前面梳理的解析JSON的步骤，main函数代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *filename = <span class="string">"./test.json"</span>;</span><br><span class="line">    cJSON *pJson = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON *pTemp = <span class="literal">NULL</span>;</span><br><span class="line">    pJson = prepare_parse_json(filename);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pJson)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parse json failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*获取name值*/</span></span><br><span class="line">    pTemp = cJSON_GetObjectItem(pJson,<span class="string">"name"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"name is %s\n"</span>,pTemp-&gt;valuestring);</span><br><span class="line">    <span class="comment">/*获取site值*/</span></span><br><span class="line">    pTemp = cJSON_GetObjectItem(pJson,<span class="string">"site"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"site is %s\n"</span>,pTemp-&gt;valuestring);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*获取age值*/</span></span><br><span class="line">    pTemp = cJSON_GetObjectItem(pJson,<span class="string">"age"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"age is %d\n"</span>,pTemp-&gt;valueint);</span><br><span class="line">    <span class="comment">/*记得释放相关内存*/</span></span><br><span class="line">    cJSON_Delete(pJson);</span><br><span class="line">    pJson = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面看来，我们自己封装好之后，解析json似乎也没有那么复杂？<br>编译：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> gcc -L .  -o parseJson parseJson.c -lcjson</span><br></pre></td></tr></table></figure></p>
<p>注意指定链接cjson库的路径。</p>
<p>运行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./parseJson</span><br><span class="line">name is 编程珠玑</span><br><span class="line">site is https://www.yanbinghu.com</span><br><span class="line">age is 1</span><br></pre></td></tr></table></figure></p>
<h2 id="写JSON"><a href="#写JSON" class="headerlink" title="写JSON"></a>写JSON</h2><p>写JSON又该如何呢？实际上不过是组装JSON对象罢了。示例代码如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&quot;cJSON.h&quot;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    cJSON *pRoot = NULL;</span><br><span class="line">    char *json = NULL;</span><br><span class="line">    cJSON *array = NULL;</span><br><span class="line">    //创建根节点对象</span><br><span class="line">    pRoot = cJSON_CreateObject();</span><br><span class="line">    //向根节点加入数字对象</span><br><span class="line">    cJSON_AddNumberToObject(pRoot, &quot;age&quot;, 1);</span><br><span class="line">    //向根节点加入字符串对象</span><br><span class="line">    cJSON_AddStringToObject(pRoot, &quot;name&quot;, &quot;编程珠玑&quot;);</span><br><span class="line">    //创建数组对象</span><br><span class="line">    array = cJSON_CreateArray();</span><br><span class="line">    cJSON_AddStringToObject(array,&quot;language&quot;,&quot;C&quot;);</span><br><span class="line">    cJSON_AddStringToObject(array,&quot;language&quot;,&quot;C++&quot;);</span><br><span class="line">    //向根节点中添加数组</span><br><span class="line">    cJSON_AddItemToObject(pRoot,&quot;array&quot;,array);</span><br><span class="line">    //解析成字符串</span><br><span class="line">    json = cJSON_Print(pRoot);</span><br><span class="line">    printf(&quot;%s\n&quot;, json);//这里也可以将字符串写入文件</span><br><span class="line">    //释放json对象的空间</span><br><span class="line">    cJSON_Delete(pRoot);</span><br><span class="line">    pRoot = NULL;</span><br><span class="line">    //记得释放json的空间</span><br><span class="line">    free(json);</span><br><span class="line">    json = NULL;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;age&quot;:	1,</span><br><span class="line">	&quot;name&quot;:	&quot;编程珠玑&quot;,</span><br><span class="line">	&quot;array&quot;:	[&quot;C&quot;, &quot;C++&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>相比于python一条搞定解析来说，C语言中解析JSON似乎显得有些麻烦，但cJSON无疑是一个超轻量级的JSON器。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>完整解析代码：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"cJSON.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">get_file_size</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filepath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*check input para*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == filepath)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">filestat</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;filestat,<span class="number">0</span>,<span class="keyword">sizeof</span>(struct stat));</span><br><span class="line">    <span class="comment">/*get file information*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == stat(filepath,&amp;filestat))</span><br><span class="line">        <span class="keyword">return</span> filestat.st_size;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">read_file_to_buf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filepath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*check input para*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == filepath)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*get file size*/</span></span><br><span class="line">    <span class="keyword">size_t</span> size = get_file_size(filepath);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == size)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*malloc memory*/</span></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(size+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == buf)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0</span>,size+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*read string from file*/</span></span><br><span class="line">    FILE *fp = fopen(filepath,<span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">size_t</span> readSize = fread(buf,<span class="number">1</span>,size,fp);</span><br><span class="line">    <span class="keyword">if</span>(readSize != size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*read error*/</span></span><br><span class="line">        <span class="built_in">free</span>(buf);</span><br><span class="line">        buf = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buf[size] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">cJSON *<span class="title">prepare_parse_json</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*check input para*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == filePath)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"input para is NULL\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*read file content to buffer*/</span></span><br><span class="line">    <span class="keyword">char</span> *buf = read_file_to_buf(filePath);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == buf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"read file to buf failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*parse JSON*/</span></span><br><span class="line">    cJSON *pTemp = cJSON_Parse(buf);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">    buf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> pTemp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *filename = <span class="string">"./test.json"</span>;</span><br><span class="line">    cJSON *pJson = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON *pTemp = <span class="literal">NULL</span>;</span><br><span class="line">    pJson = prepare_parse_json(filename);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pJson)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parse json failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*获取name值*/</span></span><br><span class="line">    pTemp = cJSON_GetObjectItem(pJson,<span class="string">"name"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"name is %s\n"</span>,pTemp-&gt;valuestring);</span><br><span class="line">    <span class="comment">/*获取site值*/</span></span><br><span class="line">    pTemp = cJSON_GetObjectItem(pJson,<span class="string">"site"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"site is %s\n"</span>,pTemp-&gt;valuestring);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*获取age值*/</span></span><br><span class="line">    pTemp = cJSON_GetObjectItem(pJson,<span class="string">"age"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"age is %d\n"</span>,pTemp-&gt;valueint);</span><br><span class="line">    <span class="comment">/*记得释放相关内存*/</span></span><br><span class="line">    cJSON_Delete(pJson);</span><br><span class="line">    pJson = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>库打桩机制-偷梁换柱</title>
    <url>/2019/07/28/59484.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>假如由于调试需要，你希望原先代码中的malloc函数更换为你自己写好的malloc函数，该怎么办呢？如何对程序进行”偷梁换柱“？<br><a id="more"></a></p>
<h2 id="打桩机制"><a href="#打桩机制" class="headerlink" title="打桩机制"></a>打桩机制</h2><p>LInux链接器有强大的库打桩机制，它允许你对共享库的代码进行截取，从而执行自己的代码。而为了调试，你通常可以在自己的代码中加入一些调试信息，例如，调用次数，打印信息，调用时间等等。本文将介绍三种打桩机制，分别在编译的不同阶段。如果你还不了解这几个阶段，建议你阅读《<a href="https://www.yanbinghu.com/2018/10/10/27133.html">hello程序是如何变成可执行文件的</a>》。</p>
<h2 id="编译时打桩"><a href="#编译时打桩" class="headerlink" title="编译时打桩"></a>编译时打桩</h2><p>编译时打桩在源代码级别进行替换。我们很容易通过#define指令来完成这件事情。首先我们定义自己的头文件mymalloc.h:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define malloc(size) mymalloc(size)</span><br><span class="line">void *mymalloc(size_t size)</span><br></pre></td></tr></table></figure></p>
<p>由于在这里使用了#define指令，我们后面需要malloc的地方都会被mymalloc替代。<br>而mymalloc.c代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MYMOCK <span class="comment">//只有MYMOCK编译选项是，这段代码才会编译进去</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*打桩函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mymalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ptr is %p\n"</span>,ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>注意第一行，我们需要在gcc中传入编译选项MYMOCK（自定义，代码与传入的一致即可）。</p>
<p>我们在main.c中调用它：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"malloc.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="built_in">malloc</span>(<span class="number">64</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> gcc -DMYMOCK -c mymalloc.c </span><br><span class="line"><span class="meta">$</span> gcc -I . -o main main.c mymalloc.o</span><br><span class="line"><span class="meta">$</span> ./main</span><br><span class="line">ptr is 0xdbd010</span><br></pre></td></tr></table></figure></p>
<p>编译时还使用-I参数，告诉编译器从当前目录下寻找头文件malloc.h，因此，main函数中的malloc调用将会被替换成mymalloc。而在mymalloc.c中的则使用原始的malloc函数，最终达到“偷梁换柱”的效果。</p>
<p>实际上你也可以通过仅仅预编译来很清楚的看到其中的变化：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -I . -E -o main.i main.c</span><br></pre></td></tr></table></figure></p>
<p>查看main.i，你会发现，使用malloc的地方，都被替换成了mymalloc。</p>
<p>小结一下前面的步骤：</p>
<ul>
<li>打桩函数内部不要打桩，即mymalloc.c中要使用原始的malloc函数，不然会造成循环调用</li>
<li>通过#define指令，将外部调用malloc的地方都替换为mymalloc</li>
<li>分开编译mymalloc.c和外部调用代码，最终链接</li>
</ul>
<p>这种方式打桩需要能够访问源代码才能完成。</p>
<h2 id="链接时打桩"><a href="#链接时打桩" class="headerlink" title="链接时打桩"></a>链接时打桩</h2><p>顾名思义，链接时打桩是在链接时替换需要的函数。Linux链接器支持用—wrap,f的方式来进行打桩，链接时符号f解析成<strong>wrap_f，还会把</strong>real_f解析成f。什么意思呢？我们修改前面mymalloc.c的代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//网站：https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MYMOCK <span class="comment">//只有MYMOCK编译选项是，这段代码才会编译进去</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span> *__real_malloc(<span class="keyword">size_t</span> size);<span class="comment">//注意声明</span></span><br><span class="line"><span class="comment">/*打桩函数*/</span></span><br><span class="line"><span class="keyword">void</span> *__wrap_malloc(<span class="keyword">size_t</span> size) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = __real_malloc(size);<span class="comment">//最后会被解析成malloc</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ptr is %p\n"</span>,ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>注意将main.c中包含的malloc.h那一行去掉。</p>
<p>编译运行：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> gcc -DMYMOCK mymalloc.c</span><br><span class="line"><span class="meta">$</span> gcc -c main.c</span><br><span class="line"><span class="meta">$</span> gcc -Wl,--wrap,malloc -o main main.o mymalloc.o</span><br><span class="line"><span class="meta">$</span> ./main</span><br><span class="line">ptr is 0x95f010</span><br></pre></td></tr></table></figure></p>
<p>我们特别关注mymalloc.c中的代码，利用链接器的打桩机制，最后在main函数中调用malloc，将会去调用<strong>wrap_malloc，而</strong>real_malloc将会被解析成真正的malloc，从而达到“偷梁换柱”的效果。</p>
<p>可以看到的是，这种打桩方式至少需要能够访问可重定位文件。</p>
<blockquote>
<p>来源：公众号【编程珠玑】<br>网站：<a href="https://www.yanbinghu.com">https://www.yanbinghu.com</a></p>
</blockquote>
<h2 id="运行时打桩"><a href="#运行时打桩" class="headerlink" title="运行时打桩"></a>运行时打桩</h2><p>前面两种打桩方式，一种需要访问源代码，另外一种至少要访问可重定位文件。可运行时打桩没有这么多要求。运行时打桩可以通过设置LD_PRELOAD环境变量，达到在你加载一个动态库或者解析一个符号时，先从LD_PRELOAD指定的目录下的库去寻找需要的符号，然后再去其他库中寻找。<br>同样我们修改mymalloc.c:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//网站：https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MYMOCK <span class="comment">//只有MYMOCK编译选项是，这段代码才会编译进去</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE  <span class="comment">//这行特别注意加上</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> FILE *<span class="built_in">stdout</span>;</span><br><span class="line"><span class="comment">/*打桩的malloc函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> calltimes;</span><br><span class="line">    calltimes++;</span><br><span class="line">    <span class="comment">/*函数指针*/</span></span><br><span class="line">    <span class="keyword">void</span> *(*realMalloc)(<span class="keyword">size_t</span> size) = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> *error;</span><br><span class="line"></span><br><span class="line">    realMalloc = dlsym(RTLD_NEXT,<span class="string">"malloc"</span>);<span class="comment">//RTLD_NEXT</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == realMalloc)</span><br><span class="line">    &#123;</span><br><span class="line">        error = dlerror();</span><br><span class="line">        <span class="built_in">fputs</span>(error,<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *ptr = realMalloc(size);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == calltimes)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ptr is %p\n"</span>,ptr);</span><br><span class="line">    &#125; </span><br><span class="line">    calltimes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>在mymalloc.c的代码中，由于我们自己的打桩函数也叫malloc，因此我们通过运行时链接调用malloc函数，以便获取malloc的地址，而不是直接调用。并且是以RTLD_NEXT方式。</p>
<p>将mymalloc.c制作成动态库（动态库的制作和使用参考《<a href="https://www.yanbinghu.com/2019/07/18/38654.html">库的制作与两种使用方式</a>》）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -DMYMOCK -shared -fPIC -o libmymalloc.so mymalloc.c -ldl</span><br><span class="line">$ gcc -o main main.c  //重新编译main</span><br><span class="line">$ LD_PRELOAD=&quot;./libmymalloc.so&quot; </span><br><span class="line">$ ./main</span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure></p>
<p>然而非常不幸的是，最后core dumped了，我们用gdb（参考《<a href="https://www.yanbinghu.com/2018/09/26/61877.html">Linux常用命令-开发调试篇</a>》）查看调用栈：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb)bt</span><br><span class="line">#0  0x00007fe0ca83518e in _IO_vfprintf_internal (</span><br><span class="line">    s=0x7fe0cabad620 &lt;_IO_2_1_stdout_&gt;, format=0x7fe0cabb26dd &quot;ptr is %p\n&quot;, </span><br><span class="line">    ap=ap@entry=0x7ffcbd652058) at vfprintf.c:1267</span><br><span class="line">#1  0x00007fe0ca83d899 in __printf (format=&lt;optimised out&gt;) at printf.c:33</span><br><span class="line">#2  0x00007fe0cabb26cc in malloc () from ./mymalloc.so</span><br><span class="line">#3  0x00007fe0ca8551d5 in __GI__IO_file_doallocate (</span><br><span class="line">    fp=0x7fe0cabad620 &lt;_IO_2_1_stdout_&gt;) at filedoalloc.c:127</span><br><span class="line">#4  0x00007fe0ca863594 in __GI__IO_doallocbuf (</span><br><span class="line">    fp=fp@entry=0x7fe0cabad620 &lt;_IO_2_1_stdout_&gt;) at genops.c:398</span><br><span class="line">#5  0x00007fe0ca8628f8 in _IO_new_file_overflow (</span><br><span class="line">    f=0x7fe0cabad620 &lt;_IO_2_1_stdout_&gt;, ch=-1) at fileops.c:820</span><br><span class="line">#6  0x00007fe0ca86128d in _IO_new_file_xsputn (</span><br><span class="line">    f=0x7fe0cabad620 &lt;_IO_2_1_stdout_&gt;, data=0x7fe0cabb26dd, n=7)</span><br><span class="line">    at fileops.c:1331</span><br><span class="line">#7  0x00007fe0ca835241 in _IO_vfprintf_internal (</span><br></pre></td></tr></table></figure></p>
<p>我们从调用栈基本可以推断，其中有反复调用，那就是说在mymalloc.c中的malloc函数中，有的语句也调用了malloc，导致了最终的反复调用。解决这种问题有两个方法：</p>
<ul>
<li>避免反复调用</li>
<li>使用不调用打桩函数的函数，即不调用其中的printf</li>
</ul>
<p>我们采用下面这种方式来避免反复调用，开始调用时，置调用次数为1，最后置0，如果发现调用次数不为0 ，则不调用。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MYMOCK <span class="comment">//只有MYMOCK编译选项是，这段代码才会编译进去</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE  <span class="comment">//这行特别注意加上</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> FILE *<span class="built_in">stdout</span>;</span><br><span class="line"><span class="comment">/*打桩的malloc函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*调用次数+1*/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> calltimes;</span><br><span class="line">    calltimes++;</span><br><span class="line">    <span class="comment">/*函数指针*/</span></span><br><span class="line">    <span class="keyword">void</span> *(*realMalloc)(<span class="keyword">size_t</span> size) = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> *error;</span><br><span class="line"></span><br><span class="line">    realMalloc = dlsym(RTLD_NEXT,<span class="string">"malloc"</span>);<span class="comment">//RTLD_NEXT</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == realMalloc)</span><br><span class="line">    &#123;</span><br><span class="line">        error = dlerror();</span><br><span class="line">        <span class="built_in">fputs</span>(error,<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *ptr = realMalloc(size);</span><br><span class="line">    <span class="comment">/*如果是第一次调用，则调用printf，否则不调用*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == calltimes)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ptr is %p\n"</span>,ptr);</span><br><span class="line">    &#125; </span><br><span class="line">    calltimes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>当然这样的写法在多线程中也是有问题的，如何改进？</p>
<p>至此，就达到了我们需要的结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./main</span><br><span class="line">ptr is 0x245c010</span><br></pre></td></tr></table></figure></p>
<p>实际上，你会发现，在设置了这个环境变量的终端下，这个打桩的动作对所有程序都生效：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls</span><br><span class="line">ptr is 0x1f1a040</span><br><span class="line">ptr is 0x1f1a680</span><br><span class="line">ptr is 0x1f1a700</span><br><span class="line">ptr is 0x1f1a040</span><br><span class="line">ptr is 0x1f1a060</span><br><span class="line">ptr is 0x1f1a040</span><br></pre></td></tr></table></figure></p>
<p>那么怎么取消呢：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ unset LD_PRELOAD</span><br></pre></td></tr></table></figure></p>
<p>在这里也可以看到，这个机制虽然强大，同样也非常危险，因为不怀好意者可以通过这种方式恶意攻击你的程序。比如说，有个程序中checkPass的接口用来校验密码，如果这个时候使用另外一个动态库，实现自己的checkPass函数，并且设置LD_PRELOAD环境变量，就可以达到跳过密码检查的目的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>怎么样，是不是觉得很神奇？尤其是最后一种方式，可以达到对任何程序进行”偷梁换柱“，对于问题的定位和程序的调试非常有帮助。但是，需要特别注意的是，采用最后一种方式打桩时，最好避免打桩函数内部还调用了打桩函数，这样会导致难以预料的后果，另外由于这种打桩机制对所有程序都有效，因此也非常危险，需要特别注意。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>链接</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之旅-类初识</title>
    <url>/2019/07/28/63773.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>无论是在Java还是Python中，都有类的概念，类的基本思想是数据抽象和封装，一个类定义了一种数据类型以及相关的操作。C++中类是怎样的呢？本文将结合C语言，来介绍C++中的类。<br><a id="more"></a></p>
<h2 id="乐一乐"><a href="#乐一乐" class="headerlink" title="乐一乐"></a>乐一乐</h2><p>问：C++的书为什么比C厚那么多？<br>答：有了对象后就是麻烦。</p>
<p>虽然这只是调侃，但不得不承认，C++在语法特性上要比C复杂，因此本文也只是挑选类的部分内容来阐述。</p>
<p>另外一提，面向对象本身是一种编程思想，只是C++在语言特性层面就支持面向对象，而C并不支持。</p>
<h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>与C语言中定义结构体类似，只不过C++的类中，除了有数据，还有相关操作，例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">double</span> height;</span><br><span class="line">    <span class="comment">/*定义getAge函数，内部用到了age变量*/</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看到，除了多了getAge成员函数，其他部分和C语言中的结构体是没有太大的差别的。但是需要注意的是，编译器在处理类的时候，先编译成员的声明，然后才会轮到成员函数。也就是说，即便getAge函数在age的声明之前，也是可以编译过的。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*定义getAge函数，内部用到了age变量*/</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">double</span> height;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中，虽然age的声明再getAge函数之后，但是不影响编译。</p>
<h2 id="声明类"><a href="#声明类" class="headerlink" title="声明类"></a>声明类</h2><p>以下几种方式都可以用来声明类：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Human human;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Human</span> <span class="title">human1</span>;</span><span class="comment">//这种形式和C语言中非常像</span></span><br></pre></td></tr></table></figure></p>
<p>不过下面这种方式是不行的奥：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Human <span class="title">human</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>因为这会被认为是函数的声明，因此编译会报错。从后面可以看到，</p>
<h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><p>类本身就是一个作用域，所以我们可以看到，在getAge函数中，可以直接访问age成员。而成员函数也可以定义在类的外部，但是为了说明这个成员函数是类的成员，就必须使用作用域符，例如在类的外部定义getAge:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">Human::getAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然前提是在类中已有声明：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>通常来说，成员函数实现可能比较复杂，因此常常会在<strong>类中声明成员函数，但是在类的外部定义</strong>，以便阅读和组织代码。</p>
<blockquote>
<p>来源：公众号【编程珠玑】<br>网站：<a href="https://www.yanbinghu.com">https://www.yanbinghu.com</a></p>
</blockquote>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>无论在C语言中还是在C++中，对于临时变量（或者说非静态，全局变量）声明之后最好进行初始化。对于普通数据类型，如int，double等都可以直接初始化为0，那么类中的数据是复杂的，我们必须有一个或几个函数用来实现类对象的初始化，类中这样的一个或几个函数就是<strong>构造函数</strong>。对于构造函数需要关注以下几点：</p>
<ul>
<li>构造函数没有返回值</li>
<li>构造函数名与类名相同</li>
<li>构造函数可以重载</li>
<li>构造函数不能被声明成const</li>
<li>如果没有定义任何构造函数，编译器会为我们提供没有参数的默认构造函数</li>
</ul>
<p>看下面的代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//网站：https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">double</span> height;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Human human;<span class="comment">//这里会去调用默认构造函数</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"age:"</span>&lt;&lt;human.age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在main函数中，我们声明了一个Human对象，虽然我们有默认的构造函数，但是由于默认构造函数并没有对成员进行初始化，因此每次运行的结果还是不一样。至于原因可以参考《<a href="https://www.yanbinghu.com/2018/11/13/9002.html">C语言入坑指南-被遗忘的初始化</a>》。</p>
<p>因此我们需要定义自己的构造函数，用来控制对象的初始化：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】</span></span><br><span class="line"><span class="comment">//网站：https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">double</span> height;</span><br><span class="line">    <span class="comment">/*构造函数*/</span></span><br><span class="line">    Human(<span class="keyword">int</span> a,<span class="built_in">string</span> n,<span class="keyword">double</span> h)</span><br><span class="line">    &#123;</span><br><span class="line">        age = a;</span><br><span class="line">        name = n;</span><br><span class="line">        height = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Human human;//这一行会报错，因为定义了构造函数之后，不会合成默认没有参数的构造函数</span></span><br><span class="line">    <span class="function">Human <span class="title">human</span><span class="params">(<span class="number">10</span>,<span class="string">"shouwang"</span>,<span class="number">180</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"age:"</span>&lt;&lt;human.age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"name:"</span>&lt;&lt;human.name&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"height:"</span>&lt;&lt;human.height&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里也验证了我们前面说到的一点，如果定义了自己的构造函数，那么就不会合成默认构造函数，如果还想要默认的构造函数呢？很简单，只需要在类中增加一行：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Human() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure></p>
<p>在这种情况下，构造函数就不止一个，即构造函数被重载了。</p>
<h2 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h2><p>前面也说到，类的基本思想是数据抽象和封装，那么必然有一些东西用来控制访问权限的。它们就是<strong>访问说明符</strong>：</p>
<ul>
<li>public说明符：在其之后的成员在整个程序内可以被访问，通常用于定义类的接口</li>
<li>private说明符：在其之后的成员不能被使用该类的外码使用，但是可以被类的成员函数访问，通常用于类的数据成员</li>
<li>protected说明符：与private成员类似，但是其基类可访问</li>
</ul>
<p>另外<strong>也可以使用class代替struct，只是他们的默认访问权限不一样</strong>，class定义的类的成员默认是private的，而struct的成员默认是public的。因此我们可以看到在前面的main函数中，可以直接使用.运算符访问数据成员，但是如果换成class就不太一样了，这个时候就会报错，因为在这种情况下，构造函数也是不可访问的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: ‘Human::Human(int, std::string, double)’ is private within this context</span><br></pre></td></tr></table></figure></p>
<p>因此我们修改class如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/*数据成员声明为private*/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">double</span> height;</span><br><span class="line"><span class="comment">/*类接口声明为public*/</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">/*默认构造函数*/</span></span><br><span class="line">    Human() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">/*构造函数*/</span></span><br><span class="line">    Human(<span class="keyword">int</span> a,<span class="built_in">string</span> n,<span class="keyword">double</span> h)</span><br><span class="line">    &#123;</span><br><span class="line">        age = a;</span><br><span class="line">        name = n;</span><br><span class="line">        height = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个时候，就需要通过调用getAge函数来访问数据成员，而不是直接访问了：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">human.getAge();</span><br></pre></td></tr></table></figure></p>
<p>封装有什么好处呢？显然：</p>
<ul>
<li>确保封装对象不会被无意间破坏数据</li>
<li>封装细节不对外呈现，其实现可以随意改变，但是不影响外部使用</li>
</ul>
<h2 id="类大小"><a href="#类大小" class="headerlink" title="类大小"></a>类大小</h2><p>虽然类中有很多成员，包括数据成员和成员函数，但是对于一个类占用的空间来说，与C中的struct是类似的，即使用sizeof计算其大小时，只需要计算其<strong>非静态数据成员</strong>大小（严格来说，是非静态数据成员，虚函数，虚基类），所以对于64位程序来说，sizeof(Human)的大小为24字节（需要考虑字节对齐，可参考《<a href="https://www.yanbinghu.com/2018/09/15/43741.html">理一理字节对齐的那些事</a>》）。到这里其实也可以猜想，<strong>不同的Human对象数据成员不同，但是其普通成员函数都是只有一份</strong>。</p>
<p>但是需要特别注意的是，C++类允许没有数据成员，那么一个没有数据成员的类（没有非静态数据成员变量，没有虚函数，也没有虚基类），大小是多少呢？<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/*do something*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Empty e;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;  <span class="keyword">sizeof</span>(e) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果为：1，而不是0。<br>为什么呢？C++标准里规定，为了避免不同的对象具有相同的地址，对象大小不允许为0。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们从前面的内容可以看到，与C语言相比，C++的类<strong>至少</strong>多了以下特点：</p>
<ul>
<li>成员函数定义在类中，即操作和数据都在类中，而不像C语言中数据与操作分离</li>
<li>使用特定的函数，即构造函数进行初始化</li>
<li>使用访问说明符来封装，决定哪些可以被用户访问，哪些不能</li>
</ul>
<p>而本文需要特别注意的点如下：</p>
<ul>
<li>class与struct本质没有太大区别，只是默认访问控制权限不一样</li>
<li>构造函数没有返回值</li>
<li>编译器在处理类的时候，先编译成员的声明，然后才会轮到成员函数</li>
</ul>
<p>介绍到这里你以为就完了吗?还早的很。</p>
<p>如有不妥之处，还请多多指教。</p>
<h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>关于C++ 空类大小，你有什么补充的吗？</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程-一个简单的echo程序(2)</title>
    <url>/2019/07/21/64710.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在《<a href="https://www.yanbinghu.com/2019/07/07/40135.html">网络编程-一个简单的echo程序(0)</a>》和《<a href="https://www.yanbinghu.com/2019/07/07/40135.html">网络编程-一个简单的echo程序(1)</a>》中分别介绍了echo程序的整体流程和用到的数据结构与函数。本文将结合两者，来看实际使用过程中，有哪些基本的异常场景。<br><a id="more"></a></p>
<h2 id="Protocol-not-supported"><a href="#Protocol-not-supported" class="headerlink" title="Protocol not supported"></a>Protocol not supported</h2><p>不支持的协议类型。前面在介绍socket函数的时候说到，TCP仅支持字节流套接字，UDP仅支持数据报套接字，如果你的第二个参数选择了SOCK_STREAM，即字节流套接字，而第三个参数选择了IPPROTO_UDP，那么将会出现不支持的协议错误。示例程序如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源 公众号【编程珠玑】 源网站：https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> socktfd = socket(AF_INET,SOCK_STREAM,IPPROTO_UDP);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == socktfd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">socket failed: Protocol not supported</span><br></pre></td></tr></table></figure></p>
<p>由于socket函数返回的是一个套接字描述符，因此它和打开文件一样，如果打开的数量到了一定的限度，也会出现失败。</p>
<p>除此之外，如果系统不支持某种协议族，例如不支持AF_KEY ，会出现:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Operation not permitted</span><br></pre></td></tr></table></figure></p>
<p>的错误。</p>
<h2 id="Cannot-assign-requested-address"><a href="#Cannot-assign-requested-address" class="headerlink" title="Cannot assign requested address"></a>Cannot assign requested address</h2><p>ip不存在。这种错误很容易模拟，还是用前文提到的server程序：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./server 192.168.3.4 1055</span><br><span class="line">bind error: Cannot assign requested address</span><br></pre></td></tr></table></figure></p>
<p>由于192.168.3.4并不是我本机的ip，因此在bind的时候必然会出错。</p>
<h2 id="address-is-already-in-use"><a href="#address-is-already-in-use" class="headerlink" title="address is already in use"></a>address is already in use</h2><p>端口已被占用，或者上一个没有停止。例如已经在一个终端启动了server，然后再次启动：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./server</span><br><span class="line">bind error: Address already in use</span><br></pre></td></tr></table></figure></p>
<p>或者连接之后，server处于TIME_WAIT状态，此时再次启动server也会遇到相同的问题。</p>
<p>关于TIME_WAIT状态，在《<a href="https://www.yanbinghu.com/2019/07/14/62738.html">网络编程-再看TCP的四次挥手</a>》中有详细的论述，本文不再赘述。</p>
<h2 id="permission-denied"><a href="#permission-denied" class="headerlink" title="permission denied"></a>permission denied</h2><p>出现这种错误的情况比较多，通常都是权限问题导致的，例如普通用户试图在1024以内的端口监听：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./server 127.0.0.1 1000</span><br><span class="line">bind error: Permission denied</span><br></pre></td></tr></table></figure></p>
<p>由于普通用户只能绑定使用1024以外的端口，因此当普通用户试图使用1024以内的端口时，就会提示Permission denied。</p>
<p>Permission denied的情况有很多种，这里只列举了其中一种。</p>
<h2 id="Bad-file-descriptor"><a href="#Bad-file-descriptor" class="headerlink" title="Bad file descriptor"></a>Bad file descriptor</h2><p>这种错误在很多场景下会出现，因为我们在很多地方都用到了套接字描述符，因此一旦套接字描述符相关参数错误，都会出现这种错误，例如我们将bind的第一个参数随便指定一个值，并运行server：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./server</span><br><span class="line">bind error: Bad file descriptor</span><br></pre></td></tr></table></figure></p>
<h2 id="Connection-refused"><a href="#Connection-refused" class="headerlink" title="Connection refused"></a>Connection refused</h2><p>这个错误常常出现于连接到一个未监听的地址，例如：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./client 127.0.0.1 8888</span></span><br><span class="line">connect failed: Connection refused</span><br></pre></td></tr></table></figure></p>
<p>这种情况下表明TCP连接的过程中收到了RST响应，有可能是8888端口没有监听，也可能是别的原因导致连接取消。</p>
<h2 id="Connection-timed-out"><a href="#Connection-timed-out" class="headerlink" title="Connection timed out"></a>Connection timed out</h2><p>这个错误常常是由于远端服务器过于繁忙，没有accept。这个我们已经在TCP连接的建立一文中有说明，一旦服务端的连接队列满，将不会处理新的连接请求，客户端将会超时。</p>
<p>当然除此之外，如果指定连接到一个不存在的IP地址：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./client 192.168.183.5 8888</span><br><span class="line">connect failed: Connection timed out</span><br></pre></td></tr></table></figure></p>
<p>前面描述的情况只是很多情况的一两种，最终原因都是客户端没有收到SYN的响应，例如主机防火墙设置了端口不可访问，也可能导致出现这种情况。</p>
<p>如果是远端不可达的IP地址，将会收到主机不可达的ICMP错误：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./client 192.168.0.5 8888</span><br><span class="line">connect failed: No route to host</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文列出了在进行网络编程中最常遇到的错误，但是还有很多错误未曾提出；除此之外，某种错误出现的场景也并没有完全指出，但对于分析常见问题基本足够。当然也欢迎在留言区补充分享。</p>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>动态库的制作与两种使用方式</title>
    <url>/2019/07/18/38654.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在《<a href="https://www.yanbinghu.com/2019/07/10/23906.html">如何制作属于自己的静态库</a>》中简单介绍了静态库的制作方法，但实际上动态库的使用更为广泛，至于原因，在《<a href="https://www.yanbinghu.com/2019/06/27/47343.html">静态库和动态库的区别</a>》一文中已有说明。本文介绍动态库的制作方法以及两种使用方式。<br><a id="more"></a></p>
<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>test.c代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】 网站：https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"test.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am test；hello，编程珠玑\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>test.h代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>代码比较简单，只有一个test函数，用于打印一段字符串。</p>
<h2 id="制作动态库"><a href="#制作动态库" class="headerlink" title="制作动态库"></a>制作动态库</h2><p>只需要执行以下命令即可：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc test.c -fPIC -shared -o libtest.so</span><br></pre></td></tr></table></figure></p>
<p>其中的-fPIC表示生成位置无关代码，以便在<strong>只有一个副本的情况下供多个应用程序共享</strong>。</p>
<p>通过readelf命令查看elf文件类型：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ readelf -h libtest.so</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&apos;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              DYN (Shared object file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br></pre></td></tr></table></figure></p>
<p>从结果中可以看到，libtest.so为Shared object file。</p>
<h2 id="使用动态库"><a href="#使用动态库" class="headerlink" title="使用动态库"></a>使用动态库</h2><p>常见有两种使用方式，一种是加载时链接，另一种是使用时链接。</p>
<blockquote>
<p>来源：公众号【编程珠玑】<br>个人博客：<a href="https://www.yanbinghu.com">https://www.yanbinghu.com</a><br>未经授权禁止以任何形式转载</p>
</blockquote>
<h4 id="加载时链接"><a href="#加载时链接" class="headerlink" title="加载时链接"></a>加载时链接</h4><p>加载时链接在代码中不需要做额外的动作，像使用静态库一样使用即可。例如main.c如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】 网站：https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"test.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译链接：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o main main.c -L . -ltest</span><br></pre></td></tr></table></figure></p>
<p>其中-L指定从当前目录下寻找动态库libtest.so，否则会找不到。</p>
<p>然后我们还可以通过ldd命令查看其依赖的动态库：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ldd main</span><br><span class="line">	linux-vdso.so.1 =&gt;  (0x00007ffd57757000)</span><br><span class="line">	libtest.so =&gt; not found</span><br><span class="line">	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f84c13f6000)</span><br><span class="line">	/lib64/ld-linux-x86-64.so.2 (0x00007f84c17c0000)</span><br></pre></td></tr></table></figure></p>
<p>其中就有我们自己制作的libtest.so。</p>
<p>运行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./main</span><br><span class="line">./main: error while loading shared libraries: libtest.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure></p>
<p>很不幸，程序并没有如预期的那样运行起来，而是报错了。这是为什么呢？</p>
<p>其实我们在使用ldd命令查看的时候，就注意到：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">libtest.so =&gt; not found</span><br></pre></td></tr></table></figure></p>
<p>它并不能找到这个动态库，因为它会默认从系统库的路径去查找这个库，但是我们并没有把这个库放到系统路径下，因此会找不到了。</p>
<p>我们有两种方法解决这个问题：</p>
<ul>
<li>将libtest.so库放到系统路径下</li>
<li>指定当前进程动态库搜索路径</li>
</ul>
<p>第一种方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cp libtest.so /usr/lib</span><br><span class="line">$ ./main</span><br><span class="line">I am test；hello，编程珠玑</span><br></pre></td></tr></table></figure></p>
<p>第二种方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ export LD_LIBRARY_PATH=./</span><br><span class="line">$ ./main</span><br><span class="line">I am test；hello，编程珠玑</span><br></pre></td></tr></table></figure></p>
<p>导入LD_LIBRARY_PATH环境变量，指定库搜索路径，使得main程序能够找到libtest.so。</p>
<p>此时再看：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ldd main</span><br><span class="line">	linux-vdso.so.1 =&gt;  (0x00007ffcdebdf000)</span><br><span class="line">	libtest.so =&gt; ./libtest.so (0x00007f494a45f000)</span><br><span class="line">	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f494a095000)</span><br><span class="line">	/lib64/ld-linux-x86-64.so.2 (0x00007f494a661000)</span><br></pre></td></tr></table></figure></p>
<p>libtest.so不再是not found了。</p>
<h4 id="使用时链接"><a href="#使用时链接" class="headerlink" title="使用时链接"></a>使用时链接</h4><p>为了使用这种方式，需要使用几个函数dlopen，dlsym，dlclose，dlerror，其原型分别如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dlopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dlsym</span><span class="params">(<span class="keyword">void</span> *handle, <span class="keyword">const</span> <span class="keyword">char</span> *symbol)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dlclose</span><span class="params">(<span class="keyword">void</span> *handle)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">dlerror</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>其中dlopen用于打开一个动态库，filename是动态库的名称，flags是打开标志，一般为RTLD_LAZY，表示当要调用的时候才去解析符号；而RTLD_NOW则在dlopen之前就会去解析，还有其他选项这里就不多介绍了。</p>
<p>dlsym函数用于从动态库中查找需要使用的函数；</p>
<p>dlclose函数用于卸载已加载的动态库；</p>
<p>dlerror函数用于打印动态库相关错误。</p>
<p>我们修改main.c，来看看具体如何使用：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】 网站：https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"test.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"start to call test\n"</span>);</span><br><span class="line">    <span class="keyword">char</span> *error = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/*打开动态库*/</span></span><br><span class="line">    <span class="keyword">void</span> *handle = dlopen(<span class="string">"libtest.so"</span>,RTLD_LAZY);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == handle)</span><br><span class="line">    &#123;</span><br><span class="line">        error = dlerror();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"open error:%s\n"</span>,error);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*返回类型为函数指针*/</span></span><br><span class="line">    <span class="keyword">void</span> (*fun)() = dlsym(handle,<span class="string">"test"</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == fun)</span><br><span class="line">    &#123;</span><br><span class="line">        error = dlerror();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"open error:%s\n"</span>,error);</span><br><span class="line">        dlclose(handle);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*调用函数*/</span></span><br><span class="line">    (*fun)();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*关闭*/</span></span><br><span class="line">    dlclose(handle);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"end to call test\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方式的动态库使用可以大致分为以下几个步骤：</p>
<ul>
<li>使用dlopen打开动态库</li>
<li>使用dlsym找到需要使用的符号</li>
<li>调用动态库中的函数</li>
<li>dlopen关闭（卸载）动态库</li>
</ul>
<p>在文本的代码中，用到了函数指针，相关内容可参考《<a href="https://www.yanbinghu.com/2019/01/03/3593.html">高级指针话题-函数指针</a>》。<br>编译运行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc  main.c -ldl -L . -o main  #需要链接libdl.so库</span><br><span class="line">$ ./main </span><br><span class="line">start to call test</span><br><span class="line">open error:libtest.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure></p>
<p>运行时，我们发现并没有如预期的那样。但是可以看到，程序已经打印了start to call test，然后才报错，说明程序是在运行起来之后再尝试去从动态库中查找test符号的。</p>
<p>当然了，至于问题原因，我们在前面已经提到了，是由于没有设置动态库搜索路径或者在系统默认库路径下没有我们需要的libtest.so。按照前面提供的两种方法修正后，重新运行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./main</span><br><span class="line">start to call test</span><br><span class="line">I am test；hello，编程珠玑</span><br><span class="line">end to call test</span><br></pre></td></tr></table></figure></p>
<p>一切正常。</p>
<p>这种方式有以下好处：</p>
<ul>
<li>编译时无需链接需要的动态库，我们注意到第二种方式编译时没有加-ltest</li>
<li>如果程序的某些场景不需要动态库的函数，那么它就不会去加载该动态库</li>
</ul>
<h2 id="再看动态库"><a href="#再看动态库" class="headerlink" title="再看动态库"></a>再看动态库</h2><p>如果我们修改test.c的代码，我们不再需要重新编译main.c，而只需要更新动态库即可。<br>假如我们将test.c代码中的打印语句修改为如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】 网站：https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"test.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello www.yanbinghu.com\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重新生成动态库libtest.so，重新执行main：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./main</span><br><span class="line">start to call test</span><br><span class="line">hello www.yanbinghu.com</span><br><span class="line">end to call test</span><br></pre></td></tr></table></figure></p>
<p>我们发现，<strong>不需要重新编译main进程，就可以达到替换test函数实现的效果</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>动态库应用广泛，其制作过程可能不作深入要求，但是其基本使用还是非常有必要了解的。本文总结如下：</p>
<ul>
<li>程序运行时不能脱离动态库</li>
<li>动态库有两种常见使用方式，一种是加载是链接，一种是运行时链接</li>
<li>只要函数声明没有改变，动态库中函数实现的更新不需要重新编译可执行文件</li>
</ul>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>链接</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程-再看TCP的四次挥手</title>
    <url>/2019/07/14/62738.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在《<a href="https://www.yanbinghu.com/2019/07/02/52476.html">网络编程-从TCP连接的建立说起</a>》中介绍了TCP的三次握手以及一些常见问题，那么四次挥手又有哪些需要特别关注的问题？哪些又是面试最常问的问题呢？<br><a id="more"></a></p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>四次挥手的流程在很多地方都可以看到，这里简略介绍一下，其最常见流程如下图所示：<br><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/tcp_disconnect/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt><br>其大体流程如下：</p>
<ul>
<li>客户端发其结束请求，发送seq=X，处于FIN_WAIT_1状态</li>
<li>服务端收到结束请求，发送应答ACK=X+1，处于CLOSE_WAIT状态</li>
<li>客户端收到X的应答后，处于FIN_WAIT_2状态，此时还可以接收来自服务端的数据</li>
<li>服务端没有数据要发送，也发送结束请求，seq=Y,处于LAST_ACK状态</li>
<li>客户端又收到服务端的结束请求，客户端回应ACK，此时处于TIME_WAIT状态，确保ACK能够到达服务端；服务端收到客户端最终ACK，关闭连接。</li>
<li>2MSL时间结束后，无论服务端是否收到最终ACK，客户端完全结束连接</li>
</ul>
<p>作为一种最常见的四次挥手场景，我们可能习以为常了，但需要注意的是，连接的断开并不只有这种情况，还可以是服务端发起主动关闭，或者双方同时发起，但这不是本文关注的重点。我们直接看看四次挥手有哪些需要注意的。</p>
<h2 id="什么是TCP的半关闭"><a href="#什么是TCP的半关闭" class="headerlink" title="什么是TCP的半关闭"></a>什么是TCP的半关闭</h2><p>TCP半关闭指的是<strong>一端结束发送后还能够接受来自另一端的数据</strong>。也就是说，虽然客户端准备断开连接并且发送了FIN报文，客户端还是可以接收来自服务端的数据。不过这种关闭方式不能使用close接口，而需要使用shutdown：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> how)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>并且how参数值为SHUT_WR，即1，表明shutdown for writing ，仅关闭本端的发送。</p>
<h2 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h2><p>为什么建立一个TCP连接需要三次握手，而终止一个连接需要四次挥手呢？<strong>这是因为TCP半关闭造成的</strong>。由于一个TCP连接是全双工的，在两个方向上都能传输数据，因此两个方向就需要单独关闭。所以这个流程是这样的：</p>
<ul>
<li>客户端执行主动关闭，发送FIN报文，告诉服务端，我没有数据要发送了，我要关闭连接，当然了，你有啥数据要给我，我随时候着</li>
<li>服务端收到后，必须及时告诉客户端我收到了，因此先回复客户端一个ACK。但是服务端可能还有未发送完的数据，因此它可以将自己未完成的数据进行发送，发送完成之后，再发送给客户端FIN报文，表明我也没啥要发送的了，关闭吧</li>
<li>客户端收到后，也回复ACK响应，最终关闭连接</li>
</ul>
<p>因而整个过程需要四次挥手。</p>
<h2 id="为什么要TIME-WAIT状态"><a href="#为什么要TIME-WAIT状态" class="headerlink" title="为什么要TIME_WAIT状态"></a>为什么要TIME_WAIT状态</h2><p>TIME_WAIT也称为2MSL等待时间。MSL为报文最大生存时间，它是任何报文在被丢弃前存在于网络内的最长时间。这个时间在不同类型的系统中可能有所不同，但这不是关键。在我个人的机器上，可以借助netstat命令和nc命令通过下面的方式观察到。在终端1监听1234端口：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nc -l 1234</span></span><br></pre></td></tr></table></figure></p>
<p>在终端2连接到1234端口：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nc 127.0.0.1 1234</span></span><br></pre></td></tr></table></figure></p>
<p>在终端3通过netstat命令观察：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ netstat -anpoc|grep :1234</span><br></pre></td></tr></table></figure></p>
<p>然后在终端1按ctrl+c，终止连接，立刻观察终端3的结果，我们发现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcp        0      0 127.0.0.1:1234          127.0.0.1:33524         TIME_WAIT   -                timewait (59.76/0/0)</span><br><span class="line">tcp        0      0 127.0.0.1:1234          127.0.0.1:33524         TIME_WAIT   -                timewait (58.74/0/0)</span><br><span class="line">tcp        0      0 127.0.0.1:1234          127.0.0.1:33524         TIME_WAIT   -                timewait (57.71/0/0)</span><br><span class="line">tcp        0      0 127.0.0.1:1234          127.0.0.1:33524         TIME_WAIT   -                timewait (56.69/0/0)</span><br></pre></td></tr></table></figure></p>
<p>我们可以观察到，服务端当前处于TIME_WAIT，且有一个timewait的定时器，为1分钟。</p>
<p>netstat命令和nc命令的使用可以分别参考《<a href="https://www.yanbinghu.com/2019/06/23/55893.html">不可不知的网络命令-netstat</a>》和《<a href="https://www.yanbinghu.com/2019/06/23/55893.html">网络工具中的”瑞士军刀“-nc</a>》。<br>TIME_WAIT状态的存在主要考虑以下两个方面：</p>
<ul>
<li>实现可靠的四次挥手</li>
<li>避免收到老的报文</li>
</ul>
<p>为什么说TIME_WAIT是为了实现可靠的四次挥手呢？试想一下，如果客户端最后回应的ACK丢了，那么服务端会再次发送FIN报文，此时，客户端必须处于一个等待状态，否则服务端永远无法收到这个ACK，而会收到一个RST，以为出错。而如果客户端此时处于TIME_WAIT状态，即等待2MSL时间，它还可以再次回应服务端ACK。这也就保证了可靠的四次挥手。</p>
<p>当然了，如果在2MSL时间内，服务端还没有收到，那么对不起，客户端已经仁至义尽了，不会再等待了。</p>
<p>这里需要注意，<strong>最终执行主动关闭的那一端会处于TIME_WAIT状态</strong>。</p>
<p><strong>那么为什么又说是为了避免收到老的重复报文呢？</strong></p>
<p>试想这样的场景：<br>假设一开始已经有一个连接在1234端口建立，我们关闭这个连接；过一会我们在同样的ip和端口建立连接，但是TCP必须防止在前一次连接中的老的报文在它原先的连接已终止后，还出现在这个新的连接中，因此，TCP将不允许在处于TIME_WAIT状态的ip和端口处建立新的连接。而2MSL时间过后，老的报文早已在网络中消失了，也就避免了这种情况的发生。</p>
<p>这种情况可以很容易通过《<a href="https://www.yanbinghu.com/2019/07/07/40135.html">网络编程-一个简单的echo程序</a>》的server程序来观察：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./server  <span class="comment">#在一个终端启动server，</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./client 127.0.0.1 1234 <span class="comment">#在另一个终端启动client</span></span></span><br></pre></td></tr></table></figure></p>
<p>在服务端终端ctrl+c终止服务端，然后再次启动server：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./server</span><br><span class="line">bind error: Address already in use</span><br><span class="line">$ netstat -anop|grep :1234</span><br><span class="line">tcp        1      0 127.0.0.1:33722         127.0.0.1:1234          CLOSE_WAIT  11691/client     off (0.00/0/0)</span><br><span class="line">tcp        0      0 127.0.0.1:1234          127.0.0.1:33722         FIN_WAIT2   -                timewait (57.92/0/0)</span><br></pre></td></tr></table></figure></p>
<p>终止服务端后，服务端处于TIME_WAIT状态，此时再次启动server，将不能使用原来的ip和端口建立连接，因此出现Address already in use的报错。</p>
<p>但是需要注意：</p>
<ul>
<li>由于客户端通常使用的是临时端口（仔细观察会发现，客户端每次启动使用的端口基本都不一样），因此客户端即便处于TIME_WAIT状态，也不影响它马上再次启动</li>
<li>一些实现允许一个新的连接请求仍然处于TIME_WAIT状态的连接，只要新的seq大于该连接的前一个连接的最后序号</li>
<li>通过设置选项SO_REUSEADDR，可以让一个进程重新使用仍处于TIME_WAIT状态的socket</li>
</ul>
<h2 id="半打开的TCP连接"><a href="#半打开的TCP连接" class="headerlink" title="半打开的TCP连接"></a>半打开的TCP连接</h2><p>假设一个连接建立之后，突然有一方异常终止连接了，但是另一个不知道，这个时候TCP的连接就是半打开的。如果服务端不加处理，那么最终就会导致服务端有大量的半打开连接。那么服务端如何知道客户端的连接已经异常终止了呢？如果等待服务端发送数据出错时发现，那么这个时候可能已经太晚了。</p>
<p>幸运的是，TCP有保活定时器。即服务端可以通过设置保活选项来了解客户端是否已经终止连接。<br>通过下面的方式可以看到很多连接有这样的定时器：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ netstat -npo|grep keepalive</span><br><span class="line">tcp        0      0 192.168.0.103:50832     59.111.179.136:443      ESTABLISHED 5882/chrome      keepalive (37.33/0/0)</span><br><span class="line">tcp        0      0 192.168.0.103:50638     154.8.131.191:443       ESTABLISHED 5882/chrome      keepalive (0.00/0/0)</span><br><span class="line">tcp        0      0 192.168.0.103:59330     203.107.41.32:9026      ESTABLISHED 5882/chrome      keepalive (0.35/0/0)</span><br><span class="line">tcp        0      0 127.0.0.1:45632         127.0.0.1:1080          ESTABLISHED 5886/firefox     keepalive (335.28/0/0)</span><br><span class="line">tcp        0      0 192.168.0.103:49940     59.56.78.189:443        ESTABLISHED 5882/chrome      keepalive (26.36/0/0)</span><br></pre></td></tr></table></figure></p>
<p>但可惜的是，这样的定时器时间太长了，并且它不能代表应用程序能够正常工作，能够正常收发数据，因此应用层常常也会实现一个心跳机制。</p>
<blockquote>
<p>来源：公众号【编程珠玑】<br>网站：<a href="https://www.yanbinghu.com">https://www.yanbinghu.com</a></p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文花了大量篇幅介绍了TIME_WAIT状态，这也是面试中常问的问题，重新梳理TCP的四次挥手是很有必要的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Unix网络编程》<br>《TCP/IP协议详解》</p>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql语法速记</title>
    <url>/2019/07/10/38883.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在数据库领域，mysql是不可避免需要学习的，本文记录常见sql语句。<br><a id="more"></a></p>
<h2 id="查看帮助信息"><a href="#查看帮助信息" class="headerlink" title="查看帮助信息"></a>查看帮助信息</h2><p>例如查看show命令的使用方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">help show;</span><br></pre></td></tr></table></figure></p>
<h2 id="数据库和表"><a href="#数据库和表" class="headerlink" title="数据库和表"></a>数据库和表</h2><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure>
<h4 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure>
<h4 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use test;</span><br></pre></td></tr></table></figure>
<h4 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop database test;</span><br></pre></td></tr></table></figure>
<h4 id="查看数据库表"><a href="#查看数据库表" class="headerlink" title="查看数据库表"></a>查看数据库表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure>
<h4 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop table userInfo;</span><br></pre></td></tr></table></figure>
<h4 id="查看创建数据库或表的mysql语句"><a href="#查看创建数据库或表的mysql语句" class="headerlink" title="查看创建数据库或表的mysql语句"></a>查看创建数据库或表的mysql语句</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show create table aa;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Table</th>
<th>Create Table</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>aa</td>
<td>CREATE TABLE <code>aa</code> (<br><code>Enc_Account_Nbr</code> int(11) DEFAULT NULL,<br><code>Residual_Code_Desc</code> varchar(7) DEFAULT NULL,<br><code>Country1_Flag</code> varchar(3) DEFAULT NULL<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8</td>
</tr>
</tbody>
</table>
</div>
<h4 id="显示信息"><a href="#显示信息" class="headerlink" title="显示信息"></a>显示信息</h4><p>显示服务器状态信息<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show status;</span><br></pre></td></tr></table></figure></p>
<p>显示授予用户的安全权限<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show grants;</span><br></pre></td></tr></table></figure></p>
<p>显示错误或警告信息<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show errors；</span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show warnings;</span><br></pre></td></tr></table></figure></p>
<h2 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h2><p>假设创建名为userInfo的表，有三个字段，分别为name，age，和id。<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> userInfo(</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    age <span class="built_in">INT</span>,</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span></span><br><span class="line"> );</span><br></pre></td></tr></table></figure></p>
<p>插入几条测试数据：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into userInfo(name,age,id) values (&quot;test&quot;,15,1);</span><br><span class="line">insert into userInfo(name,age,id) values (&quot;tet&quot;,15,2);</span><br><span class="line">insert into userInfo(name,age,id) values (&quot;编程珠玑&quot;,5,3);</span><br><span class="line">insert into userInfo(name,age,id) values (&quot;yanbinghu&quot;,5,4);</span><br></pre></td></tr></table></figure></p>
<h2 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h2><h4 id="检索特定列"><a href="#检索特定列" class="headerlink" title="检索特定列"></a>检索特定列</h4><p>从表userInfo中查找name列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name from userInfo;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>name</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>test</td>
</tr>
<tr>
<td>2</td>
<td>tet</td>
</tr>
<tr>
<td>3</td>
<td>编程珠玑</td>
</tr>
<tr>
<td>4</td>
<td>yanbinghu</td>
</tr>
</tbody>
</table>
</div>
<h4 id="检索多列"><a href="#检索多列" class="headerlink" title="检索多列"></a>检索多列</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name,age from userInfo;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>test</td>
<td>15</td>
</tr>
<tr>
<td>2</td>
<td>tet</td>
<td>15</td>
</tr>
<tr>
<td>3</td>
<td>编程珠玑</td>
<td>5</td>
</tr>
<tr>
<td>4</td>
<td>yanbinghu</td>
<td>5</td>
</tr>
</tbody>
</table>
</div>
<h4 id="检索所有列"><a href="#检索所有列" class="headerlink" title="检索所有列"></a>检索所有列</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from userInfo;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>name</th>
<th>age</th>
<th>id</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>test</td>
<td>15</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>tet</td>
<td>15</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>编程珠玑</td>
<td>5</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>yanbinghu</td>
<td>5</td>
<td>4</td>
</tr>
</tbody>
</table>
</div>
<h4 id="检索限定结果数量"><a href="#检索限定结果数量" class="headerlink" title="检索限定结果数量"></a>检索限定结果数量</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name,age from userInfo limit 2;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>test</td>
<td>15</td>
</tr>
<tr>
<td>2</td>
<td>tet</td>
<td>15</td>
</tr>
</tbody>
</table>
</div>
<h4 id="检索某列不同的值"><a href="#检索某列不同的值" class="headerlink" title="检索某列不同的值"></a>检索某列不同的值</h4><p>将age不同的列检索出来<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select distinct age from userInfo;</span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>15</td>
</tr>
<tr>
<td>2</td>
<td>5</td>
</tr>
</tbody>
</table>
</div>
<h4 id="检索结果排序"><a href="#检索结果排序" class="headerlink" title="检索结果排序"></a>检索结果排序</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from userInfo order by age;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>name</th>
<th>age</th>
<th>id</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>编程珠玑</td>
<td>5</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>yanbinghu</td>
<td>5</td>
<td>4</td>
</tr>
<tr>
<td>3</td>
<td>test</td>
<td>15</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>tet</td>
<td>15</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<p>按年龄递减顺序<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from userInfo order by age desc;</span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>name</th>
<th>age</th>
<th>id</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>test</td>
<td>15</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>tet</td>
<td>15</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>编程珠玑</td>
<td>5</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>yanbinghu</td>
<td>5</td>
<td>4</td>
</tr>
</tbody>
</table>
</div>
<h4 id="条件过滤"><a href="#条件过滤" class="headerlink" title="条件过滤"></a>条件过滤</h4><p>查找name为”test”的行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from userInfo where name=&quot;test&quot;;</span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>name</th>
<th>age</th>
<th>id</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>test</td>
<td>15</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>除了可以用等于条件外，还可以使用</p>
<ul>
<li><blockquote>
<p>大于</p>
</blockquote>
</li>
<li>&lt; 小于</li>
<li>&lt;&gt; 不等于</li>
</ul>
<p>查找id在2到3范围的行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from userInfo where id between 2 and 3;</span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>name</th>
<th>age</th>
<th>id</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>tet</td>
<td>15</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>编程珠玑</td>
<td>5</td>
<td>3</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下制作静态库</title>
    <url>/2019/07/10/23906.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在《<a href="https://www.yanbinghu.com/2019/06/27/47343.html">一文带你了解静态库和动态库</a>》一文中介绍了静态库的特点以及与动态库的区别。那么你有没有想过如何把自己写好的函数接口制作成静态库给别人用呢？本文教你如何制作属于自己的静态库。<br><a id="more"></a></p>
<h2 id="编译成可重定位文件"><a href="#编译成可重定位文件" class="headerlink" title="编译成可重定位文件"></a>编译成可重定位文件</h2><p>在《<a href="https://www.yanbinghu.com/2019/06/27/47343.html">一文带你了解静态库和动态库</a>》简单介绍了可重定位文件。其中也有一位非常细心的读者发现，在ubuntu18.04的系统，使用gcc7.4编译出来的可执行文件的type是DYN，这是编译器生成了一种位置无关的可执行文件（PIE），它类似于动态库，其地址在加载时确定，从而更加安全。本文不再展开介绍。</p>
<p>本文实例代码test1.c代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】 网站：https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"test1.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am test1\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译成可重定位文件，即生成.o文件：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> gcc -c test1.c</span><br><span class="line"><span class="meta">$</span> readelf -h test1.o</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2's complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              REL (Relocatable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">(省略部分内容)</span><br></pre></td></tr></table></figure></p>
<p>关于编译的几个阶段，可以参考《<a href="https://www.yanbinghu.com/2018/10/10/27133.html">代码是如何变成可执行文件的</a>》。</p>
<h2 id="制作成静态库"><a href="#制作成静态库" class="headerlink" title="制作成静态库"></a>制作成静态库</h2><p>为了制作成静态库，我们需要使用ar命令。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> ar -rcs libtest1.a test1.o   #库名一般以.a为扩展名，以lib开头</span><br><span class="line"><span class="meta">$</span> ar -t libtest1.a  #查看内容</span><br><span class="line">test1.o</span><br></pre></td></tr></table></figure></p>
<p>通常来说，静态库以.a作为后缀，且以lib开头。至此就将我们提供的test1函数做成了静态库，但是为了方便其他人使用，我们再提供一个头文件test1.h，代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>这个时候就可以将我们做好的静态库给其他人使用啦。</p>
<h2 id="使用静态库"><a href="#使用静态库" class="headerlink" title="使用静态库"></a>使用静态库</h2><p>我们写一个main.c来调用test1():<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】 网站：https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"test1.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> gcc -o main main.c -L ./  -ltest1</span><br><span class="line"><span class="meta">$</span> ./main</span><br><span class="line">I am test1</span><br></pre></td></tr></table></figure></p>
<p>其中-L用于指定链接库的路径，由于我们要链接的库名为libtest1.a，在链接的时候，去掉开头的lib和后缀.a，前面再加l，就变成了-ltest1，其他库也是类似。例如，你如果看到程序链接使用-lm，说明它使用了名为libm.a的库。</p>
<h2 id="再看静态库使用"><a href="#再看静态库使用" class="headerlink" title="再看静态库使用"></a>再看静态库使用</h2><p>如果这时候还有一个库libtest0.a，库中调用了test1.c的函数，而main函数调用了libtest0.a中的函数呢？即，假设有test0.c中调用test1()，且两者位于不同的库中，test0.c代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"test0.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am test0,I will call test1\n"</span>);</span><br><span class="line">    test1();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"test0 call test1 end\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>头文件test0.h:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"test1.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>还是以类似的方法制作静态库libtest0.a:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">$</span> gcc -c test0.c</span><br><span class="line"><span class="meta">$</span> ar -rcs libtest0.a test0.o</span><br></pre></td></tr></table></figure></p>
<p>改写main.c：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】 网站：https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"test0.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test0();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重新编译链接：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o main main.c -L ./ -ltest1 -ltest0</span><br><span class="line">.//libtest0.a(test0.o): In function `test0&apos;:</span><br><span class="line">test0.c:(.text+0x14): undefined reference to `test1&apos;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure></p>
<p>这里我们发现编译出错了，提示test1未定义，很显然是由于test0中调用了test1。至于解决办法也很简单，调整链接库的顺序即可，更加详细的原因可以参考《<a href="https://www.yanbinghu.com/2018/10/06/46212.html">一个奇怪的链接问题</a>》和《<a href="https://www.yanbinghu.com/2019/06/27/47343.html">静态库和动态库的区别</a>》。</p>
<p>我们调整之后再次编译链接并运行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o main main.c -L ./ -ltest0 -ltest1</span><br><span class="line">$ ./main</span><br><span class="line">I am test0,I will call test1</span><br><span class="line">I am test1                </span><br><span class="line">test0 call test1 end</span><br></pre></td></tr></table></figure></p>
<p>可以看到，在调整两个库的顺序之后，编译链接正常，并且程序也按照我们预期的结果运行。</p>
<p>因此，<strong>我们在链接时，应该尽量把被需要的库放在后面</strong>。</p>
<blockquote>
<p>本文作者：守望<br>来源：<a href="https://www.yanbinghu.com">https://www.yanbinghu.com</a></p>
</blockquote>
<h2 id="ar命令详解"><a href="#ar命令详解" class="headerlink" title="ar命令详解"></a>ar命令详解</h2><p>从前面的内容我们可以观察到，我们是通过ar命令来制作静态库（归档文件）的，它<strong>可以将多个按照一定的规则组织在一起</strong>。我们再来了解一下ar命令，ar命令常见参数如下：</p>
<ul>
<li>r 向归档文件中添加内容,如原先已存在，则替换</li>
<li>c 创建归档文件</li>
<li>s 添加索引信息</li>
<li>d 从归档文件中删除</li>
<li>t 查看归档文件的内容</li>
<li>x 解压归档文件</li>
<li>a/b 向归档文件中添加内容</li>
<li>v 显示详细信息</li>
</ul>
<p>rcs参数我们已经在前面用到了。-a（after）或者-b（before）参数可以向归档文件中添加文件，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ar -ra test0.o libtest0.a test1.o</span><br></pre></td></tr></table></figure></p>
<p>这里表示在libtest0.a中的test0.o之后，添加test1.o。<br>添加后内容如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> ar -t libtest0.a</span><br><span class="line">test0.o</span><br><span class="line">test1.o</span><br></pre></td></tr></table></figure></p>
<p>当然了，归档文件是可以解开的，比如：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> ar -xv libtest0.a </span><br><span class="line">x - test0.o</span><br><span class="line">x - test1.o</span><br></pre></td></tr></table></figure></p>
<p>你要删除其中的某个文件，也是没人阻止的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ar -d test1.o libtest0.a </span><br><span class="line">d - test1.o</span><br></pre></td></tr></table></figure></p>
<p>-d参数后面跟着要移除的文件。</p>
<p>需要特别注意的是，这里<strong>ar归档的作用并不仅仅针对可重定位目标文件，而是几乎针对任何类型的普通文件</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>制作静态库不过是利用ar命令把一些文件可重定位文件打包在一起，其他程序在使用时需要通过链接动态将自己需要的内容“拷贝”到最终的可执行文件中。现在知道如何制作属于自己的静态库了吗？赶紧自己试试吧！</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>链接</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程-一个简单的echo程序(1)</title>
    <url>/2019/07/08/3270.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在《<a href="https://www.yanbinghu.com/2019/07/07/40135.html">网络编程-一个简单的echo程序(0)</a>》中已经对程序整体有了宏观的认识，本文将抽丝剥茧，逐步深入了解echo程序。<br><a id="more"></a></p>
<h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><p>由于代码内容较多，具体代码可访问《<a href="https://www.yanbinghu.com/2019/07/07/40135.html">网络编程-一个简单的echo程序(0)</a>》或者访问：<br><a href="https://www.yanbinghu.com/2019/07/07/40135.html">https://www.yanbinghu.com/2019/07/07/40135.html</a></p>
<h2 id="数据结构与函数详解"><a href="#数据结构与函数详解" class="headerlink" title="数据结构与函数详解"></a>数据结构与函数详解</h2><p>既然要详细了解echo程序，就必须对其中用到的一些数据结构和接口有所了解。在echo程序中，我们主要用到了以下的数据结构或函数：</p>
<ul>
<li>htons/ntohs</li>
<li>inet_pton/inet_ntop</li>
<li>sockaddr_in</li>
<li>socket</li>
<li>bind</li>
<li>listen</li>
<li>connect</li>
<li>accept</li>
</ul>
<p>当然需要清楚的是，网络编程中用到的数据结构或函数远不止上面提到的这些，但这些都是最基本的。下面的解释都基于echo程序，多数函数都使用默认的阻塞模式。</p>
<h2 id="htons-ntohs"><a href="#htons-ntohs" class="headerlink" title="htons/ntohs"></a>htons/ntohs</h2><p>htons/ntohs这两个宏分别用于将本地字节序转为网络字节序和将网络字节序转为本地字节序。关于字节序，本文不展开介绍，可以参考《<a href="https://www.yanbinghu.com/2018/10/02/25450.html">谈一谈字节序的问题</a>》，<strong>如何判断当前机器的字节序</strong>，也是面试中经常问到的题目。</p>
<h2 id="inet-pton-inet-ntop"><a href="#inet-pton-inet-ntop" class="headerlink" title="inet_pton/inet_ntop"></a>inet_pton/inet_ntop</h2><p>inet_pton/inet_ntop分别用于将字符串ip地址转为4字节大小的无符号整型和将无符号整型转换为ip地址字符串。例如：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：公众号【编程珠玑】网站：https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ip[<span class="number">16</span>] = <span class="string">"192.168.0.1"</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">addr</span>;</span></span><br><span class="line">    inet_pton(AF_INET, ip, &amp;addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"addr is %x\n"</span>,addr);</span><br><span class="line"></span><br><span class="line">    addr.s_addr = <span class="number">0x153a8c0</span>;</span><br><span class="line">    inet_ntop(AF_INET,&amp;addr,ip,<span class="keyword">sizeof</span>(ip));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ip is %s"</span>,ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addr is 100a8c0                                                                 </span><br><span class="line">ip is 192.168.83.1</span><br></pre></td></tr></table></figure></p>
<p>从运行结果中可以清晰看到两者之间的转换。需要注意的是，inet_pton/inet_ntop对IPV4和IPV6地址都适用。</p>
<h2 id="sockaddr-in"><a href="#sockaddr-in" class="headerlink" title="sockaddr_in"></a>sockaddr_in</h2><p>sockaddr_in是IPV4套接字地址结构，它在不同系统中具体定义可能有所不同：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family;</span><br><span class="line">    <span class="keyword">in_port_t</span> sin_port;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> sin_zero[<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>但它们都包含三个基本的成员：</p>
<ul>
<li>sin_family  协议族</li>
<li>sin_port    协议端口</li>
<li>sin_addr    协议地址</li>
</ul>
<p>协议族通常有以下几种类型：</p>
<ul>
<li>AF_INET   IPV4协议</li>
<li>AF_INET6  IPV6协议</li>
<li>AF_LOCAL  Unix域协议</li>
<li>AF_ROUTE  路由套接字</li>
<li>AF_KEY    秘钥套接字</li>
<li>…</li>
</ul>
<p>而目前echo程序中用到的是IPV4协议，因此选择了AF_INET。</p>
<p>而sin_port就比较容易理解了，它是一个16比特大小的端口，但是由于它的信息需要在网络中传输，因此需要使用前面介绍的htons进行字节序的转换。</p>
<p>sin_addr用4字节存储ip地址，如果是形如127.0.0.1的地址，需要通过inet_pton函数将其转换为struct in_addr类型。</p>
<h2 id="socket—确定协议族和套接字类型"><a href="#socket—确定协议族和套接字类型" class="headerlink" title="socket—确定协议族和套接字类型"></a>socket—确定协议族和套接字类型</h2><p>调用socket函数是执行网络I/O之前必须做的一件事情。<strong>通过socket函数指定了本次网络通信的协议族，套接字类型</strong>，调用成功后，会返回一个非负的套接字描述符，否则返回-1，具体失败原因，被存放于全局变量errno。它和文件描述类似，只不过此时它还不能进行正常的网络读写。<br>socket函数相关信息如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> family,<span class="keyword">int</span> type,<span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>其中family就是在介绍sockaddr_in中提到的协议族。</p>
<p>type通常有以下几个值：</p>
<ul>
<li>SOCK_STREAM 字节流套接字</li>
<li>SOCK_DGRA   数据报套接字</li>
<li>SOCK_RAW    原始套接字</li>
<li>SOCK_SEQPACKET  有序分组套接字</li>
<li>SOCK_PACKET   分组套接字</li>
<li>…</li>
</ul>
<p>需要注意的是：</p>
<ul>
<li>TCP仅支持字节流套接字</li>
<li>UDP仅支持数据报套接字</li>
<li>SCTP支持字节流套接字和数据报套接字</li>
</ul>
<p>protocol通常指以下几种：</p>
<ul>
<li>IPPROPO_TCP   TCP协议</li>
<li>IPPROPO_UDP  UDP协议</li>
<li>IPPROPO_SCTP SCTP协议</li>
<li>…</li>
</ul>
<p>通常来说，一种传输协议只支持一种套接字，此时protocol可以为0，系统会选择其对应的协议类型；否则的话，需要指定protocol的值。在当前echo程序中，type为SOCK_STREAM，我们的protocol值为0，因此使用的就是TCP协议。</p>
<p>我们通过一个简单的例子，观察这个套接字描述符：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//testSocket.c</span></span><br><span class="line"><span class="comment">//来源：公众号【编程珠玑】网站：https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> socktfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    sleep(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在一个终端运行testSocket，在另外一个终端找到该程序的pid，并查看打开的文件描述符：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pidof testSocket</span></span><br><span class="line">5903</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l /proc/5903/fd/</span></span><br><span class="line">total 0</span><br><span class="line">lrwx------ 1 hyb hyb 64 7月   8 19:59 0 -&gt; /dev/pts/6</span><br><span class="line">lrwx------ 1 hyb hyb 64 7月   8 19:59 1 -&gt; /dev/pts/6</span><br><span class="line">lrwx------ 1 hyb hyb 64 7月   8 19:59 2 -&gt; /dev/pts/6</span><br><span class="line">lrwx------ 1 hyb hyb 64 7月   8 19:59 3 -&gt; socket:[62182]</span><br></pre></td></tr></table></figure></p>
<p>还记得那句话吗：linux下一切皆文件。</p>
<h2 id="bind—指定套接字地址信息"><a href="#bind—指定套接字地址信息" class="headerlink" title="bind—指定套接字地址信息"></a>bind—指定套接字地址信息</h2><p>调用socket函数之后已经确定了协议族和传输协议，但是还没有确定本地协议，即套接字地址信息。bind函数描述如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">const</span> struct sockaddr *addr,<span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>sockfd是前面调用socket函数返回的套接字描述符，用于将协议地址绑定到指定套接字中去，返回0表明成功，-1表示失败，具体失败原因，被存放于全局变量errno。addr是套接字地址，它并不是我们前面所看到的sockaddr_in类型，而是struct sockaddr，因为struct sockaddr是通用类型，不仅适用于IPV4套接字地址，也需要适用于IPV6套接字地址。</p>
<p>addr中的ip地址可以为0（INADDR_ANY），表示使用通配地址；而端口为0，表示由内核分配一个临时端口。服务器需要被客户端连接，因此其端口通常都是确定的，不会选择一个临时端口。</p>
<p>但是在客户端其ip地址和端口并非需要确切知道，因此客户端常常不绑定端口。在我们的echo程序中，我们也没有在客户端调用bind函数。</p>
<h2 id="listen—监听客户端连接"><a href="#listen—监听客户端连接" class="headerlink" title="listen—监听客户端连接"></a>listen—监听客户端连接</h2><p>listen函数用于将前面得到的套接字变为一个被动套接字，即<strong>可用于接受来自客户端的连接</strong>。描述如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>返回0表明成功，-1表明失败，具体失败原因，被存放于全局变量errno。sockfd就是socket函数调用返回的套接字描述符，而backlog指明了连接队列的大小，即完成和还未完成TCP三次握手的连接总和。如果这个队列满了，服务器就不会理会新的连接请求。还记得在《<a href="https://www.yanbinghu.com/2019/07/02/52476.html">网络编程-从TCP连接的建立说起</a>》中提到的SYN攻击吗？</p>
<h2 id="connect—建立连接"><a href="#connect—建立连接" class="headerlink" title="connect—建立连接"></a>connect—建立连接</h2><p><strong>connect函数在客户端调用</strong>，它用来与服务端建立连接。描述如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">const</span> struct sockaddr *addr,<span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>返回0表明成功，-1表明失，具体失败原因，被存放于全局变量errno。connect函数的参数与bind函数一样，这里就不多做解释了，只不过addr指明的是远端协议地址。如果本次连接是TCP协议，则<strong>connect函数调用将会发起TCP的三次握手</strong>。</p>
<h2 id="accept—接受来自客户端的连接"><a href="#accept—接受来自客户端的连接" class="headerlink" title="accept—接受来自客户端的连接"></a>accept—接受来自客户端的连接</h2><p>accept函数在服务端调用，它用于接受来自客户端的连接，从已完成连接队列返回一个已完成连接。描述如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">const</span> struct sockaddr *addr,<span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>成功返回非负套接字描述符，失败返回-1，具体失败原因，被存放于全局变量errno。需要注意的是accept函数参数类型和数量与connect函数一致，但是含义不同，addr用于获取客户端的套接字地址信息，如果不关心客户端的协议地址，那么该参数可为NULL。</p>
<p>另外需要注意的是，它的返回值是一个非负的套接字描述符，这个套接字描述符是已连接套接字描述符，而其参数sockfd是监听套接字描述符。一个服务器通常一直有且只有一个监听套接字描述符，但通常会有多个已连接套接字描述符。还记得在上一篇中问到的吗？为什么客户端连接到服务端后，服务端有一个处于LISTEN状态，还有一个处于ESTABLISHED状态吗？</p>
<p>通过已连接套接字描述符就可以对其进行数据的读写了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文主要对echo程序中用到的一些数据结构和函数进行了介绍，但没有涉及具体的异常场景，后面的文章将根据实际情况来看看其具体应用。本文常用接口总结如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>接口</th>
<th>作用</th>
<th>成功</th>
<th>失败</th>
<th>调用者</th>
</tr>
</thead>
<tbody>
<tr>
<td>socket</td>
<td>确定协议族和套接字类型</td>
<td>套接字描述符</td>
<td>-1</td>
<td>客户端/服务端</td>
</tr>
<tr>
<td>bind</td>
<td>确定套接字地址</td>
<td>0</td>
<td>-1</td>
<td>[客户端]/服务端</td>
</tr>
<tr>
<td>listen</td>
<td>套接字转为被动套接字</td>
<td>0</td>
<td>-1</td>
<td>服务端</td>
</tr>
<tr>
<td>connect</td>
<td>建立连接</td>
<td>0</td>
<td>-1</td>
<td>客户端</td>
</tr>
<tr>
<td>accept</td>
<td>接受连接</td>
<td>套接字描述符</td>
<td>-1</td>
<td>服务端</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/network/echo/echo0.png" alt="网络编程"></p>
<h2 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h2><ul>
<li>《Unix网络编程》</li>
<li>《TCP/IP协议详解：卷一》</li>
</ul>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程-一个简单的echo程序(0)</title>
    <url>/2019/07/07/40135.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一篇《<a href="https://www.yanbinghu.com/2019/07/02/52476.html">网络编程-从TCP连接的建立说起</a>》中简单介绍了TCP连接的建立，本文暂时先抛开TCP更加详细的介绍，来看看如何实现一个简单的网络程序。<br><a id="more"></a></p>
<h2 id="一个简单的echo程序"><a href="#一个简单的echo程序" class="headerlink" title="一个简单的echo程序"></a>一个简单的echo程序</h2><p>本文以及后续文章都将会围绕该程序进行介绍。程序大体流程如下：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/network/echo/echo.png" alt="echo程序"></p>
<p>首先启动服务端，客户端通过TCP的三次握手与服务端建立连接；而后，客户端发送一段字符串，服务端收到字符串后，原封不动的发回给客户端。</p>
<p>我们先将代码呈现，后面再进行更加详细的解释。<br>客户端代码client.c如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//client.c</span></span><br><span class="line"><span class="comment">//来源：公众号【编程珠玑】网站：https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 128</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>    sockfd;  <span class="comment">//连接描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>    <span class="title">servaddr</span>;</span><span class="comment">//socket结构信息</span></span><br><span class="line">    <span class="keyword">char</span> sendMsg[MAXLINE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> recvMsg[MAXLINE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检查参数数量</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage: ./client ip port\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化结构体</span></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指定协议族</span></span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">//第一个参数为ip地址，需要把ip地址转换为sin_addr类型</span></span><br><span class="line">    inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr);</span><br><span class="line">    <span class="comment">//第二个参数为端口号</span></span><br><span class="line">    servaddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == sockfd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接服务器，如果非0，则连接失败</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> != connect(sockfd, (<span class="keyword">const</span> struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"connect failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从控制台读取消息</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> !=fgets(sendMsg,MAXLINE,<span class="built_in">stdin</span>))</span><br><span class="line">    &#123;        </span><br><span class="line">        write(sockfd, sendMsg, <span class="built_in">strlen</span>(sendMsg));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> != read(sockfd, recvMsg, MAXLINE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"recv msg:%s\n"</span>,recvMsg);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>服务端代码server.c如下:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//server.c</span></span><br><span class="line"><span class="comment">//来源：公众号【编程珠玑】网站：https://www.yanbinghu.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 1234</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 128</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>    listenfd = <span class="number">0</span>;<span class="comment">//监听描述符</span></span><br><span class="line">    <span class="keyword">int</span>    connfd = <span class="number">0</span>; <span class="comment">//已连接描述符</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clilen;</span><br><span class="line">    <span class="keyword">char</span> recvMsg[MAXLINE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//服务器和客户端socket信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>    <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> ip[MAXLINE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化服务端socket信息</span></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果输入ip和端口，使用输入的ip和端口</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">3</span> == argc)</span><br><span class="line">    &#123;</span><br><span class="line">        inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr);</span><br><span class="line">        servaddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">//使用默认的ip和port</span></span><br><span class="line">        servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">        servaddr.sin_port        = htons(SERV_PORT);</span><br><span class="line">    &#125;</span><br><span class="line">    listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == listenfd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//绑定指定ip和端口</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> != bind(listenfd,  (struct sockaddr *) &amp;servaddr, <span class="keyword">sizeof</span>(servaddr)))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"start server at %s:%d\n"</span>,inet_ntop(AF_INET,&amp;servaddr.sin_addr,ip,MAXLINE),ntohs(servaddr.sin_port));</span><br><span class="line">    listen(listenfd, <span class="number">4</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//处理来自客户端的连接</span></span><br><span class="line">    clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == connfd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"accept failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"connect from %s %d\n"</span>,inet_ntop(AF_INET,&amp;cliaddr.sin_addr,ip,MAXLINE),ntohs(cliaddr.sin_port));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读取客户端发送的消息</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> != read(connfd, recvMsg, MAXLINE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"recv msg:%s\n"</span>,recvMsg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将读取内容原封不动地发送回去</span></span><br><span class="line">    write(connfd, recvMsg, MAXLINE);</span><br><span class="line">    close(connfd);</span><br><span class="line">    close(listenfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h2><p>编译客户端服务端代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o client client.c</span><br><span class="line">$ gcc -o server server.c</span><br></pre></td></tr></table></figure></p>
<p>在两个终端分别运行server和client。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./server</span><br><span class="line">start server at 0.0.0.0:1234</span><br></pre></td></tr></table></figure></p>
<p>运行客户端，并输入内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./client 127.0.0.1 1234</span><br><span class="line">hello 编程珠玑</span><br></pre></td></tr></table></figure></p>
<p>服务端最终打印：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start server at 0.0.0.0:1234</span><br><span class="line">connect from 127.0.0.1 47536</span><br><span class="line">recv msg:hello 编程珠玑</span><br></pre></td></tr></table></figure></p>
<p>客户端最终打印：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello 编程珠玑</span><br><span class="line">recv msg:hello 编程珠玑</span><br></pre></td></tr></table></figure></p>
<p>从运行结果可以看到，客户端连接到服务端后，发送一段字符串“hello 编程珠玑”后，服务端返回同样的字符串，达到了我们想要的目的。当然代码里有很多地方还需要完善，但这不影响我们对网络编程的学习。</p>
<h2 id="整体流程说明"><a href="#整体流程说明" class="headerlink" title="整体流程说明"></a>整体流程说明</h2><p>整体流程可结合下图来理解：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/network/echo/echo1.png" alt="TCP三次握手"><br>TCP的三次握手，我们在《<a href="https://www.yanbinghu.com/2019/07/02/52476.html">网络编程-从TCP连接的建立说起</a>》中就已经介绍了。在图中，标示了在调用某些接口后的状态。例如，服务端在调用socket，bind，listen等函数后，处于LISTEN状态；客户端调用connect函数并返回后，完成三次握手，客户端与服务端都处于ESTABLISHED状态。</p>
<p>这些状态我们是可以观察到的，首先在一个终端启动服务器：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./server</span><br><span class="line">start server at 0.0.0.0:1234</span><br></pre></td></tr></table></figure></p>
<p>在另外一个终端使用netstat命令（或使用<a href="https://www.yanbinghu.com/2019/06/30/19183.html">ss命令</a>）观察：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ netstat -anp |grep :1234</span><br><span class="line">tcp        0      0 0.0.0.0:1234            0.0.0.0:*               LISTEN      17730/server</span><br></pre></td></tr></table></figure></p>
<p>netstat命令的使用可参考<a href="https://www.yanbinghu.com/2019/06/15/40941.html">netstat命令详解</a>，可以看到server程序当前处于LISTEN状态。</p>
<p>而如果客户端进行连接后再观察会发现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ netstat -anp |grep :1234</span><br><span class="line">tcp        0      0 0.0.0.0:1234            0.0.0.0:*               LISTEN      17730/server    </span><br><span class="line">tcp        0      0 127.0.0.1:48094         127.0.0.1:1234          ESTABLISHED 17957/client    </span><br><span class="line">tcp        0      0 127.0.0.1:1234          127.0.0.1:48094         ESTABLISHED 17730/server</span><br></pre></td></tr></table></figure></p>
<p>从结果中看到，客户端此时处于ESTABLISHED状态，而服务端有一条连接处于ESTABLISHED，还有一条处于LISTEN状态，这是为何呢？我们后面再解释。<br>由于三次握手的过程非常快，其他的状态我们不是很方便能观察到。</p>
<p>那么结合代码，整个流程又是怎样的呢？请看下图：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/network/echo/echo0.png" alt="客户端-服务端"></p>
<p>在弄清楚图中的接口含义之前，实际上你可以认为客户端连接服务器的整个过程你可以看成是这样的：</p>
<ul>
<li>服务端准备（socket，bind，listen，accept等待客户端）</li>
<li>客户端准备（socket）</li>
<li>客户端连接（connect）</li>
<li>服务端收到客户端的连接（accept返回），客户端连接成功，connect返回</li>
<li>客户端发送数据（write）</li>
<li>服务端接收数据（read），随后又将原数据发回（write）</li>
<li>客户端收到来自服务端的数据（read）</li>
</ul>
<p>当然了，我们需要注意到的是：</p>
<ul>
<li>服务端在accept阻塞的过程中，处于LISTEN状态</li>
<li>客户端在connect返回之后完成TCP的三次握手</li>
<li>三次握手完成后，客户端与服务端处于ESTABLISHED状态</li>
<li>服务端始终有一个处于LISTEN状态 </li>
</ul>
<p>不要着急，对于图中所提到的接口和数据结构的介绍和使用说明都会在后面进行详细介绍。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>看到这里，想必你对我们的echo程序的整体已经有了大致的了解。在对这些接口和数据结构进行详细介绍之前，你可以将代码复制并进行编译运行，观察文中提到的内容。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>TCP的三次握手发生在哪个阶段</li>
<li>客户端为什么不需要bind</li>
<li>多个客户端尝试连接会出现什么</li>
<li>客户端的端口是多少，是如何获取的</li>
<li>启动一个server之后，再启动一个会发生什么</li>
<li>htons的作用是什么</li>
</ul>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程-从TCP连接的建立说起</title>
    <url>/2019/07/02/52476.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>网络编程几乎是每一门编程语言都会涉及的内容，虽然各种语言调用的方式可能不一样，但它们背后的原理支持都是一样的。因此本文将从TCP的连接的建立说起。在此之前，假设你已经对计算机网络有了最基本的认识。<br><a id="more"></a></p>
<h2 id="网络编程做什么"><a href="#网络编程做什么" class="headerlink" title="网络编程做什么"></a>网络编程做什么</h2><p>当下网络应用数不胜数，如微信，可以让你通过网络与远在异国他乡的朋友交流沟通；如在线视频，让你通过网络就可以观看你喜欢的视频，而这一切的背后，都有网络编程技术的支持。通俗来讲，可以认为网络编程是<strong>两台或者多台主机（应用）之间进行数据交换或传输</strong>。</p>
<h2 id="TCP：传输控制协议"><a href="#TCP：传输控制协议" class="headerlink" title="TCP：传输控制协议"></a>TCP：传输控制协议</h2><p>而数据交换需要按照一定的规则，而这种规则就是<strong>协议</strong>。只有按照约定的规则，双方之间才能正确地进行数据交换。而TCP就是这些协议的一种，<strong>它提供一种面向连接的，可靠的字节流服务</strong>。</p>
<ul>
<li>面向连接：两个使用TCP的应用在交换数据之前必须先建立一个TCP连接</li>
<li>可靠的：TCP有很多机制来<strong>尽可能</strong>的保证数据不丢失</li>
<li>字节流： 不区分是ASCII字符还是二进制数据，数据解释交给应用层</li>
</ul>
<h2 id="为什么要理解TCP"><a href="#为什么要理解TCP" class="headerlink" title="为什么要理解TCP"></a>为什么要理解TCP</h2><p>事实上不理解TCP背后的基本原理，仍然可以写出代码，但是当你遇到一些奇奇怪怪的而通过API的说明又无法解决的问题时，你就会庆幸自己花了点时间去学习TCP了。</p>
<h2 id="TCP连接的建立"><a href="#TCP连接的建立" class="headerlink" title="TCP连接的建立"></a>TCP连接的建立</h2><p>关于TCP连接的建立，你可能早已耳熟能详，其流程倒背如流。但我觉得还是有必要再理一理。TCP连接的建立，也就是三次握手的流程如下：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/tcp_connect/TCP.png" alt="TCP三次握手"></p>
<p>我们再试着描述一下三次握手的过程：</p>
<ul>
<li>服务端启动，并监听等待，处于LISTEN状态</li>
<li>客户端发起连接请求，发送序列号seq=X，处于SYN_SENT状态</li>
<li>服务端收到后，并回应ACK=X+1和seq=Y，处于SYN_RCVD状态，客户端发送能力，服务端接收能力正常。</li>
<li>客户端收到服务端的ACK，连接建立，同时向服务端回复ACK，处于ESTABLISHED状态</li>
<li>服务端收到ACK，连接建立，处于ESTABLISHED状态，客户端接收能力正常。</li>
</ul>
<p>至此三次握手完成。需要注意的是，这是正常流程下的三次握手。而前面所说的这些状态可以通过<a href="https://www.yanbinghu.com/2019/06/15/40941.html">netstat命令</a>或者<a href="https://www.yanbinghu.com/2019/06/30/19183.html">ss命令</a>查看到，当然有些状态的存在时间比较短，可能无法观察到。</p>
<p>好了，那么问题来了：</p>
<ul>
<li>为什么要三次握手</li>
<li>连接到一个不存在的端口会发生什么</li>
<li>连接到一个不存在的服务器主机会发生什么</li>
<li>初始seq是如何变化的</li>
<li>半连接队列是什么</li>
<li>SYN攻击是什么</li>
</ul>
<p>如果以上所有问题你都能轻而易举的回答出来，那么本文后面的内容你可以跳过了。</p>
<h2 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h2><p>这几乎是面试中必问的一个问题。一个TCP连接是全双工的，即数据在两个方向上能同时传输。因此，建立连接的过程也就必须确认双方的收发能力都是正常的。</p>
<p>四次握手是否可以呢？完全可以！<strong>但是没有必要</strong>！在服务端收到SYN之后，它可以先回ACK，再发送SYN，但是这两个信息可以一起发送出去，<strong>因此没有必要</strong>。</p>
<p>两次握手是否可以呢？想象这样一种情况，客户端发起了一个连接请求在网络中滞留了很长时间，以至于在连接建立好且断开连接后，它才到达服务端，此时如果采用两次握手，那么服务端就会认为这个报文是新的连接请求，于是建立连接，等待客户端发送数据，但是实际上客户端根本没有发出建立请求，也不会理睬服务端，因此导致服务端空等而浪费资源。</p>
<p>为什么服务器会认为这个迟到的报文是新的连接请求？因为如果采用两次握手机制，那么服务端无法通过SYN来判断这是一个迟到或者重复的报文，还是正常到达的报文，但是对于三次握手，即便出现这样的情况，也不会在服务端建立起真正的连接。</p>
<h2 id="一个正常的连接三次握手"><a href="#一个正常的连接三次握手" class="headerlink" title="一个正常的连接三次握手"></a>一个正常的连接三次握手</h2><p>我们利用tcpdump命令和<a href="https://www.yanbinghu.com/2019/06/23/55893.html">nc命令</a>来观察一个正常的tcp连接建立过程。首先在终端1准备抓包：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tcpdump port 1234   -i any -v -n</span><br></pre></td></tr></table></figure></p>
<p>在终端2启动监听1234端口：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nc -l 1234</span><br></pre></td></tr></table></figure></p>
<p>在终端3连接：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nc 127.0.0.1 1234</span><br></pre></td></tr></table></figure></p>
<p>在终端1得到以下输出内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcpdump: listening on any, link-type LINUX_SLL (Linux cooked), capture size 262144 bytes</span><br><span class="line">21:00:50.794424 IP (tos 0x0, ttl 64, id 50542, offset 0, flags [DF], proto TCP (6), length 60)</span><br><span class="line">    127.0.0.1.45848 &gt; 127.0.0.1.1234: Flags [S], cksum 0xfe30 (incorrect -&gt; 0x3163), seq 1310563628, win 43690, options [mss 65495,sackOK,TS val 3721786049 ecr 0,nop,wscale 7], length 0</span><br><span class="line">21:00:50.794437 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 60)</span><br><span class="line">    127.0.0.1.1234 &gt; 127.0.0.1.45848: Flags [S.], cksum 0xfe30 (incorrect -&gt; 0xef35), seq 1685196050, ack 1310563629, win 43690, options [mss 65495,sackOK,TS val 3721786049 ecr 3721786049,nop,wscale 7], length 0</span><br><span class="line">21:00:50.794449 IP (tos 0x0, ttl 64, id 50543, offset 0, flags [DF], proto TCP (6), length 52)</span><br><span class="line">    127.0.0.1.45848 &gt; 127.0.0.1.1234: Flags [.], cksum 0xfe28 (incorrect -&gt; 0xc17a), ack 1, win 342, options [nop,nop,TS val 3721786049 ecr 3721786049], length 0</span><br></pre></td></tr></table></figure></p>
<p>从上面抓包内容可以看到，总共有三个报文，分别是客户端发送到服务端的SYN，服务端回应给客户端的SYN和ACK，以及客户端回应给服务端的ACK。</p>
<h2 id="连接到一个不存在的端口"><a href="#连接到一个不存在的端口" class="headerlink" title="连接到一个不存在的端口"></a>连接到一个不存在的端口</h2><p>如果要连接的服务器端口不存在会出现什么情况呢？我们利用nc命令来抓包观察。<br>在一个终端窗口使用管理员权限执行下面的命令进行抓包，并打印相关信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tcpdump port 1234   -i any -v -n</span><br></pre></td></tr></table></figure></p>
<p>在另外一个终端使用nc命令尝试连接到本地的1234端口<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nc 127.0.0.1 1234 -v</span><br><span class="line">nc: connect to 127.0.0.1 port 1234 (tcp) failed: Connection refused</span><br></pre></td></tr></table></figure></p>
<p>TCP抓包内容如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcpdump: listening on any, link-type LINUX_SLL (Linux cooked), capture size 262144 bytes</span><br><span class="line">21:06:15.295407 IP (tos 0x0, ttl 64, id 29112, offset 0, flags [DF], proto TCP (6), length 60)</span><br><span class="line">    127.0.0.1.46108 &gt; 127.0.0.1.1234: Flags [S], cksum 0xfe30 (incorrect -&gt; 0x7fef), seq 1175796450, win 43690, options [mss 65495,sackOK,TS val 2076405654 ecr 0,nop,wscale 7], length 0</span><br><span class="line">21:06:15.295462 IP (tos 0x0, ttl 64, id 58706, offset 0, flags [DF], proto TCP (6), length 40)</span><br><span class="line">    127.0.0.1.1234 &gt; 127.0.0.1.46108: Flags [R.], cksum 0x77e7 (correct), seq 0, ack 1175796451, win 0, length 0</span><br></pre></td></tr></table></figure></p>
<p>从抓包内容中可以看到，首先nc客户端发送一个SYN（Flags为S），seq为1175796450。而后收到一个RST（Flags为R），seq为1175796451。</p>
<p>也就是说，如果连接到一个不存在的端口，服务端所在的系统会<strong>响应一个RST</strong>（复位），直接终止连接。</p>
<p>Flags字段含义如下：</p>
<ul>
<li>F : FIN - 结束; 结束会话</li>
<li>S : SYN - 同步; 表示开始会话请求</li>
<li>R : RST - 复位;中断一个连接</li>
<li>P : PUSH - 推送; 数据包立即发送</li>
<li>A : ACK - 应答</li>
<li>U : URG - 紧急</li>
<li>E : ECE - 显式拥塞提醒回应</li>
<li>W : CWR - 拥塞窗口减少</li>
</ul>
<h2 id="连接到一个不存在的服务器"><a href="#连接到一个不存在的服务器" class="headerlink" title="连接到一个不存在的服务器"></a>连接到一个不存在的服务器</h2><p>同样是利用nc和tcpdump命令。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tcpdump port 1234   -i any -v -n</span><br></pre></td></tr></table></figure></p>
<p>在另外一个窗口使用nc命令连接到一个不存在的或者无法连接的服务器地址：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nc 121.11.12.31 1234 -v</span><br><span class="line">nc: connect to 121.11.12.31 port 1234 (tcp) failed: Connection timed out</span><br></pre></td></tr></table></figure></p>
<p>tcpdump输出内容如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcpdump: listening on any, link-type LINUX_SLL (Linux cooked), capture size 262144 bytes</span><br><span class="line">21:13:04.259752 IP (tos 0x0, ttl 64, id 33411, offset 0, flags [DF], proto TCP (6), length 60)</span><br><span class="line">    192.168.0.103.52402 &gt; 121.11.12.31.1234: Flags [S], cksum 0xcdc0 (correct), seq 2648987704, win 29200, options [mss 1460,sackOK,TS val 75888078 ecr 0,nop,wscale 7], length 0</span><br><span class="line">21:13:05.269438 IP (tos 0x0, ttl 64, id 33412, offset 0, flags [DF], proto TCP (6), length 60)</span><br><span class="line">    192.168.0.103.52402 &gt; 121.11.12.31.1234: Flags [S], cksum 0xc9ce (correct), seq 2648987704, win 29200, options [mss 1460,sackOK,TS val 75889088 ecr 0,nop,wscale 7], length 0</span><br><span class="line">21:13:07.285415 IP (tos 0x0, ttl 64, id 33413, offset 0, flags [DF], proto TCP (6), length 60)</span><br><span class="line">    192.168.0.103.52402 &gt; 121.11.12.31.1234: Flags [S], cksum 0xc1ee (correct), seq 2648987704, win 29200, options [mss 1460,sackOK,TS val 75891104 ecr 0,nop,wscale 7], length 0</span><br><span class="line">21:13:11.445491 IP (tos 0x0, ttl 64, id 33414, offset 0, flags [DF], proto TCP (6), length 60)</span><br><span class="line">    192.168.0.103.52402 &gt; 121.11.12.31.1234: Flags [S], cksum 0xb1ae (correct), seq 2648987704, win 29200, options [mss 1460,sackOK,TS val 75895264 ecr 0,nop,wscale 7], length 0</span><br><span class="line">21:13:19.637403 IP (tos 0x0, ttl 64, id 33415, offset 0, flags [DF], proto TCP (6), length 60)</span><br><span class="line">    192.168.0.103.52402 &gt; 121.11.12.31.1234: Flags [S], cksum 0x91ae (correct), seq 2648987704, win 29200, options [mss 1460,sackOK,TS val 75903456 ecr 0,nop,wscale 7], length 0</span><br><span class="line">21:13:35.765417 IP (tos 0x0, ttl 64, id 33416, offset 0, flags [DF], proto TCP (6), length 60)</span><br><span class="line">    192.168.0.103.52402 &gt; 121.11.12.31.1234: Flags [S], cksum 0x52ae (correct), seq 2648987704, win 29200, options [mss 1460,sackOK,TS val 75919584 ecr 0,nop,wscale 7], length 0</span><br><span class="line">21:14:09.045497 IP (tos 0x0, ttl 64, id 33417, offset 0, flags [DF], proto TCP (6), length 60)</span><br><span class="line">    192.168.0.103.52402 &gt; 121.11.12.31.1234: Flags [S], cksum 0xd0ad (correct), seq 2648987704, win 29200, options [mss 1460,sackOK,TS val 75952864 ecr 0,nop,wscale 7], length 0</span><br></pre></td></tr></table></figure></p>
<p>通过实际操作可以发现，当发送第一个SYN没有响应时，客户端会再次发送；如果还是没有响应，再隔更长一段时间，继续发送SYN，最终连接超时。从观察情况来看，<strong>默认会进行5次重发</strong>，5次的重试时间间隔分别为1s, 2s, 4s, 8s, 16s。</p>
<h2 id="初始序列号是如何变化的"><a href="#初始序列号是如何变化的" class="headerlink" title="初始序列号是如何变化的"></a>初始序列号是如何变化的</h2><p>通过前面的两次抓包可以看到，发送第一个SYN请求的初始序列号seq并不是固定的。实际上，不同的系统它的生成方法可能不同，但是可以知道的是，它在一定时间内，生成seq值肯定不同，否则服务端无法区分这到底是同一个seq的重发还是这个报文在网络中滞留一段时间后又重新到达。RFC 793指出初始序列号可以可看成一个32位的计数器，每隔4ms加1（但不同系统实际实现又可能不太一样，为了安全起见会处理成随机值），因此当它重新回到开始的时候，已经过了够长时间，使得网络中延迟的报文早已消失。</p>
<h2 id="半连接队列"><a href="#半连接队列" class="headerlink" title="半连接队列"></a>半连接队列</h2><p>在服务器收到客户端的连接请求，并发送ACK之后，服务端处于SYN_RECV状态，此时的连接成为半连接，服务器会将半连接放到一个名为半连接队列的地方。</p>
<h2 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h2><p>正因如此，如果有人恶意地向服务器发送大量的SYN包，并且由于客户端IP是伪造的，导致服务器收不到ACK，不断重发ACK，以至于半连接队列容易占满，导致无法处理正常的连接请求，并且可能导致服务器资源耗尽。</p>
<p>如何处理SYN攻击又是另外一个话题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>TCP三次握手的正常场景我们很容易描述出来，但是涉及更多细节以及异常场景的时候，我们可能不是那么熟悉，通过本文可以简单地了解TCP连接的建立，为后面的网络编程打下基础。但是需要说明的是，本文仅仅简单介绍了TCP连接的建立，并没有深入介绍。</p>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>netstat的替代者-ss命令详解</title>
    <url>/2019/06/30/19183.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在介绍netstat的时候说过，<a href="https://www.yanbinghu.com/2019/06/15/40941.html">netstat</a>是一个非常实用的socket查看命令。但是有人留言它已经被ss（Socket Statistics）替代了，那么这个所谓替代netstat的命令，到底怎么用呢？为什么它能替代netstat？<br><a id="more"></a></p>
<h2 id="为什么使用ss"><a href="#为什么使用ss" class="headerlink" title="为什么使用ss"></a>为什么使用ss</h2><p>值得注意的是，<strong>几乎所有的linux系统都默认支持netstat命令，而并不一定支持ss</strong>，从这一点来说，netstat通常还是不二选择。但是不得不承认的是，ss命令更加快捷高效。</p>
<p>netstat从proc文件系统（可参考<a href="https://www.yanbinghu.com/2018/11/18/43716.html">linux中不可错过的信息宝库</a>）获取所需要的信息，而ss利用netlink机制，与内核通信，通过TCP 协议栈中 tcp_diag 模块获取第一手的内核信息。当然这些都不是我们关注的重点，我们来看看ss命令到底如何使用。</p>
<h2 id="查看TCP-UDP连接"><a href="#查看TCP-UDP连接" class="headerlink" title="查看TCP/UDP连接"></a>查看TCP/UDP连接</h2><p>使用-t（TCP）参数查看TCP连接，而使用-u(UDP)参数查看UDP socket：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ss -t</span><br><span class="line">State       Recv-Q Send-Q                                     Local Address:Port                                                      Peer Address:Port                </span><br><span class="line">ESTAB       0      0                                          192.168.0.103:56296                                                   113.107.216.82:https                </span><br><span class="line">ESTAB       0      0                                          192.168.0.103:56540                                                  185.199.108.153:https                </span><br><span class="line">ESTAB       0      0                                              127.0.0.1:socks                                                        127.0.0.1:44452                </span><br><span class="line">ESTAB       0      0                                              127.0.0.1:42150                                                        127.0.0.1:9614</span><br></pre></td></tr></table></figure></p>
<p>其中state显示了当前连接的状态，例如结果的第一行是ESTABLISHED状态，Local Address:port代表本地连接的ip和端口号。<strong>另外使用-n参数显示数字形式的ip和端口</strong>。</p>
<h2 id="查看socket进程信息"><a href="#查看socket进程信息" class="headerlink" title="查看socket进程信息"></a>查看socket进程信息</h2><p>查看到某个连接后，怎么知道是哪个进程的连接呢？使用-p（processes）即可，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ss -tp</span><br><span class="line">State       Recv-Q Send-Q                                     Local Address:Port                                                      Peer Address:Port                </span><br><span class="line">ESTAB       0      0                                              127.0.0.1:42150                                                        127.0.0.1:9614                  users:((&quot;chrome&quot;,pid=2578,fd=347))</span><br><span class="line">ESTAB       0      0                                              127.0.0.1:41910                                                        127.0.0.1:9614                  users:((&quot;chrome&quot;,pid=2578,fd=383))</span><br></pre></td></tr></table></figure></p>
<p>拖动滚动条到最后可以看到，-p参数显示了这条连接的进程信息，例如，对于第一条结果，可以看到，该进程是chrome，进程id为2578，并且这条连接的文件描述符为383。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">users:((&quot;chrome&quot;,pid=2578,fd=383))</span><br></pre></td></tr></table></figure></p>
<h2 id="查看处于特定状态的socket"><a href="#查看处于特定状态的socket" class="headerlink" title="查看处于特定状态的socket"></a>查看处于特定状态的socket</h2><p>我们知道，对于TCP连接来讲，在不同的阶段它的状态不同，常见状态有</p>
<ul>
<li>ESTABLISHED  已建立</li>
<li>CLOSED   已关闭</li>
<li>LISTENING 正在监听</li>
<li>FIN-WAIT-2 等待连接关闭</li>
<li>TIME-WAIT 等待足够时间，确保服务器正常关闭该连接</li>
<li>……</li>
</ul>
<p>这里还有很多其他状态，我们会留到介绍TCP的时候展开。</p>
<p>如何查看处于特定状态的连接呢？例如，要查看处于LISTENING状态的连接：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ss -t state LISTENING</span><br><span class="line">Recv-Q Send-Q                                          Local Address:Port                                                           Peer Address:Port                </span><br><span class="line">0      5                                                   127.0.1.1:domain                                                                    *:*                    </span><br><span class="line">0      128                                                 127.0.0.1:5941                                                                      *:*                    </span><br><span class="line">0      5                                                   127.0.0.1:ipp                                                                       *:*</span><br></pre></td></tr></table></figure></p>
<p>使用state选项即可查看。当然对于LISTENING状态，也可以使用-l参数。</p>
<p>除此之外，还有以下参数，用于查看某类状态，例如：</p>
<ul>
<li>all 所有类型</li>
<li>connected  除closed和listen状态以外已连接的状态</li>
<li>synchronized  除了syn-sent外的状态</li>
</ul>
<h2 id="查看TCP相关定时器信息"><a href="#查看TCP相关定时器信息" class="headerlink" title="查看TCP相关定时器信息"></a>查看TCP相关定时器信息</h2><p>我们知道在TCP中，有很多定时器，和netstat一样，可以使用-o参数显示定时器相关信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ss -to</span><br><span class="line">State       Recv-Q Send-Q                                     Local Address:Port                                                      Peer Address:Port                </span><br><span class="line">ESTAB       0      0                                              127.0.0.1:44660                                                        127.0.0.1:socks                 timer:(keepalive,4min42sec,0)</span><br><span class="line">ESTAB       0      0                                          192.168.0.103:60306                                                    203.208.41.37:https                 timer:(keepalive,9.956ms,0)</span><br><span class="line">ESTAB       0      0</span><br></pre></td></tr></table></figure></p>
<p>例如上面显示的keepalive定时器剩余时间：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">timer:(keepalive,9.956ms,0)</span><br></pre></td></tr></table></figure></p>
<h2 id="查看socket详细信息"><a href="#查看socket详细信息" class="headerlink" title="查看socket详细信息"></a>查看socket详细信息</h2><p>如果想要查看连接更加详细信息呢？比如收到多少数据？上一个ACK是什么时候？mss是多大？拥塞窗口大小是多少？这些信息在分析理解TCP的时候非常有帮助，而查看这些信息只需要使用-i(information)参数即可：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ss -ti  #(内容很长，省略了很多信息，可执行尝试)</span><br><span class="line">cubic wscale:7,7 rto:204 rtt:2.302/4.528 ato:40 mss:23488 cwnd:10 bytes_acked:1560 bytes_received:3907 segs_out:18 segs_in:20 send 816.3Mbps lastsnd:1384 lastrcv:1384 lastack:1384 pacing_rate 1632.1Mbps rcv_rtt:546 rcv_space:43690</span><br></pre></td></tr></table></figure></p>
<p>由于显示的内容比较多，这里就不贴出来了，可自行尝试，里面展示了TCP很多关键信息。</p>
<h2 id="查看socket内存使用情况"><a href="#查看socket内存使用情况" class="headerlink" title="查看socket内存使用情况"></a>查看socket内存使用情况</h2><p>使用-m（memory）参数可以查看连接使用内存信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ss -tm  #只显示内存部分信息</span><br><span class="line">skmem:(r0,rb374400,t0,tb46080,f0,w0,o0,bl0)</span><br></pre></td></tr></table></figure></p>
<p>由于信息较多，这里只显示内存部分，括号内从左到右分别代表：</p>
<ul>
<li>接收报文分配的内存</li>
<li>接收报文可分配的内存</li>
<li>发送报文分配的内存</li>
<li>发送报文可分配的内存</li>
<li>socket使用的缓存</li>
<li>为将要发送的报文分配的内存</li>
<li>保存socket选项使用的内存</li>
<li>连接队列使用的内存</li>
</ul>
<h2 id="根据IP或端口过滤socket信息"><a href="#根据IP或端口过滤socket信息" class="headerlink" title="根据IP或端口过滤socket信息"></a>根据IP或端口过滤socket信息</h2><p>你可以使用grep命令（可参考《<a href="https://www.yanbinghu.com/2019/06/02/59940.html">Linux下的文本查找技巧</a>》）来获取你需要的信息，但是ss本身提供一些参数用来过滤信息。例如，查看本地ip为192.168.0.103的连接：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ss -t src 192.168.0.103</span><br><span class="line">State       Recv-Q Send-Q                                     Local Address:Port                                                      Peer Address:Port                </span><br><span class="line">ESTAB       0      0                                          192.168.0.103:44528                                                  185.199.109.153:https  </span><br><span class="line">$ ss -t src 192.168.0.103:35418</span><br><span class="line">State       Recv-Q Send-Q                                     Local Address:Port                                                      Peer Address:Port                </span><br><span class="line">ESTAB       0      0                                          192.168.0.103:35418                                                  111.230.120.127:https</span><br></pre></td></tr></table></figure></p>
<p>src后面跟本地ip:port，而也可以使用dst根据远端ip来过滤信息。</p>
<p>同样还可以根据协议类型（端口）来过滤，例如查看https socket信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ss -t &apos;( dport = :https or sport = :https )&apos;</span><br><span class="line">State       Recv-Q Send-Q                                     Local Address:Port                                                      Peer Address:Port                </span><br><span class="line">ESTAB       0      0                                          192.168.0.103:44528                                                  185.199.109.153:https                </span><br><span class="line">ESTAB       0      0                                          192.168.0.103:35418                                                  111.230.120.127:https     </span><br><span class="line">$ ss -t dport = :https</span><br><span class="line">State       Recv-Q Send-Q                                     Local Address:Port                                                      Peer Address:Port                </span><br><span class="line">CLOSE-WAIT  32     0                                          192.168.0.103:46626                                                   123.58.182.252:https</span><br><span class="line">$ ss -t sport \&gt; :44550   #显示本地端口大于44550的连接</span><br><span class="line">State       Recv-Q Send-Q                                     Local Address:Port                                                      Peer Address:Port                </span><br><span class="line">ESTAB       390    0                                              127.0.0.1:46468                                                        127.0.0.1:socks                </span><br><span class="line">ESTAB       0      0                                              127.0.0.1:46382                                                        127.0.0.1:socks                </span><br><span class="line">ESTAB       0      0                                              127.0.0.1:46490                                                        127.0.0.1:socks</span><br></pre></td></tr></table></figure></p>
<p>其中dport，指定本地协议，sport指定远端协议。</p>
<h2 id="显示socket统计信息"><a href="#显示socket统计信息" class="headerlink" title="显示socket统计信息"></a>显示socket统计信息</h2><p>使用-s(summary)查看整体统计信息。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ss -s</span><br><span class="line">Total: 1379 (kernel 2907)</span><br><span class="line">TCP:   68 (estab 58, closed 1, orphaned 0, synrecv 0, timewait 1/0), ports 0</span><br><span class="line"></span><br><span class="line">Transport Total     IP        IPv6</span><br><span class="line">*	  2907      -         -        </span><br><span class="line">RAW	  1         0         1        </span><br><span class="line">UDP	  13        8         5        </span><br><span class="line">TCP	  67        47        20       </span><br><span class="line">INET	  81        55        26       </span><br><span class="line">FRAG	  0         0         0</span><br></pre></td></tr></table></figure></p>
<p>从统计结果中可以看到，共有67个TCP连接。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了ss命令一些实用的用法，为后面介绍网络编程相关内容打下基础，更多ss用法可查看帮助手册。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>静态库和动态库区别</title>
    <url>/2019/06/27/47343.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在编写代码的时候经常用到已有的接口，他们是以库的形式提供给我们使用的，而常见形式有两种，一种常以.a为后缀，为静态库；另一种以.so为后缀，为动态库。那么这两种库有什么区别呢？</p>
<p>说明：本文主要说明Linux下的情况，windows不涉及。<br><a id="more"></a></p>
<h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2><p>在解释静态库和动态库之前，需要简单了解一下什么是目标文件。目标文件常常按照特定格式来组织，在linux下，它是ELF格式（Executable Linkable Format，可执行可链接格式），而在windows下是PE（Portable Executable，可移植可执行）。</p>
<p>而通常目标文件有三种形式：</p>
<ul>
<li>可执行目标文件。即我们通常所认识的，可直接运行的二进制文件。</li>
<li>可重定位目标文件。包含了二进制的代码和数据，可以与其他可重定位目标文件合并，并创建一个可执行目标文件。</li>
<li>共享目标文件。它是一种在加载或者运行时进行链接的特殊可重定位目标文件。</li>
</ul>
<p>我们来看一个简单实例：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello 编程珠玑\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="built_in">exp</span>(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码计算e的2次方并打印结果。由于代码中用到了exp函数，它位于数学库libm.so或者libm.a中，因此编译时需要加上-lm。</p>
<p>生成可重定位目标文件main.o:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -c main.c   #生成可重定位目标文件</span><br><span class="line">$ readelf -h main.o  #查看elf文件头部信息</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&apos;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              REL (Relocatable file)</span><br><span class="line">(省略其他内容)</span><br></pre></td></tr></table></figure></p>
<p>通过上面的命令将main.c生成为可重定位目标文件。通过readelf命令也可以看出来：REL (Relocatable file)。</p>
<p>观察共享目标文件libm.so：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ readelf -h /lib/x86_64-linux-gnu/libm.so.6</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 03 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&apos;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - GNU</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              DYN (Shared object file)</span><br><span class="line">（省略其他内容）</span><br></pre></td></tr></table></figure></p>
<p>不同系统中libm.so的位置可能不一样，你可以通过locate命令来查找。locate命令的用法可参考《<a href="https://www.yanbinghu.com/2018/11/24/18359.html">Linux中的文件查找技巧</a>》。从结果可以看到，libm.so是共享目标文件（Shared object file）。</p>
<p>查看可执行目标文件main：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o main main.o -lm  #编译成最终的可执行文件</span><br><span class="line">$ readelf -h main         #查看ELF文件头</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&apos;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              EXEC (Executable file)</span><br><span class="line">(省略其他内容)</span><br></pre></td></tr></table></figure></p>
<p>这里必须要强调一点，<strong>如果使用到的函数没有在libc库中，那么你就需要指定要链接的库</strong>，本文中需要链接libm.so或libm.a。可以看到，最终生成的main类型是Executable file，即可执行目标文件。</p>
<h2 id="什么是静态库"><a href="#什么是静态库" class="headerlink" title="什么是静态库"></a>什么是静态库</h2><p>前面所提到可重定位目标文件以一种特定的方式打包成一个单独的文件，并且在链接生成可执行文件时，从这个单独的文件中“拷贝”它自己需要的内容到最终的可执行文件中。这个单独的文件，称为静态库。linux中通常以.a(archive)为后缀</p>
<p>还是拿前面的例子来说，我们使用静态链接构建我们的可执行文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -c main.c</span><br><span class="line">$ gcc -static -o main main.o -lm</span><br></pre></td></tr></table></figure></p>
<p>在这个过程中，就会用到系统中的静态库libm.a。这个过程做了什么呢？首先第一条命令会将main.c编译成<strong>可重定位目标文件</strong>main.o，第二条命令的static参数，告诉链接器应该使用静态链接，-lm参数表明链接libm.a这个库（类似的，如果要链接libxxx.a,使用-lxxx即可）。由于main.c中使用了libm.a中的exp函数，因此链接时，会将libm.a中需要的代码“拷贝”到最终的可执行文件main中。</p>
<p>特别注意，必须把-lm放在后面。放在最后时它是这样的一个解析过程：</p>
<ul>
<li>链接器从左往右扫描可重定位目标文件和静态库</li>
<li>扫描main.o时，发现一个未解析的符号exp，记住这个未解析的符号</li>
<li>扫描libm.a，找到了前面未解析的符号，因此提取相关代码</li>
<li>最终没有任何未解析的符号，编译链接完成</li>
</ul>
<p>那如果将-lm放在前面，又是怎样的情况呢？</p>
<ul>
<li>链接器从左往右扫描可重定位目标文件和静态库</li>
<li>扫描libm.a，由于前面没有任何未解析的符号，因此不会提取任何代码</li>
<li>扫描main.o，发现未解析的符号exp</li>
<li>扫描结束，还有一个未解析的符号，因此编译链接报错</li>
</ul>
<p>如果把-lm放在前面，编译结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -static -lm -o main main.o </span><br><span class="line">main.o: In function `main&apos;:</span><br><span class="line">main.c:(.text+0x2f): undefined reference to `exp&apos;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure></p>
<p>更详细的解释也可以参考《<a href="https://www.yanbinghu.com/2018/10/06/46212.html">一个奇怪的链接问题</a>》。</p>
<p>我们看看最终生成的文件大小：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -lh main</span><br><span class="line">-rwxrwxr-x 1 hyb hyb 988K 6月  27 20:22 main</span><br></pre></td></tr></table></figure></p>
<p>生成的可执行文件大小为988k。ls的高级用法可参考《<a href="https://www.yanbinghu.com/2018/09/16/51043.html">ls命令常见实用用法</a>》。</p>
<p>由于最终生成的可执行文件中已经包含了exp相关的二进制代码，因此这个可执行文件在一个没有libm.a的linux系统中也能正常运行。</p>
<h2 id="什么是动态库"><a href="#什么是动态库" class="headerlink" title="什么是动态库"></a>什么是动态库</h2><p>动态库和静态库类似，但是它并不在链接时将需要的二进制代码都“拷贝”到可执行文件中，而是仅仅“拷贝”一些重定位和符号表信息，这些信息可以在程序运行时完成真正的链接过程。linux中通常以.so（shared object）作为后缀。</p>
<p>通常我们编译的程序默认就是实用动态链接：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o main main.c -lm  #默认使用的是动态链接</span><br></pre></td></tr></table></figure></p>
<p>我们来看最终生成的文件大小：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -lh main</span><br><span class="line">-rwxrwxr-x 1 hyb hyb 8.5K 6月  27 20:25 main</span><br></pre></td></tr></table></figure></p>
<p>可以看到，通过动态链接的程序<strong>只有8.5k</strong>！</p>
<p>另外我们还可以通过ldd命令来观察可执行文件链接了哪些动态库：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ldd main</span><br><span class="line">	linux-vdso.so.1 =&gt;  (0x00007ffc7b5a2000)</span><br><span class="line">	libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007fe9642bf000)</span><br><span class="line">	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fe963ef5000)</span><br><span class="line">	/lib64/ld-linux-x86-64.so.2 (0x00007fe9645c8000)</span><br></pre></td></tr></table></figure></p>
<p>正因为我们并没有把libm.so中的二进制代码“拷贝”可执行文件中，我们的程序在其他没有上面的动态库时，将无法正常运行。</p>
<h2 id="有什么区别"><a href="#有什么区别" class="headerlink" title="有什么区别"></a>有什么区别</h2><p>到这里我们大致了解了静态库和动态库的区别了，静态库被使用目标代码最终和可执行文件在一起（它只会有自己用到的），而动态库与它相反，它的目标代码在运行时或者加载时链接。正是由于这个区别，会导致下面所介绍的这些区别。</p>
<h4 id="可执行文件大小不一样"><a href="#可执行文件大小不一样" class="headerlink" title="可执行文件大小不一样"></a>可执行文件大小不一样</h4><p>从前面也可以观察到，静态链接的可执行文件要比动态链接的可执行文件要大得多，因为它将需要用到的代码从二进制文件中“拷贝”了一份，而动态库仅仅是复制了一些重定位和符号表信息。</p>
<h4 id="占用磁盘大小不一样"><a href="#占用磁盘大小不一样" class="headerlink" title="占用磁盘大小不一样"></a>占用磁盘大小不一样</h4><p>如果有多个可执行文件，那么静态库中的同一个函数的代码就会被复制多份，而动态库只有一份，因此使用静态库占用的磁盘空间相对比动态库要大。</p>
<h4 id="扩展性与兼容性不一样"><a href="#扩展性与兼容性不一样" class="headerlink" title="扩展性与兼容性不一样"></a>扩展性与兼容性不一样</h4><p>如果静态库中某个函数的实现变了，那么可执行文件必须重新编译，而对于动态链接生成的可执行文件，只需要更新动态库本身即可，不需要重新编译可执行文件。正因如此，使用动态库的程序方便升级和部署。</p>
<h4 id="依赖不一样"><a href="#依赖不一样" class="headerlink" title="依赖不一样"></a>依赖不一样</h4><p>静态链接的可执行文件不需要依赖其他的内容即可运行，而动态链接的可执行文件必须依赖动态库的存在。所以如果你在安装一些软件的时候，提示某个动态库不存在的时候也就不奇怪了。</p>
<p>即便如此，系统中一班存在一些大量公用的库，所以使用动态库并不会有什么问题。</p>
<h4 id="复杂性不一样"><a href="#复杂性不一样" class="headerlink" title="复杂性不一样"></a>复杂性不一样</h4><p>相对来讲，动态库的处理要比静态库要复杂，例如，如何在运行时确定地址？多个进程如何共享一个动态库？当然，作为调用者我们不需要关注。另外动态库版本的管理也是一项技术活。这也不在本文的讨论范围。</p>
<h4 id="加载速度不一样"><a href="#加载速度不一样" class="headerlink" title="加载速度不一样"></a>加载速度不一样</h4><p>由于静态库在链接时就和可执行文件在一块了，而动态库在加载或者运行时才链接，因此，对于同样的程序，静态链接的要比动态链接加载更快。所以选择静态库还是动态库是空间和时间的考量。但是通常来说，牺牲这点性能来换取程序在空间上的节省和部署的灵活性时值得的。再加上<strong>局部性原理</strong>，牺牲的性能并不多。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>静态库和动态库具体是何如链接的已经超出了本文的介绍范围，本文仅简单介绍了一些静态库和动态库的区别，另外文中提到的在其他的linux系统，也指的是同样处理器架构的系统。但是了解这些基本信息，就能够帮助我们解决很多编译问题了。更多内容可自己阅读装载，链接方面的书籍。后面的文章也会介绍更多相关信息。</p>
<h2 id="本文相关阅读"><a href="#本文相关阅读" class="headerlink" title="本文相关阅读"></a>本文相关阅读</h2><ul>
<li>《<a href="https://www.yanbinghu.com/2018/09/16/51043.html">ls命令常见实用用法</a>》</li>
<li>《<a href="https://www.yanbinghu.com/2018/09/26/61877.html">linux常用命令-开发调试篇</a>》</li>
<li>《<a href="https://www.yanbinghu.com/2018/10/06/46212.html">一个奇怪的链接问题</a>》</li>
<li>《<a href="https://www.yanbinghu.com/2018/11/24/18359.html">Linux中的文件查找技巧</a>》<h2 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h2></li>
<li>《程序员的自我修养》</li>
<li>《深入理解计算机系统》</li>
</ul>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>链接</tag>
      </tags>
  </entry>
  <entry>
    <title>记64位地址截断引发的挂死问题</title>
    <url>/2019/06/25/47531.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近要将整个项目的代码从原先的只支持32位变成同时支持32位和64位，这个过程中遇到一个很不容易定位的挂死问题，花了不少时间才定位解决，因此分享给大家。<br><a id="more"></a></p>
<h2 id="32位和64位代码区别"><a href="#32位和64位代码区别" class="headerlink" title="32位和64位代码区别"></a>32位和64位代码区别</h2><p>在分享之前，需要了解一下32位和64位程序代码有何区别，它的主要区别体现在某些数据类型的占用字节大小的不同：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据类型</th>
<th>32位</th>
<th>64位</th>
</tr>
</thead>
<tbody>
<tr>
<td>long</td>
<td>4字节</td>
<td>8字节</td>
</tr>
<tr>
<td>unsigned long</td>
<td>4字节</td>
<td>8字节</td>
</tr>
<tr>
<td>指针</td>
<td>4字节</td>
<td>8字节</td>
</tr>
<tr>
<td>size_t</td>
<td>4字节</td>
<td>8字节</td>
</tr>
<tr>
<td>ssize_t</td>
<td>4字节</td>
<td>8字节</td>
</tr>
</tbody>
</table>
</div>
<p>这些是主要的差别。</p>
<p>那么为什么要切64位呢？原因也很简单，32位寻址范围有限，能使用的最大内存也是非常有限的，因此需要使其能够支持64位，这个过程需要修改编译工程，编译第三方库为64位，修改代码等等。当然这些都不是本文的重点，本文仅介绍遇到的这个典型的问题。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>由于项目本身涉及的系统比较复杂，因此简单分享一下定位过程，下一节将通过简洁的示例程序来说明。</p>
<p>问题现象：向服务器发送一条操作指令后直接挂死</p>
<p>分析解决过程简化为如下步骤：</p>
<ul>
<li>查看日志以及coredump信息，<strong>初步定位挂死的位置</strong></li>
<li>发现挂死在停止定时器的位置</li>
<li>32位程序正常，而64位异常，因此<strong>和32位与64位的差别有关</strong></li>
<li>怀疑传入定时器数据有问题，编写小demo，<strong>排除传入数据问题</strong></li>
<li>编译可调试版本，加入-g参数</li>
<li>跟踪调试，发现最终挂在了一个动态库中</li>
<li>设置gdb源码路径，以便调试跟踪动态库</li>
<li>通过gdb观察传入指针，在访问指针时，出现错误，提示访问非法内存</li>
<li>打印传入定时器指针地址，发现异常，地址开头4字节为全f，不正常，因此怀疑该指针最开始就已经出问题</li>
<li>跟踪启动定时器部分，动态库接口返回的地址值，就已经异常了，但是跟踪到动态库接口内部，发现返回的结果是正常的8字节地址值，排除定时器接口的问题</li>
<li>最终可以确定，在调用动态库接口时，虽然返回的是8字节地址，但是赋给外部变量时，就<strong>被截断</strong>了</li>
<li>换项目中的另外一个进程调试demo发现，编译时出现错误，提示函数没有声明</li>
<li>于是加上声明之后编译通过，但并没有出现挂死的问题</li>
<li>随即继续跟踪原项目出问题的进程，发现同样这些接口都没有外部声明，再加上另外一个进程的警告信息，提示有int往指针强转，因此怀疑和函数的声明有关。</li>
</ul>
<p>最终确实如此。</p>
<p>具体是为什么呢？</p>
<h2 id="简化示例"><a href="#简化示例" class="headerlink" title="简化示例"></a>简化示例</h2><p>示例代码分别放在main.c和test.c中，main.c内容如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="comment">//公众号编程珠玑</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//打印p的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;p);</span><br><span class="line">    <span class="comment">//为p赋值</span></span><br><span class="line">    p = testFun();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,p);</span><br><span class="line">    <span class="comment">//释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>test.c的内容如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">testFun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//申请内存需要足够大，能方便达到本文的示例效果</span></span><br><span class="line">    <span class="keyword">void</span> *p = (<span class="keyword">void</span>*)<span class="built_in">malloc</span>(<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"malloc failed\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"malloc success,p = %p\n"</span>,p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面两段代码再简单不过，testFun在函数中申请一段内存，并返回。而main函数通过调用testFun，将地址值返回给p，并打印p的地址值。</p>
<p>编译运行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o main main.c test.c</span><br><span class="line">$ ./main</span><br><span class="line">0x7ffef59d4230</span><br><span class="line">malloc success,p = 0x7f193ec5f010</span><br><span class="line">0x3ec5f010</span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure></p>
<p>从运行结果中，我们可以发现以下几个事实：</p>
<ul>
<li>64位程序地址为8字节</li>
<li>testFun内部申请到的内存地址值是占用8字节的值</li>
<li>main函数中的p的地址值为4字节</li>
<li>返回值被截断了 </li>
</ul>
<p>也就是和我们预期的结果完全不一样。我们逐步分析，到底是为什么。</p>
<p>特别说明：<br>如果赋值那一行改成下面这样<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = (<span class="keyword">void</span>*)testFun();</span><br></pre></td></tr></table></figure></p>
<p>运行结果中如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x7ffd5a75dbe0</span><br><span class="line">malloc success,p = 0x7fc6fb5ac010</span><br><span class="line">0xfffffffffb5ac010</span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure></p>
<p>其实看到8字节的前面4字节都是f，就可以判断这个地址是非法的了。为什么？（提示：程序地址空间分布）。</p>
<h2 id="为什么coredump？"><a href="#为什么coredump？" class="headerlink" title="为什么coredump？"></a>为什么coredump？</h2><p>这个问题很明显，因为申请内存得到的地址值与释放内存的地址不是同一个，因此导致coredump（coredump的查看可参考《<a href="https://www.yanbinghu.com/2018/09/26/61877.html">linux常用命令-开发调试篇</a>》中的gdb部分）。</p>
<h2 id="为什么地址值被截断？"><a href="#为什么地址值被截断？" class="headerlink" title="为什么地址值被截断？"></a>为什么地址值被截断？</h2><p>在解释这个之前，我们先看一个简单的示例程序：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//testReturn.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">test()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"test function\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o test testReturn.c</span><br><span class="line">testReturn.c:2:1: warning: return type defaults to ‘int’ [-Wimplicit-int]</span><br><span class="line"> test()</span><br><span class="line"> ^</span><br></pre></td></tr></table></figure></p>
<p>我们在编译的时候出现了一个警告，提示test函数没有返回值，会默认返回值为int。</p>
<p>也就是说，<strong>如果函数实际有返回值，但是函数返回值类型却没有指明，编译器会将其默认为int</strong>。</p>
<p>实际上前面的示例程序在编译的时候就有警告：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main.c: In function ‘main’:</span><br><span class="line">main.c:11:9: warning: implicit declaration of function ‘testFun’ [-Wimplicit-function-declaration]</span><br><span class="line">     p = testFun();</span><br><span class="line">         ^</span><br><span class="line">main.c:11:7: warning: assignment makes pointer from integer without a cast [-Wint-conversion]</span><br><span class="line">     p = testFun();</span><br><span class="line">       ^</span><br></pre></td></tr></table></figure></p>
<p>两个警告的意思分别为：</p>
<ul>
<li>testFun没有声明</li>
<li>尝试从整形转换成指针</li>
</ul>
<p>第一个警告很容易理解，虽然定义了testFun函数，但是在main函数中并没有声明。因此对mian函数来说，它在编译阶段（关于编译阶段，可参考《<a href="https://www.yanbinghu.com/2018/10/10/27133.html">hello程序是如何变成可执行文件的</a>》），“看不到”testFun，因此会默认为其返回值为int。而正因如此，就有了第二个警告，提示从整型转换成指针。</p>
<p>到此其实也就真相大白了。既然testFun的返回值被编译器默认为int，返回一个8字节的指针类型，而返回值却是int，自然就会被截断了。</p>
<h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>既然知道原因所在，那么如何解决呢？这里提供两种方式。</p>
<ul>
<li>extern声明</li>
<li>在头文件中声明，调用者包含该头文件</li>
</ul>
<p>按照第一种方式，在main.c中增加一行声明：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> *<span class="title">testFun</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x7fffee1bd7b0</span><br><span class="line">malloc success,p = 0x7fcafef2e010</span><br><span class="line">0x7fcafef2e010</span><br></pre></td></tr></table></figure></p>
<p>第二种方式，增加test.h，内容为testFun的声明：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">testFun</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>main.c包含test.h头文件：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="comment">//公众号编程珠玑</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"test.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//打印p的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;p);</span><br><span class="line">    <span class="comment">//为p赋值</span></span><br><span class="line">    p = testFun();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,p);</span><br><span class="line">    <span class="comment">//释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>test.c修改如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"test.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">testFun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *p = (<span class="keyword">void</span>*)<span class="built_in">malloc</span>(<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"malloc failed\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"malloc success,p = %p\n"</span>,p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上两种方式都可解决前面的问题。</p>
<p>而32位程序为什么正常？相信你已经有了答案。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于对出现问题的程序代码不熟悉，加上其编译工程充斥着大量的警告而没有处理，以及涉及动态库，导致这个引起挂死问题的罪魁祸首没有提前暴露处出来。而问题的根本原因我们也清楚了，就是因为调用函数前没有声明。本文总结如下：</p>
<ul>
<li>不要忽略任何一个警告，除非你非常清楚地知道自己在做什么</li>
<li>在头文件中声明函数，并提供给调用者</li>
<li>函数使用前进行声明</li>
<li>问题长期定位不出来时，休息一下</li>
<li>尽量编写通用性代码</li>
<li>非必要时不强转</li>
<li>使用void *指针格外小心</li>
</ul>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul>
<li>为什么32位的时候运行正常，而64位程序会挂死</li>
<li>32位和64位程序用户空间地址范围分别是多少</li>
<li>如何在调试中设置程序源码路径</li>
<li>程序完整编译经历那几个阶段</li>
</ul>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>网络命令中的瑞士军刀-nc命令详解</title>
    <url>/2019/06/23/55893.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面介绍过<a href="https://www.yanbinghu.com/2019/06/15/40941.html">一个不可不知的网络命令-netstat</a>，今天来介绍这个网络工具界的“瑞士军刀”-nc（netcat），它短小精悍，是网络调试利器，它到底有何能耐呢？<br><a id="more"></a></p>
<h2 id="查看端口是否被占用"><a href="#查看端口是否被占用" class="headerlink" title="查看端口是否被占用"></a>查看端口是否被占用</h2><p>还记得我们在netstat中介绍的如何查看端口被占用吗？nc也可以完成这样的事情。它使用-l(listen)参数，用于绑定指定端口并监听连接：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nc -l 6379</span><br><span class="line">nc: Address already in use</span><br></pre></td></tr></table></figure></p>
<p>当看到Address already in use的时候，就知道这个端口被占用了，否则它就会在这个端口监听。当然这个作用是我瞎说的，但是可以用。</p>
<h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p>例如需要扫描某个机器上21-30哪些端口是开放的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nc  -n 127.0.0.1 -z 1230-1234 -v</span><br><span class="line">nc: connect to 127.0.0.1 port 1230 (tcp) failed: Connection refused</span><br><span class="line">nc: connect to 127.0.0.1 port 1231 (tcp) failed: Connection refused</span><br><span class="line">nc: connect to 127.0.0.1 port 1232 (tcp) failed: Connection refused</span><br><span class="line">nc: connect to 127.0.0.1 port 1233 (tcp) failed: Connection refused</span><br><span class="line">Connection to 127.0.0.1 1234 port [tcp/*] succeeded!</span><br></pre></td></tr></table></figure></p>
<p>其中-n说明直接使用ip地址，而不使用域名，-z指定端口范围，-v输出详细信息。从结果就可以看到，1234端口是可连接的。</p>
<h2 id="TCP-UDP连接测试"><a href="#TCP-UDP连接测试" class="headerlink" title="TCP/UDP连接测试"></a>TCP/UDP连接测试</h2><p>当你在学习TCP相关的内容时，是否想着如何自己实践观察里面的状态或者数据包？虽然推荐自己去写一个TCP连接的服务端-客户端程序，但是也可以利用nc命令来完成，例如，在一个终端中输入如下内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nc -l 1234</span><br><span class="line">hello</span><br></pre></td></tr></table></figure></p>
<p>表明在1234端口监听，然后可以在另外一个终端进行连接;<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nc 127.0.0.1 1234</span><br><span class="line">hello</span><br></pre></td></tr></table></figure></p>
<p>连接本地地址1234端口，这个过程中就可以抓包，分析TCP的三次握手了。</p>
<p>除此之外，你还可以在建立好的连接之间发送消息（<strong>简单的聊天功能</strong>），让你分析更多！</p>
<p>默认情况，它创建的是TCP连接，而使用-u(UDP)参数可以测试UDP连通性。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nc -v -u 182.3.226.35 80</span><br><span class="line">Connection to 182.3.226.35 80 port [udp/http] succeeded!</span><br></pre></td></tr></table></figure></p>
<p>除此之外，还有很多参数用于调试，例如：</p>
<ul>
<li>-b 允许广播消息</li>
<li>-D 开启socket调试模式</li>
<li>-d 禁止从标准输入读取内容</li>
<li>-k 客户端退出后，保持连接</li>
<li>-v 显示详细信息</li>
</ul>
<p>由于在后面的文章中还会借助nc来说明，因此这里不详解介绍。</p>
<h2 id="HTTP连接测试"><a href="#HTTP连接测试" class="headerlink" title="HTTP连接测试"></a>HTTP连接测试</h2><p>例如查看HTTP头信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nc  www.baidu.com 80</span><br><span class="line">HEAD / HTTP/1.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Length: 17931</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Date: Sun, 23 Jun 2019 13:52:12 GMT</span><br><span class="line">Etag: &quot;54d9748e-460b&quot;</span><br><span class="line">Server: bfe/1.0.8.18</span><br></pre></td></tr></table></figure></p>
<p>连接后，输入HEAD / HTTP/1.1或HEAD / HTTP/1.0，然后输入两个回车，可查看web服务器相关信息。</p>
<h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><p>还是利用前面的连接，借助重定向符可以进行文件传输，例如服务端监听，并把内容输出到out.txt：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nc -l 1234 &gt; out.txt</span><br></pre></td></tr></table></figure></p>
<p>而客户端连接：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nc 127.0.0.1 1234 &lt; in.txt</span><br></pre></td></tr></table></figure></p>
<p>这样客户端in.txt的内容，就会传输到out.txt</p>
<p>关于重定向，可参考《<a href="https://www.yanbinghu.com/2018/10/26/9186.html">如何linux shell中的2 &gt; &amp;1</a>》</p>
<p>当然了，对于文件传输，scp命令能更好地完成这件事。如果你没有其他办法了，可以试试nc。</p>
<h2 id="网络测试"><a href="#网络测试" class="headerlink" title="网络测试"></a>网络测试</h2><p>前面说到可以通过nc传输数据，同样如果我们想测试两个主机间的网络速度（当然你可以利用iperf工具来完成这个工作），nc也是可以帮忙的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#服务端监听：</span><br><span class="line">$ nc -vl 1234 &gt;/dev/null</span><br></pre></td></tr></table></figure></p>
<p>其中重定向到/dev/null，表示将数据丢弃。</p>
<p>然后在另一台主机上执行:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ dd if=/dev/zero bs=1M count=10 |nc -vn 127.0.0.1 1234</span><br><span class="line">Connection to 127.0.0.1 1234 port [tcp/*] succeeded!</span><br><span class="line">10+0 records in</span><br><span class="line">10+0 records out</span><br><span class="line">10485760 bytes (10 MB, 10 MiB) copied, 0.0333675 s, 314 MB/s</span><br></pre></td></tr></table></figure></p>
<p>dd拷贝数据，这里从/dev/zero拷贝数据0，且一次1M，拷贝10次，最后通过nc命令发送到服务端。结束后，就可以看到统计信息了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>nc命令短小精悍，但在很多方面能够帮助我们，例如：</p>
<ul>
<li>端口扫描</li>
<li>连接测试</li>
<li>TCP/UDP服务端客户端监听与连接</li>
<li>网络测试</li>
<li>代理</li>
</ul>
<p>nc命令的更多妙用等着你去探索！</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言中的传值与传指针</title>
    <url>/2019/06/20/53981.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们可能听过C语言中的传值和传指针，在其他语言中，也有传引用一说，那么他们到底有什么区别呢？如果你还不能准确地分辨，就该好好了解一下了。<br><a id="more"></a></p>
<h2 id="传值"><a href="#传值" class="headerlink" title="传值"></a>传值</h2><p>我们在初学C语言的时候就被老师教过，下面的方式是无法交换a和b的值的：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"swap a = %d,b = %d\n"</span>,a,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"before swap:a = %d,b = %d\n"</span>,a,b);</span><br><span class="line">    swap(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"after  swap:a = %d,b = %d\n"</span>,a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">before swap:a = 10,b = 20                                                                                                                                                                   </span><br><span class="line">internal swap a = 20,b = 10                                                                                                                                                                 </span><br><span class="line">after  swap:a = 10,b = 20</span><br></pre></td></tr></table></figure></p>
<p>可以看到，a和b的值最终并没有被交换。开始时a，b的值为10,20，而最终还是同样的值。</p>
<p>为什么呢？因为函数参数在传递的时候，都是传<strong>原数据的副本</strong>，也就是说，swap内部使用的a和b只是最初始a和b的一个副本而已，所以无论在swap函数内部对a和b做任何改变，都不会影响初始的a和b的值。</p>
<p>正因如此，我们常常被告知，<strong>不要把直接把结构体直接作为参数</strong>，这样效率会很低。由于结构体本身占用字节数较大，如果直接作为参数，那么将会产生一个较大的”副本“，如此一来，效率也就很低了。</p>
<p>我们再结合下面的图来理解：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E5%80%BC%E4%BC%A0%E9%80%92/value.png" alt="值传递"></p>
<p>首先图中方框中的上部分a和b代表了main函数中的a和b，即原始数据，而方框中的下部分a和b代表了函数的参数a和b，即原始数据的“副本”。（后面的图都是如此，上部分代表原始值，下部分代表函数参数值）。</p>
<p>调用swap函数前后的情形如下：<br><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E5%80%BC%E4%BC%A0%E9%80%92/value1.png" alt="调用swap前后"></p>
<p>由于在swap中永远只是对a和b的副本进行操作，因此完全不影响原始的a和b的值。最终也不可能达到交换a和b的值的目的。</p>
<h2 id="传指针"><a href="#传指针" class="headerlink" title="传指针"></a>传指针</h2><p>那么为解决上面的问题，我们知道，需要传指针。其代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"swap a = %d,b = %d\n"</span>,*a,*b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"before swap:a = %d,b = %d\n"</span>,a,b);</span><br><span class="line">    swap(&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"after  swap:a = %d,b = %d\n"</span>,a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">before swap:a = 10,b = 20                                                                                                                                                                   </span><br><span class="line">swap a = 20,b = 10                                                                                                                                                                          </span><br><span class="line">after  swap:a = 20,b = 10</span><br></pre></td></tr></table></figure></p>
<p>可以看到在这种情况下，a，b的值才是真正交换了。</p>
<h2 id="为什么又有传值，又有传指针"><a href="#为什么又有传值，又有传指针" class="headerlink" title="为什么又有传值，又有传指针"></a>为什么又有传值，又有传指针</h2><p>看到这里，不知道你是否会疑惑，为什么给函数传递参数的时候，一会是传值，一会是传指针呢？为什么传指针就能改变参数的值呢？实际上，<strong>C语言里，参数传递都是值传递！</strong>也就是说，<strong>你认为的传指针也是传值</strong>，只不过它的值是指针类型罢了。</p>
<p>我们再通过图来理解前面为什么传指针就可以交换a，b的值：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E5%80%BC%E4%BC%A0%E9%80%92/pointer.jpg" alt="传指针"></p>
<p>从图中可以看出，虽然传递给函数的是指向a和b的指针的副本，但是它的副本同样也是指向a和b，因此<strong>虽然不能改变指针的指向，但是能改变参数a和b指向的内容，即改变原始a和b的值</strong>。</p>
<h2 id="再看传指针"><a href="#再看传指针" class="headerlink" title="再看传指针"></a>再看传指针</h2><p>如果是为指针p申请一段内存，下面的代码能达到目的吗？<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMemery</span><span class="params">(<span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*申请1024个int大小*/</span></span><br><span class="line">    p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"malloc failed\n"</span>);</span><br><span class="line">        p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    getMemery(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"address of p is %p\n"</span>,p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过前面的内容分析，肯定是达不到预期效果的。<br>运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">address of p is (nil)</span><br></pre></td></tr></table></figure></p>
<p>这是为什么呢？我们还是利用前面所知来分析，由于传递给getMemory函数的参数都是一个副本，因此函数内的p也是外部p的一个副本，因此即便在函数内部，将p指向了一块新申请的内存，仍然不会改变外面p的值，即p还是指向NULL。</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E5%80%BC%E4%BC%A0%E9%80%92/getMemory.png" alt="getMemory"></p>
<p>如何修改呢？我们需要传入p的地址，即指向int类型指针的指针。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMemery</span><span class="params">(<span class="keyword">int</span> **p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*申请1024个int大小*/</span></span><br><span class="line">    *p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == *p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"malloc failed\n"</span>);</span><br><span class="line">        *p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    getMemery(&amp;p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"address of p is %p\n"</span>,p);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">address of p is 0x144f010</span><br></pre></td></tr></table></figure></p>
<p>从运行结果可以看到，p的值被改变了。<br>可配合下面的图进行理解：<br><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E5%80%BC%E4%BC%A0%E9%80%92/getMemory1.png" alt="getMemory"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文总结如下：</p>
<ul>
<li>函数的形参都是原数据的“副本”，因此在函数内无法改变原数据</li>
<li>函数中参数都是传值，传指针本质上也是传值</li>
<li>如果想要改变入参内容，则需要传该入参的地址（指针和引用都是类似的作用），通过解引用修改其指向的内容</li>
<li>以上结论不限于C语言</li>
</ul>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul>
<li>如何实现不借助第三个变量，交换两个整数的值？</li>
<li>结合本文，理解C++/Java中所谓的传引用</li>
</ul>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>算法可视化网站助你学算法</title>
    <url>/2019/06/15/36031.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>无疑，数据结构与算法学习最大的难点之一就是如何在脑中形象化其抽象的逻辑步骤。而图像在很多时候能够大大帮助我们理解其对应的抽象化的东西，而如果这个图像还是我们自己一点点画出来的，那么无疑这个印象是最深刻的了。没错，今天给大家分享的就是算法可视化的网站。<br><a id="more"></a></p>
<h2 id="Data-Structure-Visualizations"><a href="#Data-Structure-Visualizations" class="headerlink" title="Data Structure Visualizations"></a>Data Structure Visualizations</h2><p>网站地址为：<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p>
<p>目前已经有很多常用的数据结构与算法的可视化，例如常见的栈，队列，递归，二叉树等等。<br><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/visualization/Algorithms.png" alt="Data Structure Visualizations"></p>
<p>我们点一个二叉查找树进去看看：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/visualization/binarytree.png" alt="二叉查找树"></p>
<p>开始时，是一片空白，左上角有几个按钮，为insert，delete，find，print，分别用于二叉查找树的插入，删除，查找和遍历。而这些过程的每一步都在你的掌控之中，你可以看到每一个节点是如何插入或者删除的。<br><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/visualization/binarytree2.png" alt="二叉查找树"></p>
<p>还有很多其他算法的可视化，非常简洁直观，值得一试。</p>
<p><strong>该网站特点</strong>:</p>
<ul>
<li>算法可视化</li>
<li>界面简洁直观</li>
<li>过程可控制</li>
</ul>
<h2 id="VisuAlgo"><a href="#VisuAlgo" class="headerlink" title="VisuAlgo"></a>VisuAlgo</h2><p>网址地址为：<a href="https://visualgo.net/zh/。这个网站涉及的算法就更加全面了。从首页就可以看出来不一样了，不仅支持多种算法可视化，还支持搜索。" target="_blank" rel="noopener">https://visualgo.net/zh/。这个网站涉及的算法就更加全面了。从首页就可以看出来不一样了，不仅支持多种算法可视化，还支持搜索。</a></p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/visualization/visualgo.png" alt="VisuAlgo"></p>
<p>而它除了提供和前面一个网址类似的算法动画以外，还提供大量的文字讲解：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/visualization/visualgo1.png" alt="VisuAlgo"></p>
<p>而在执行动画的时候，旁边仍然会有文字描述当前步骤，并且左下角还有算法复杂度的注释说明。<br><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/visualization/heapsort.gif" alt="堆排序"></p>
<p><strong>该网站特点</strong>：</p>
<ul>
<li>算法可视化</li>
<li>文字讲解</li>
<li>复杂度备注</li>
<li>图形可操控调整</li>
</ul>
<h2 id="algorithm-visualizer"><a href="#algorithm-visualizer" class="headerlink" title="algorithm-visualizer"></a>algorithm-visualizer</h2><p>网址地址：<a href="https://algorithm-visualizer.org/" target="_blank" rel="noopener">https://algorithm-visualizer.org/</a><br>它支持的算法种类也很多，除此之外，它还提供java，c++，js代码。而控制台也输出着整个过程来帮助你理解算法。</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/visualization/visualizer.png" alt="algorithm-visualizer"></p>
<p>来看一个冒泡排序：<br><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/visualization/bs.gif" alt="bubble sort"></p>
<p><strong>该网站特点</strong>：</p>
<ul>
<li>算法可视化</li>
<li>有代码</li>
<li>有控制台输出帮助理解</li>
<li>算法种类丰富</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上几个网站各有特点，可自己体验后，选择自己喜欢的。</p>
<h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>你是如何学习算法的？欢迎分享你的算法学习经验。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数据结构与算法</tag>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title>netstat命令实例详解</title>
    <url>/2019/06/15/40941.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在调试网络程序或者定位网络相关问题时，<strong>有一个命令不得不知，它就是netstat</strong>。netstat命令用于查看网络连接，路由表，网络接口统计数据, 虚拟连接等信息。netstat的选项很多，但是本文准备介绍一些netstat命令的实用技巧。<br><a id="more"></a></p>
<h2 id="查看某个端口是否被占用"><a href="#查看某个端口是否被占用" class="headerlink" title="查看某个端口是否被占用"></a>查看某个端口是否被占用</h2><p>如果你遇到“Address already in use”的错误，那么你就需要好好看看是不是端口已经被占用了。<strong>-a（all）参数用于列出所有监听和非监听状态的连接</strong>。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ netstat -a|grep 6379</span><br><span class="line">tcp        0      0 *:6379                  *:*                     LISTEN     </span><br><span class="line">tcp6       0      0 [::]:6379               [::]:*                  LISTEN</span><br></pre></td></tr></table></figure></p>
<p>这里我们可以看到，有一个tcp连接使用了6379端口，并且当前处于LISTEN状态，这些状态信息对于分析网络连接问题非常有帮助，我们将会在后面的文章中看到它们大放异彩。</p>
<p>当然你也可以使用<a href="https://www.yanbinghu.com/2019/03/05/61180.html">lsof命令</a>中的方法来查看。关于grep的用法，也可以参考《<a href="https://www.yanbinghu.com/2019/06/02/59940.html">grep命令详解</a>》，这里就不展开了，我们后面会在很多地方用到。</p>
<h2 id="查找占用端口的进程"><a href="#查找占用端口的进程" class="headerlink" title="查找占用端口的进程"></a>查找占用端口的进程</h2><p>前面虽然知道已经有进程使用了6379端口，但是不知道是哪个进程，因此<strong>为了知道进程信息，需要使用-p(program)参数</strong>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ netstat -ap|grep 6379</span><br><span class="line">tcp        0      0 *:6379                  *:*                     LISTEN      10011/redis-server </span><br><span class="line">tcp6       0      0 [::]:6379               [::]:*                  LISTEN      10011/redis-server</span><br></pre></td></tr></table></figure></p>
<p>这个时候就可以看到是进程id为10011的redis-server进程占用了6379端口，至此要杀要剐就随你便了。</p>
<h2 id="查看指定协议的连接"><a href="#查看指定协议的连接" class="headerlink" title="查看指定协议的连接"></a>查看指定协议的连接</h2><p>我们都知道，除了TCP之外还有UDP，如果我们想查看指定类型的连接呢？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ netstat -at   #-t,查看tcp连接</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line">tcp        0      0 192.168.0.103:42468     113.96.233.139:https    ESTABLISHED</span><br><span class="line">tcp        0      0 192.168.0.103:59326     123.58.182.252:https    TIME_WAIT  </span><br><span class="line">tcp        0      0 192.168.0.103:59328     123.58.182.252:https    TIME_WAIT  </span><br><span class="line">（未显示完全）</span><br></pre></td></tr></table></figure></p>
<p>以此种方式，可以看到所有的TCP连接，而对于UDP连接，只需要使用-u(UDP):<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ netstat -au</span><br><span class="line">udp        0      0 *:36305                 *:*                                </span><br><span class="line">udp        0      0 127.0.1.1:domain        *:*                                </span><br><span class="line">udp        0      0 *:bootpc                *:*                                </span><br><span class="line">udp        0      0 *:ipp                   *:*   </span><br><span class="line"></span><br><span class="line">(未显示完全))</span><br></pre></td></tr></table></figure></p>
<p>当然了，这两个参数也是可以一起用的。</p>
<p>除此之外，还可以使用-4或-6来指定查看ipv4还是ipv6的连接：</p>
<h2 id="查看处于监听状态的连接"><a href="#查看处于监听状态的连接" class="headerlink" title="查看处于监听状态的连接"></a>查看处于监听状态的连接</h2><p>对于还没有建立完整连接的服务器来说，它启动后正常的状态是LISTEN状态，<strong>如果只想查看处于该状态的连接，则可以使用-l（LISTEN）参数</strong>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ netstat -l</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        0      0 127.0.1.1:domain        *:*                     LISTEN     </span><br><span class="line">tcp        0      0 localhost:5941          *:*                     LISTEN     </span><br><span class="line">tcp        0      0 localhost:ipp           *:*                     LISTEN     </span><br><span class="line">tcp        0      0 localhost:socks         *:*                     LISTEN     </span><br><span class="line">tcp        0      0 *:6379                  *:*                     LISTEN</span><br><span class="line">（未显示完全）</span><br></pre></td></tr></table></figure></p>
<p>这个时候记得<strong>不要带上-a参数</strong>，它会列出所有。</p>
<p>而你如果要查看其他状态的连接，只需要结合grep使用即可，例如，查看ESTABLISHED状态的连接：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ netstat -anp |grep ESTAB</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">tcp        0      0 192.168.0.103:42468     113.96.233.139:443      ESTABLISHED 2613/chrome     </span><br><span class="line">tcp        0      0 192.168.0.103:38024     108.177.125.188:443     ESTABLISHED 2613/chrome</span><br></pre></td></tr></table></figure></p>
<h2 id="不解析主机，端口等信息"><a href="#不解析主机，端口等信息" class="headerlink" title="不解析主机，端口等信息"></a>不解析主机，端口等信息</h2><p>不知道你有没有发现，<strong>在执行前面的命令的时候，速度很慢</strong>，让你一度怀疑是不是自己电脑太卡了。实际上，你观察前面的输出结果就会发现，很多连接的主机名和端口对应的应用都解析出来了，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123.58.182.252:https</span><br></pre></td></tr></table></figure></p>
<p>所以慢是因为它需要做解析，<strong>使用-n（numeric）参数就可以快速显示原始数字端口或地址了</strong>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ netstat -anp</span><br></pre></td></tr></table></figure></p>
<p>一定要自己尝试一下奥！</p>
<h2 id="持续输出连接信息"><a href="#持续输出连接信息" class="headerlink" title="持续输出连接信息"></a>持续输出连接信息</h2><p>你在定位网络相关问题的时候，总不想执行一次观察一次吧？能不能自动反复执行查看呢？当然可以啦！可以使用-c（continuous）参数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ netstat -npc</span><br></pre></td></tr></table></figure></p>
<p>这样，它就会每隔一秒执行一次。当然你完全可以使用watch命令，关于watch命令的使用可以参考《<a href="https://www.yanbinghu.com/2019/03/08/61352.html">解放你的双手-watch</a>》。</p>
<h2 id="查看用户和连接的iNode"><a href="#查看用户和连接的iNode" class="headerlink" title="查看用户和连接的iNode"></a>查看用户和连接的iNode</h2><p>这条连接是哪个用户建立的呢？unix下一切皆文件，那么这个连接的iNode是多少呢？借助-e(extend)参数可以看到这些信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ netstat -ent</span><br><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       User       Inode      </span><br><span class="line">tcp        0      0 192.168.0.103:42468     113.96.233.139:443      ESTABLISHED 1000       134891     </span><br><span class="line">tcp        0      0 192.168.0.103:46556     121.9.246.106:443       TIME_WAIT   0          0</span><br></pre></td></tr></table></figure></p>
<p>可以看到在使用-e参数后，多了最后两列，分别是user和Inode。而使用id命令可以知道该user到底是谁：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ id 1000</span><br><span class="line">uid=1000(hyb) gid=1000(hyb) groups=1000(hyb),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare)</span><br></pre></td></tr></table></figure></p>
<h2 id="查看连接相关的定时器"><a href="#查看连接相关的定时器" class="headerlink" title="查看连接相关的定时器"></a>查看连接相关的定时器</h2><p>使用-o可以查看和连接相的定时器信息，<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ netstat -nto</span><br><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       Timer</span><br><span class="line">tcp        0      0 192.168.0.103:42468     113.96.233.139:443      ESTABLISHED keepalive (18.69/0/0)</span><br><span class="line">tcp        1      1 192.168.0.103:43718     113.96.233.139:443      LAST_ACK    on (19.97/7/0)</span><br><span class="line">tcp        0      0 192.168.0.103:38024     108.177.125.188:443     ESTABLISHED keepalive (34.76/0/0)</span><br><span class="line">tcp        0      0 192.168.0.103:60362     123.58.182.252:443      TIME_WAIT   timewait (6.70/0/0)</span><br><span class="line">tcp6       0      0 127.0.0.1:9614          127.0.0.1:59736         ESTABLISHED off (0.00/0/0)</span><br></pre></td></tr></table></figure></p>
<p>最后的timer列相关字段含义如下：</p>
<ul>
<li>keepalive keepalive的时间计时</li>
<li>on 重发的时间计时</li>
<li>off 没有时间计时</li>
<li>timewait 等待时间计时</li>
</ul>
<p>关于定时器的含义，需要对TCP协议有较多理解，这里就不展开了。</p>
<h2 id="查看数据包统计信息"><a href="#查看数据包统计信息" class="headerlink" title="查看数据包统计信息"></a>查看数据包统计信息</h2><p>各种协议的数据包的收发情况如何呢？连接数量如何呢是用-s(statistics)参数可以查看：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ netstat -s</span><br><span class="line">（仅显示了TCP协议的结果）</span><br><span class="line">Tcp:</span><br><span class="line">    3067 active connections openings</span><br><span class="line">    1 passive connection openings</span><br><span class="line">    173 failed connection attempts</span><br><span class="line">    587 connection resets received</span><br><span class="line">    10 connections established</span><br><span class="line">    657576 segments received</span><br><span class="line">    456349 segments send out</span><br><span class="line">    2700 segments retransmited</span><br><span class="line">    16 bad segments received.</span><br><span class="line">    1321 resets sent</span><br></pre></td></tr></table></figure></p>
<h2 id="查看路由信息"><a href="#查看路由信息" class="headerlink" title="查看路由信息"></a>查看路由信息</h2><p>使用-r(route)参数可以查看路由相关信息，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ netstat -r</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</span><br><span class="line">default         192.168.0.1     0.0.0.0         UG        0 0          0 wlp3s0</span><br><span class="line">link-local      *               255.255.0.0     U         0 0          0 wlp3s0</span><br><span class="line">192.168.0.0     *               255.255.255.0   U         0 0          0 wlp3s0</span><br></pre></td></tr></table></figure></p>
<p>当然你也可以借助route命令完成这样简单的工作。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>netstat命令是我们定位网络相关问题的利器，如果你还不会使用，那么最好花几分钟学习一下。netstat更详细的字段解释可以参考其手册。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>图解堆排序-C语言实现</title>
    <url>/2019/06/04/26564.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在介绍《<a href="https://www.yanbinghu.com/2019/05/17/36705.html">什么是优先队列</a>》的时候就注意到，如果每次都删除堆顶元素，那么将会得到一个有序的数据。因此，我们可以利用二叉堆来对数据进行排序。<a href="https://github.com/yanbinghu/data-structures-and-algorithms-in-c/blob/master/heapSort/heapSort.c" target="_blank" rel="noopener"><strong>点我查看本文代码地址。</strong></a></p>
<a id="more"></a>
<h2 id="堆排序分析"><a href="#堆排序分析" class="headerlink" title="堆排序分析"></a>堆排序分析</h2><p>通过前面的学习我们可以看到，如果构建一个二叉堆，最后每次从堆顶取出一个元素，那么最终取出元素就是有序的，不过如果要用来对数据按照从小到大排序，就不是构造小顶堆，而是大顶堆了，即堆顶元素大于等于其左右儿子节点。总结堆排序思路如下：</p>
<ul>
<li>以O(N)时间复杂度构建N个元素的二叉堆</li>
<li>以O(logN)时间复杂度删除一个堆顶元素，N个元素时间复杂度为O（NlogN）</li>
<li>由于删除一个堆顶元素时，就会空出一个位置，为了节省空间，将删除的堆顶元素放到数组末尾</li>
<li>当堆为空时，完成排序</li>
<li>由于数组元素从下标0开始，因此每个位置必须利用好。假设堆顶元素位置为i,那么左右儿子节点位置分别为2i+1,2i+2</li>
</ul>
<h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p>根据前面的分析，我们来看一个具体的例子。假设我们要对<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 10 8 5 7 15 35</span><br></pre></td></tr></table></figure></p>
<p>进行排序。</p>
<p>该数据构成的原始二叉树如下：<br><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/heap/heap1.png" alt="二叉树"></p>
<h4 id="构建二叉堆"><a href="#构建二叉堆" class="headerlink" title="构建二叉堆"></a>构建二叉堆</h4><p>为了能够使得数组所有元素满足堆的性质，即父节点大于等于儿子节点，我们需要从倒数第二层开始调整（为什么不是从最后一层？）。即调整8和10。<br>对于8来说，找到它的儿子节点中较大的一个，即35,将8和35交换后如下：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/heap/heap2.png" alt="第一次交换后"></p>
<p>此时数组数据为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 10 35 5 7 15 8</span><br></pre></td></tr></table></figure></p>
<p>对于10来说，它比左右儿子节点都大，因此不需要调整。</p>
<p>对于１来说，它的右儿子35最大，因此需要调整，和右儿子交换后如下：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/heap/heap3.png" alt="第二次交换后"></p>
<p>此时数组数据为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">35 10 1 5 7 15 8</span><br></pre></td></tr></table></figure></p>
<p>但是一次交换后，我们发现，１的左儿子还是比它大，因此交换它和较大的左儿子的位置，交换后如下：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/heap/heap4.png" alt="第三次交换后"></p>
<p>此时数组数据为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">35 10 15 5 7 1 8</span><br></pre></td></tr></table></figure></p>
<p>最终我们得到了满足堆性质的二叉堆了。</p>
<h4 id="基于二叉堆的排序"><a href="#基于二叉堆的排序" class="headerlink" title="基于二叉堆的排序"></a>基于二叉堆的排序</h4><p>在堆创建好后，每次取出堆顶元素，并且调整堆，把堆顶元素放在数组最后即可。<br>例如，对于前面创建好的堆，堆顶元素是35，我们取出第i（此时为1）个元素35，并把堆最后一个元素放在数组倒数第i个位置：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/heap/heap5.png" alt="堆顶元素交换"></p>
<p>为了满足堆性质，我们需要调整堆顶元素，因为堆顶元素目前不满足堆性质，因此需要交换8和15的位置：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/heap/heap6.png" alt="调整位置"></p>
<p>此时所有元素再次满足堆性质。</p>
<p>此时数组数据为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15 10 8 5 7 1 35</span><br></pre></td></tr></table></figure></p>
<p>对于其他元素也是同样的操作，因此不再赘述。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>根据上面的分析，关键代码实现如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjust_ele</span><span class="params">(ElementType arr[],<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> child ;</span><br><span class="line">    ElementType temp;</span><br><span class="line">    <span class="keyword">for</span>(temp = arr[i];<span class="number">2</span>*i+<span class="number">1</span> &lt; length;i = child)</span><br><span class="line">    &#123;</span><br><span class="line">        child = <span class="number">2</span> * i +<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*找到较大的儿子*/</span></span><br><span class="line">        <span class="keyword">if</span>(child != length<span class="number">-1</span> &amp;&amp; arr[child+<span class="number">1</span>] &gt; arr[child])</span><br><span class="line">            child+=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/*如果空穴元素小于该儿子，则空穴下滑*/</span></span><br><span class="line">        <span class="keyword">if</span>(temp &lt; arr[child])</span><br><span class="line">           arr[i] = arr[child];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*将i位置的元素放到正确的位置*/</span></span><br><span class="line">    arr[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(ElementType arr[],<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*构建堆*/</span></span><br><span class="line">    <span class="keyword">for</span>(i = length /<span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        adjust_ele(arr,i,length);</span><br><span class="line">        <span class="comment">//printArr(arr,length);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = length<span class="number">-1</span>;i &gt; <span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*填充i位置的空穴*/</span></span><br><span class="line">        swap(&amp;arr[<span class="number">0</span>],&amp;arr[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*每次都处理堆顶元素*/</span></span><br><span class="line">        adjust_ele(arr,<span class="number">0</span>,i);</span><br><span class="line">        <span class="comment">//printArr(arr,length);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完整可运行代码地址：<a href="https://github.com/yanbinghu/data-structures-and-algorithms-in-c/blob/master/heapSort/heapSort.c" target="_blank" rel="noopener">heapSort</a></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">before sort:1 10 8 5 7 15 35 </span><br><span class="line">after  sort:1 5 7 8 10 15 35</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>结合我们前面介绍的优先队列，我们很容易理解堆排序，不过需要注意的就是位置0必须使用上。另外通过利用删除堆顶元素后空出来的位置，避免了另外申请数组内存来存放排序好的数组。建议自己修改完整可运行代码，来观察数据调整情况。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数据结构与算法</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux grep命令详解</title>
    <url>/2019/06/02/59940.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前介绍过很多linux下查找相关的命令，例如《<a href="https://www.yanbinghu.com/2018/11/24/18359.html">Linux中的文件查找技巧</a>》，《<a href="https://www.yanbinghu.com/2018/12/15/21083.html">find命令高级用法</a>》，《<a href="https://www.yanbinghu.com/2019/03/05/61180.html">如何查看linux中文件打开情况-lsof命令</a>》等等，而对文件内容搜索的命令似乎还没有涉及，因此本文介绍文本搜索命令—grep。<br><a id="more"></a></p>
<h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h2><p>我们会经常结合管道符（|）来使用它，即在前面命令执行的结果中查找包含相关字符串的内容。例如：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ps -ef|grep redis</span><br></pre></td></tr></table></figure></p>
<p>ps -ef用于查看系统进程情况，但是它列出的结果很多，如果我们只想看到自己需要的，则通过管道符，用grep进行过滤搜索，例如搜索redis相关的进程，最后它只会列出和redis相关的进程了：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$  ps -ef|grep redis</span><br><span class="line">root     10748 10733  0 21:14 pts/21   00:00:00 redis-server *:6379</span><br><span class="line">root     10754 10733  0 21:14 pts/21   00:00:00 grep --color=auto redis</span><br></pre></td></tr></table></figure></p>
<p>那么如果要排除某些不相关信息呢？我们可以使用-v参数<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ps -ef|grep redis |grep -v auto</span><br><span class="line">root     10748 10733  0 21:14 pts/21   00:00:00 redis-server *:6379</span><br></pre></td></tr></table></figure></p>
<p>这样一来，包含auto相关的结果就不会出现在最终结果里了。</p>
<p>如果只想统计结果数量呢？我们可以结合-c（count）参数：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ps -ef|grep redis -c</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>
<h2 id="文件内容搜索"><a href="#文件内容搜索" class="headerlink" title="文件内容搜索"></a>文件内容搜索</h2><p>好了，说完了最常见的用法，我们来看看如何搜索文件内容。实际上awk和sed在这方面也颇有经验，不过本文的主角是grep，所以另外两个命令暂时不涉及。我们来看几个实例。</p>
<h4 id="在指定文件中查找指定关键字"><a href="#在指定文件中查找指定关键字" class="headerlink" title="在指定文件中查找指定关键字"></a>在指定文件中查找指定关键字</h4><p>例如，要在linux_command_debug.md文件中，查找test字符串：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$  grep <span class="string">"test"</span> aaa/bbb/linux_command_debug.md</span><br><span class="line">int <span class="built_in">test</span>(int a,int b)</span><br><span class="line">    <span class="built_in">test</span>(a,b);</span><br></pre></td></tr></table></figure></p>
<p>如果想要显示指定关键字的行号，可以使用-n参数，例如：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$  grep -n <span class="string">"test"</span> aaa/bbb/linux_command_debug.md</span><br><span class="line">18:int <span class="built_in">test</span>(int a,int b)</span><br><span class="line">27:    <span class="built_in">test</span>(a,b);</span><br></pre></td></tr></table></figure></p>
<h4 id="搜索时指定或排除多个文件"><a href="#搜索时指定或排除多个文件" class="headerlink" title="搜索时指定或排除多个文件"></a>搜索时指定或排除多个文件</h4><p>前面提到了对一个文件内容进行搜索，如果是多个呢？或者不想从某些文件里搜索呢？</p>
<p>如果想对文件进行指定也是可以的，例如搜索所有的md结尾的文件：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$  grep -n <span class="string">"test"</span> *.md</span><br></pre></td></tr></table></figure></p>
<p>或者可以使用—exclude参数来排除某些文件，例如，查找包含test，但是排除txt文件：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ grep -rn <span class="string">"test"</span> --exclude=*.txt</span><br></pre></td></tr></table></figure></p>
<p>搜索时就会忽略.txt结尾的文件了。</p>
<p>如果要排除的条件比较多，可以将要排除的条件存储在另外一个文件里：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ grep -rn <span class="string">"test"</span> --exclude-from=skip.txt</span><br></pre></td></tr></table></figure></p>
<p>skip.txt的内容可以是模式匹配的文件名或者具体文件名：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">*.txt</span><br><span class="line">test.md</span><br></pre></td></tr></table></figure></p>
<p>这样，以.txt结尾，以及test.md文件都不会搜索了。</p>
<p>除此之外，还可以排除指定目录，它需要用到—exclude-dir参数：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ grep -rn <span class="string">"test"</span> --exclude-dir=aaa</span><br></pre></td></tr></table></figure></p>
<p>它在搜索时将会跳过aaa目录下的文件。</p>
<h4 id="查找包含指定关键字的文件"><a href="#查找包含指定关键字的文件" class="headerlink" title="查找包含指定关键字的文件"></a>查找包含指定关键字的文件</h4><p>如果要在当前目录下所有文件查找包含“int main(void)”字符串的文件：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ grep -rn <span class="string">"int main(void)"</span></span><br><span class="line">aaa/bbb/c_main_func.md:49:int main(void)</span><br><span class="line">aaa/bbb/c_main_func.md:71:int main(void) &#123; /* ... */ &#125;</span><br><span class="line">aaa/bbb/c_array.md:104:int main(void)</span><br><span class="line">aaa/bbb/c_array.md:129:int main(void)</span><br><span class="line">aaa/bbb/pc-lint.md:42:int main(void)</span><br><span class="line">aaa/bbb/pc-lint.md:128:int main(void)</span><br></pre></td></tr></table></figure></p>
<p><strong>这可能是最实用的使用方法之一了</strong>。这里-r参数表示递归查找当前目录的文件，-n会显示查找位置的行号，如果只想显示包含该指定关键字的文件名，可使用-l（—file-with-matches）参数：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ grep -rln <span class="string">"int main(void)"</span></span><br><span class="line">aaa/bbb/c_main_func.md</span><br><span class="line">aaa/bbb/c_array.md</span><br><span class="line">aaa/bbb/pc-lint.md</span><br></pre></td></tr></table></figure></p>
<p>如果你尝试一下就会发现，如果不带-r参数，它会暂停，等待你从控制台输入，例如：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ grep -n <span class="string">"test"</span></span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">1:<span class="built_in">test</span></span><br></pre></td></tr></table></figure></p>
<p>所以使用时记得带上相关参数奥！</p>
<h4 id="查找不包含指定关键字的文件"><a href="#查找不包含指定关键字的文件" class="headerlink" title="查找不包含指定关键字的文件"></a>查找不包含指定关键字的文件</h4><p>前面提到了如何查找包含某个关键字的文件，如果要找的是<strong>不包含</strong>该关键字的文件呢？<br>实际上只要使用-L参数即可:<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ grep -rLn <span class="string">"int main(void)"</span></span><br><span class="line">(这里会显示不包含指定关键字内容的文件名)</span><br></pre></td></tr></table></figure></p>
<h4 id="搜索时忽略大小写"><a href="#搜索时忽略大小写" class="headerlink" title="搜索时忽略大小写"></a>搜索时忽略大小写</h4><p>使用-i（—ignore-case）参数即可：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ grep -rni <span class="string">"int MAIN(void)"</span></span><br><span class="line">aaa/bbb/c_main_func.md:49:int main(void)</span><br><span class="line">aaa/bbb/c_main_func.md:71:int main(void) &#123; /* ... */ &#125;</span><br><span class="line">aaa/bbb/c_array.md:104:int main(void)</span><br><span class="line">aaa/bbb/c_array.md:129:int main(void)</span><br><span class="line">aaa/bbb/pc-lint.md:42:int main(void)</span><br><span class="line">aaa/bbb/pc-lint.md:128:int main(void)</span><br></pre></td></tr></table></figure></p>
<h4 id="搜索显示不包含指定关键字的行"><a href="#搜索显示不包含指定关键字的行" class="headerlink" title="搜索显示不包含指定关键字的行"></a>搜索显示不包含指定关键字的行</h4><p>前面的大部分例子都是显示符合条件的行，如果要显示不符合条件的行呢？可以用我们前面提到的-v参数：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ grep -rnv <span class="string">"int main(void)"</span></span><br><span class="line">(内容较多，未显示)</span><br></pre></td></tr></table></figure></p>
<p>从结果中就会发现，它会展示出包含指定关键字的文件，但是展示的是不包含该关键字的行。</p>
<h4 id="显示指定关键字前后内容"><a href="#显示指定关键字前后内容" class="headerlink" title="显示指定关键字前后内容"></a>显示指定关键字前后内容</h4><p>假如你需要查看包含指定关键字行附近的行，前面的方式是没有办法看到的，不过我们可以用-A(—after-context=)和-B(—before-context=)参数来显示前后的行：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ grep -rn <span class="string">"int main(void)"</span> -A 1 -B 1</span><br><span class="line">aaa/bbb/c_array.md-103-&#125;</span><br><span class="line">aaa/bbb/c_array.md:104:int main(void)</span><br><span class="line">aaa/bbb/c_array.md-105-&#123;</span><br><span class="line">(其他内容省略)</span><br></pre></td></tr></table></figure></p>
<p>通过最后加上-A和-B参数，显示了指定关键字前面的行，这在日志搜索分析时非常有用。</p>
<h4 id="指定规则文件进行搜索"><a href="#指定规则文件进行搜索" class="headerlink" title="指定规则文件进行搜索"></a>指定规则文件进行搜索</h4><p>如果有多个搜索关键字怎么处理呢？我们可以把关键字写在一个文件，搜索时指定文件即可，例如规则文件为key.txt：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">test</span><br></pre></td></tr></table></figure></p>
<p>从指定文件中搜索上面的关键字：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat filename |grep -f key.txt</span><br></pre></td></tr></table></figure></p>
<p>这样结果就会显示匹配key.txt文件中所有关键字的行，非常适合用于多个条件的搜索。</p>
<h4 id="正则表达式搜索"><a href="#正则表达式搜索" class="headerlink" title="正则表达式搜索"></a>正则表达式搜索</h4><p>看完前面的内容，是不是还没有感受到grep的强大？grep的另一个强大之处是，它的搜索<strong>支持正则表达式</strong>，例如查找文本行以t开头，以t结尾的文件：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ grep -rn ^t.*t$</span><br><span class="line">key.txt:2:<span class="built_in">test</span></span><br><span class="line">aaa/bbb/c_operate_redis_start.md:68:typedef struct Stu_Info_Struct</span><br><span class="line">aaa/bbb/c_operate_redis_start.md:101:typedef struct Stu_Info_Struct</span><br></pre></td></tr></table></figure></p>
<p>其中^t，表明以t开头，t$表明以t结尾，如果需要使用扩展的正则表达式进行搜索，可使用egrep命令。关于正则表达式的写法，本文不做详细介绍。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在内容搜索方面，grep常常能够助我们一臂之力，因此掌握grep的使用也是linux学习不可缺少的一部分，当然我们不需要完全记住每个参数的作用，但我们至少知道有这样的参数，并且在需要时能够快速查询到。本文常用参数如下：</p>
<ul>
<li>-v #显示不包含匹配关键字的所有行。</li>
<li>-l #显示包含匹配关键字的文件</li>
<li>-L #显示不包含匹配关键字的文件</li>
<li>-r #递归搜索</li>
<li>-i #忽略大小写</li>
<li>-n #显示关键字所在行号</li>
<li>-A n #显示关键字后n行</li>
<li>-B n #显示关键字前n行</li>
<li>—exclude #搜索时排除某些文件</li>
<li>—exclude-dir #搜索时排除某些目录</li>
<li>-f #指定规则文件进行搜索</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>优先队列-C语言实现</title>
    <url>/2019/05/17/36705.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们之前已经介绍过<a href="https://www.yanbinghu.com/2019/03/28/13055.html">队列-C语言实现</a>，它们是先入先出的，这很容易用平常的排队来理解。但是如果这个队列要支持有紧急情况的人先出队呢？原先那种队列就不再适用了，我们需要使用本文所提到的特殊队列—优先队列。本文相关代码地址<a href="https://github.com/yanbinghu/data-structures-and-algorithms-in-c/blob/master/priorityQueue/priorityQueue.c" target="_blank" rel="noopener">github</a>。</p>
<a id="more"></a>
<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>优先队列也是一种抽象数据类型。优先队列中的每个元素都有优先级，而优先级高（或者低）的将会先出队，而优先级相同的则按照其在优先队列中的顺序依次出队。</p>
<p>也就是说优先队列，通常会有下面的操作：</p>
<ul>
<li>将元素插入队列</li>
<li>将最大或者最小元素删除</li>
</ul>
<p>这样的话，我们完全可以使用链表来实现，例如以O（1）复杂度插入，每次在表头插入，而以O（N）复杂度执行删除最小元素；或者以O（N）复杂度插入，保持链表有序，而以O（1）复杂度删除。</p>
<p>然而<strong>优先队列往往使用堆来实现</strong>，以至于通常说堆时，就自然而然地想到了优先队列。</p>
<h2 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h2><p>二叉树堆是一棵<strong>完全二叉树</strong>，并且对于每一个节点（根节点除外），它的父节点小于或等于它，这样最小元素就会在堆顶，我们就很容易找到最小元素。如果你还不清楚二叉树，建议先阅读《<a href="https://www.yanbinghu.com/2019/04/07/55964.html">二叉树-C语言实现</a>》。为了理解二叉堆的特性，还需要再介绍两个概念：</p>
<ul>
<li>满二叉树：除叶子节点外，所有节点都有两个子节点，称为满二叉树。这个很容易理解，就不多做解释。</li>
<li><strong>完全二叉树</strong>：除了最后一层外，每层节点个数达到最大，并且最后一层的叶子节点都靠左边排列。</li>
</ul>
<p>如下图一是一棵完全二叉树，而图二中的不是，因为最后一层的叶子节点不全在左边排列。</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/completedTree.png" alt="图一：完全二叉树"></p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/notCompleted.png" alt="图二：非完全二叉树"></p>
<p>二叉堆可以很容易用数组来表示，因为一棵高度为h的完全二叉树有2^h到2^(h+1)-1个节点，这样存放一个二叉堆就不会太浪费空间，而且一旦知道高度，就可以知道节点数的范围。</p>
<p>那么如何使用数组来表示二叉堆怎么存放元素呢？</p>
<ul>
<li>对于数组i上的元素，它的左儿子在2i位置，右儿子2i+1的位置，那么它的父节点在[i/2]的位置。例如节点1位置的左儿子节点在2处。</li>
<li>本文位置0不存储数据</li>
</ul>
<p>例如，对于下面的二叉堆（用字母表示的二叉堆），如果存储在数组中，则是下面这样：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/heapSample.png" alt="二叉堆示例"></p>
<p>数组中存放情况：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>不存储</td>
<td>a</td>
<td>b</td>
<td>c</td>
<td>d</td>
<td>e</td>
<td>f</td>
</tr>
</tbody>
</table>
</div>
<h2 id="二叉堆的操作"><a href="#二叉堆的操作" class="headerlink" title="二叉堆的操作"></a>二叉堆的操作</h2><p>我们假设后面的操作都是让最小元素在堆顶，即对小堆操作。堆的常见操作有：</p>
<ul>
<li>初始化</li>
<li>判断堆是否满</li>
<li>判断堆是否为空</li>
<li>向堆中插入元素</li>
<li>销毁堆</li>
<li>删除最小元素</li>
<li>找到最小元素</li>
</ul>
<h4 id="初始化堆"><a href="#初始化堆" class="headerlink" title="初始化堆"></a>初始化堆</h4><p>初始化堆之前，先定义堆结构。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> capacity;   <span class="comment">//最大元素数量</span></span><br><span class="line">    <span class="keyword">int</span> size;    <span class="comment">//堆元素数量</span></span><br><span class="line">    ElementType *eles;  <span class="comment">//堆元素数组</span></span><br><span class="line">&#125;PriorityQueue;</span><br></pre></td></tr></table></figure></p>
<p>这里定义了HeapStruct结构，包含三个元素，分别是最大容量，当前堆大小，以及堆数组。<br>因为这里使用的是动态数组，所以我们需要对其进行初始化，当然你也可以参考《<a href="https://www.yanbinghu.com/2019/03/16/31765.html">如何自己实现一个栈</a>》使用静态数组来实现，但这种方式的缺点很明显，它只能固定堆大小。</p>
<p>堆初始化函数如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">PriorityQueue *<span class="title">init_PQ</span><span class="params">(<span class="keyword">int</span> maxEleNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PriorityQueue *pq = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*检查输入大小的合法性*/</span></span><br><span class="line">    <span class="keyword">if</span>(maxEleNum &lt;= <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    pq = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(PriorityQueue));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pq)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"malloc failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*下标为0的位置保留，不作使用*/</span></span><br><span class="line">    pq-&gt;eles = <span class="built_in">malloc</span>((maxEleNum + <span class="number">1</span>)*<span class="keyword">sizeof</span>(ElementType));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pq-&gt;eles)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"malloc failed\n"</span>);</span><br><span class="line">        <span class="built_in">free</span>(pq);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*初始化成员*/</span></span><br><span class="line">    <span class="built_in">memset</span>(pq-&gt;eles,<span class="number">0</span>,(maxEleNum + <span class="number">1</span>)*<span class="keyword">sizeof</span>(ElementType));</span><br><span class="line">    pq-&gt;capacity = maxEleNum;</span><br><span class="line">    pq-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> pq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主要做了以下几件事：</p>
<ul>
<li>创建一个空堆</li>
<li>初始化元素数量为0</li>
</ul>
<h4 id="堆是否已满"><a href="#堆是否已满" class="headerlink" title="堆是否已满"></a>堆是否已满</h4><p>判断堆是否已满只需要判断容量和当前大小的比较结果即可：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pq_is_full</span><span class="params">(PriorityQueue *pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pq)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(pq-&gt;capacity == pq-&gt;size)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="堆是否已空"><a href="#堆是否已空" class="headerlink" title="堆是否已空"></a>堆是否已空</h4><p>判断堆是否为空只需要判断它的size是否为0即可：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pq_is_empty</span><span class="params">(PriorityQueue *pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pq)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == pq-&gt;size)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="堆的插入"><a href="#堆的插入" class="headerlink" title="堆的插入"></a>堆的插入</h4><p>按照我们前面的分析，插入操作是比较容易，放在属于它的下标位置即可，但是为了保持堆的性质，即节点的值要大于等于它的父节点，插入时就需要考虑更多了。</p>
<p>我们可以采取这样的方式：</p>
<ul>
<li>将元素准备插入到下一个空闲位置（空穴）</li>
<li>如果插入后，仍然保持堆得性质，则直接插入该位置</li>
<li>如果插入后，导致父节点不再小于等于它，则将父节点值移到该空穴，父节点原来的位置就变成空穴</li>
<li>继续尝试将心得元素放入上面的空穴，并与父节点比较，知道新元素找到属于它的位置</li>
</ul>
<p>举个例子，假如要在下面的二叉堆中，再插入2：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/build1.png" alt="二叉堆创建或插入"></p>
<p>首先把2放在完全二叉树的最后一个位置，即前面提到的空闲位置，如下图：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/build2.png" alt="二叉堆插入"></p>
<p>由于2比它的父节点5要小，如果插在这里，则不满足堆性质，因此，需要交换它和父节点的位置：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/build3.png" alt="二叉堆插入"></p>
<p>此时，发现2所在位置仍然比它的父节点要小，因此，还需要和它的父节点交换位置：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/build4.png" alt="二叉堆插入"></p>
<p>最终状态则满足堆得性质，即父节点总是小于等于它的子节点。</p>
<p>代码实现如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert_pq</span><span class="params">(ElementType value,PriorityQueue *pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*确保优先队列没有满*/</span></span><br><span class="line">    <span class="keyword">if</span>(pq_is_full(pq))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"priorityQueue is full\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"insert %d\n"</span>,value);</span><br><span class="line">    <span class="comment">/*不断和父节点探测比较，直到找到属于它的位置*/</span></span><br><span class="line">    <span class="keyword">for</span>(i = pq-&gt;size+<span class="number">1</span>;pq-&gt;eles[i/<span class="number">2</span>] &gt; value &amp;&amp; i &gt; <span class="number">1</span>;i/=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pq-&gt;eles[i] = pq-&gt;eles[i/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    pq-&gt;eles[i] = value;</span><br><span class="line">    pq-&gt;size++;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>建立N个元素的二叉堆的时间复杂度为O（N）。</p>
<h4 id="找到最小元素"><a href="#找到最小元素" class="headerlink" title="找到最小元素"></a>找到最小元素</h4><p>由于我们在插入的时候就保证了堆的性质，因此找到最小元素是非常容易的，因为它就是位于堆顶，因此代码实现如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int find_min(PriorityQueue *pq,ElementType *value)</span><br><span class="line">&#123;</span><br><span class="line">    if(pq_is_empty(pq))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;priorityQueue is empty\n&quot;);</span><br><span class="line">        return FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    /*0处的元素作为哨兵没有使用*/</span><br><span class="line">    *value = pq-&gt;eles[1];</span><br><span class="line">    return SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="删除最小元素"><a href="#删除最小元素" class="headerlink" title="删除最小元素"></a>删除最小元素</h2><p>删除与插入相反，删除的是堆顶元素，我们需要找到一个元素来替代堆顶的位置，以保证堆的性质不被破坏。因此进行如下的操作：</p>
<ul>
<li>删除堆顶元素，堆顶成为空穴</li>
<li>由于直接将最后的元素放入前面的空穴可能破坏堆性质，因此将较小的儿子插入空穴，该儿子的位置变成空穴，这样空穴就下滑了一层</li>
<li>重复上面的过程，空穴不能再下滑，将最后的元素放入该空穴</li>
</ul>
<p>还是以前面建立的二叉堆为例，假如要删除堆顶的2。则直接先把2删除，那么2的位置就有一个空穴。</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/delete1.png" alt="删除堆顶元素"></p>
<p>这个时候，我们将它的两个子节点中较小的一个，移动到堆顶位置：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/delete2.png" alt="删除堆顶元素"></p>
<p>最后继续将空穴位置处它的子节点较小的一个，移动到空穴位置：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/delete3.png" alt="删除堆顶元素"></p>
<p>最终删除了堆顶元素。</p>
<p>代码实现如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete_min</span><span class="params">(PriorityQueue *pq,ElementType *min)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> minChild =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(pq_is_empty(pq))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"priorityqueue is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*取得最小值*/</span></span><br><span class="line">    *min = pq-&gt;eles[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*暂时取出最后的元素*/</span></span><br><span class="line">    ElementType last = pq-&gt;eles[pq-&gt;size];</span><br><span class="line">    pq-&gt;size--;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == pq-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        pq-&gt;eles[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*不断将空穴下滑*/</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i * <span class="number">2</span> &lt;= pq-&gt;size;i = minChild)</span><br><span class="line">    &#123;</span><br><span class="line">        minChild = i * <span class="number">2</span>;</span><br><span class="line">        <span class="comment">/*找到更小的孩子*/</span></span><br><span class="line">        <span class="keyword">if</span>(minChild != pq-&gt;size &amp;&amp; pq-&gt;eles[minChild+<span class="number">1</span>] &lt; pq-&gt;eles[minChild])</span><br><span class="line">            minChild+=<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">/*如果最后一个元素比空穴处的小儿子大，则继续下滑空穴，将该孩子上滤*/</span></span><br><span class="line">        <span class="keyword">if</span>(last &gt;pq-&gt;eles[minChild])</span><br><span class="line">            pq-&gt;eles[i] = pq-&gt;eles[minChild];</span><br><span class="line">        <span class="comment">/*否则说明last放的位置不会破坏堆性质，则直接退出循环*/</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*将最后的元素放在空穴位置*/</span></span><br><span class="line">    pq-&gt;eles[i] = last;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>删除操作的平均时间复杂度为O(logN)</p>
<h2 id="完整代码运行结果"><a href="#完整代码运行结果" class="headerlink" title="完整代码运行结果"></a>完整代码运行结果</h2><p>完整代码见开头说明的地址，运行结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert 3</span><br><span class="line">insert 4</span><br><span class="line">insert 5</span><br><span class="line">insert 6</span><br><span class="line">insert 8</span><br><span class="line">insert 2</span><br><span class="line">priorityQueue is full</span><br><span class="line">priorityQueue is full</span><br><span class="line">the arr value is: 2 4 3 6 8 5</span><br><span class="line">pq size is 6</span><br><span class="line">the min is 2</span><br><span class="line">the min is 3</span><br><span class="line">the min is 4</span><br><span class="line">the min is 5</span><br><span class="line">the min is 6</span><br><span class="line">the min is 8</span><br><span class="line">destory pq success</span><br></pre></td></tr></table></figure></p>
<p>观察删除最小元素的结果，有没有发现什么呢？</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了优先队列最常见的实现方式-二叉堆实现，并且介绍了二叉堆地创建，插入和删除等基本操作。而典型的TOP k问题也非常适合使用堆来解决，本文不做介绍。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数据结构与算法</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>全局变量，静态全局变量，局部变量，静态局部变量</title>
    <url>/2019/05/08/43402.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这些是编程语言中的基本概念，如果你还不是非常明确地清楚标题的问题，并且不知道<strong>作用域，链接属性，存储期</strong>等概念的具体含义，那么本文你不该错过。为了更加清晰的理解我们的问题，需要先了解三个概念：作用域，链接属性，存储期。当然需要注意的是，本文说明的是这些名称在C语言中的含义。<br><a id="more"></a></p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>C语言中，作用域用来描述标识符能够被哪些区域访问。</p>
<p>而常见作用域有以下几种：</p>
<ul>
<li>块作用域，可见范围是从定义处到包含该定义的块结尾</li>
<li>函数作用域，goto语句的标签就具有函数作用域</li>
<li>文件作用域，从定义处到定义该文件的末尾都可见。定义在函数之外的变量，就具有文件作用域了。</li>
<li>函数原型作用域，从形参定义处到原型声明结束</li>
</ul>
<p>为了便于说明，我们来看一个例子，就很容易理解了：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/****************************</span></span><br><span class="line"><span class="comment">作者：守望先生</span></span><br><span class="line"><span class="comment">来源：公众号编程珠玑</span></span><br><span class="line"><span class="comment">个人博客：https://www.yanbinghu.com</span></span><br><span class="line"><span class="comment">***************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">222</span>;         <span class="comment">//定位在函数外，具有文件作用域</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num2 = <span class="number">111</span>;  <span class="comment">//定义在函数外，具有文件作用域</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span>; <span class="comment">//这里的a，b是函数原型作用域</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>== a || <span class="literal">NULL</span> == b)</span><br><span class="line">        <span class="keyword">goto</span> error;    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = *a;  <span class="comment">//定义在函数内，块作用域</span></span><br><span class="line">        *a = *b;</span><br><span class="line">        *b = temp;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf("temp is %d\n",temp);   //因为temp具有块作用域，因此在这里不能直接使用</span></span><br><span class="line">    error:<span class="comment">//goto语句的标签，函数作用域,因此在前面就可以引用</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"input para is NULL\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"num1=%d,num2=%d\n"</span>,num1,num2);</span><br><span class="line">    swap(&amp;num1,&amp;num2);  <span class="comment">//num1 num2具有文件作用域，可以在main函数中直接使用</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"num1=%d,num2=%d"</span>,num1,num2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，error标签具有函数作用域，整个函数内都可见，而temp具有块作用域，因此在大括号外部，不能直接使用它。而num1和num2具有文件作用域，因此main函数可以直接使用它。</p>
<h2 id="链接属性"><a href="#链接属性" class="headerlink" title="链接属性"></a>链接属性</h2><p>在《<a href="https://www.yanbinghu.com/2018/10/10/27133.html">hello程序是如何变成可执行文件的</a>》我们说到了编译的过程，最后一个步骤就是链接。<strong>链接属性决定了在不同作用域的同名标识符能否绑定到同一个对象或者函数</strong>。或者说，不同作用域的标识符在编译后是否是同一个实体。</p>
<p>c变量有三种链接属性：</p>
<ul>
<li>外部链接，extern修饰的，或者没有static修饰的具有文件作用域的变量具有外部链接属性</li>
<li>内部链接，static修饰的具有文件作用域的变量具有内部链接属性</li>
<li>无链接，块作用域，函数作用域和函数原型作用域的变量无链接属性</li>
</ul>
<p>再稍作解释，没有static修饰，且具有文件作用域的变量，他们在链接时，多个同名标识符的变量最终都绑定到同一个实体。而static修饰的具有文件作用域的变量就不一样了，不同文件内，即便标识符名字相同，它们也绑定到了不同的实体。</p>
<p>因此，如果我们希望某个变量或函数只在某一个文件使用，那么使用static修饰是一个很好的做法。</p>
<p>同样的，来看一个例子。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/****************************</span><br><span class="line">作者：守望先生</span><br><span class="line">来源：公众号编程珠玑</span><br><span class="line">个人博客：https://www.yanbinghu.com</span><br><span class="line">***************************************/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int a = 5;   //文件作用域，外部链接属性，其他文件可通过extern int a的方式使用该文件的a</span><br><span class="line">static b = 6;  //文件作用域，内部链接属性，即便其他文件也有同名标识符，它们也是不同的</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int sum = 0 ; //无链接属性</span><br><span class="line">    sum = a + b;</span><br><span class="line">    printf(&quot;sum is %d\n&quot;,sum);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码中可以看到，a和b都具有文件作用域，a具有外部链接属性，而b具有内部链接属性，sum具有块作用域，因此无链接属性。</p>
<h2 id="存储期"><a href="#存储期" class="headerlink" title="存储期"></a>存储期</h2><p>实际上作用域和链接属性都描述了标识符的可见性，而存储期则描述了这些标识符对应的对象的生存期。存储期，也分下面几种：</p>
<ul>
<li>静态存储期，程序执行期间一直都在，文件作用域的变量具有静态存储期</li>
<li>自动存储期，它（变长数组除外）从块开始，到块末尾，因此，块作用域的变量具有自动存储期，它在栈中存储，需要显式初始化。</li>
<li>动态分配存储期，即通过malloc分配内存的变量。它在堆中存储，需要显式初始。</li>
<li>线程存储期，从名字可以知道， 它与线程相关，使用关键字_Thread_local声明的变量具有线程存储期，它从声明到线程结束一直存在。</li>
</ul>
<p>关于初始化，可参考《<a href="https://www.yanbinghu.com/2018/11/13/9002.html">C语言入坑指南-被遗忘的初始化</a>》。<br>同样地，我们通过下面的代码来更好地理解存储期：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/****************************</span><br><span class="line">作者：守望先生</span><br><span class="line">来源：公众号编程珠玑</span><br><span class="line">个人博客：https://www.yanbinghu.com</span><br><span class="line">***************************************/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int num1 = 222;         //静态存储期</span><br><span class="line">static int num2 = 111;  //静态存储期</span><br><span class="line">int add(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    static int tempSum = 0;  //静态存储期</span><br><span class="line">    tempSum = tempSum + a + b;</span><br><span class="line">    return tempSum;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;num1=%d,num2=%d\n&quot;,num1,num2);</span><br><span class="line">    int sum = 0;  //自动存储期</span><br><span class="line">    sum = add(num1,num2);</span><br><span class="line">    printf(&quot;first time sum=%d\n&quot;,sum);//sum = 333</span><br><span class="line">    sum = add(num1,num2);</span><br><span class="line">    printf(&quot;second time sum=%d\n&quot;,sum); //sum = 666</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，如果我们通过nm命令查看编译出来的程序文件的符号表，我们可以找到num1，num2，tempSum，而没有sum，前者所用的内存数量在编译时就确定了。关于nm命令的使用可以参考《<a href="https://www.yanbinghu.com/2018/09/26/61877.html">linux常用命令-开发调试篇</a>》。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -g -o lifetime lifetime.c </span><br><span class="line">$ nm lifetime|grep num1</span><br><span class="line">0000000000601038 D num1</span><br><span class="line">$ nm lifetime|grep num2</span><br><span class="line">000000000060103c d num2</span><br><span class="line">$ nm lifetime|grep tempSum</span><br><span class="line">0000000000601044 b tempSum.2289</span><br><span class="line">$ nm lifetime|grep sum</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<h2 id="什么全局变量，局部变量，静态局部变量，静态全局变量"><a href="#什么全局变量，局部变量，静态局部变量，静态全局变量" class="headerlink" title="什么全局变量，局部变量，静态局部变量，静态全局变量"></a>什么全局变量，局部变量，静态局部变量，静态全局变量</h2><p>到这里，我们就可以很容易区分上面的变量类型了。实际上这里只是换了一种说法：<br>全局：具有文件作用域的变量<br>静态：具有静态存储期或内部链接属性<br>局部：具有函数或块作用域的变量</p>
<p>因而结合起来，也就很好理解了。</p>
<ul>
<li>局部变量：函数或块作用域的变量</li>
<li>静态局部变量：函数或块作用域,静态存储期</li>
<li>全局变量：具有文件作用域的变量</li>
<li>静态全局变量：内部链接属性的，具有文件作用域的变量</li>
</ul>
<p>当然，这仅仅是为了区分它们，这并不是它们的严格定义。更好的方法，是通过代码来理解：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int num1 = 222;         //全局变量</span><br><span class="line">static int num2 = 111;  //静态全局变量</span><br><span class="line">int add(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    static int tempSum = 0;  //静态局部变量</span><br><span class="line">    tempSum = tempSum + a + b;</span><br><span class="line">    return tempSum;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;num1=%d,num2=%d\n&quot;,num1,num2);</span><br><span class="line">    int sum = 0;  //局部变量</span><br><span class="line">    sum = add(num1,num2);</span><br><span class="line">    printf(&quot;first time sum=%d\n&quot;,sum);//sum = 333</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文总结如下：</p>
<ul>
<li>具有文件作用域的变量具有静态存储期，并且具有链接属性</li>
<li>不希望其他文件访问的文件作用域变量最好使用static修饰</li>
<li>static关键字的含义需要结合上下文来理解</li>
<li>如果可以，全局变量应该尽量避免使用，因为它可能带来变量被意外修改</li>
<li>使用动态内存通常比栈内存慢，但是栈内存很有限</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://en.wikipedia.org/wiki/Global_variables" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Global_variables</a></p>
<p><a href="https://en.wikipedia.org/wiki/Local_variable" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Local_variable</a></p>
<p>《C11标准文档》</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>lua简明教程</title>
    <url>/2019/05/07/16354.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>lua是一种轻量小巧的脚本语言。</p>
<h3 id="lua特性"><a href="#lua特性" class="headerlink" title="lua特性"></a>lua特性</h3><p>1.轻量级，编译后不过200K<br>2.可扩展性<br>3.自动内存管理<br>4.支持面向过程编程和函数式编程<br>……</p>
<a id="more"></a>
<h3 id="lua应用场景"><a href="#lua应用场景" class="headerlink" title="lua应用场景"></a>lua应用场景</h3><p>1.游戏开发<br>2.独立应用脚本<br>3.web应用脚本<br>4.扩展和数据库插件<br>5.安全系统</p>
<h2 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h2><h3 id="安装问题"><a href="#安装问题" class="headerlink" title="安装问题"></a>安装问题</h3><p>1.编译lua时，提示<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lua.c:80:31: fatal error: readline/readline.h: No such file or directory</span><br></pre></td></tr></table></figure></p>
<p>linux环境缺少readline库。<br>到ftp://ftp.gnu.org/gnu/readline/  下载并进行安装</p>
<p>2.安装完readline后提示<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/local/lib/libreadline.so: undefined reference to `tputs&apos;</span><br><span class="line">/usr/local/lib/libreadline.so: undefined reference to `tgoto&apos;</span><br><span class="line">/usr/local/lib/libreadline.so: undefined reference to `tgetflag&apos;</span><br><span class="line">/usr/local/lib/libreadline.so: undefined reference to `UP&apos;</span><br><span class="line">/usr/local/lib/libreadline.so: undefined reference to `tgetent&apos;</span><br><span class="line">/usr/local/lib/libreadline.so: undefined reference to `tgetnum&apos;</span><br><span class="line">/usr/local/lib/libreadline.so: undefined reference to `PC&apos;</span><br><span class="line">/usr/local/lib/libreadline.so: undefined reference to `tgetstr&apos;</span><br><span class="line">/usr/local/lib/libreadline.so: undefined reference to `BC&apos;</span><br></pre></td></tr></table></figure></p>
<p>需要安装Ncurses</p>
<p>3.编译Ncurses提示 error: expected ‘)’ before ‘int’</p>
<p>导入环境变量,在进行配置编译,安装,命令如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export CPPFLAGS=&quot;-P&quot;</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">Ncurses</span><br></pre></td></tr></table></figure></p>
<p>参考:<br><a href="https://stackoverflow.com/questions/37475222/ncurses-6-0-compilation-error-error-expected-before-int" target="_blank" rel="noopener">https://stackoverflow.com/questions/37475222/ncurses-6-0-compilation-error-error-expected-before-int</a></p>
<p>总结:安装成功安装lua的前提是linux上有readline和ncurses库.</p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>和Python类似，它也可以交互式编程，在命令行输入lua后即可进入：<br><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">print</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">Hello World</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
<p>当然也可以将脚本内容写在文件，例如，将上面的内容写在hello.lua：<br><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">#!/usr/<span class="keyword">local</span>/bin/lua</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Hello World"</span>)</span><br></pre></td></tr></table></figure></p>
<p>其中第一行指定了lua解释器路径，执行：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod +x hello.lua  <span class="comment">#赋予执行权限</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./hello.lua</span></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure></p>
<p>这里注意，如果你没有加第一行，shell就不知道用哪个解释器去解释运行，当然你也可以通过下面的方式运行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ lua hello.lua</span><br></pre></td></tr></table></figure></p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>同样地，它至少有两种注释，单行注释使用—：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 这里是单行注释</span><br><span class="line">print(&quot;hello&quot;)</span><br></pre></td></tr></table></figure></p>
<p>多行注释：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--[[</span><br><span class="line">多行注释</span><br><span class="line">多行注释</span><br><span class="line">--]]</span><br><span class="line">print(&quot;yanbinghu.com&quot;)</span><br></pre></td></tr></table></figure></p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>nil—表示无效值</li>
<li>boolean false和true,lua将nil看成是”假”</li>
<li>number 双精度类型的实浮点数</li>
<li>string 字符串</li>
<li>function 由c或lua编写的函数</li>
<li>userdata 表示任意存储在变量中的c数据结构</li>
<li>thread 表示执行的独立线路,用于执行协同程序</li>
<li>table lua中的表,类似于关联数组</li>
</ul>
<h4 id="判断类型"><a href="#判断类型" class="headerlink" title="判断类型"></a>判断类型</h4><p>可以通过type函数来判断数据类型<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(type(“hello”) ) --string</span><br><span class="line">print(type(type)) --function</span><br></pre></td></tr></table></figure></p>
<h4 id="字符串算数操作"><a href="#字符串算数操作" class="headerlink" title="字符串算数操作"></a>字符串算数操作</h4><p>在对一个数字字符串上进行算术操作时，Lua 会尝试将这个数字字符串转成一个数字:<br>例如:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;print(“2” + “6”)</span><br><span class="line">8</span><br></pre></td></tr></table></figure></p>
<ul>
<li>字符串连接 ..</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;print(“a”..”b”)</span><br><span class="line">ab</span><br></pre></td></tr></table></figure>
<ul>
<li>计算字符串长度 #</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;print(#“a”)</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h4 id="table"><a href="#table" class="headerlink" title="table"></a>table</h4><p>Lua 里表的默认初始索引一般以 1 开始</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li><p>默认情况下,变量总认为是全局的.<br>全局变量不需要声明,访问未初始化的全局变量不会报错,得到的结果是 nil</p>
</li>
<li><p>想删除一个全局变量,只需要将变量赋值为nil<br>当且仅当该变量不为nil时,变量存在</p>
</li>
<li><p>a =1 —&gt;全局变量</p>
</li>
<li><p>local b =2 —&gt;局部变量</p>
</li>
<li><p>Lua可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量。</p>
</li>
</ul>
<h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>]]></content>
      <categories>
        <category>lua</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell必备基础知识</title>
    <url>/2019/05/07/53959.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在linux下使用shell编程常常能够极大简化我们的工作。本文总结了Shell编程必备的基础知识。<br><a id="more"></a></p>
<h2 id="入参和默认变量"><a href="#入参和默认变量" class="headerlink" title="入参和默认变量"></a>入参和默认变量</h2><p>对于shell脚本而言，有些内容是专门用于处理参数的，它们都有特定的含义，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/home/shouwang/test.sh para1 para2 para3</span><br><span class="line">$0                      $1    $2    $3</span><br><span class="line">脚本名              第一个参数      第三个参数</span><br></pre></td></tr></table></figure></p>
<p>除此之外，还有一些其他的默认变量，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$#  代表脚本后面跟的参数个数，前面的例子中有3个参数</span><br><span class="line">$@  代表了所有参数，并且可以被遍历</span><br><span class="line">$*  代表了所有参数，且作为整体，和$*很像，但是有区别</span><br><span class="line">$$  代表了当前脚本的进程ID</span><br><span class="line">$?  代表了上一条命令的退出状态</span><br></pre></td></tr></table></figure>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>给变量赋值，使用等号即可，但是<strong>等号两边千万不要有空格</strong>，等号右边有空格的字符串也必须用引号引起来：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">para1=<span class="string">"hello world"</span>  <span class="comment">#字符串直接赋给变量para1</span></span><br></pre></td></tr></table></figure>
<p>unset用于取消变量。例如：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unset</span> para1</span><br></pre></td></tr></table></figure></p>
<p>如何使用变量呢？使用变量时，需要在变量前加$，例如要打印前面para1的内容：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"para1 is <span class="variable">$para1</span>"</span></span><br><span class="line"><span class="comment">#将会输出 para1 is hello world</span></span><br></pre></td></tr></table></figure>
<p>或者变量名两边添加大括号：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"para1 is <span class="variable">$&#123;para1&#125;</span>!"</span></span><br><span class="line"><span class="comment">#将会输出 para1 is hello world!</span></span><br></pre></td></tr></table></figure></p>
<h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>在shell中执行命令通常只需要像在终端一样执行命令即可，不过，如果想要命令结果打印出来的时候，这样的方式就行不通了。因此，shell的命令方式常有：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">a=`ls`   <span class="comment">#`是左上角～键，不是单引号</span></span><br></pre></td></tr></table></figure></p>
<p>或者使用$，后面括号内是执行的命令：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"current path is <span class="variable">$(pwd)</span>"</span>   <span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>另外，前面两种方式对于计算表达式也是行不通的，而要采取下面的方式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;1+1=$((1+1))&quot;  #打印：1+1=2</span><br></pre></td></tr></table></figure></p>
<p>即$后面用<strong>两重括号将要计算的表达式包裹起来</strong>。</p>
<p>那如果要执行的命令存储在变量中呢？前面的方法都不可行了，当然括号内的内容被当成命令执行还是成立的。要使用下面的方式，例如：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">a=<span class="string">"ls"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$($a)</span>"</span></span><br></pre></td></tr></table></figure></p>
<p>但是如果字符串时多条命令的时候，上面的方式又不可行了，而要采用下面的方式：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">a=<span class="string">"ls;pwd"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$(eval $a)</span>"</span></span><br></pre></td></tr></table></figure></p>
<p>这是使用了eval，将a的内容都作为命令来执行。</p>
<h2 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h2><p>一般说明，如果命令执行成功，则其返回值为0，否则为非0，因此，可以通过下面的方式判断上条命令的执行结果：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ $? -eq 0 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"success"</span></span><br><span class="line"><span class="keyword">elif</span> [ $? -eq 1 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"failed,code is 1"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"other code"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p>
<p>case语句使用方法如下：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">name=<span class="string">"aa"</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$name</span> <span class="keyword">in</span></span><br><span class="line">    <span class="string">"aa"</span>)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"name is <span class="variable">$name</span>"</span></span><br><span class="line">    ;;</span><br><span class="line">    <span class="string">""</span>)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"name is empty"</span></span><br><span class="line">    ;;</span><br><span class="line">    <span class="string">"bb"</span>)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"name is <span class="variable">$name</span>"</span></span><br><span class="line">    ;;</span><br><span class="line">    *)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"other name"</span></span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure></p>
<p>初学者特别需要注意以下几点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ []前面要有空格，它里面是逻辑表达式</span><br><span class="line">+ if elif后面要跟then，然后才是要执行的语句</span><br><span class="line">+ 如果想打印上一条命令的执行结果，最好的做法是将$?赋给一个变量，因为一旦执行了一条命令$?的值就可能会变。</span><br><span class="line">+ case每个分支最后以两个分号结尾，最后是case反过来写，即esac。</span><br></pre></td></tr></table></figure>
<p>多个条件如何使用呢，两种方式，方式一：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 10 -gt 5 -o 10 -gt 4 ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"10&gt;5 or 10 &gt;4"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p>
<p>方式二：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 10 -gt 5 ] || [ 10 -gt 4 ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"10&gt;5 or 10 &gt;4"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p>
<p>其中-o或者||表示或。这里也有一些常见的条件判定。</p>
<p>总结如下：</p>
<ul>
<li>-o or 或者，同||</li>
<li>-a and 与，同&amp;&amp;</li>
<li>! 非</li>
</ul>
<p>整数判断：</p>
<ul>
<li>-eq 两数是否相等</li>
<li>-ne 两数是否不等</li>
<li>-gt 前者是否大于后者（greater then）</li>
<li>-lt 前面是否小于后者（less than）</li>
<li>-ge 前者是否大于等于后者（greater then or equal）</li>
<li>-le 前者是否小于等于后者（less than or equal）</li>
</ul>
<p>字符串判断str1 exp str2：</p>
<ul>
<li>-z “$str1”  str1是否为空字符串</li>
<li>-n “$str1”  str1是否不是空字符串</li>
<li>“$str1” == “$str2”  str1是否与str2相等</li>
<li>“$str1” != “$str2”  str1是否与str2不等</li>
<li>“$str1” =~ “str2”   str1是否包含str2</li>
</ul>
<p>特别注意，<strong>字符串变量最好用引号引起来</strong>，因为一旦字符串中有空格，这个表达式就错了，有兴趣的可以尝试当str1=”hello world”，而str2=”hello”的时候进行比较。</p>
<p>文件目录判断：filename</p>
<ul>
<li>-f $filename 是否为文件</li>
<li>-e $filename 是否存在</li>
<li>-d $filename 是否为目录</li>
<li>-s $filename 文件存在且不为空</li>
<li>! -s $filename 文件是否为空</li>
</ul>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>循环形式一，和Python的for in很像：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#遍历输出脚本的参数</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$@</span>; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>循环形式二，和C语言风格很像：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ((i = 0 ; i &lt; 10 ; i++)); <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>循环打印0到9。</p>
<p>循环形式三：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125;; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Welcome <span class="variable">$i</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>循环打印1到5。</p>
<p>循环方式四：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> [ <span class="string">"<span class="variable">$ans</span>"</span> != <span class="string">"yes"</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">read</span> -p <span class="string">"please input yes to exit loop:"</span> ans</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>只有当输入yes时，循环才会退出。即条件满足时，就进行循环。</p>
<p>循环方式五：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ans=yes</span><br><span class="line">until [ <span class="variable">$ans</span> != <span class="string">"yes"</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">read</span> -p <span class="string">"please input yes to exit loop:"</span> ans</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>这里表示，只有当ans不是yes时，循环就终止。</p>
<p>循环方式六：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;5..15..3&#125;; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"number is <span class="variable">$i</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>每隔5打印一次，即打印5,8,11,14。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>定义函数方式如下：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">myfunc() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"hello world <span class="variable">$1</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myfunc() </span><br><span class="line">&#123;</span><br><span class="line">    echo &quot;hello world $1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数调用：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">para1=<span class="string">"shouwang"</span></span><br><span class="line">myfunc <span class="variable">$para1</span></span><br></pre></td></tr></table></figure></p>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>通常函数的return返回值只支持0-255，因此想要获得返回值，可以通过下面的方式。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">myfunc</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> myresult=<span class="string">'some value'</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$myresult</span></span><br><span class="line">&#125;</span><br><span class="line">val=$(myfunc)  <span class="comment">#val的值为some value</span></span><br></pre></td></tr></table></figure></p>
<p>通过return的方式<strong>适用于判断函数的执行是否成功</strong>：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">myfunc</span></span>() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#do something</span></span><br><span class="line">    <span class="built_in">return</span> 0</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> myfunc;<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"success"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"failed"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>shell通过#来注释一行内容，前面我们已经看到过了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># 这是一行注释</span><br><span class="line">:&apos;</span><br><span class="line">这是</span><br><span class="line">多行</span><br><span class="line">注释</span><br><span class="line">&apos;</span><br><span class="line">ls</span><br><span class="line"></span><br><span class="line">:&lt;&lt;EOF</span><br><span class="line">这也可以</span><br><span class="line">达到</span><br><span class="line">多行注释</span><br><span class="line">的目的</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p>
<h2 id="日志保存"><a href="#日志保存" class="headerlink" title="日志保存"></a>日志保存</h2><p>脚本执行后免不了要记录日志，最常用的方法就是重定向。以下面的脚本为例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#test.sh</span><br><span class="line">lll  #这个命令是没有的，因此会报错</span><br><span class="line">date</span><br></pre></td></tr></table></figure></p>
<p>方式一，将标准输出保存到文件中，打印标准错误：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./test.sh &gt; log.dat</span><br></pre></td></tr></table></figure></p>
<p>这种情况下，如果命令执行出错，错误将会打印到控制台。所以如果你在程序中调用，这样将不会讲错误信息保存在日志中。</p>
<p>方式二，标准输出和标准错误都保存到日志文件中：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./test.sh &gt; log.dat 2&gt;&amp;1</span><br></pre></td></tr></table></figure></p>
<p>2&gt;&amp;1的含义可以参考《<a href="https://www.yanbinghu.com/2018/10/26/9186.html">如何理解linuxshell中的2&gt;&amp;1</a>》</p>
<p>方式三，保存日志文件的同时，也输出到控制台：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./test.sh |tee log.dat</span><br></pre></td></tr></table></figure></p>
<h2 id="脚本执行"><a href="#脚本执行" class="headerlink" title="脚本执行"></a>脚本执行</h2><p>最常见的执行方式前面已经看到了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./test.sh</span><br></pre></td></tr></table></figure></p>
<p>其它执行方式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh test.sh  #在子进程中执行</span><br><span class="line">sh -x test.sh #会在终端打印执行到命令，适合调试</span><br><span class="line">source test.sh #test.sh在父进程中执行</span><br><span class="line">. test.sh   #不需要赋予执行权限，临时执行</span><br></pre></td></tr></table></figure></p>
<h2 id="脚本退出码"><a href="#脚本退出码" class="headerlink" title="脚本退出码"></a>脚本退出码</h2><p>很多时候我们需要获取脚本的执行结果，即退出状态，通常0表示执行成功，而非0表示失败。为了获得退出码，我们需要使用exit。例如：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> myfun()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$#</span> -lt 2 ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">       <span class="built_in">echo</span> <span class="string">"para num error"</span></span><br><span class="line">       <span class="built_in">exit</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"ok"</span></span><br><span class="line">    <span class="built_in">exit</span> 2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -lt 1 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"para num error"</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">returnVal=`myfun aa`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"end shell"</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure></p>
<p>这里需要特别注意的一点是，使用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">returnVal=`myfun aa`</span><br></pre></td></tr></table></figure></p>
<p>这样的句子执行函数，即便函数里面有exit，它也不会退出脚本执行，而只是会退出该函数，这是因为<strong>exit是退出当前进程</strong>，而这种方式执行函数，相当于fork了一个子进程，因此不会退出当前脚本。最终结果就会看到，无论你的函数参数是什么最后end shell都会打印。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./test.sh;echo $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p>
<p>这里的0就是脚本的执行结果。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是shell编程最基本也是最关键的内容。当然这并非全部，例如数组，字典,参数处理等都没有详细介绍，由于篇幅有限，将会在后面的文章中进行详细介绍。</p>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是散列表（哈希表）</title>
    <url>/2019/05/04/61373.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>假设你们班级100个同学每个人的学号是由院系-年级-班级和编号组成，例如学号为01100168表示是1系，10级1班的68号。为了快速查找到68号的成绩信息，可以建立一张表，但是不能用学号作为下标，学号的数值实在太大。因此将学号除以1100100取余，即得到编号作为该表的下标，那么，要查找学号为01100168的成绩的时候，只要直接访问表下标为68的数据即可。这就能够在O（1）时间复杂度内完成成绩查找。</p>
<p>实际上这里就用到了散列的思想。本文将会散列表进行简单介绍。<br><a id="more"></a></p>
<h2 id="散列表（哈希表）"><a href="#散列表（哈希表）" class="headerlink" title="散列表（哈希表）"></a>散列表（哈希表）</h2><p>理想散列表（哈希表）是一个包含关键字的具有固定大小的数组，它能够<strong>以常数时间执行插入，删除和查找操作</strong>。</p>
<ul>
<li>每个关键字被映射到0到数组大小N-1范围，并且放到合适的位置，这个<strong>映射规则就叫散列函数</strong></li>
<li>理想情况下，两个不同的关键字映射到不同的单元，然而由于数组单元有限，关键字范围可能远超数组单元，因此就会出现两个关键字散列到同一个值得时候，这就是<strong>散列冲突</strong></li>
</ul>
<h2 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h2><p>通过前面的描述，我们已经了解了一些基本概念，现在来看一个实例。<br>假设有一个大小为7的表，现在，要将13,18,19，50，20散列到表中。</p>
<ul>
<li>选择散列函数，例如使用hash(x)=x%7作为散列函数</li>
<li>计算数据散列值，并放到合适的位置</li>
</ul>
<p>计算13 % 7得到6，因此将13放到下标为6的位置：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>13</td>
</tr>
</tbody>
</table>
</div>
<p>计算18 % 7得到4，因此将18放到下标为4的位置：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>18</td>
<td></td>
<td>13</td>
</tr>
</tbody>
</table>
</div>
<p>计算19 % 7得到5，因此将19放到下标为5的位置：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>18</td>
<td>19</td>
<td>13</td>
</tr>
</tbody>
</table>
</div>
<p>计算50 % 7得到1，因此将50放到下标为1的位置：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>50</td>
<td></td>
<td></td>
<td>18</td>
<td>19</td>
<td>13</td>
</tr>
</tbody>
</table>
</div>
<p>计算20 % 7得到6，因此将20放到下标为6的位置，但是此时6的位置已经被占用了，因此就产生了<strong>散列冲突</strong>，关于散列冲突的解决，我们后面再介绍。</p>
<p>将数据散列之后，如何从表中查找呢？例如，查找数值为50的数据位置，只需要计算50 % 7，得到下标1，访问下标1的位置即可。但是如果考虑散列冲突，就没有那么简单了。</p>
<p>通过这个实例，了解了以下几个概念：</p>
<ul>
<li>散列函数，散列函数的选择非常重要</li>
<li>散列冲突，涉及散列表时，因尽量避免散列冲突，对于冲突也要有好的解决方案</li>
<li>快速从散列表中查找数据</li>
</ul>
<h2 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h2><p>解决散列冲突通常有以下几种方法：</p>
<ul>
<li>拉链法</li>
<li>开放定址法</li>
<li>再散列</li>
<li>…</li>
</ul>
<h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h4><p><strong>分离链接法的做法是将同一个值的关键字保存在同一个表中</strong>。例如，对于前面：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>50</td>
<td></td>
<td></td>
<td>18</td>
<td>19</td>
<td>13</td>
</tr>
</tbody>
</table>
</div>
<p>如果再要插入元素20，则在下标为6的位置存储表头，而表的内容是13和20。</p>
<p>这种方法的特点是需要另外分配新的单元来存储散列到同一个位置的数据。</p>
<p>查找的时候，除了根据计算出来的散列值找到对应位置外，还需要在链表上进行搜索。而在单链表上的查找速度是很慢的。因此可以考虑其他搜索速度较快的数据结构，就可以大大提高搜索速度。另外散列函数如果设计得好，冲突的概率其实也会很小。</p>
<h4 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h4><p>而开放定址法的思想是，<strong>如果冲突发生，就选择另外一个可用的位置</strong>。</p>
<p>而开放定址法中也有常见的几种策略。</p>
<ul>
<li>线性探测法</li>
</ul>
<p>还是以前面的为例：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>50</td>
<td></td>
<td></td>
<td>18</td>
<td>19</td>
<td>13</td>
</tr>
</tbody>
</table>
</div>
<p>如果此时再要插入20，则20 % 7 = 6，但是6的位置已有元素，因此探测下一个位置（6+1）%7，在这里就是下标为0的位置。因此20的存储位置如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td><font color="red">20</font></td>
<td>50</td>
<td></td>
<td></td>
<td>18</td>
<td>19</td>
<td>13</td>
</tr>
</tbody>
</table>
</div>
<p>但这种方式的一个问题是，可能造成<strong>一次聚集</strong>，因为一旦冲突发生，为了处理冲突就会占用下一个位置，而如果冲突较多时，就会出现数据都<strong>聚集在一块区域</strong>。这样就会导致任何关键字都需要多次尝试才可能解决冲突。</p>
<ul>
<li>平方探测法</li>
</ul>
<p>顾名思义，如果说前面的探测函数是F（i）= i % 7，那么平方探测法就是F（i）= (i^2 )% 7。<br>但是这也同样会产生<strong>二次聚集</strong>问题。</p>
<ul>
<li>双散列</li>
</ul>
<p>为了<strong>避免聚集</strong>，在探测时选择跳跃式的探测，即再使用一个散列函数，用来计算探测的位置。假设前面的散列函数为hash1(X)，用于探测的散列函数为hash2(X)，那么一种流行的选择是F(i) = i * hash2(X)，即第一次冲突时探测hash1(X)+hash2(X)的位置，第二次探测<br>hash1(X)+2hash2(X)的位置。</p>
<p>可以看到，无论是哪种开放定址法，它都要求表足够大。</p>
<h4 id="再散列"><a href="#再散列" class="headerlink" title="再散列"></a>再散列</h4><p>我们前面也说到，散列表可以认为是具有固定大小的数组，那么如果插入新的数据时散列表已满，或者散列表所剩容量不多该怎么办？这个时候就需要再散列，常见做法是，建立一个是原来两倍大小的散列表，将原来表中的关键字重新散列到新表中。</p>
<h2 id="散列表的应用"><a href="#散列表的应用" class="headerlink" title="散列表的应用"></a>散列表的应用</h2><p>散列表应用很广泛。例如做文件校验或数字签名。当然还有快速查询功能的实现。例如，redis中的字典结构就使用了散列表，使用<strong>MurmurHash算法</strong>来计算字符串的hash值，并采用<strong>拉链法</strong>处理冲突，当散列表的<strong>装载因子</strong>（关键字个数与散列表大小的比）接近某个大小时，进行<strong>再散列</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个设计良好的散列表能够几乎在O（1）时间复杂度内完成插入，删除和查找，但前提是<strong>散列函数设计得足够优雅，以及有着合适散列冲突解决方案</strong>。常见冲突解决方案有：</p>
<ul>
<li>拉链法</li>
<li>开放地址检测法</li>
</ul>
<p>其中拉链法在实际中是很常见的一种解决方案。另外本文重点说明什么是散列表（哈希表），因此没有涉及具体的代码，后面将会通过实例来看散列表的实际应用。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《数据结构与算法分析》<br><a href="https://en.wikipedia.org/wiki/Hash_table" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Hash_table</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>《深入理解计算机系统》摘要</title>
    <url>/2019/05/01/5629.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>《深入理解计算机系统》值得每位程序员一读，看完之后将会对整个计算机体系有一个直观的认识。<br><a id="more"></a></p>
<h2 id="第一章计算机系统漫游"><a href="#第一章计算机系统漫游" class="headerlink" title="第一章计算机系统漫游"></a>第一章计算机系统漫游</h2><ul>
<li>只有ascii字符构成的文件称为文本文件，所有其它文件都称为二进制文件。</li>
<li>c语言是古怪的，有缺陷的，但同时也是一个巨大的成功，为什么会成功呢</li>
</ul>
<ul>
<li>c语言与unix操作系统关系密切</li>
<li>c语言小而简单</li>
<li>c语言是为实践目的设计的</li>
</ul>
<p>有一些重要的原因促使程序员必须知道编译系统是如何工作的</p>
<ul>
<li>优化程序性能</li>
<li>理解链接时出现的错误</li>
<li><p>避免安全漏洞</p>
</li>
<li><p>shell是一个命令行解释器，它提出一个提示符，等待输入一个命令行，然后执行这个命令。如果该命令行的第一个单词不是一个内置的shell命令，那么shell就会假设这是一个可执行文件的名字，它将加载并运行这个文件。</p>
</li>
<li><p>贯穿整个系统的是一组电子管道，称作总线。</p>
</li>
<li><p>io设备是系统与外部世界的联系通道。</p>
</li>
<li><p>主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。<br>处理器，是解释或执行存储在主存中指令的引擎。</p>
</li>
<li><p>利用直接存储器存取，数据可以不通过处理器而直接从磁盘到达主存。</p>
</li>
</ul>
<ul>
<li>通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成</li>
</ul>
<ul>
<li><p>每个计算机系统中的存储设备都被组织成了一个存储器层次结构。</p>
</li>
<li><p>操作系统有两个基本功能<br>防止硬件被失控的应用程序滥用，向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。操作系统通过基本的抽象概念(进程，虚拟内存和文件)来实现这两个功能。</p>
</li>
</ul>
<ul>
<li>文件是对i/o设备的抽象表示，虚拟内存是对主存和磁盘i/o设备的抽象表示，进程则是对处理器，主存和i/o设备的抽象表示。</li>
</ul>
<ul>
<li><p>进程是对操作系统对一个正在运行的程序的一种抽象。</p>
</li>
<li><p>进程并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的。操作系统实现这种交错执行的机制称为上下文切换。</p>
</li>
<li><p>操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文。</p>
</li>
<li><p>当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文，恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。</p>
</li>
<li><p>虽然我们对系统的一个主要部分做出了重大改进，但是获得的系统加速却明显小于这部分的加速比。这就是amdahl定律的主要观点——想要显著加速整个系统。必须提升全系统中相当大的部分的速度。</p>
</li>
</ul>
<h2 id="第二章信息的表示处理"><a href="#第二章信息的表示处理" class="headerlink" title="第二章信息的表示处理"></a>第二章信息的表示处理</h2><ul>
<li><p>每台计算机都有一个字长，指明指针数据的标称大小。因为虚拟地址是以这样的一个字来编码的。所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。</p>
</li>
<li><p>32位字长限制虚拟地址空间为4GB</p>
</li>
</ul>
<ul>
<li><p>最低有效字节在最前面的方式，称为小端法，最高有效字节在最前面的方式，称为大端法。</p>
</li>
<li><p>逻辑右移是在左端补k个0，而算术右移是在左端补k个最高有效位的值</p>
</li>
<li><p>java中，正常的右移运算符&gt;&gt;被定义为执行算术右移，特别的运算符&gt;&gt;&gt;被指定为执行逻辑右移</p>
</li>
</ul>
<ul>
<li><p>几乎所有的编译器/机器组合都对有符号数使用算术右移，且许多程序员也都假设机器会使用这种右移，另一方面，对于无符号数，右移必须是逻辑的。</p>
</li>
<li><p>整型数据类型中，唯一一个与机器相关的取值范围是大小指示符long的</p>
</li>
<li><p>取值范围不是对称的，负数的范围正数的范围大1。</p>
</li>
<li><p>c和c++都支持有符号和无符号数，java只支持有符号数。</p>
</li>
<li><p>c语言标准并没有要求用补码形式来表示有符号整数，但是几乎所有的机器都是这么做的。</p>
</li>
<li><p>有符号数还可以通过反码和原码的方式表示。</p>
</li>
<li><p>要将一个无符号数转换为一个更大的数据类型，我们只要简单地在表示的开头添加零，这种运算称为零扩展。</p>
</li>
<li><p>要将一个补码数字转换为一个更大的数据类型，可以执行一个符号扩展，在表示中添加最高有效位的值。例如sx=-12345       cf  c7，扩展后x=-12345    ff ff cf c7</p>
</li>
<li><p>算术运算溢出，是指完整的整数结果不能放到数据类型的字长限制中去。</p>
</li>
<li><p>整数乘法指定相当慢，因此，编译器使用了一项重要的优化，试着用移位和加法运算的组合来代替乘以常数因子的乘法。</p>
</li>
</ul>
<ul>
<li><p>整数除法比整数乘法更慢。</p>
</li>
<li><p>ieee浮点标准用V=（-1）^s×M×2^E<br>符号（sign）s决定这数是负数（s=1）还是正数（s=0），而对于数值0的符号位解释作为特殊情况处理。</p>
</li>
<li><p>尾数（signficand）M是一个二进制小数，它的范围是1～2-ξ或者是0～1-ξ</p>
</li>
<li><p>阶码（exponent）E的作用是对浮点数加权，这个权重是2的E次幂（可能是负数）</p>
</li>
<li><p>将浮点数的位表示划分为三个字段<br>一个单独的符号位，直接编码符号s<br>k位的阶段字段exp=ek-1e0编码阶码E<br>n位小数字段frac=fn-1…f0编码尾数M，但是编码出来的值也依赖于阶码字段的值是否等于0</p>
</li>
<li><p>在单精度浮点格式（c语言中的float）中，s，exp和frac字段分别为1位，8位和23位，……分别为1位，11位和52位</p>
</li>
<li><p>阶码的值决定了这个数是格式化的，非格式化的或特殊值。</p>
</li>
<li><p>ieee浮点格式定义了四种不同的舍入方式。向偶数舍入，向零舍入，向下舍入，向上舍入。</p>
</li>
<li><p>为什么有向偶数舍入呢？计算平均值的情况。如果总是把两个可表示值中间的数字向下舍入，那么舍入后的一组数的平均值将比这些数本身的平均值略低一些。向偶数舍入的大多数现实情况中避免了这种统计偏差。</p>
</li>
<li><p>从float或者double转换成int，值将会向零舍入。</p>
</li>
</ul>
<h2 id="第三章-程序的机器级表示"><a href="#第三章-程序的机器级表示" class="headerlink" title="第三章 程序的机器级表示"></a>第三章 程序的机器级表示</h2><ul>
<li><p>相对于c代码表示的计算操作，优化编译器能够重新排列执行顺序，消除不必要的计算，用快速操作代替慢速操作。</p>
</li>
<li><p>超线程，可以在一个处理器上同时运行两个程序。2004年，pentium 4E开始支持。</p>
</li>
<li><p>c语言中的聚合类型，例如数组和结构，在机器代码中用一组连续的字节来表示。即使是对标量数据类型，汇编代码也不区分有符号或无符号，不区分各种类型的指针，甚至于不区分指针和整数。</p>
</li>
<li><p>程序内存包含程序可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块。</p>
</li>
<li><p>一条机器指令只执行一个非常基本的操作。</p>
</li>
<li><p>反汇编目标文件objdump  -d  output.o</p>
</li>
</ul>
<p>+x86-64的指令长度从1到15个字节不等。常用以及操作数较少的指令所需字节数少，而不太常用或操作数较多的指令所需字节数较多？</p>
<p>+反汇编器只是基于机器代码文件中的字节序列来确定汇编代码，它不需要访问该程序的源代码或汇编代码。</p>
<ul>
<li><p>指令结尾的“q”是大小指示符，用来表明操作数的大小。例如，callq表明其操作数为4字。<br>1+ 6位为一字（word）。</p>
</li>
<li><p>b一字节 1字节</p>
</li>
<li>w一字  2字节</li>
<li>l一双字 或双精度4字节或8字节（整型操作和浮点数操作指令和寄存器不同，不会产生歧义。）</li>
<li>q一四字 8字节</li>
<li><p>s一单精度 4字节</p>
</li>
<li><p>指令的操作数分为三种类型。<br>第一种是立即数。用来表示常数值。在att格式的汇编代码中，立即数的书写方式是“$”后面跟一个用标准c表示法表示的整数。比如$0x1C<br>第二种类型是寄存器。表示寄存器的内容。<br>第三种是内存引用，它根据计算出来的地址访问某个内存位置。而寻址方式有多种。</p>
</li>
<li><p>最频繁使用的指令是将数据从一个位置复制到另一个位置的指令。</p>
</li>
<li><p>访问寄存器比访问内存要快的多。</p>
</li>
<li><p>栈向下增长，栈顶元素是所有栈中元素地址中最低的。</p>
</li>
<li><p>机器代码对于有符号和无符号两种情况都是用一样的指令，这是因为许多算术运算对无符号和补码算术都有一样的位级行为。有些情况需要使用不同的指令来处理有符号和无符号操作，例如，使用不同版本的右移，除法，和乘法指令。</p>
</li>
</ul>
<ul>
<li>跳转指令有几种不同的编码，但是常用的都是PC相对的。</li>
</ul>
<ul>
<li><p>实现条件操作的传统控制方法是通过使用控制的条件转移，当条件满足时，程序沿着执行路径执行，而当条件不满足时，就右另一条路径。这种机制简单而通用，但是在现代处理器上，它可能会非常低效。</p>
</li>
<li><p>一种替代的策略是使用数据的条件转移。这种方法计算一个条件操作的两种结果，然后再根据条件是否满足，从中选择选取一个。</p>
</li>
<li><p>条件传送指令更符合现代处理器的性能特性。</p>
</li>
<li><p>处理器采用非常精密的分支预测逻辑来猜测每条跳转指令是否会执行，只要它的猜测还比较可靠，指令流水线充满着指令。另外一方面，错误预测一个跳转，要求处理器丢掉它为该跳转指令后所有指令已做的工作，然后再开始用从正确的位置处起始的指令去填充流水线。这样一个错误预测会招致很严重的惩罚，浪费大约15～30个时钟周期，导致程序性能严重下降。</p>
</li>
</ul>
<ul>
<li><p>只有当两个表达式都很容易计算时，它才会使用条件传送。</p>
</li>
<li><p>理解产生的汇编代码与原始源代码之间的关系，环境是找到程序值和寄存器之间的映射关系。</p>
</li>
<li><p>switch开关语句可以根据一个整数索引值进行多重分值。它通过使用跳转表这种数据结构使得实现更加高效。跳转表示一个数组，表项i示一个代码段的地址，这个代码段实现党开关索引值等于i时程序应该采取的动作。与使用if else语句相比，使用跳转表的优点是执行开关语句的时间与开关情况的数量无关。</p>
</li>
</ul>
<ul>
<li><p>c语言的struct声明创建一个数据类型，将可能不同的类型的对象聚合到一个对象中，用名字来引用结构的各个组成部分。类似于数组的实现，结构的所有组成都存放在内存中的一段连续的区域内，而指向结构的指针就是结构第一个字节的地址。</p>
</li>
<li><p>结构的各个字段的选取完全是在编译时处理的。机器代码不包含关于字段声明或字段名字的信息。</p>
</li>
<li><p>无论数据是否对齐，x86-64硬件都能正确工作，不过，intel还是建议要对齐数据以提高内存系统的性能。</p>
</li>
</ul>
<ul>
<li><p>对齐原则是任何k字节的基本对象的地址必须是k的倍数。</p>
</li>
<li><p>许多计算机对基本数据类型的合法地址做了一些限制，要求某种类型对象的地址必须是某个值通常是2,4,或8（）得倍数。</p>
</li>
<li><p>对于大多数x86-64指令来说，保持数据对其能够提高效率，但它不会影响程序的行为</p>
</li>
</ul>
<p>将指针从一种类型强制转换成另一种类型，只改变他的类型，而不改变它的值</p>
<p>函数指针的值是改函数机器代码表示中第一条指令的地址</p>
<p>*操作符用于间接引用指针</p>
<ul>
<li><p>蠕虫和病毒都试图在计算机中传播它们自己的代码段。蠕虫可以自己运行，并且能够将自己的等效副本传播到其它机器。病毒能够将自己添加到包括操作系统在内的其它程序中，但它不能独立运行？</p>
</li>
<li><p>缓冲区一个更加致命的使用就是让程序执行它本来不愿意执行的函数。</p>
</li>
<li><p>对抗缓冲区溢出攻击</p>
</li>
<li><p>1.栈随机化，地址空间布局随机化，198页，使得栈的位置在程序每次运行时都有变化</p>
</li>
<li><p>栈破坏检测，插入金丝雀值</p>
</li>
<li><p>限制可执行代码区域</p>
</li>
<li><p>变长数组意味着在编译时无法确定栈帧的大小</p>
</li>
<li><p>c对于数组引用不进行任何边界检查，而且局部变量和状态信息都存放在栈中。这两种情况结合到一起就能导致严重的程序错误，对越界的数组元素的写操作会破坏存储在栈中的状态信息。</p>
</li>
</ul>
<ul>
<li>把浮点数转换成整数时，指令会进行截断，把值向0进行舍入，这是c和大多数其他编程语言的要求。</li>
</ul>
<h2 id="第5章"><a href="#第5章" class="headerlink" title="第5章"></a>第5章</h2><ul>
<li><p>程序优化的第一步就是消除不必要的工作，让代码尽可能有效地执行所期望任务。这包括消除不必要的函数调用,条件测试和内存引用。</p>
</li>
<li><p>了解处理器的运作，我们就可以进行程序优化的第二步，利用处理器提供的指令级并行能力，同时执行多条指令。</p>
</li>
<li><p>gcc优化级别越高，使用的优化量也更大，这样做可以进一步提高程序的性能，但是也能增加程序的规模，也可能使标准的调试工具更难对程序调试。</p>
</li>
<li><p>我们会发现可以写出的c代码，即使用-o1选项编译得到的性能，也比用可能的最高优化等级编译一个原始的版本得到的性能好。</p>
</li>
<li><p>简单的使用命令行选项-O1，就会进行一些基本的优化。</p>
</li>
</ul>
<ul>
<li><p>边界检查降低了程序出错的机会，但是它也会减缓程序的执行。</p>
</li>
<li><p>对于会改变在哪里调用函数或调用多少次的变换，编译器通常会非常小心。他们不能可靠地发现一个函数是否会有副作用，因而假设函数会有副作用。</p>
</li>
<li><p>消除循环的低效率。<br>优化类型，代码移动。<br>这类优化包括识别要多次执行（例如在循环里）但是计算结果不会改变的计算。因而可以将计算代码移动到代码前面不会被多次求值的部分。（strlen）</p>
</li>
<li><p>减少过程调用</p>
</li>
</ul>
<ul>
<li>消除不必要的内存引用<br>把结果累积在临时变量中。临时变量可能会保存在寄存器中</li>
</ul>
<p>在实际的处理器中，是同时对多条指令求值的，这个现象称为指令级并行。</p>
<h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><p>在程序中利用局部性</p>
<h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><p>目标文件有三种格式：</p>
<ul>
<li>可重定位目标文件</li>
<li>可执行目标文件</li>
<li><p>共享目标文件</p>
</li>
<li><p>每个可重定位目标文件在.symtab中都有用一张符号表（不需要-g编译选项，除非strip掉才会没有符号表）<br>.debug -g选项编译时才会有这张表<br>.line -g选项编译时会有有行号和.text节中机器指令之间的映射。<br>.symtab中的符号表不包含对应于本地费静态程序变量的任何符号</p>
</li>
</ul>
<p>函数和已经初始化的全局变量是强符号，未初始化的全局变量是弱符号。</p>
<ul>
<li><p>Linux链接器使用下面的规则来处理多重定义的符号名：<br>规则1;不允许有多个同名的强符号。<br>规则2：如果一个强符号和多个弱符号同名，那么选择强符号<br>规则3：如果有多个弱符号同名，那么从这些弱符号中任意选择一个。<br>静态库，在链接时，链接器将只复制被程序引用的目标模块，这就减少了可执行文件在磁盘和内存中的大小。</p>
</li>
<li><p>生成静态库 ar rcs lib<strong>.a </strong>.o<br>gcc -static参数告诉编译器驱动程序，链接器应该构造一个完全链接的可执行目标文件，它可以加载到内存并运行，在加载时无需更进一步的链接。</p>
</li>
<li><p>在符号解析阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件，但是，如果一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析，链接就会失败。</p>
</li>
<li><p>关于库的一般准则是将它们放在命令行的结尾。如果各个库的成员是相互独立的，那么这些库就可以任务顺序放置在命令行的结尾处。</p>
</li>
</ul>
<h4 id="3-3-重定位"><a href="#3-3-重定位" class="headerlink" title="3.3 重定位"></a>3.3 重定位</h4><p>重定位由两步组成，重定位节和符号定位，重定位节中的符号引用</p>
<h2 id="第八章异常控制流"><a href="#第八章异常控制流" class="headerlink" title="第八章异常控制流"></a>第八章异常控制流</h2><p>异常的类别</p>
<ul>
<li>中断  来自io设备的信号</li>
<li>陷阱  有意的异常</li>
<li>故障 潜在可恢复的错误</li>
<li><p>终止 不可恢复的错误</p>
</li>
<li><p>每个系统调用都有一个唯一的整数号，对应于一个到内核中跳转表的偏移量。</p>
</li>
</ul>
<p>所有到linux系统调用的参数都是通过通用寄存器而不是栈传递的。</p>
<p>进程会因为三种原因终止</p>
<ul>
<li>收到一个信号，该信号的默认行为是终止</li>
<li>从主程序返回</li>
<li>调用exit函数</li>
</ul>
<h2 id="第九章-虚拟内存"><a href="#第九章-虚拟内存" class="headerlink" title="第九章 虚拟内存"></a>第九章 虚拟内存</h2><ul>
<li><p>bss内存位置总是被加载器初始化为0，但堆中的数据不是这样的，需要自己将其初始化</p>
</li>
<li><p>虚拟页面包括未分配的，缓存的，未缓存的</p>
</li>
<li>DRAM缓存不命中称为缺页</li>
<li>如果工作集的大小超出了物理内存的大小，那么将会产生抖动</li>
<li>虚拟内存大大简化了内存管理，并提供了一种自然的保护内存的方法</li>
<li>vm简化了链接，加载，和共享 </li>
<li>分配的目标，1最大化吞吐率，最大化内存利用率</li>
<li>内部碎片：已分配块大小和它们的有效载荷大小之差的和。内部碎片的数量只取决于以前请求的模式和分配器的实现方式</li>
<li>外部碎片是当空闲内存合计起来足够满足一个分配请求，但是没有一个单独的空闲快足够大来处理这个请求时发生的。<h2 id="第十章-系统级IO"><a href="#第十章-系统级IO" class="headerlink" title="第十章 系统级IO"></a>第十章 系统级IO</h2></li>
<li><p>无缓冲的输入输出函数。对于从网络读写二进制数据尤其有用</p>
</li>
<li><p>带缓冲的输入函数，从文件中读取文本行和二进制数据。</p>
</li>
<li>首次适配，从头开始搜索，找到第一个合适的空闲块</li>
<li><h2 id="第十二章-并发编程"><a href="#第十二章-并发编程" class="headerlink" title="第十二章 并发编程"></a>第十二章 并发编程</h2>1.基于进程的并发编程<br>2.基于I/O多路复用的并发编程<br>3.基于线程的并发编程</li>
</ul>
<p>终止线程<br>1.顶层线程例程返回时，线程会隐式的终止<br>2.调用pthread_exit函数，线程会显式的终止<br>3.某个对等线程调用Linux的exit函数<br>4.pthread_cancel</p>
<ul>
<li>一个分离线程是不能被其他线程回收或插死的。它的内存在它终止时由系统自动释放。</li>
</ul>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux进程间通信方式</title>
    <url>/2019/04/25/38588.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>进程能够单独运行并且完成一些任务，但是也经常免不了和其他进程传输数据或互相通知消息，即需要进行通信，本文将简单介绍一些进程之间相互通信的技术—进程间通信（InterProcess Communication，IPC）。由于篇幅有限，本文不会对每一种进行详细介绍。<br><a id="more"></a></p>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>进程间通信常见方式如下：</p>
<ul>
<li>管道</li>
<li>FIFO</li>
<li>消息队列</li>
<li>信号量</li>
<li>共享内存</li>
<li>UNXI域套接字</li>
<li>套接字（Socket）</li>
</ul>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道是一种古老的IPC通信形式。它有两个特点：</p>
<ul>
<li>半双工，即不能同时在两个方向上传输数据。有的系统可能支持全双工。</li>
<li>只能在父子进程间。经典的形式就是管道由父进程创建，进程fork子进程之后，就可以在父子进程之间使用了。</li>
</ul>
<p>使用popen函数和pclose函数结合来执行系统命令，就用到了管道，它们声明如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FILE *popen(const char *command,const char *type);</span><br><span class="line">int pclose(FILE *stream);</span><br></pre></td></tr></table></figure></p>
<p>system()函数虽然也能够执行系统命令，但是无法获取执行状态码，而执行系统命令本质上就需要创建子进程来完成，因此利用管道可以很方便的获取子进程的输出内容。本文不详细展开。</p>
<p>我们看一个简单的使用管道的例子，这里使用了pipe函数来创建管道：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LEN 128</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*0为读，1为写*/</span></span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//描述符</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> line[MAX_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*创建管道，需要传入两个文件描述符*/</span></span><br><span class="line">    <span class="keyword">if</span>(pipe(fd) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"create pipe failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*fork子进程*/</span></span><br><span class="line">    <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*父进程*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*关闭管道的写描述符*/</span></span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*从管道读取数据*/</span></span><br><span class="line">        n = read(fd[<span class="number">0</span>],line,MAX_LEN);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"read %d bytes from pipe :%s\n"</span>,n,line);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*子进程*/</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*关闭管道的读描述符*/</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">/*向管道写入数据*/</span></span><br><span class="line">        write(fd[<span class="number">1</span>],<span class="string">"www.yanbinghu.com"</span>,<span class="keyword">sizeof</span>(<span class="string">"www.yanbinghu.com"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在程序中，我们创建了一个管道，父进程关闭了写通道，子进程关闭读通道；子进程向管道内写入字符串，而父进程从管道中读取字符串并输出。</p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">read 18 bytes from pipe :www.yanbinghu.com</span><br></pre></td></tr></table></figure></p>
<h2 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h2><p>FIFO也被称为命名管道，与管道不同的是，不相关的进程也能够进行数据交换。</p>
<p>涉及FIFO操作主要函数为：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>而FIFO也常常有以下两个用途：</p>
<ul>
<li>无需创建中间临时文件，复制输出流</li>
<li>多客户-服务进程应用中，通过FIFO作为汇聚点，传输客户进程和服务进程之间的数据</li>
</ul>
<p>我们看一个简单的例子，写进程代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIFO <span class="meta-string">"/tmp/fifo"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LEN 128</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> writeFd;</span><br><span class="line">    <span class="keyword">char</span> line[MAX_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(mkfifo(FIFO,S_IRUSR|S_IWUSR) &lt; <span class="number">0</span> &amp;&amp; (errno != EEXIST))</span><br><span class="line">    &#123;</span><br><span class="line">         perror(<span class="string">"make fifo failed:"</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*关闭管道的读描述符*/</span></span><br><span class="line">    writeFd = open(FIFO,O_WRONLY,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*向管道写入数据*/</span></span><br><span class="line">    write(writeFd,<span class="string">"www.yanbinghu.com"</span>,<span class="keyword">sizeof</span>(<span class="string">"www.yanbinghu.com"</span>));</span><br><span class="line">    close(writeFd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它首先创建了一个FIFO，并且打开后，往里面写入字符串，然后关闭退出。</p>
<p>读进程代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIFO <span class="meta-string">"/tmp/fifo"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LEN 128</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> readFd,n;</span><br><span class="line">    <span class="keyword">char</span> line[MAX_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">/*打开FIFO，这里打开可能失败，应该要对返回值处理*/</span></span><br><span class="line">    readFd = open(FIFO,O_RDONLY,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*从FIFO读取数据*/</span></span><br><span class="line"></span><br><span class="line">    n = read(readFd,line,MAX_LEN);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"read %d bytes from pipe :%s\n"</span>,n,line);</span><br><span class="line">    close(readFd);</span><br><span class="line">    <span class="comment">/*删除FIFO*/</span></span><br><span class="line">    unlink(FIFO);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它先打开一个已知的FIFO，然后从FIFO中读取数据。</p>
<p>在一个终端先运行写进程，然后运行读进程，结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">read 18 bytes from pipe :www.yanbinghu.com</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到，两个没有亲缘关系的进程可以通过FIFO进行通信。</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列可以认为是一个消息链表，存储在内核中，进程可以从中读写数据。与管道和FIFO不同，进程可以在没有另外一个进程等待读的情况下进行写。另外一方面，管道和FIFO一旦相关进程都关闭并退出后，里面的数据也就没有了，但是对于消息队列，一个进程往消息队列中写入数据后退出，另外一个进程仍然可以打开并读取消息。消息队列与后面介绍的UNIX域套接字相比，在速度上没有多少优势。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量是一个计数器，它主要用在多个进程需要对共享数据进行访问的时候。考虑这一的情况，不能同时有两个进程对同一数据进行访问，那么借助信号量就可以完成这样的事情。</p>
<p>它的主要流程如下：</p>
<ul>
<li>检查控制该资源的信号量</li>
<li>如果信号量值大于0，则资源可用，并且将其减1，表示当前已被使用</li>
<li>如果信号量值为0，则进程休眠直至信号量值大于0</li>
</ul>
<p>也就是说，它实际上是<strong>提供了一个不同进程或者进程的不同线程之间访问同步的手段</strong>。</p>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>共享内存允许多个进程共享一个给定的存储区，由于它们是共享一块内存数据，因此其速度非常快。但是需要另外提供手段来保证共享内存的同步访问，例如它可以用到前面所提到的信号量来实现访问同步。</p>
<h2 id="UNIX域套接字"><a href="#UNIX域套接字" class="headerlink" title="UNIX域套接字"></a>UNIX域套接字</h2><p>UNIX域套接字和套接字很相似，但是它有更高的效率，因为它不需要执行协议处理，例如计算校验和，发送确认报文等等，它仅仅复制数据。</p>
<p>当然，它也只适用于同一台计算机上的进程间通信。</p>
<p>例如redis服务配置unixsocket启动后，通过redis-cli的-s参数就可以指定UNIX域套接字，连接到redis服务器。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ redis-cli -s /tmp/redis.sock</span><br><span class="line">redis /tmp/redis.sock&gt;</span><br></pre></td></tr></table></figure></p>
<p>它会比使用网络套接字的速度要快。</p>
<h2 id="网络套接字"><a href="#网络套接字" class="headerlink" title="网络套接字"></a>网络套接字</h2><p>这个不用多说，它利用网络进行通信，与前面所提到的通信方式不同的是，它<strong>能用于不同计算机之间的不同进程间通信</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文简单介绍了进程间通信的常见方式，其中对管道和命名管道我们使用了一个例子来简单说明，因为我们可能会经常见到它。对于FIFO，最后一个引用它的进程终止时，留在FIFO的数据也将会被删除，而对于消息队列却不是这样，它会一直留到被显示删除或者系统自举，另外消息队列于其他方式相比并没有特别的优势。而信号量实际上常用于共享数据的同步访问。共享内存在进程间传递数据非常高效，但是系统没有对访问进行同步，因此还需要另外实现数据的访问同步。套接字（socket）是应该目前应用最广泛的进程间通信方式。</p>
<p>本文仅做简单介绍，实际内容远不止此。</p>
<p>参考：</p>
<ul>
<li>《Unix环境高级编程》</li>
<li>《unix网络编程卷2：进程间通信》</li>
<li>《深入Linux内核架构》</li>
</ul>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>系统编程</tag>
      </tags>
  </entry>
  <entry>
    <title>《宽容》摘录</title>
    <url>/2019/04/21/2947.html</url>
    <content><![CDATA[<p>守望：你所看到的不宽容的背后可能隐藏着更多的不宽容。只要这个世界上还存在恐惧，就会存在不宽容。但是，这只是一个视觉上的错误，人类具有几乎使人难以置信的生命力。就如房龙所言：不宽容只不过是群氓自卫本能的表现。<br><a id="more"></a></p>
<ul>
<li>只有能赢得最大的幸福和换取最小的痛苦的社会，才是有价值的。——德谟克利特。</li>
<li>如果任何一个组织基本的选择是，只有一种正确的思维方式和生活方式，其他所有方式都是可耻的、被诅咒的，那么当它的权威受到质疑的时候，它必然会采取极端的措施。</li>
<li>许多事情在前辈的眼中都是天经地义的，他们会对这些事情说“一直都是这样的”，而现在都要严肃的讨论。</li>
<li>这群头脑简单的人，在以前一直被告知世界是一个扁平的圆盘子，耶路撒冷是宇宙的中心。当小小的“维多利亚”环球航行之后归来，《旧约》中的地理学被证明有不少严重的错误时，这些人应该信什么才好呢？</li>
<li>宗教改革是形形色色的人怀着形形色色的动机造成的。</li>
<li>由于某些动机，一个历史人物做了他所做的事情，或被迫放弃了他没有做的事情。如果没有深刻地理解他的这些动机，要评价这个历史人物是很困难的，近乎是不可能的。</li>
<li>它（宗教改革）没有宽容的秩序，而是效法早期教会的做法，一旦获得了权力，依靠着无数的教义回答、教旨和忏悔构筑了一道坚固的防线，就对那些敢于不赞同自己社会的官方正统教义的人公然宣战。</li>
<li>人类可以被划分成两种：一种是对生活说“是”，另一种是说“不”。前者接受生活，不管廉价的命运给了他什么，都勇敢地接受。后者也接受生活（否则他们又梦怎么样么？）但他们看不起这个馈赠。他们像个孩子，本来想要个木偶或者玩具火车，缺得到一个新生的小弟弟，他们因此而烦恼。</li>
<li>无疑他们（巴鲁克，约翰）的父母都用各自信仰的严格教义训练自己的孩子，他们当然是好意。不过这样的教育不是摧毁了孩子的灵魂，就是使他变成一个叛逆。</li>
<li>像其他许多需要巨大智慧和无比的耐心的事物一样，撰写百科全书的传统也起源于中国。</li>
<li>就在这个时候，一些骄傲的民族终于摆脱了“永远正确的人”硬加在他们头上的枷锁，但他们却马上接受了一本“永远正确的书（指《人权宣言》）”的统治。</li>
<li>没有一种宗教能够垄断真理。重要的是人的内心灵魂，比他在表面上奉行某些规定的仪式和教条更有价值，因此，人们有友好相处的义务，没有人有权把自认为是完美无缺的偶像让别人崇拜，无权声称“我比其他所有人都好，因为只有我独自掌握真理”。</li>
<li>潘恩相信，真正的宗教，即他所说的“人性的宗教”，有两个敌人，一个是无神论，另一个是宗教狂热主义。</li>
<li>许多善良的人直道最近还生活在幻想之中，以为进步是一块自动时钟，只要偶尔表示一下赞许，就不用再上发条了，这想法看上去太可怕了。</li>
<li>他们痛斥着人类本性的无可救药，人类一代代地交学费，却总是不能学会教训。</li>
<li>进步的轨迹常常被中断，但是我们如果把感情上的偏见置于一边，可以对两千年来的历史作一个冷静的论断，我们就会注意到，发展的过程虽然缓慢，却是毋庸置疑的，人类从几乎无法形容的残忍和粗野的状态走向了另一种境界，未来比过去会更加高贵和美好，甚至连世界大战的可怕错误也无法动摇这个坚定的信念。</li>
<li>多少个时代流逝，生命本来应该是一次光荣的冒险，结果变成了一场可怕的经历，这一切之所以发生，就是因为迄今为止人类的生存完全被恐惧所笼罩。</li>
</ul>
<p>备注：亨德里克?威廉?房龙 (Hendrik Willem van Loon, 1882―1944) 荷裔美国作家和历史学家。1911年获德国慕尼黑大学博土学位，毕业后曾先后从事多种职业，但在写作方面取得了最令人瞩目的成就。代表作包括《荷兰共和国衰亡史》、 《人类的故事》、 《房龙地理》、《发明的故事》、 《宽容》等二十余部，均有相当大的影响，饮誉世界。其作品先后在荷兰、德国、法国、瑞典、日本、中国等二十多个国家翻译出版。<br>《宽容》，是一部两千年来人类思想发展的历史。房龙从人文主义的立场出发，探寻千百年来人类精神上“不宽容”的根由。历史上由于信仰、道德、风俗等的不同，人类形成了大大小小的集团，每个集团总是居住在壁垒森严的城堡里，用偏见和固执这个坚固的屏障抵御外界和外来的影响。而这种不宽容来自于对人类生存的恐惧。房龙乐观地认为宽容的实现是可能的，在知识和理性统治的时代，人类战胜了自己的恐惧，宽容便会大行其道了。  </p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>《瓦尔登湖》摘录</title>
    <url>/2019/04/21/5609.html</url>
    <content><![CDATA[<p>   守望： 对于梭罗先生笔下的瓦尔登湖的生活，我并不觉得有多自然，新奇，惬意，以至于向往，或许是因为我本身从小就是在农村长大吧。但是，这却可以让现代人（自然也包括我自己）放下手中的活，静静地思考。就连中译本序的作者也说：“你能把你的心安静下来吗？如果你的心并没有安静下来，我说，你也许最好是先把你的心安静下来，然后你再打开这本书，否则你也许会读不下去，认为它太浓缩，难读，艰深，甚至会觉得它莫明其妙，莫知所云。”在自然被现代文明日渐“吞噬”的情况下，我们难以有梭罗先生那样的生活方式，却未必不能有那样的生活态度!<br><a id="more"></a></p>
<ul>
<li>如果我的知人之深，比得上我的自知之明，我就不会畅谈自我，谈那么多了。</li>
<li>大多数人，即使是在这个比较<br>自由的国土上的人们，也仅仅因为无知和错误，满载着虚构的忧虑，忙不完的粗活，却不能采集生命的美果。</li>
<li>正是一个人怎么看待自己，决定了此人的命运，指向了他的归宿。</li>
<li>所谓听天由命，正是肯定的绝望。</li>
<li>抛弃我们的偏见，是永远不会来不及的。无论如何古老的思想与行为，除非有确证，便不可以轻信。</li>
<li>在今天人人附和或以为不妨默认的真理，很可能在明天变成虚无缥缈的氤氲，但还会有人认为是乌云，可以将一阵甘霖洒落到大地上来。</li>
<li>我们对自己的关怀能放弃多少，便可以忠实地给别人多少的关怀。</li>
<li>你想，我怎么配有一个有家具的房屋呢？我宁可坐在露天，因为草叶之上，没有灰尘，除非是人类已经玷辱过了的地方。</li>
<li>简单一句活，我已经确信，根据信仰和经验，一个人要在世间谋生，如果生活得比较单纯而且聪明，那并不是苦事，而且还是一种消遣</li>
<li>我们也许不能够在一个预定的时日里到达目的港，但我们总可以走在</li>
<li>一条真正的航线上。清醒就是生活。我还没有遇到过一个非常清醒的人。要是见到了他，我怎敢凝视他呢？</li>
<li>我们必须学会再苏醒，更须学会保持清醒而不再昏睡，但不能用机械的方法，而应寄托无穷的期望于黎明，就在最沉的沉睡中，黎明也不会抛弃我们的。</li>
<li>每人都应该把最崇高的和紧急时刻内他所考虑到的做到，使他的生命配得上他所想的，甚至小节上也配得上。</li>
<li>读得好书，就是说，在真实的精神中读真实的书，是一种崇高的训练，这花费一个人的力气，超过举世公认的种种训练。</li>
<li>它们没有什么私事要诉说，可是，当它们启发并支持了读者，他的常识使他不能拒绝它们。</li>
<li>我们必须踮起足尖，把我们最灵敏、最清醒的时刻，献予阅读才对。</li>
<li>一本书，能解释我们的奇迹，又能启发新的奇迹，这本书就为我们而存在了。</li>
<li>我们在肉体的疾病方面花了不少钱，精神的病害方面却没有花什么，现在已经到了时候，我们应该有不平凡的学校。</li>
<li>怎样一种空间才能把人和人群隔开而使人感到寂寞呢？我已经发现了，无论两条腿怎样努力也不能使两颗心灵更形接近。</li>
<li>这就是说，一个人如果是活着的，他就随时随地有死亡的危险，其实这样的死亡危险，由于他已经是一个活着的死人而相对地减少了。</li>
<li>每一个人都应该在清醒过来之后，经常看看罗盘上的方向。非到我们迷了路，换句话说，非到我们失去了这个世界之后，我们才开始发现我们自己，认识我们的处境，并且认识了我们的联系之无穷的界限。</li>
<li>我本可以疯狂地反对社会，但是我宁可让社会疯狂地来反对我，因为它才是那绝望的一方</li>
<li>我想，身体固然需要营养，想象力同样需要营养，二者应该同时得到满足，这也许是可以做到的。</li>
<li>食物入口并不足以玷辱一个人，但他吃这种食物的胃口却足以玷辱他。问题不在量，不在质，而在口腹的贪嗜上，如果吃东西不是为了养活我们的生命，也不是为了激励我们的精神生活，而是为了在肚皮里缠住我们的蛔虫。</li>
<li>这竖琴好比宇宙保险公司里的旅行推销员，宣传它的条例，我们的小小善行是我们所付的保险费。</li>
<li>从西风中听一听谴责之辞吧，一定有的，听不到的人是不幸的。</li>
<li>我们所知道的规则与和谐，常常局限于经我们考察了的一些事物；可是有更多数的似乎矛盾而实在却呼应着的法则，我们只是还没有找出来而已，它们所产生的和谐却是更惊人的。</li>
<li>这是真的，我们是一些可怜的航海家，我们的思想大体说来都有点虚无缥缈，在一个没有港口的海岸线上，顶多和有诗意的小港汊有些往还，不然就驶入公共的大港埠，驶进了科学这枯燥的码头上，在那里他们重新拆卸组装，以适应世俗，并没有一种潮流使它们同时保持其独立性。</li>
<li>在一个智慧者的印象中，宇宙万物是普遍无知的。毒药反而不一定是毒的，受伤反而不一定是致命的。恻隐之心是一个很不可靠的基础。它是稍纵即逝的。它的诉诸同情的方法不能一成不变。</li>
<li>我离开森林，就跟我进入森林，有同样的好理由。我觉得也许还有好几个生命可过，我不必把更多时间来交给这一种生命了。惊人的是我们很容易糊里糊涂习惯于一种生活，踏出一条自己的一定轨迹。</li>
<li>一个人若能自信地向他梦想的方向行进，努力经营他所想望的生活，他是可以获得通常还意想不到的成功的。</li>
<li>他自己的生活越简单，宇宙的规律也就越显得简单，寂寞将不成其为寂寞，贫困将不成其为贫困，软弱将不成其为软弱。</li>
<li>为什么我们时常降低我们的智力到了愚笨的程度，而又去赞美它为常识？最平常的常识是睡着的人的意识，在他们打鼾 中表达出来的。</li>
<li>英国努力防治土豆腐烂，难道就不 努力医治脑子腐烂？而后者实在是更普遍更危险的呢。</li>
<li>因为他并不跟时间妥协，时间就站在一旁叹气，拿他没办法。</li>
<li>多余的财富只能够买多余的东西，人的灵魂必需的东西，是不需要花钱买的。</li>
<li>只有我们睁开眼睛醒过来的那一天，天才亮了。天亮的日子多着呢。太阳不过是一个晓星。</li>
</ul>
<p>备注：亨利·戴维·梭罗(Henry David Thoreau，1817-1862)，美国作家、哲学家，超验主义代表人物，也是一位废奴主义及自然主义者，有无政府主义倾向，曾任职土地勘测员。毕业于哈佛大学，曾协助爱默生编辑评论季刊《日晷》。写有许多政论，反对美国与墨西哥的战争，一生支持废奴运动。其思想深受爱默生影响，提倡回归本心，亲近自然。</p>
<p>《瓦尔登湖》（Walden 或 Life in the Woods），中国大陆译“瓦尔登湖”，台湾译“湖滨散记”，是美国作家亨利·戴维·梭罗所著的一本著名散文集。该书出版于1854年，梭罗在书中详尽地描述了他在瓦尔登湖湖畔一片再生林中度过两年又两月的生活以及期间他的许多思考。当我们离自然越来越远的时候，当我们的精神已经越来越麻木的时候，《瓦尔登湖》这本书无疑能带我们回归心灵的纯净世界。</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>《娱乐至死》摘录</title>
    <url>/2019/04/21/37185.html</url>
    <content><![CDATA[<p>守望：信息时代，越来越多的产品加强了电视等所产生的一种独有的“侵蚀性”的娱乐功能。也许，多少年以后，我们才意识到，特殊的媒介让我们忽略了它本来要表达的意义。<br><a id="more"></a></p>
<ul>
<li>用书面文字记录哲学观点，不是这些观点的终结，而是这些观点的起点。</li>
<li>分分秒秒的存在不是上帝的意图，也不是大自然的产物，而是人类运用自己创造出来的机械和自己对话的结果</li>
<li>对于真理的认识是同表达方式密切关联的。真理不能、也从来没有，毫无修饰地存在。它必须穿着某种合适的外衣出现，否则就可能得不到承认。这也正说明了“真理”是一种文化偏见。</li>
<li>所有的教堂，不论是犹太人的、基督徒或土耳其人的，在我看来，都只不过是人的发明，是为了吓唬和奴役人类、垄断权利和利益而建立的——潘恩《理性时代》</li>
<li>如果只拘泥于耳熟能详的专门术语，就会丧失对事物进行宏观全面认识的能力，即使在熟悉的领域里也一样——佩里•米勒《美国的思想：从大革命到国内战争》</li>
<li>报纸上一行行有序而连贯的文字渐渐失去了帮助我们获取知识和了解这个世界的能力。“了解”事实开始有了新的定义，因为“了解”并不意味着人们能够“理解”事实的言下之意，背景知识与其他事实的关联。</li>
<li>伪语境的作用是为了让脱离生活毫无关联的信息获得一种表面的用处，但伪语境可能提供的不是行为或解决问题的方法或变化。这种信息剩下的唯一用处和我们的生活也没有真正的联系。当然这种唯一的用处就是它的娱乐功能。</li>
<li>不管是哪一种“伪语境”，都为“这些没有彼此关联的事实和我有什么关系”这个问题提供了一个答案，而且答案是一致的：为什么不利用它们作为消遣娱乐或在游戏中找点乐？</li>
<li>在18和19世纪，美国的宗教思想和宗教组织被一种质朴、博学的话语形式统治着，而这正是今天的宗教活动所缺少的。</li>
<li>这是一个没有连续性，没有意义的世界，一个不要求我们也不允许我们做任何事的世界，一个像孩子们的躲躲猫的游戏那样完全是独立闭塞的世界，但和躲躲猫一样’也是其乐无穷的。</li>
<li>这是一个没有连续性，没有意义的世界，一个不要求我们也不允许我们做任何事的世界，一个像孩子们的躲躲猫的游戏那样完全是独立闭塞的世界，但和躲躲猫一样’也是其乐无穷的。</li>
<li>当然，玩躲躲猫游戏并没有什么过错，娱乐本身也没有过错。正如有些精神病学家提出的，我们每个人都会筑起自己的空中楼阁，但是如果我们想要住在里面，问题就出现了。</li>
<li>西塞罗说过，教育的目的是让学生摆脱现实的奴役，而现在年轻人正竭力做着相反的努力-为了适应现实而改变自己。</li>
<li>我们显然已经意识到，信息的形式、容量、速度和背景发生的变化意味深长某种东西，但除此之外，我们没有想得更多</li>
<li>为我们提供纯粹的娱乐是电视最大的好处，它最糟糕的用处是它企图涉足严肃的话语模式——新闻、政治、科学、教育、商业和宗教，然后给它们换上娱乐的包装。</li>
<li>如果你博览教育文献，你会发现有人说过——柏拉图和杜威对此也十分强调——理性只有在情感的肥沃土壤里才能得到最好的培养：你甚至会发现有人说，一个慈爱的老师会使学习成为一件轻松的事。但从来没有人说过或暗示过，只有当教育成为娱乐时，学习才能最有效，最持久，最真实。<ul>
<li>只有深刻而持久地意识到信息的结构和效应，消除对媒介的神秘感，我们才有可能对电视，或电脑，或任何其他媒介获得某种程度的控制。</li>
<li>由于电脑的到来，他们开始产生了某种“媒介意识”。但是’他们这种意识往往集中在“我们怎样利用电视（或电脑，或文字处理机）来控制教育”这个问题强，而不是“我们怎样利用教育来控制电视（或电脑，或文字处理机）”上。</li>
<li>赫胥黎试图在《美丽新世界》中告诉我们，人们感到痛苦的不是他们用笑声代替了思考，而是他们不知道自己为什么笑以及为什么不再思考。</li>
<li>教育哲学家们认为获得知识是一件困难的事情，因为其中必然有各种约束的介入。</li>
</ul>
</li>
</ul>
<p>在此，无力也不便作过多评论，只想问，是否为了达到某个目的就可以采取任何方式呢？我想答案是明显的！ </p>
<p>备注：尼尔·波兹曼（Neil Postman，1931-2003），世界著名媒体文化研究者和批评家，生前一直在纽约大学任教，首创了媒体生态学专业。波兹曼出版过18部书籍，并为各大报刊写过两百多篇文章。这些报刊包括：纽约时报、时代杂志、哈佛教育文摘、华盛顿邮报、洛杉矶时报等。<br>《娱乐至死》由尼尔·波兹曼所著，他指出，现实社会（书中主要以美国社会为例）的一切公众话语日渐以娱乐的方式出现，并成为一种文化精神。我们的政治、宗教、新闻、体育、教育和商业都心甘情愿的成为娱乐的附庸。主要观点有2种方法可以让文化精神枯萎一种是让文化成为一个监狱 另一种就是把文化变成一场娱乐至死的舞台意义</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>《蒙田随笔》摘录</title>
    <url>/2019/04/21/62474.html</url>
    <content><![CDATA[<p>蒙田（1533.2.28-1592.9.13），法国文艺复兴后期、十六世纪人文主义思想家。主要作品有《蒙田随笔全集》、《蒙田意大利之旅》。在十六世纪的作家中，很少有人像蒙田这样受到现代人的崇敬和接受。他是启蒙运动以前法国的一位知识权威和批评家，是一位人类感情的冷峻的观察家，亦是对各民族文化，特别是西方文化进行冷静研究的学者。</p>
<p>它与《培根人生论》《帕斯卡尔思想录》一起，被人们誉为欧洲近代哲理散文三大经典。也有”生活的哲学“之美称。在蒙田的作品中，日常生活、传统习俗、人生哲理无所不谈，并旁征博引了许多古希腊罗马作家的论述。作者还对自己作了大量的描写与剖析，使人读来有亲切之感，增加了作品的文学趣味。 —以上内容来自百度百科。<br><a id="more"></a></p>
<ul>
<li>大自然规定生命的入口只有一个，生命的出口却有成千上万。</li>
<li>人要有三个头脑，天生的一个头脑，从书中得来的一个头脑，从生活中得来的一个头脑。</li>
<li>重要的是不但要看到事物，而且要有看待事物的方法。</li>
<li>应该用精神的健康来促进身体的健康，心灵应让安详和快乐显露外部，用自己的模子来塑造身体的举止，使之雍容尔雅，轻捷活泼，自信淳朴，精神将抗的最显著的标志，就是永远快快乐乐。</li>
<li>万事皆有自己适宜的时机，人类天性最大的弱点莫过于欲望层出无穷。</li>
<li>人一活动就会暴露自己，人的一言一行，一举一动都在展示人，表现人。</li>
<li>人能衡量一切，却不能衡量自己。</li>
<li>真正有知识的人的成长过程，就像麦穗的成长过程：麦穗空的时候麦子长的很快，麦穗骄傲地高高昂起，但是麦穗成熟饱满时，他们开始谦虚，垂下麦芒。</li>
<li>世界上最伟大的事，是一个人懂得如何做自己的主人。</li>
<li>人最难做的是始终如一，而最易做的是变幻无常。</li>
<li>我们的欲望蔑视我无视已经到手的东西，却去追逐自己没有的东西。</li>
<li>傲慢有两种原因：对自己评价过高，对别人评价过低。</li>
<li>知识如果不能改变思想，使之变得完善，那就最好把它抛弃，拥有知识，却毫无本事—不知道如何使用，还不如什么都没有学。</li>
<li>最美好最合法的事莫过于正正派派做好一个人，最艰难之学识莫过于自自然然过好这一生，人最凶险的病症是轻视个人的存在。</li>
<li>人间有那么多出其不意的突变，很难说我们怎样才算是到了穷途末路，人只要一息尚存，对什么都了抱有希望。</li>
<li>命运对我们的品行无能为力，恰恰相反，我们的品行会影响命运给它打上自己的印记。</li>
<li>生之本质在于死。因此只有乐于生的人才能真正不感到死之苦恼。</li>
<li>灵魂如果没有确定的目标，它就会丧失自己，因为俗语说的好，无所不在等于无所在。</li>
<li>没有一定的目标，智慧就会丧失；哪儿都是目标，那儿就没有目标。</li>
<li>智者向愚人学习的东西多于愚人向智者学习的东西。</li>
<li>生活乐趣的大小是随对生活的关心程度而定。</li>
<li>骚扰我们的，是我们对于事物的意识，而不是事物本身。</li>
<li>人的眼睛看不见身后任何东西。一天当中我们成百次谈论邻居其实是在自己嘲讽自己，我们憎恨别人身上的缺点，而那些缺点在我们身上更为明显，出于一种不可思议的恬不知耻和疏忽，我们竟对那些缺点感到惊讶。</li>
<li>人间万象，其中一种状态相当普遍：对于己无关之事的兴趣超过对本人私事的兴趣，人热衷于动，热衷于变。</li>
<li>做事迅速，敏捷是性格所致，而沉着，缓慢则是理性所为。<br>在这里摘取的只言片语与原文的精彩相比不及万分之一，所摘录断落可能有其特定语境以及更加精确的论述，因而有失其本色。若能品读原文，自是受益不浅。</li>
</ul>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>只有程序员才会玩的游戏</title>
    <url>/2019/04/21/26641.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这些游戏恐怕只有程序员才会玩了。<br><a id="more"></a></p>
<h2 id="Nazo-Game"><a href="#Nazo-Game" class="headerlink" title="Nazo Game"></a>Nazo Game</h2><p>这是一个在线解谜游戏，画风简洁，部分关卡需要具备一定的web知识。url地址直接访问，打开浏览器调试等操作都是解谜必要的。对于web开发人员来说非常值得一玩。</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E5%8F%AA%E6%9C%89%E7%A8%8B%E5%BA%8F%E5%91%98%E6%89%8D%E4%BC%9A%E7%8E%A9%E7%9A%84%E6%B8%B8%E6%88%8F/nazo1.png" alt="nazo"></p>
<p>地址：<br><a href="http://nazo.one-story.cn/" target="_blank" rel="noopener">http://nazo.one-story.cn/</a></p>
<p>第一关：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E5%8F%AA%E6%9C%89%E7%A8%8B%E5%BA%8F%E5%91%98%E6%89%8D%E4%BC%9A%E7%8E%A9%E7%9A%84%E6%B8%B8%E6%88%8F/nazo2.png" alt="nazo"></p>
<h2 id="LightBot"><a href="#LightBot" class="headerlink" title="LightBot"></a>LightBot</h2><p>这同样是一个用到编程相关知识的小游戏。关卡从简单到困难，会慢慢地用到诸如条件判断，循环，函数调用，递归等几乎任何语言中都有的特点。当然实际上非程序员也是可以试着玩一玩的。它支持Android和IOS以及在线。</p>
<p>地址：<br><a href="http://lightbot.com/" target="_blank" rel="noopener">http://lightbot.com/</a></p>
<p>在线地址：<br><a href="http://lightbot.com/flash.html" target="_blank" rel="noopener">http://lightbot.com/flash.html</a></p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E5%8F%AA%E6%9C%89%E7%A8%8B%E5%BA%8F%E5%91%98%E6%89%8D%E4%BC%9A%E7%8E%A9%E7%9A%84%E6%B8%B8%E6%88%8F/lightbot.png" alt="lightBot"></p>
<h2 id="vim-adventures"><a href="#vim-adventures" class="headerlink" title="vim-adventures"></a>vim-adventures</h2><p>这是一个vim相关的游戏，让你在游戏中不断学习和练习vim的操作。喜欢vim的小伙伴赶紧试试吧！</p>
<p>地址：<br><a href="https://vim-adventures.com/" target="_blank" rel="noopener">https://vim-adventures.com/</a></p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E5%8F%AA%E6%9C%89%E7%A8%8B%E5%BA%8F%E5%91%98%E6%89%8D%E4%BC%9A%E7%8E%A9%E7%9A%84%E6%B8%B8%E6%88%8F/vim.png" alt="vim-adventures"></p>
<h2 id="Git-Game"><a href="#Git-Game" class="headerlink" title="Git-Game"></a>Git-Game</h2><p>从名字就可以看出来，这是一个需要git知识才能玩的游戏。项目地址如下：<br><a href="https://github.com/git-game/git-game" target="_blank" rel="noopener">https://github.com/git-game/git-game</a><br>不过项目提供的在线使用地址并不能使用了，所以ha是建议clone下来把玩。</p>
<p>1.把项目clone下来：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/hgarc014/git-game.git</span><br></pre></td></tr></table></figure></p>
<p>但是clone下来的文件只有两个，没有太多信息，不过从基本每次都是从README.md中获取相关信息，例如在clone下来的README.md中我们发现如下信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Level 1</span><br><span class="line"></span><br><span class="line">Your first task is to checkout the commit whose commit message is the answer to this question:</span><br><span class="line"></span><br><span class="line">When a programmer is born, what is the first thing he/she learns to say?</span><br></pre></td></tr></table></figure></p>
<p>问的是，当一个程序员第一次编码代码时，他/她需要学会说什么？我们很容易想到就是hello world!  于是我们查看提交日志：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 640273807f9bac8af03575f82b788663d4b99927</span><br><span class="line">Author: Henry Garcia &lt;hgarc014@ucr.edu&gt;</span><br><span class="line">Date:   Wed Jun 10 20:55:07 2015 -0700</span><br><span class="line"></span><br><span class="line">    Hello World!</span><br><span class="line"></span><br><span class="line">commit 8cafb7c87b129686da362b14c3f3c750c1fe4bf5</span><br><span class="line">Author: Henry Garcia &lt;hgarc014@ucr.edu&gt;</span><br><span class="line">Date:   Sun Nov 30 18:29:35 2014 -0800</span><br><span class="line"></span><br><span class="line">    Initial commit</span><br></pre></td></tr></table></figure></p>
<p>就可以找到Hello World的那次提交了。将它回退到该版本：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset --hard 6402</span><br><span class="line">HEAD is now at 6402738 Hello World!</span><br></pre></td></tr></table></figure></p>
<p>到这里就获取到了第二关的信息。更多内容就不再介绍了，有兴趣的可以自己尝试。</p>
<h2 id="Robocode"><a href="#Robocode" class="headerlink" title="Robocode"></a>Robocode</h2><p>Robocode是一款编程游戏，你可以通过开发代码来创造你自己的机器人坦克，用于消灭其他坦克。它主要使用Java语言来创建属于你自己的机器人。</p>
<p>下载地址：<br><a href="https://sourceforge.net/projects/robocode/" target="_blank" rel="noopener">https://sourceforge.net/projects/robocode/</a></p>
<p>安装：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar robocode-1.9.3.5-setup.jar  #安装你下载的对应版本</span><br></pre></td></tr></table></figure></p>
<p>你可以通过battle-new并添加机器人来查看模拟战斗：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E5%8F%AA%E6%9C%89%E7%A8%8B%E5%BA%8F%E5%91%98%E6%89%8D%E4%BC%9A%E7%8E%A9%E7%9A%84%E6%B8%B8%E6%88%8F/robocode.png" alt="robocode"></p>
<p>你也可以通过robot-source editor来创建属于你自己的机器人坦克,创建时它已经具备一些基本的接口：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E5%8F%AA%E6%9C%89%E7%A8%8B%E5%BA%8F%E5%91%98%E6%89%8D%E4%BC%9A%E7%8E%A9%E7%9A%84%E6%B8%B8%E6%88%8F/robot.png" alt="robocode"></p>
<h2 id="其他游戏"><a href="#其他游戏" class="headerlink" title="其他游戏"></a>其他游戏</h2><p>类似的游戏还有比较多，可以自行尝试：</p>
<ul>
<li>hack game  <a href="https://chaozz.nl/hackthegame/" target="_blank" rel="noopener">https://chaozz.nl/hackthegame/</a></li>
<li>代码坦克 <a href="http://codetank.alloyteam.com/" target="_blank" rel="noopener">http://codetank.alloyteam.com/</a></li>
<li>大型多人在线开放策略游戏 <a href="https://screeps.com/" target="_blank" rel="noopener">https://screeps.com/</a> （JavaScript）</li>
<li>极客战记 <a href="https://codecombat.com/" target="_blank" rel="noopener">https://codecombat.com/</a></li>
<li>康丁游戏 <a href="https://www.codingame.com/" target="_blank" rel="noopener">https://www.codingame.com/</a>  支持二十多种语言</li>
<li>checkIo  <a href="https://checkio.org/" target="_blank" rel="noopener">https://checkio.org/</a> （Python，JavaScript）</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是今天介绍的一些只有程序员才会玩的游戏，尽情享受吧！你有什么推荐？欢迎留言！</p>
]]></content>
      <categories>
        <category>程序员</category>
      </categories>
      <tags>
        <tag>程序员</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB调试指南</title>
    <url>/2019/04/20/41283.html</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>本文为GDB调试指南，参考GDB调试手册，但加入了很多实例，目前已有的篇目：</p>
<ul>
<li><a href="#启动调试">启动调试</a></li>
<li><a href="#断点设置">断点设置</a></li>
<li><a href="#变量查看">变量查看</a></li>
<li><a href="#单步调试">单步调试</a></li>
<li><a href="#源码查看">源码查看</a><a id="more"></a>
</li>
</ul>
<h1 id="启动调试"><a href="#启动调试" class="headerlink" title="启动调试"></a>启动调试</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>GDB（GNU Debugger）是UNIX及UNIX-like下的强大调试工具，可以调试ada, c, c++, asm, minimal, d, fortran, objective-c, go, java,pascal等语言。本文以C程序为例，介绍GDB启动调试的多种方式。<br><!--more--></p>
<h2 id="哪类程序可被调试"><a href="#哪类程序可被调试" class="headerlink" title="哪类程序可被调试"></a>哪类程序可被调试</h2><p>对于C程序来说，需要在编译时加上-g参数，保留调试信息，否则不能使用GDB进行调试。<br>但如果不是自己编译的程序，并不知道是否带有-g参数，如何判断一个文件是否带有调试信息呢？</p>
<h4 id="gdb-文件"><a href="#gdb-文件" class="headerlink" title="gdb 文件"></a>gdb 文件</h4><p>例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gdb helloworld</span><br><span class="line">Reading symbols from helloWorld...(no debugging symbols found)...done.</span><br></pre></td></tr></table></figure></p>
<p>如果没有调试信息，会提示no debugging symbols found。<br>如果是下面的提示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Reading symbols from helloWorld...done.</span><br></pre></td></tr></table></figure></p>
<p>则可以进行调试。</p>
<h4 id="readelf查看段信息"><a href="#readelf查看段信息" class="headerlink" title="readelf查看段信息"></a>readelf查看段信息</h4><p>例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ readelf -S helloWorld|grep debug</span><br><span class="line">  [28] .debug_aranges    PROGBITS         0000000000000000  0000106d</span><br><span class="line">  [29] .debug_info       PROGBITS         0000000000000000  0000109d</span><br><span class="line">  [30] .debug_abbrev     PROGBITS         0000000000000000  0000115b</span><br><span class="line">  [31] .debug_line       PROGBITS         0000000000000000  000011b9</span><br><span class="line">  [32] .debug_str        PROGBITS         0000000000000000  000011fc</span><br></pre></td></tr></table></figure></p>
<p>helloWorld为文件名，如果没有任何debug信息，则不能被调试。</p>
<h4 id="file查看strip状况"><a href="#file查看strip状况" class="headerlink" title="file查看strip状况"></a>file查看strip状况</h4><p>下面的情况也是不可调试的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file helloWorld</span><br><span class="line">helloWorld: (省略前面内容) stripped</span><br></pre></td></tr></table></figure></p>
<p>如果最后是stripped，则说明该文件的符号表信息和调试信息已被去除，不能使用gdb调试。但是not stripped的情况并不能说明能够被调试。</p>
<h2 id="调试方式运行程序"><a href="#调试方式运行程序" class="headerlink" title="调试方式运行程序"></a>调试方式运行程序</h2><p>程序还未启动时，可有多种方式启动调试。</p>
<h4 id="调试启动无参程序"><a href="#调试启动无参程序" class="headerlink" title="调试启动无参程序"></a>调试启动无参程序</h4><p>例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gdb helloWorld</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>输入run命令，即可运行程序</p>
<h4 id="调试启动带参程序"><a href="#调试启动带参程序" class="headerlink" title="调试启动带参程序"></a>调试启动带参程序</h4><p>假设有以下程序，启动时需要带参数：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> &gt;= argc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage:hello name\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World %s!\n"</span>,argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -g -o hello hello.c</span><br></pre></td></tr></table></figure></p>
<p>这种情况如何启动调试呢？需要设置参数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gdb hello</span><br><span class="line">(gdb)run 编程珠玑</span><br><span class="line">Starting program: /home/shouwang/workspaces/c/hello 编程珠玑</span><br><span class="line">Hello World 编程珠玑!</span><br><span class="line">[Inferior 1 (process 20084) exited normally]</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>只需要run的时候带上参数即可。<br>或者使用set args，然后在用run启动：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb hello</span><br><span class="line">(gdb) set args 编程珠玑</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/hyb/workspaces/c/hello 编程珠玑</span><br><span class="line">Hello World 编程珠玑!</span><br><span class="line">[Inferior 1 (process 20201) exited normally]</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<h4 id="调试core文件"><a href="#调试core文件" class="headerlink" title="调试core文件"></a>调试core文件</h4><p>当程序core dump时，可能会产生core文件，它能够很大程序帮助我们定位问题。但前提是系统没有限制core文件的产生。可以使用命令limit -c查看：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ulimit -c</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p>
<p>如果结果是0，那么恭喜你，即便程序core dump了也不会有core文件留下。我们需要让core文件能够产生：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ulimit -c unlimied  #表示不限制core文件大小</span><br><span class="line">ulimit -c 10        #设置最大大小，单位为块，一块默认为512字节</span><br></pre></td></tr></table></figure></p>
<p>上面两种方式可选其一。第一种无限制，第二种指定最大产生的大小。<br>调试core文件也很简单：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb 程序文件名 core文件名</span><br></pre></td></tr></table></figure></p>
<p>具体可参看《<a href="https://www.yanbinghu.com/2018/09/26/61877.html">linux常用命令-开发调试篇</a>》gdb部分。</p>
<h2 id="调试已运行程序"><a href="#调试已运行程序" class="headerlink" title="调试已运行程序"></a>调试已运行程序</h2><p>如果程序已经运行了怎么办呢？<br>首先使用ps命令找到进程id：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef|grep 进程名</span><br></pre></td></tr></table></figure></p>
<h4 id="attach方式"><a href="#attach方式" class="headerlink" title="attach方式"></a>attach方式</h4><p>假设获取到进程id为20829，则可用下面的方式调试进程：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gdb</span><br><span class="line">(gdb) attach 20829</span><br></pre></td></tr></table></figure></p>
<p>接下来就可以继续你的调试啦。</p>
<p>可能会有下面的错误提示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Could not attach to process.  If your uid matches the uid of the target</span><br><span class="line">process, check the setting of /proc/sys/kernel/yama/ptrace_scope, or try</span><br><span class="line">again as the root user.  For more details, see /etc/sysctl.d/10-ptrace.conf</span><br><span class="line">ptrace: Operation not permitted.</span><br></pre></td></tr></table></figure></p>
<p>解决方法，切换到root用户：<br>将/etc/sysctl.d/10-ptrace.conf中的<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kernel.yama.ptrace_scope = 1</span><br></pre></td></tr></table></figure></p>
<p>修改为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kernel.yama.ptrace_scope = 0</span><br></pre></td></tr></table></figure></p>
<h4 id="直接调试相关id进程"><a href="#直接调试相关id进程" class="headerlink" title="直接调试相关id进程"></a>直接调试相关id进程</h4><p>还可以是用这样的方式gdb program pid，例如:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb hello 20829</span><br></pre></td></tr></table></figure></p>
<p>或者：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb hello --pid 20829</span><br></pre></td></tr></table></figure></p>
<h4 id="已运行程序没有调试信息"><a href="#已运行程序没有调试信息" class="headerlink" title="已运行程序没有调试信息"></a>已运行程序没有调试信息</h4><p>为了节省磁盘空间，已经运行的程序通常没有调试信息。但如果又不能停止当前程序重新启动调试，那怎么办呢？还有办法，那就是同样的代码，再编译出一个带调试信息的版本。然后使用和前面提到的方式操作。对于attach方式，在attach之前，使用file命令即可：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gdb</span><br><span class="line">(gdb) file hello</span><br><span class="line">Reading symbols from hello...done.</span><br><span class="line">(gdb)attach 20829</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了两种类型的GDB启动调试方式，分别是调试未运行的程序和已经运行的程序。对于什么样的程序能够进行调试也进行了简单说明。</p>
<h1 id="断点设置"><a href="#断点设置" class="headerlink" title="断点设置"></a>断点设置</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>上篇《<a href="https://www.yanbinghu.com/2019/01/08/62137.html">GDB调试指南-启动调试</a>》我们讲到了GDB启动调试的多种方式，分别应用于多种场景。今天我们来介绍一下断点设置的多种方式。<br><!--more--></p>
<h2 id="为何要设置断点"><a href="#为何要设置断点" class="headerlink" title="为何要设置断点"></a>为何要设置断点</h2><p>在介绍之前，我们首先需要了解，为什么需要设置断点。我们在指定位置设置断点之后，程序运行到该位置将会“暂停”，这个时候我们就可以对程序进行更多的操作，比如查看变量内容，堆栈情况等等，以帮助我们调试程序。</p>
<h2 id="查看已设置的断点"><a href="#查看已设置的断点" class="headerlink" title="查看已设置的断点"></a>查看已设置的断点</h2><p>在学习断点设置之前，我们可以使用info breakpoints查看已设置断点：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">info breakpoints</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x00000000004005fc in printNum2 at test.c:17</span><br><span class="line">    breakpoint already hit 1 time</span><br><span class="line">2       hw watchpoint  keep y                      a</span><br><span class="line">    breakpoint already hit 1 time</span><br><span class="line">    ignore next 3 hits</span><br></pre></td></tr></table></figure></p>
<p>它将会列出所有已设置的断点，每一个断点都有一个标号，用来代表这个断点。例如，第2个断点设置是一个观察点，并且会忽略三次。</p>
<h2 id="断点设置-1"><a href="#断点设置-1" class="headerlink" title="断点设置"></a>断点设置</h2><p>断点设置有多种方式，分别应用于不同的场景。借助示例程序进行一一介绍：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNum</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"printNum\n"</span>);</span><br><span class="line">    <span class="keyword">while</span>(a &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a);</span><br><span class="line">        a--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNum2</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"printNum\n"</span>);</span><br><span class="line">    <span class="keyword">while</span>(a &gt; num &amp;&amp; a&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a);</span><br><span class="line">        a--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d,b=%d\n"</span>,a,b);</span><br><span class="line">    <span class="keyword">int</span> temp = a/b;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printNum2(<span class="number">12</span>,<span class="number">5</span>);</span><br><span class="line">    printNum(<span class="number">10</span>);</span><br><span class="line">    div(<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -g -o test test.c</span><br></pre></td></tr></table></figure></p>
<p>注意，编译时需要带上-g参数，具体原因参见《<a href="https://www.yanbinghu.com/2019/01/08/62137.html">GDB调试指南-启动调试</a>》。</p>
<h4 id="根据行号设置断点"><a href="#根据行号设置断点" class="headerlink" title="根据行号设置断点"></a>根据行号设置断点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b 9  #break 可简写为b</span><br></pre></td></tr></table></figure>
<p>或者<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b test.c:9</span><br></pre></td></tr></table></figure></p>
<p>程序运行到第9行的时候会断住。</p>
<h4 id="根据函数名设置断点"><a href="#根据函数名设置断点" class="headerlink" title="根据函数名设置断点"></a>根据函数名设置断点</h4><p>同样可以将断点设置在函数处：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b printNum</span><br></pre></td></tr></table></figure></p>
<p>程序在调用到printNum函数的时候会断住。</p>
<h4 id="根据条件设置断点"><a href="#根据条件设置断点" class="headerlink" title="根据条件设置断点"></a>根据条件设置断点</h4><p>假设程序某处发生崩溃，而崩溃的原因怀疑是某个地方出现了非期望的值，那么你就可以在这里断点观察，当出现该非法值时，程序断住。这个时候我们可以借助gdb来设置条件断点，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">break test.c:23 if b==0</span><br></pre></td></tr></table></figure></p>
<p>当在b等于0时，程序将会在第23行断住。<br>它和condition有着类似的作用，假设上面的断点号为1，那么：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">condition 1 b==0</span><br></pre></td></tr></table></figure></p>
<p>会使得b等于0时，产生断点1。而实际上可以很方便地用来改变断点产生的条件，例如，之前设置b==0时产生该断点，那么使用condition可以修改断点产生的条件。</p>
<h4 id="根据规则设置断点"><a href="#根据规则设置断点" class="headerlink" title="根据规则设置断点"></a>根据规则设置断点</h4><p>例如需要对所有调用printNum函数都设置断点，可以使用下面的方式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rbreak printNum*</span><br></pre></td></tr></table></figure></p>
<p>所有以printNum开头的函数都设置了断点。而下面是对所有函数设置断点：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#用法：rbreak file:regex</span><br><span class="line">rbreak . </span><br><span class="line">rbreak test.c:. #对test.c中的所有函数设置断点</span><br><span class="line">rbreak test.c:^print #对以print开头的函数设置断点</span><br></pre></td></tr></table></figure></p>
<h4 id="设置临时断点"><a href="#设置临时断点" class="headerlink" title="设置临时断点"></a>设置临时断点</h4><p>假设某处的断点只想生效一次，那么可以设置临时断点，这样断点后面就不复存在了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tbreak test.c:l0  #在第10行设置临时断点</span><br></pre></td></tr></table></figure></p>
<h4 id="跳过多次设置断点"><a href="#跳过多次设置断点" class="headerlink" title="跳过多次设置断点"></a>跳过多次设置断点</h4><p>假如有某个地方，我们知道可能出错，但是前面30次都没有问题，虽然在该处设置了断点，但是想跳过前面30次，可以使用下面的方式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ignore 1 30</span><br></pre></td></tr></table></figure></p>
<p>其中，1是你要忽略的断点号，可以通过前面的方式查找到，30是需要跳过的次数。这样设置之后，会跳过前面30次。再次通过info breakpoints可以看到：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x00000000004005e8 in printNum2 at test.c:16</span><br><span class="line">    ignore next 30 hits</span><br></pre></td></tr></table></figure></p>
<h4 id="根据表达式值变化产生断点"><a href="#根据表达式值变化产生断点" class="headerlink" title="根据表达式值变化产生断点"></a>根据表达式值变化产生断点</h4><p>有时候我们需要观察某个值或表达式，知道它什么时候发生变化了，这个时候我们可以借助watch命令。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watch a</span><br></pre></td></tr></table></figure></p>
<p>这个时候，让程序继续运行，如果a的值发生变化，则会打印相关内容，如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hardware watchpoint 2: a</span><br><span class="line">Old value = 12</span><br><span class="line">New value = 11</span><br></pre></td></tr></table></figure></p>
<p>但是这里要特别注意的是，程序必须运行起来，否则会出现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">No symbol &quot;a&quot; in current context.</span><br></pre></td></tr></table></figure></p>
<p>因为程序没有运行，当前上下文也就没有相关变量信息。</p>
<p>rwatch和awatch同样可以设置观察点前者是当变量值被读时断住，后者是被读或者被改写时断住。</p>
<h2 id="禁用或启动断点"><a href="#禁用或启动断点" class="headerlink" title="禁用或启动断点"></a>禁用或启动断点</h2><p>有些断点暂时不想使用，但又不想删除，可以暂时禁用或启用。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">disable  #禁用所有断点</span><br><span class="line">disable bnum #禁用标号为bnum的断点</span><br><span class="line">enable  #启用所有断点</span><br><span class="line">enable bnum #启用标号为bnum的断点</span><br><span class="line">enable delete bnum  #启动标号为bnum的断点，并且在此之后删除该断点</span><br></pre></td></tr></table></figure></p>
<h2 id="断点清除"><a href="#断点清除" class="headerlink" title="断点清除"></a>断点清除</h2><p>断点清除主要用到clear和delete命令。常见使用如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clear   #删除当前行所有breakpoints</span><br><span class="line">clear function  #删除函数名为function处的断点</span><br><span class="line">clear filename:function #删除文件filename中函数function处的断点</span><br><span class="line">clear lineNum #删除行号为lineNum处的断点</span><br><span class="line">clear f:lename：lineNum #删除文件filename中行号为lineNum处的断点</span><br><span class="line">delete  #删除所有breakpoints,watchpoints和catchpoints</span><br><span class="line">delete bnum #删除断点号为bnum的断点</span><br></pre></td></tr></table></figure></p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了常见的断点设置方法，断点设置之后，可以便于我们后期观察变量，堆栈等信息，为进一步的定位与调试做准备。</p>
<h1 id="变量查看"><a href="#变量查看" class="headerlink" title="变量查看"></a>变量查看</h1><h2 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h2><p>在启动调试以及设置断点之后，就到了我们非常关键的一步-查看变量。GDB调试最大的目的之一就是走查代码，查看运行结果是否符合预期。既然如此，我们就不得不了解一些查看各种类型变量的方法，以帮助我们进一步定位问题。<br><!--more--></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在查看变量之前，需要先启动调试并设置断点，该部分内容可参考《<a href="https://www.yanbinghu.com/2019/01/08/62137.html">GDB调试指南－启动调试</a>》和《<a href="https://www.yanbinghu.com/2019/02/24/44483.html">GDB调试指南－断点设置</a>》。后面的内容都基于在某个位置已经断住。</p>
<p>本文辅助说明程序如下:<br>testGdb.c<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//testGdb.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"testGdb.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">//整型</span></span><br><span class="line">    <span class="keyword">int</span> b[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;  <span class="comment">//数组</span></span><br><span class="line">    <span class="keyword">char</span> c[] = <span class="string">"hello,shouwang"</span>;<span class="comment">//字符数组</span></span><br><span class="line">    <span class="comment">/*申请内存，失败时退出*/</span>    </span><br><span class="line">    <span class="keyword">int</span> *d = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(a*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == d)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"malloc error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*赋值*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        d[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(d);</span><br><span class="line">    d = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">float</span> e = <span class="number">8.5f</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>testGdb.h<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">11</span>;</span><br></pre></td></tr></table></figure></p>
<p>编译：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -g -o testGdb testGdb.o</span><br></pre></td></tr></table></figure></p>
<h2 id="普通变量查看"><a href="#普通变量查看" class="headerlink" title="普通变量查看"></a>普通变量查看</h2><h4 id="打印基本类型变量，数组，字符数组"><a href="#打印基本类型变量，数组，字符数组" class="headerlink" title="打印基本类型变量，数组，字符数组"></a>打印基本类型变量，数组，字符数组</h4><p>最常见的使用便是使用print（可简写为p）打印变量内容。<br>例如，打印基本类型，数组，字符数组等直接使用p 变量名即可：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">(gdb) p a</span><br><span class="line">$1 = 10</span><br><span class="line">(gdb) p b</span><br><span class="line">$2 = &#123;1, 2, 3, 5&#125;</span><br><span class="line">(gdb) p c</span><br><span class="line">$3 = &quot;hello,shouwang&quot;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>当然有时候，多个函数或者多个文件会有同一个变量名，这个时候可以在前面加上函数名或者文件名来区分：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) p &apos;testGdb.h&apos;::a</span><br><span class="line">$1 = 11</span><br><span class="line">(gdb) p &apos;main&apos;::b</span><br><span class="line">$2 = &#123;1, 2, 3, 5&#125;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>这里所打印的a值是我们定义在testGdb.h文件里的，而b值是main函数中的b。</p>
<h4 id="打印指针指向内容"><a href="#打印指针指向内容" class="headerlink" title="打印指针指向内容"></a>打印指针指向内容</h4><p>如果还是使用上面的方式打印指针指向的内容，那么打印出来的只是指针地址而已，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) p d</span><br><span class="line">$1 = (int *) 0x602010</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>而如果想要打印指针指向的内容，需要解引用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) p *d</span><br><span class="line">$2 = 0</span><br><span class="line">(gdb) p *d@10</span><br><span class="line">$3 = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看到，仅仅使用*只能打印第一个值，如果要打印多个值，后面跟上@并加上要打印的长度。<br>或者@后面跟上变量值：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) p *d@a</span><br><span class="line">$2 = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>由于a的值为10，并且是作为整型指针数据长度，因此后面可以直接跟着a，也可以打印出所有内容。</p>
<p>另外值得一提的是，$可表示上一个变量，而假设此时有一个链表linkNode，它有next成员代表下一个节点，则可使用下面方式不断打印链表内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) p *linkNode</span><br><span class="line">(这里显示linkNode节点内容)</span><br><span class="line">(gdb) p *$.next</span><br><span class="line">(这里显示linkNode节点下一个节点的内容)</span><br></pre></td></tr></table></figure></p>
<p>如果想要查看前面数组的内容，你可以将下标一个一个累加，还可以定义一个类似UNIX环境变量，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) set $index=0</span><br><span class="line">(gdb) p b[$index++]</span><br><span class="line">$11 = 1</span><br><span class="line">(gdb) p b[$index++]</span><br><span class="line">$12 = 2</span><br><span class="line">(gdb) p b[$index++]</span><br><span class="line">$13 = 3</span><br></pre></td></tr></table></figure></p>
<p>这样就不需要每次修改下标去打印啦。</p>
<h2 id="按照特定格式打印变量"><a href="#按照特定格式打印变量" class="headerlink" title="按照特定格式打印变量"></a>按照特定格式打印变量</h2><p>对于简单的数据，print默认的打印方式已经足够了，它会根据变量类型的格式打印出来，但是有时候这还不够，我们需要更多的格式控制。常见格式控制字符如下：</p>
<ul>
<li>x 按十六进制格式显示变量。</li>
<li>d 按十进制格式显示变量。</li>
<li>u 按十六进制格式显示无符号整型。</li>
<li>o 按八进制格式显示变量。</li>
<li>t 按二进制格式显示变量。</li>
<li>a 按十六进制格式显示变量。</li>
<li>c 按字符格式显示变量。</li>
<li>f 按浮点数格式显示变量。</li>
</ul>
<p>还是以辅助程序来说明，正常方式打印字符数组c：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) p c</span><br><span class="line">$18 = &quot;hello,shouwang&quot;</span><br></pre></td></tr></table></figure></p>
<p>但是如果我们要查看它的十六进制格式打印呢？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) p/x c</span><br><span class="line">$19 = &#123;0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x73, 0x68, 0x6f, 0x75, 0x77, 0x61, </span><br><span class="line">  0x6e, 0x67, 0x0&#125;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>但是如果我们想用这种方式查看浮点数的二进制格式是怎样的是不行的，因为直接打印它首先会被转换成整型，因此最终会得到8：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) p e</span><br><span class="line">$1 = 8.5</span><br><span class="line">(gdb) p/t e</span><br><span class="line">$2 = 1000</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>那么就需要另外一种查看方式了。</p>
<h2 id="查看内存内容"><a href="#查看内存内容" class="headerlink" title="查看内存内容"></a>查看内存内容</h2><p>examine(简写为x)可以用来查看内存地址中的值。语法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x/[n][f][u] addr</span><br></pre></td></tr></table></figure></p>
<p>其中：</p>
<ul>
<li>n 表示要显示的内存单元数，默认值为1</li>
<li>f 表示要打印的格式，前面已经提到了格式控制字符</li>
<li>u 要打印的单元长度</li>
<li>addr 内存地址</li>
</ul>
<p>单元类型常见有如下：</p>
<ul>
<li>b 字节</li>
<li>h 半字，即双字节</li>
<li>w 字，即四字节</li>
<li>g 八字节</li>
</ul>
<p>我们通过一个实例来看，假如我们要把float变量e按照二进制方式打印，并且打印单位是一字节：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) x/4tb &amp;e</span><br><span class="line">0x7fffffffdbd4:    00000000    00000000    00001000    01000001</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>可以看到，变量e的四个字节都以二进制的方式打印出来了。</p>
<h2 id="自动显示变量内容"><a href="#自动显示变量内容" class="headerlink" title="自动显示变量内容"></a>自动显示变量内容</h2><p>假设我们希望程序断住时，就显示某个变量的值，可以使用display命令。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) display e</span><br><span class="line">1: e = 8.5</span><br></pre></td></tr></table></figure></p>
<p>那么每次程序断住时，就会打印e的值。要查看哪些变量被设置了display，可以使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb)info display</span><br><span class="line">Auto-display expressions now in effect:</span><br><span class="line">Num Enb Expression</span><br><span class="line">1:   y  b</span><br><span class="line">2:   y  e</span><br></pre></td></tr></table></figure></p>
<p>如果想要清除可以使用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete display num #num为前面变量前的编号,不带num时清除所有。</span><br></pre></td></tr></table></figure></p>
<p>或者去使能：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">disable display num  #num为前面变量前的编号，不带num时去使能所有</span><br></pre></td></tr></table></figure></p>
<h2 id="查看寄存器内容"><a href="#查看寄存器内容" class="headerlink" title="查看寄存器内容"></a>查看寄存器内容</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb)info registers</span><br><span class="line">rax            0x0    0</span><br><span class="line">rbx            0x0    0</span><br><span class="line">rcx            0x7ffff7dd1b00    140737351850752</span><br><span class="line">rdx            0x0    0</span><br><span class="line">rsi            0x7ffff7dd1b30    140737351850800</span><br><span class="line">rdi            0xffffffff    4294967295</span><br><span class="line">rbp            0x7fffffffdc10    0x7fffffffdc10</span><br><span class="line">(内容过多未显示完全)</span><br></pre></td></tr></table></figure>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>通过不同方式查看变量值或者内存值能够极大的帮助我们判断程序的运行是否符合我们的预期，如果发现观察的值不是我们预期的时候，就需要检查我们的代码了。</p>
<h1 id="单步调试"><a href="#单步调试" class="headerlink" title="单步调试"></a>单步调试</h1><h2 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h2><p>前面通过《<a href="https://www.yanbinghu.com/2019/01/08/62137.html">启动调试</a>》，《<a href="https://www.yanbinghu.com/2019/02/24/44483.html">断点设置</a>》，《<a href="https://www.yanbinghu.com/2019/03/10/50132.html">变量查看</a>》,我们已经了解了GDB基本的启动，设置断点，查看变量等，如果这些内容你还不知道，建议先回顾一下前面的内容。在启动调试设置断点观察之后，没有我们想要的信息怎么办呢？这个时候，就需要单步执行或者跳过当前断点继续执行等等。而本文所说的单步调试并非仅仅指单步执行，而是指在你的控制之下，按要求执行语句。<br><!--more--></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>老规矩，先准备一个示例程序如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*gdbStep.c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/*计算简单乘法,这里没有考虑溢出*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*打印从0到num-1的数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> &gt; num)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">7</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"it will calc a + b\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> c = add(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d + %d = %d\n"</span>,a,b,c);</span><br><span class="line">    count(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -g -o gdbStep gdbStep.c</span><br></pre></td></tr></table></figure></p>
<p>程序的功能比较简单，这里不多做解释。</p>
<p>特别简单说明一条命令，list（可简写为l），它可以将源码列出来，例如：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="built_in">list</span></span><br><span class="line"><span class="number">1</span>    <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="number">2</span>    </span><br><span class="line"><span class="number">3</span>    <span class="comment">/*计算简单乘法,这里没有考虑溢出*/</span></span><br><span class="line"><span class="number">4</span>    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">5    </span>&#123;</span><br><span class="line"><span class="number">6</span>        <span class="keyword">int</span> c = a * b;</span><br><span class="line"><span class="number">7</span>        <span class="keyword">return</span> c;</span><br><span class="line"><span class="number">8</span>    &#125;</span><br><span class="line"><span class="number">9</span>    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">10    </span>&#123;</span><br><span class="line">(gdb) l</span><br><span class="line"><span class="number">11</span>        <span class="keyword">int</span> a = <span class="number">13</span>;</span><br><span class="line"><span class="number">12</span>        <span class="keyword">int</span> b = <span class="number">57</span>;</span><br><span class="line"><span class="number">13</span>        <span class="built_in">printf</span>(<span class="string">"it will calc a * b\n"</span>);</span><br><span class="line"><span class="number">14</span>        <span class="keyword">int</span> c = add(a,b);</span><br><span class="line"><span class="number">15</span>        <span class="built_in">printf</span>(<span class="string">"%d*%d = %d\n"</span>,a,b,c);</span><br><span class="line"><span class="number">16</span>        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">17</span>    &#125;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<h2 id="单步执行-next"><a href="#单步执行-next" class="headerlink" title="单步执行-next"></a>单步执行-next</h2><p>next命令（可简写为n）用于在程序断住后，继续执行下一条语句，假设已经启动调试，并在第12行停住，如果要继续执行，则使用n执行下一条语句，如果后面跟上数字num，则表示执行该命令num次，就达到继续执行n行的效果了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gdb gdbStep   #启动调试</span><br><span class="line">(gdb)b 25       #将断点设置在12行</span><br><span class="line">(gdb)run        #运行程序</span><br><span class="line">Breakpoint 1, main () at gdbStep.c:25</span><br><span class="line">25        int b = 7;</span><br><span class="line">(gdb) n     #单步执行</span><br><span class="line">26        printf(&quot;it will calc a + b\n&quot;);</span><br><span class="line">(gdb) n 2   #执行两次</span><br><span class="line">it will calc a + b</span><br><span class="line">28        printf(&quot;%d + %d = %d\n&quot;,a,b,c);</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>从上面的执行结果可以看到，我们在25行处断住，执行n之后，运行到26行，运行n 2之后，运行到28行，但是有没有发现一个问题，为什么不会进入到add函数内部呢？那就需要用到另外一个命令啦。</p>
<h2 id="单步进入-step"><a href="#单步进入-step" class="headerlink" title="单步进入-step"></a>单步进入-step</h2><p>对于上面的情况，如果我们想跟踪add函数内部的情况，可以使用step命令（可简写为s），它可以单步跟踪到函数内部，但前提是该函数有调试信息并且有源码信息。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gdb gdbStep    #启动调试</span><br><span class="line">(gdb) b 25       #在12行设置断点</span><br><span class="line">Breakpoint 1 at 0x4005d3: file gdbStep.c, line 25.</span><br><span class="line">(gdb) run        #运行程序</span><br><span class="line">Breakpoint 1, main () at gdbStep.c:25</span><br><span class="line">25        int b = 7;</span><br><span class="line">(gdb) s          </span><br><span class="line">26        printf(&quot;it will calc a + b\n&quot;);</span><br><span class="line">(gdb) s     #单步进入，但是并没有该函数的源文件信息</span><br><span class="line">_IO_puts (str=0x4006b8 &quot;it will calc a + b&quot;) at ioputs.c:33</span><br><span class="line">33    ioputs.c: No such file or directory.</span><br><span class="line">(gdb) finish    #继续完成该函数调用</span><br><span class="line">Run till exit from #0  _IO_puts (str=0x4006b8 &quot;it will calc a + b&quot;)</span><br><span class="line">    at ioputs.c:33</span><br><span class="line">it will calc a + b</span><br><span class="line">main () at gdbStep.c:27</span><br><span class="line">27        int c = add(a,b);</span><br><span class="line">Value returned is $1 = 19</span><br><span class="line">(gdb) s        #单步进入，现在已经进入到了add函数内部</span><br><span class="line">add (a=13, b=57) at gdbStep.c:6</span><br><span class="line">6        int c = a + b;</span><br></pre></td></tr></table></figure></p>
<p>从上面的过程可以看到，s命令会尝试进入函数，但是如果没有该函数源码，需要跳过该函数执行，可使用finish命令，继续后面的执行。如果没有函数调用，s的作用与n的作用并无差别，仅仅是继续执行下一行。它后面也可以跟数字，表明要执行的次数。</p>
<p>当然它还有一个选项，用来设置当遇到没有调试信息的函数，s命令是否跳过该函数，而执行后面的。默认情况下，它是会跳过的，即step-mode值是off：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) show step-mode </span><br><span class="line">Mode of the step operation is off.</span><br><span class="line">(gdb) set step-mode on</span><br><span class="line">(gdb) set step-mode off</span><br></pre></td></tr></table></figure></p>
<p>还有一个与step相关的命令是stepi（可简写为si），它与step不同的是，每次执行一条机器指令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) si</span><br><span class="line">0x0000000000400573    6        int c = a + b;</span><br><span class="line">(gdb) display/i $pc</span><br><span class="line">1: x/i $pc</span><br><span class="line">=&gt; 0x400573 &lt;add+13&gt;:    mov    -0x18(%rbp),%eax</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<h2 id="继续执行到下一个断点-continue"><a href="#继续执行到下一个断点-continue" class="headerlink" title="继续执行到下一个断点-continue"></a>继续执行到下一个断点-continue</h2><p>我们可能打了多处断点，或者断点打在循环内，这个时候，想跳过这个断点，甚至跳过多次断点继续执行该怎么做呢？可以使用continue命令（可简写为c）或者fg，它会继续执行程序，直到再次遇到断点处：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gdb gdbStep</span><br><span class="line">(gdb)b 18    #在count函数循环内打断点</span><br><span class="line">(gdb)run</span><br><span class="line">Breakpoint 1, count (num=10) at gdbStep.c:18</span><br><span class="line">18            i++;</span><br><span class="line">(gdb) c      #继续运行，直到下一次断住</span><br><span class="line">Continuing.</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">Breakpoint 1, count (num=10) at gdbStep.c:18</span><br><span class="line">18            i++;</span><br><span class="line">(gdb) fg     #继续运行，直到下一次断住</span><br><span class="line">Continuing.</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">Breakpoint 1, count (num=10) at gdbStep.c:18</span><br><span class="line">18            i++;</span><br><span class="line">(gdb) c 3    #跳过三次</span><br><span class="line">Will ignore next 2 crossings of breakpoint 1.  Continuing.</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">Breakpoint 1, count (num=10) at gdbStep.c:18</span><br><span class="line">18            i++;</span><br></pre></td></tr></table></figure></p>
<h2 id="继续运行到指定位置-until"><a href="#继续运行到指定位置-until" class="headerlink" title="继续运行到指定位置-until"></a>继续运行到指定位置-until</h2><p>假如我们在25行停住了，现在想要运行到29行停住，就可以使用until命令（可简写为u）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gdb gdbStep</span><br><span class="line">(gdb)b 25</span><br><span class="line">(gdb)run</span><br><span class="line">(gdb) u 29</span><br><span class="line">it will calc a + b</span><br><span class="line">3 + 7 = 10</span><br><span class="line">main () at gdbStep.c:29</span><br><span class="line">29        count(c);</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>可以看到，在执行u 29之后，它在29行停住了。它利用的是临时断点。</p>
<h2 id="跳过执行—skip"><a href="#跳过执行—skip" class="headerlink" title="跳过执行—skip"></a>跳过执行—skip</h2><p>skip可以在step时跳过一些不想关注的函数或者某个文件的代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gdb gdbStep</span><br><span class="line">(gdb) b 27</span><br><span class="line">Breakpoint 1 at 0x4005e4: file gdbStep.c, line 27.</span><br><span class="line">(gdb) skip function add    #step时跳过add函数</span><br><span class="line">Function add will be skipped when stepping.</span><br><span class="line">(gdb) info skip   #查看step情况</span><br><span class="line">Num     Type           Enb What</span><br><span class="line">1       function       y   add</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/hyb/workspaces/gdb/gdbStep </span><br><span class="line">it will calc a + b</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at gdbStep.c:27</span><br><span class="line">27        int c = add(a,b);</span><br><span class="line">(gdb) s</span><br><span class="line">28        printf(&quot;%d + %d = %d\n&quot;,a,b,c);</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>可以看到，再使用skip之后，使用step将不会进入add函数。<br>step也后面也可以跟文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb)skip file gdbStep.c</span><br></pre></td></tr></table></figure></p>
<p>这样gdbStep.c中的函数都不会进入。</p>
<p>其他相关命令：</p>
<ul>
<li>skip delete [num] 删除skip</li>
<li>skip enable [num] 使能skip</li>
<li>skip disable [num] 去使能skip</li>
</ul>
<p>其中num是前面通过info skip看到的num值，上面可以带或不带该值，如果不带num，则针对所有skip，如果带上了，则只针对某一个skip。</p>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了一些简单情况的单步调试方法或常见命令使用，但这些已经够用了，毕竟大部分程序的执行或停止都在我们的掌控之中了。</p>
<h1 id="源码查看"><a href="#源码查看" class="headerlink" title="源码查看"></a>源码查看</h1><h2 id="前言-4"><a href="#前言-4" class="headerlink" title="前言"></a>前言</h2><p>我们在调试过程中难免要对照源码进行查看，如果已经开始了调试，而查看源码或者编辑源码却要另外打开一个窗口，那未免显得太麻烦。文本将会介绍如何在GDB调试模式下<strong>查看源码或对源码进行编辑</strong>。<br><!--more--></p>
<h2 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h2><p>为了说明后面的内容，我们先准备一些源码，分别是main.c：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"test.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"it will print from 5 to 1\n"</span>);</span><br><span class="line">    printNum(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"print end\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"it will print 1 to 5\n"</span>);</span><br><span class="line">    printNum1(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"print end\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>头文件test.h：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _TEST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TEST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNum</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNum1</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>以及test.c:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"test.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNum</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n);</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNum1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -g  -o main  main.c test.c</span><br><span class="line">$ chmod +x main</span><br><span class="line">$ ./main</span><br><span class="line">it will print from 5 to 1</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">print end</span><br><span class="line">it will print 1 to 5</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">print end</span><br></pre></td></tr></table></figure></p>
<p>程序功能比较简单，用来打印5到1的数以及1到5的数，这里也就不多做解释。</p>
<h2 id="列出源码"><a href="#列出源码" class="headerlink" title="列出源码"></a>列出源码</h2><p>首先要介绍的就是list命令（可简写为l），它用来打印源码。</p>
<h4 id="直接打印源码"><a href="#直接打印源码" class="headerlink" title="直接打印源码"></a>直接打印源码</h4><p>例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gdb main</span><br><span class="line">(gdb) l</span><br><span class="line">1    //main.c</span><br><span class="line">2    #include&lt;stdio.h&gt;</span><br><span class="line">3    #include&quot;test.h&quot;</span><br><span class="line">4    int main(void)</span><br><span class="line">5    &#123;</span><br><span class="line">6        printf(&quot;it will print from 5 to 1\n&quot;);</span><br><span class="line">7        printNum(5);</span><br><span class="line">8        printf(&quot;print end\n&quot;);</span><br><span class="line">9    </span><br><span class="line">10        printf(&quot;it will print 1 to 5\n&quot;);</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>直接输入l可从第一行开始显示源码，继续输入l，可列出后面的源码。后面也可以跟上+或者-，分别表示要列出上一次列出源码的后面部分或者前面部分。</p>
<h4 id="列出指定行附近源码"><a href="#列出指定行附近源码" class="headerlink" title="列出指定行附近源码"></a>列出指定行附近源码</h4><p>l后面可以跟行号，表明要列出附近的源码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) l 9</span><br><span class="line">4    int main(void)</span><br><span class="line">5    &#123;</span><br><span class="line">6        printf(&quot;it will print from 5 to 1\n&quot;);</span><br><span class="line">7        printNum(5);</span><br><span class="line">8        printf(&quot;print end\n&quot;);</span><br><span class="line">9    </span><br><span class="line">10        printf(&quot;it will print 1 to 5\n&quot;);</span><br><span class="line">11        printNum1(5);</span><br><span class="line">12        printf(&quot;print end\n&quot;);</span><br><span class="line">13        return 0;</span><br></pre></td></tr></table></figure></p>
<p>在这里，l后面跟上9，表明要列出第9行附近的源码。</p>
<h4 id="列出指定函数附近的源码"><a href="#列出指定函数附近的源码" class="headerlink" title="列出指定函数附近的源码"></a>列出指定函数附近的源码</h4><p>这个很容易理解，而使用也很简单，l后面跟函数名即可，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) l printNum</span><br><span class="line">1    #include&quot;test.h&quot;</span><br><span class="line">2    void printNum(int n)</span><br><span class="line">3    &#123;</span><br><span class="line">4        if( n &lt; 0)</span><br><span class="line">5            return;</span><br><span class="line">6        while(n &gt; 0)</span><br><span class="line">7        &#123;</span><br><span class="line">8            printf(&quot;%d\n&quot;,n);</span><br><span class="line">9            n--;</span><br><span class="line">10        &#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里，l后面跟上函数名printNum，它便列出了printNum函数附近的源码。</p>
<h4 id="设置源码一次列出行数"><a href="#设置源码一次列出行数" class="headerlink" title="设置源码一次列出行数"></a>设置源码一次列出行数</h4><p>不知道你有没有发现，在列出函数源码的时候，它并没有列全，因为l每次只显示10行，那么有没有方法每次列出更多呢？<br>我们可以通过listsize属性来设置，例如设置每次列出20行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) set listsize 20</span><br><span class="line">(gdb) show listsize</span><br><span class="line">Number of source lines gdb will list by default is 20.</span><br></pre></td></tr></table></figure></p>
<p>这样每次就会列出20行，当然也可以设置为0或者unlimited，这样设置之后，列出就没有限制了，但源码如果较长，查看将会不便。</p>
<h4 id="列出指定行之间的源码"><a href="#列出指定行之间的源码" class="headerlink" title="列出指定行之间的源码"></a>列出指定行之间的源码</h4><p>list first,last<br>例如，要列出3到15行之间的源码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) l 3,15</span><br><span class="line">3    &#123;</span><br><span class="line">4        if( n &lt; 0)</span><br><span class="line">5            return;</span><br><span class="line">6        while(n &gt; 0)</span><br><span class="line">7        &#123;</span><br><span class="line">8            printf(&quot;%d\n&quot;,n);</span><br><span class="line">9            n--;</span><br><span class="line">10        &#125;</span><br><span class="line">11    &#125;</span><br><span class="line">12    </span><br><span class="line">13    void printNum1(int n)</span><br><span class="line">14    &#123;</span><br><span class="line">15        if( n &lt; 0)</span><br></pre></td></tr></table></figure></p>
<p>启始行和结束行号之间用逗号隔开。两者之一也可以省略，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) list 3,</span><br><span class="line">3    &#123;</span><br><span class="line">4        if( n &lt; 0)</span><br><span class="line">5            return;</span><br><span class="line">6        while(n &gt; 0)</span><br><span class="line">7        &#123;</span><br><span class="line">8            printf(&quot;%d\n&quot;,n);</span><br><span class="line">9            n--;</span><br><span class="line">10        &#125;</span><br><span class="line">11    &#125;</span><br><span class="line">12</span><br></pre></td></tr></table></figure></p>
<p>省略结束行的时候，它列出从开始行开始，到指定大小行结束，而省略开始行的时候，到结束行结束，列出设置的大小行，例如默认设置为10行，则到结束行为止，总共列出10行。前面我们也介绍了修改和查看默认列出源码行数的方法。</p>
<h4 id="列出指定文件的源码"><a href="#列出指定文件的源码" class="headerlink" title="列出指定文件的源码"></a>列出指定文件的源码</h4><p>前面执行l命令时，默认列出main.c的源码，如果想要看指定文件的源码呢？可以<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l location</span><br></pre></td></tr></table></figure></p>
<p>其中location可以是<strong>文件名加行号或函数名</strong>，因此可以使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) l test.c:1</span><br><span class="line">1    #include&quot;test.h&quot;</span><br><span class="line">2    void printNum(int n)</span><br><span class="line">3    &#123;</span><br><span class="line">4        if( n &lt; 0)</span><br><span class="line">5            return;</span><br><span class="line">6        while(n &gt; 0)</span><br><span class="line">7        &#123;</span><br><span class="line">8            printf(&quot;%d\n&quot;,n);</span><br><span class="line">9            n--;</span><br><span class="line">10        &#125;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>来查看指定文件指定行，或者指定文件指定函数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) l test.c:printNum1</span><br><span class="line">9            n--;</span><br><span class="line">10        &#125;</span><br><span class="line">11    &#125;</span><br><span class="line">12    </span><br><span class="line">13    void printNum1(int n)</span><br><span class="line">14    &#123;</span><br><span class="line">15        if( n &lt; 0)</span><br><span class="line">16            return;</span><br><span class="line">17        int i = 1;</span><br><span class="line">18        while(i &lt;= n)</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>或者指定文件指定行之间：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) l test.c:1,test.c:3</span><br><span class="line">1    #include&quot;test.h&quot;</span><br><span class="line">2    void printNum(int n)</span><br><span class="line">3    &#123;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<h2 id="指定源码路径"><a href="#指定源码路径" class="headerlink" title="指定源码路径"></a>指定源码路径</h2><p>在查看源码之前，首先要确保我们的程序能够关联到源码，一般来说，我们在自己的机器上加上-g参数编译完之后，使用gdb都能查看到源码，但是如果出现下面的情况呢？</p>
<h4 id="源码被移走"><a href="#源码被移走" class="headerlink" title="源码被移走"></a>源码被移走</h4><p>例如，我现在将main.c移动到当前的temp目录下，再执行l命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line">1    main.c: No such file or directory.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>它就会提示找不到源码文件了，那么怎么办呢？<br>我们可以使用dir命名指定源码路径，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) dir ./temp</span><br><span class="line">Source directories searched: /home/hyb/workspaces/gdb/sourceCode/./temp:$cdir:$cwd</span><br></pre></td></tr></table></figure></p>
<p>这个时候它就能找到源码路径了。我这里使用的是相对路径，保险起见，你也可以使用绝对路径。</p>
<h4 id="更换源码目录"><a href="#更换源码目录" class="headerlink" title="更换源码目录"></a>更换源码目录</h4><p>例如，你编译好的程序文件，放到了另外一台机器上进行调试，或者你的源码文件全都移动到了另外一个目录，怎么办呢？当然你还可以使用前面的方法添加源码搜索路径，也可以使用set substitute-path from to将原来的路径替换为新的路径，那么我们如何知道原来的源码路径是什么呢？借助readelf命令可以知道：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ readelf main -p .debug_str</span><br><span class="line">  [     0]  long unsigned int</span><br><span class="line">  [    12]  short int</span><br><span class="line">  [    1c]  /home/hyb/workspaces/gdb/sourceCode</span><br><span class="line">  [    40]  main.c</span><br><span class="line">（显示部分内容）</span><br></pre></td></tr></table></figure></p>
<p>main为你将要调试的程序名，这里我们可以看到原来的路径，那么我们现在替换掉它：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) set substitute-path /home/hyb/workspaces/gdb/sourceCode /home/hyb/workspaces/gdb/sourceCode/temp</span><br><span class="line">(gdb) show substitute-path</span><br><span class="line">List of all source path substitution rules:</span><br><span class="line">  `/home/hyb/workspaces/gdb/sourceCode&apos; -&gt; `/home/hyb/workspaces/gdb/sourceCode/temp&apos;.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>设置完成后，可以通过show substitute-path来查看设置结果。这样它也能在正确的路径查找源码啦。</p>
<p>需要注意的是，这里<strong>对路径做了字符串替换</strong>，那么如果你有多个路径，可以做多个替换。甚至可以对指定文件路径进行替换。</p>
<p>最后你也可以通过unset substitute-path [path]取消替换。</p>
<h2 id="编辑源码"><a href="#编辑源码" class="headerlink" title="编辑源码"></a>编辑源码</h2><p>为了避免已经启动了调试之后，需要编辑源码，又不想退出，可以直接在gdb模式下编辑源码，它默认使用的编辑器是/bin/ex，但是你的机器上可能没有这个编辑器，或者你想使用自己熟悉的编辑器，那么可以通过下面的方式进行设置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ EDITOR=/usr/bin/vim</span><br><span class="line">$ export EDITOR</span><br></pre></td></tr></table></figure></p>
<p>/usr/bin/vim可以替换为你熟悉的编辑器的路径，如果你不知道你的编辑器在什么位置，可借助whereis命令或者witch命令查看：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ whereis vim</span><br><span class="line">vim: /usr/bin/vim /usr/bin/vim.tiny /usr/bin/vim.basic /usr/bin/vim.gnome /etc/vim /usr/share/vim /usr/share/man/man1/vim.1.gz</span><br><span class="line">$ which vim</span><br><span class="line">/usr/bin/vim</span><br></pre></td></tr></table></figure></p>
<p>设置之后，就可以在gdb调试模式下进行编辑源码了，使用命令edit location，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb)edit 3  #编辑第三行</span><br><span class="line">(gdb)edit printNum #编辑printNum函数</span><br><span class="line">(gdb)edit test.c:5 #编辑test.c第五行</span><br></pre></td></tr></table></figure>
<p>可自行尝试，这里的location和前面介绍的一样，可以跟指定文件的特定行或指定文件的指定函数。<br>编辑完保存后，别忘了重新编译程序：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb)shell gcc -g -o main main.c test.c</span><br></pre></td></tr></table></figure></p>
<p>这里要注意，为了在gdb调试模式下执行shell命令，需要在命令之前加上shell，表明这是一条shell命令。这样就能在不用退出GDB调试模式的情况下编译程序了。</p>
<h2 id="另外一种模式"><a href="#另外一种模式" class="headerlink" title="另外一种模式"></a>另外一种模式</h2><p>启动时，带上tui(Text User Interface)参数，会有意想不到的效果，它会将调试在多个文本窗口呈现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb main -tui</span><br></pre></td></tr></table></figure></p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/GDB%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97-%E6%BA%90%E7%A0%81%E6%9F%A5%E7%9C%8B/gdb-tui.png" alt="GDB-TUI"></p>
<p>但是本文不作介绍，有兴趣的可以探索一下。</p>
<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了GDB调试中的源码查看，源码编辑以及如何在GDB调试模式下执行shell命令。</p>
]]></content>
      <categories>
        <category>gdb</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>《深入Linux内核架构》摘要</title>
    <url>/2019/04/18/48046.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文为《深入Linux内核》一书部分内容摘要。<br><a id="more"></a></p>
<h2 id="简介和概述"><a href="#简介和概述" class="headerlink" title="简介和概述"></a>简介和概述</h2><h4 id="地址空间与特权级别"><a href="#地址空间与特权级别" class="headerlink" title="地址空间与特权级别"></a>地址空间与特权级别</h4><ul>
<li>32位系统，每个进程的地址空间是3GB,1Gb内核空间。这种划分与内存的数量无关，当然这种比例可以通过配置来修改</li>
<li>64位系统情况更复杂，它们倾向于使用小于64位的理论最大虚拟地址空间，这样管理有效地址空间所需的位数较少。</li>
<li>intel处理器分四种特权级别，linux只有使用了两种，核心态和用户态。从用户态道核心态需要通过系统调用来切换。</li>
<li>ps fax查看的结果中，用方括号扩起来的是内核线程。</li>
<li>多数情况下，虚拟地址空间要比可用的物理内存要大。</li>
<li>物理内存页常常被称为页帧，页则专指虚拟地址空间中的页。</li>
<li>用来将虚拟地址空间映射到物理地址空间的数据结构称为页表。</li>
<li>由于页表通常是4KB这样导致记录页表的数据也非常大，因此采用个多级分页。linux采用了四级页表。32位两级，64位三级或四级</li>
<li>内存映射，映射方法可以将任意来源的数据传输到进程虚拟地址空间中。</li>
</ul>
<h4 id="物理内存的分配"><a href="#物理内存的分配" class="headerlink" title="物理内存的分配"></a>物理内存的分配</h4><ul>
<li>内核中很多时候要求分配连续页。为快速检测内存中的连续区域，内核采用了一种古老而历经检验的技术：伙伴系统</li>
<li>由于内核无法使用标准库的函数，因而必须在伙伴系统基础上自行定义额外的内存管理层，将伙伴系统提供的页划分为更小的部分。-slab缓存。</li>
</ul>
<h2 id="进程管理和调度"><a href="#进程管理和调度" class="headerlink" title="进程管理和调度"></a>进程管理和调度</h2><h4 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h4><ul>
<li>进程可分为实时进程和非实时进程</li>
<li>通常有，硬实时进程，软实时进程，普通进程</li>
</ul>
<h4 id="进程生命周期"><a href="#进程生命周期" class="headerlink" title="进程生命周期"></a>进程生命周期</h4><ul>
<li>运行态：进程正在执行</li>
<li>等待态（就绪）：进程能够运行，但是没有许可，需要等待CPU时间</li>
<li>睡眠态（阻塞态）：进程阻塞无法运行，它正在等待一个外部事件</li>
<li>进程无法直接从阻塞态直接变为运行态</li>
<li>从用户态切换到核心态，通常方法有系统调用，中断（例如进入系统的网络数据包）</li>
<li>普通进程总是可能被抢占</li>
<li>如果系统处理核心态，那么系统中的其他进程无法夺取CPU时间，但中断可以中止系统调用</li>
<li>中断可以暂停处于用户态和核心态的进程。中断具有最高优先级</li>
</ul>
<h4 id="进程类型"><a href="#进程类型" class="headerlink" title="进程类型"></a>进程类型</h4><ul>
<li>新进程是使用fork和exec系统调用产生的</li>
<li>fork生成当前进程的一个相同副本，该副本称之为子进程。原进程的所有资源都以适当的方式复制到子进程。注意，fork采用了写时复制技术</li>
<li>exec从一个可执行的二进制文件加载另一个应用程序，来代替当前运行的进程。</li>
</ul>
<h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><ul>
<li>全局资源可以通过命名空间抽象起来，这使得可以将一组进程放置到容器中，哥哥容器彼此隔离。</li>
</ul>
<h4 id="进程ID号"><a href="#进程ID号" class="headerlink" title="进程ID号"></a>进程ID号</h4><ul>
<li>UNIX进程总是会分配一个号码用于在其命名空间中唯一地标识它们。该号码称作进程ID号</li>
<li>分配一个空闲的piu，本质上就等同于寻找位图中第一个值位0的比特，释放一个pid可通过将对应的比特从1切换为0来实现。</li>
</ul>
<h4 id="进程管理相关的系统调用"><a href="#进程管理相关的系统调用" class="headerlink" title="进程管理相关的系统调用"></a>进程管理相关的系统调用</h4><ul>
<li>fork是重量级调用，因为它建立了父进程的一个完整副本，然后作为子进程执行。</li>
<li>vfokr类似于fork，但并不创建父进程数据的副本。相反，父子进程之间共享数据。它用于子进程形成后，立即执行execve系统调用加载新程序的情形。但是由于fork使用了写时复制技术，vfork在速度方面不再有优势。</li>
<li>clone产生线程，可以对父子进程之间的工农乡，复制进行精确控制</li>
<li>写时复制技术。fork时，并不复制进程的整个地址空间，而只复制其页表，这样就建立了虚拟地址空间和物理内存页之间的联系。只要一个进程师徒像复制的内存页写入，处理器就会像内核报告访问错误。如果该页是可读可写，则进行复制。写时复制机制使得内核可以尽可能延迟内存页的复制，更重要的是，在很多情况下不需要复制，这节省了大量时间。</li>
<li>依赖于execve的实现，释放原进程使用的所有资源，将应用程序映射到虚拟地址空间，设置进程指令指针和其他特定于体系结构的寄存器。</li>
<li>进程必须用exit系统调用终止，这使得内核有机会将该进程使用的资源释放回系统。</li>
<li></li>
</ul>
<h4 id="调度器的实现"><a href="#调度器的实现" class="headerlink" title="调度器的实现"></a>调度器的实现</h4><ul>
<li>调度器的任务是在程序之间共享CPU时间，创造并行执行的错觉。</li>
<li>该任务分为两个不同部分，一个是调度策略，一个是上下文切换</li>
<li>内核必须提供一种方法，在各个进程之间尽可能地公平地共享CPU时间，而同时又要考虑不同的任务优先级。</li>
<li>linux调度器的一个杰出特性是，它不需要时间片概念，至少不需要传统的时间片。而只考虑进程的等待时间，即进程在就绪队列中已经等待了多长时间。</li>
</ul>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><ul>
<li>如果物理内存比可以映射到内核地址空间中的数量要多，那么内核必须借助高端内存方法来管理多余的内存</li>
<li></li>
</ul>
<h2 id="进程虚拟内存"><a href="#进程虚拟内存" class="headerlink" title="进程虚拟内存"></a>进程虚拟内存</h2><ul>
<li>每个应用程序都有自身的地址空间，与其他所有应用程序分隔开</li>
<li>在巨大的线性地址空间中，只有很少的段可用于各个用户空间进程</li>
<li>地址空间只有极小的一部分与物理内存页直接关联</li>
<li>无论当前哪个用户进程处于活动状态，虚拟地址空间内核部分的内容总是相同的</li>
<li>按需分配和填充页称之为按需调页法</li>
</ul>
<h2 id="锁与进程间通信"><a href="#锁与进程间通信" class="headerlink" title="锁与进程间通信"></a>锁与进程间通信</h2><h4 id="控制机制"><a href="#控制机制" class="headerlink" title="控制机制"></a>控制机制</h4><ul>
<li>几个进程在访问资源时彼此干扰的情况通常称之为竞态条件</li>
<li>只要没有其他进程进入临界区，那么在临界区中执行的进程完全是可以中断的</li>
<li>信号量只是受保护的特别变量，其初始值位1.down操作将值减1，变为0，如果发现信号量的值为0，则导致后面的进程在该信号量上睡眠。</li>
<li>虽然信号量初看起来容易实现，但其开销对内核来说过大。</li>
<li>如果处理器同时处于核心态，则理论上它们可以同时访问一个数据结构，这就刚好造成了竞态条件</li>
<li>内核使用了由锁组成细粒度网络，来明确地保护各个数据结构</li>
<li>原子操作 ，不中断地执行</li>
<li>自旋锁，用于短期保护某段代码，内核进入睡眠状态，直到被唤醒。在此期间会重复检查能够获取锁，而不会进入睡眠状态</li>
<li>信号量 等待释放信号量是，内核进入睡眠状态，直至被唤醒，直到被唤醒后，才重新尝试获取信号量。互斥量是信号量的特例。</li>
<li>读写锁。任意数目的处理器都可以对数据结构进行并发读访问，但只有一个处理器能进行写访问，在进行写访问时，读访问页无法进行。</li>
<li>自旋锁不应该长期持有</li>
<li>在单处理器系统上，自旋锁定义为空操作，因为不存在几个CPU同时进入临界区额情况，但如果启动了内核抢占，这种说法就不适用了。</li>
<li>信号量适合于保护更长的临界区。以防止并行访问</li>
<li>RCU保护 read-copt-update</li>
</ul>
<h2 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h2><ul>
<li>VFS的任务不简单，它用来提供一种操作文件，目录以及其他对象的统一方法，另一方面，它必须能够与各种方法给出的具体文件系统的实现达成妥协。</li>
<li>文件系统一般可以分为三种，基于磁盘的文件系统，虚拟文件系统，网络文件系统</li>
<li>对用户程序来说，一个文件由一个文件描述符标识</li>
<li>内核处理文件的关键是iNode</li>
<li>在硬连接建立事，创建的目录项使用了一个现存的inode编号</li>
<li>普通文件支持随机访问，但是命名管道，字符设备等文件不支持这种做法。</li>
<li></li>
</ul>
<h2 id="页缓存和块缓存"><a href="#页缓存和块缓存" class="headerlink" title="页缓存和块缓存"></a>页缓存和块缓存</h2><ul>
<li>数据并非每次在修改后都立即写回，而是在一定的时间间隔之后才进行回写，时间间隔的长度取决于多种因素，如空闲物理内存的容量，物理内存中数据的利用率等等。</li>
<li>用于缓存的内存区不能分配和普通应用程序，这减少了实际可用的物理内存容量。</li>
<li>slab是一个内存到内存的缓存，其目的不是加速对低速设备的操作，而是对现存资源进行更简单，更搞笑的使用。</li>
<li>何时回写？pdflush进程周期性激活；短期内快速增加；用户调用sync</li>
<li></li>
</ul>
<h2 id="页面回收和页交换"><a href="#页面回收和页交换" class="headerlink" title="页面回收和页交换"></a>页面回收和页交换</h2><ul>
<li>只有少量几种页可以换出到交换区，类型为MAP_ANONYMOUS的页，没有关联到文件</li>
<li>进程的私有映射用于映射修改后不向底层块设备回写的文件</li>
<li>所有属于进程堆以及使用malloc分配的页</li>
<li>用于实现某种进程间通信的页</li>
<li>内核本身使用的内存页绝不会换出</li>
<li>用于将外设映射到内存空间的页也不能换出</li>
</ul>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB调试指南-源码查看</title>
    <url>/2019/04/14/48991.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在调试过程中难免要对照源码进行查看，如果已经开始了调试，而查看源码或者编辑源码却要另外打开一个窗口，那未免显得太麻烦。文本将会介绍如何在GDB调试模式下<strong>查看源码或对源码进行编辑</strong>。<br><a id="more"></a></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>为了说明后面的内容，我们先准备一些源码，分别是main.c：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"test.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"it will print from 5 to 1\n"</span>);</span><br><span class="line">    printNum(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"print end\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"it will print 1 to 5\n"</span>);</span><br><span class="line">    printNum1(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"print end\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>头文件test.h：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _TEST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TEST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNum</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNum1</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>以及test.c:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"test.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNum</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n);</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNum1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -g  -o main  main.c test.c</span><br><span class="line">$ chmod +x main</span><br><span class="line">$ ./main</span><br><span class="line">it will print from 5 to 1</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">print end</span><br><span class="line">it will print 1 to 5</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">print end</span><br></pre></td></tr></table></figure></p>
<p>程序功能比较简单，用来打印5到1的数以及1到5的数，这里也就不多做解释。</p>
<h2 id="列出源码"><a href="#列出源码" class="headerlink" title="列出源码"></a>列出源码</h2><p>首先要介绍的就是list命令（可简写为l），它用来打印源码。</p>
<h4 id="直接打印源码"><a href="#直接打印源码" class="headerlink" title="直接打印源码"></a>直接打印源码</h4><p>例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gdb main</span><br><span class="line">(gdb) l</span><br><span class="line">1	//main.c</span><br><span class="line">2	#include&lt;stdio.h&gt;</span><br><span class="line">3	#include&quot;test.h&quot;</span><br><span class="line">4	int main(void)</span><br><span class="line">5	&#123;</span><br><span class="line">6	    printf(&quot;it will print from 5 to 1\n&quot;);</span><br><span class="line">7	    printNum(5);</span><br><span class="line">8	    printf(&quot;print end\n&quot;);</span><br><span class="line">9	</span><br><span class="line">10	    printf(&quot;it will print 1 to 5\n&quot;);</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>直接输入l可从第一行开始显示源码，继续输入l，可列出后面的源码。后面也可以跟上+或者-，分别表示要列出上一次列出源码的后面部分或者前面部分。</p>
<h4 id="列出指定行附近源码"><a href="#列出指定行附近源码" class="headerlink" title="列出指定行附近源码"></a>列出指定行附近源码</h4><p>l后面可以跟行号，表明要列出附近的源码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) l 9</span><br><span class="line">4	int main(void)</span><br><span class="line">5	&#123;</span><br><span class="line">6	    printf(&quot;it will print from 5 to 1\n&quot;);</span><br><span class="line">7	    printNum(5);</span><br><span class="line">8	    printf(&quot;print end\n&quot;);</span><br><span class="line">9	</span><br><span class="line">10	    printf(&quot;it will print 1 to 5\n&quot;);</span><br><span class="line">11	    printNum1(5);</span><br><span class="line">12	    printf(&quot;print end\n&quot;);</span><br><span class="line">13	    return 0;</span><br></pre></td></tr></table></figure></p>
<p>在这里，l后面跟上9，表明要列出第9行附近的源码。</p>
<h4 id="列出指定函数附近的源码"><a href="#列出指定函数附近的源码" class="headerlink" title="列出指定函数附近的源码"></a>列出指定函数附近的源码</h4><p>这个很容易理解，而使用也很简单，l后面跟函数名即可，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) l printNum</span><br><span class="line">1	#include&quot;test.h&quot;</span><br><span class="line">2	void printNum(int n)</span><br><span class="line">3	&#123;</span><br><span class="line">4	    if( n &lt; 0)</span><br><span class="line">5	        return;</span><br><span class="line">6	    while(n &gt; 0)</span><br><span class="line">7	    &#123;</span><br><span class="line">8	        printf(&quot;%d\n&quot;,n);</span><br><span class="line">9	        n--;</span><br><span class="line">10	    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里，l后面跟上函数名printNum，它便列出了printNum函数附近的源码。</p>
<h4 id="设置源码一次列出行数"><a href="#设置源码一次列出行数" class="headerlink" title="设置源码一次列出行数"></a>设置源码一次列出行数</h4><p>不知道你有没有发现，在列出函数源码的时候，它并没有列全，因为l每次只显示10行，那么有没有方法每次列出更多呢？<br>我们可以通过listsize属性来设置，例如设置每次列出20行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) set listsize 20</span><br><span class="line">(gdb) show listsize</span><br><span class="line">Number of source lines gdb will list by default is 20.</span><br></pre></td></tr></table></figure></p>
<p>这样每次就会列出20行，当然也可以设置为0或者unlimited，这样设置之后，列出就没有限制了，但源码如果较长，查看将会不便。</p>
<h4 id="列出指定行之间的源码"><a href="#列出指定行之间的源码" class="headerlink" title="列出指定行之间的源码"></a>列出指定行之间的源码</h4><p>list first,last<br>例如，要列出3到15行之间的源码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) l 3,15</span><br><span class="line">3	&#123;</span><br><span class="line">4	    if( n &lt; 0)</span><br><span class="line">5	        return;</span><br><span class="line">6	    while(n &gt; 0)</span><br><span class="line">7	    &#123;</span><br><span class="line">8	        printf(&quot;%d\n&quot;,n);</span><br><span class="line">9	        n--;</span><br><span class="line">10	    &#125;</span><br><span class="line">11	&#125;</span><br><span class="line">12	</span><br><span class="line">13	void printNum1(int n)</span><br><span class="line">14	&#123;</span><br><span class="line">15	    if( n &lt; 0)</span><br></pre></td></tr></table></figure></p>
<p>启始行和结束行号之间用逗号隔开。两者之一也可以省略，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) list 3,</span><br><span class="line">3	&#123;</span><br><span class="line">4	    if( n &lt; 0)</span><br><span class="line">5	        return;</span><br><span class="line">6	    while(n &gt; 0)</span><br><span class="line">7	    &#123;</span><br><span class="line">8	        printf(&quot;%d\n&quot;,n);</span><br><span class="line">9	        n--;</span><br><span class="line">10	    &#125;</span><br><span class="line">11	&#125;</span><br><span class="line">12</span><br></pre></td></tr></table></figure></p>
<p>省略结束行的时候，它列出从开始行开始，到指定大小行结束，而省略开始行的时候，到结束行结束，列出设置的大小行，例如默认设置为10行，则到结束行为止，总共列出10行。前面我们也介绍了修改和查看默认列出源码行数的方法。</p>
<h4 id="列出指定文件的源码"><a href="#列出指定文件的源码" class="headerlink" title="列出指定文件的源码"></a>列出指定文件的源码</h4><p>前面执行l命令时，默认列出main.c的源码，如果想要看指定文件的源码呢？可以<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l location</span><br></pre></td></tr></table></figure></p>
<p>其中location可以是<strong>文件名加行号或函数名</strong>，因此可以使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) l test.c:1</span><br><span class="line">1	#include&quot;test.h&quot;</span><br><span class="line">2	void printNum(int n)</span><br><span class="line">3	&#123;</span><br><span class="line">4	    if( n &lt; 0)</span><br><span class="line">5	        return;</span><br><span class="line">6	    while(n &gt; 0)</span><br><span class="line">7	    &#123;</span><br><span class="line">8	        printf(&quot;%d\n&quot;,n);</span><br><span class="line">9	        n--;</span><br><span class="line">10	    &#125;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>来查看指定文件指定行，或者指定文件指定函数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) l test.c:printNum1</span><br><span class="line">9	        n--;</span><br><span class="line">10	    &#125;</span><br><span class="line">11	&#125;</span><br><span class="line">12	</span><br><span class="line">13	void printNum1(int n)</span><br><span class="line">14	&#123;</span><br><span class="line">15	    if( n &lt; 0)</span><br><span class="line">16	        return;</span><br><span class="line">17	    int i = 1;</span><br><span class="line">18	    while(i &lt;= n)</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>或者指定文件指定行之间：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) l test.c:1,test.c:3</span><br><span class="line">1	#include&quot;test.h&quot;</span><br><span class="line">2	void printNum(int n)</span><br><span class="line">3	&#123;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<h2 id="指定源码路径"><a href="#指定源码路径" class="headerlink" title="指定源码路径"></a>指定源码路径</h2><p>在查看源码之前，首先要确保我们的程序能够关联到源码，一般来说，我们在自己的机器上加上-g参数编译完之后，使用gdb都能查看到源码，但是如果出现下面的情况呢？</p>
<h4 id="源码被移走"><a href="#源码被移走" class="headerlink" title="源码被移走"></a>源码被移走</h4><p>例如，我现在将main.c移动到当前的temp目录下，再执行l命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line">1	main.c: No such file or directory.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>它就会提示找不到源码文件了，那么怎么办呢？<br>我们可以使用dir命名指定源码路径，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) dir ./temp</span><br><span class="line">Source directories searched: /home/hyb/workspaces/gdb/sourceCode/./temp:$cdir:$cwd</span><br></pre></td></tr></table></figure></p>
<p>这个时候它就能找到源码路径了。我这里使用的是相对路径，保险起见，你也可以使用绝对路径。</p>
<h4 id="更换源码目录"><a href="#更换源码目录" class="headerlink" title="更换源码目录"></a>更换源码目录</h4><p>例如，你编译好的程序文件，放到了另外一台机器上进行调试，或者你的源码文件全都移动到了另外一个目录，怎么办呢？当然你还可以使用前面的方法添加源码搜索路径，也可以使用set substitute-path from to将原来的路径替换为新的路径，那么我们如何知道原来的源码路径是什么呢？借助readelf命令可以知道：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ readelf main -p .debug_str</span><br><span class="line">  [     0]  long unsigned int</span><br><span class="line">  [    12]  short int</span><br><span class="line">  [    1c]  /home/hyb/workspaces/gdb/sourceCode</span><br><span class="line">  [    40]  main.c</span><br><span class="line">（显示部分内容）</span><br></pre></td></tr></table></figure></p>
<p>main为你将要调试的程序名，这里我们可以看到原来的路径，那么我们现在替换掉它：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) set substitute-path /home/hyb/workspaces/gdb/sourceCode /home/hyb/workspaces/gdb/sourceCode/temp</span><br><span class="line">(gdb) show substitute-path</span><br><span class="line">List of all source path substitution rules:</span><br><span class="line">  `/home/hyb/workspaces/gdb/sourceCode&apos; -&gt; `/home/hyb/workspaces/gdb/sourceCode/temp&apos;.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>设置完成后，可以通过show substitute-path来查看设置结果。这样它也能在正确的路径查找源码啦。</p>
<p>需要注意的是，这里<strong>对路径做了字符串替换</strong>，那么如果你有多个路径，可以做多个替换。甚至可以对指定文件路径进行替换。</p>
<p>最后你也可以通过unset substitute-path [path]取消替换。</p>
<h2 id="编辑源码"><a href="#编辑源码" class="headerlink" title="编辑源码"></a>编辑源码</h2><p>为了避免已经启动了调试之后，需要编辑源码，又不想退出，可以直接在gdb模式下编辑源码，它默认使用的编辑器是/bin/ex，但是你的机器上可能没有这个编辑器，或者你想使用自己熟悉的编辑器，那么可以通过下面的方式进行设置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ EDITOR=/usr/bin/vim</span><br><span class="line">$ export EDITOR</span><br></pre></td></tr></table></figure></p>
<p>/usr/bin/vim可以替换为你熟悉的编辑器的路径，如果你不知道你的编辑器在什么位置，可借助whereis命令或者witch命令查看：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ whereis vim</span><br><span class="line">vim: /usr/bin/vim /usr/bin/vim.tiny /usr/bin/vim.basic /usr/bin/vim.gnome /etc/vim /usr/share/vim /usr/share/man/man1/vim.1.gz</span><br><span class="line">$ which vim</span><br><span class="line">/usr/bin/vim</span><br></pre></td></tr></table></figure></p>
<p>设置之后，就可以在gdb调试模式下进行编辑源码了，使用命令edit location，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb)edit 3  #编辑第三行</span><br><span class="line">(gdb)edit printNum #编辑printNum函数</span><br><span class="line">(gdb)edit test.c:5 #编辑test.c第五行</span><br></pre></td></tr></table></figure>
<p>可自行尝试，这里的location和前面介绍的一样，可以跟指定文件的特定行或指定文件的指定函数。<br>编辑完保存后，别忘了重新编译程序：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb)shell gcc -g -o main main.c test.c</span><br></pre></td></tr></table></figure></p>
<p>这里要注意，为了在gdb调试模式下执行shell命令，需要在命令之前加上shell，表明这是一条shell命令。这样就能在不用退出GDB调试模式的情况下编译程序了。</p>
<h2 id="另外一种模式"><a href="#另外一种模式" class="headerlink" title="另外一种模式"></a>另外一种模式</h2><p>启动时，带上tui(Text User Interface)参数，会有意想不到的效果，它会将调试在多个文本窗口呈现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb main -tui</span><br></pre></td></tr></table></figure></p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/GDB%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97-%E6%BA%90%E7%A0%81%E6%9F%A5%E7%9C%8B/gdb-tui.png" alt="GDB-TUI"></p>
<p>但是本文不作介绍，有兴趣的可以探索一下。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了GDB调试中的源码查看，源码编辑以及如何在GDB调试模式下执行shell命令。</p>
]]></content>
      <categories>
        <category>gdb</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的遍历-C语言实现</title>
    <url>/2019/04/11/63105.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在《<a href="https://www.yanbinghu.com/2019/04/10/9448.html">什么是二叉树</a>》中，我们介绍了二叉树的创建（插入），查找和删除，本文将介绍二叉树的遍历。而二叉树遍历有多种形式，他们也可以应用在不同的场景中，常见的<strong>深度优先</strong>遍历方式有前序遍历，中序遍历，后序遍历，而不常用<strong>广度优先</strong>遍历方式有层次遍历。本文将会对以上遍历方式都进行介绍。<br><a id="more"></a></p>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>常见遍历顺序有以下几种：</p>
<ul>
<li>前序遍历，先检查节点值，然后递归遍历左子树和右子树</li>
<li>中序遍历，先遍历左子树，然后检查当前节点值，最后遍历右子树</li>
<li>后序遍历，先递归遍历左右子树，然后检查当前节点值</li>
<li>层次遍历，如名字所言，从第一层开始，一层一层往下遍历</li>
</ul>
<p>以下图为例，我们一一介绍四种遍历方式。</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/insert3.png" alt="二叉树"></p>
<h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><ul>
<li>输出当前节点值10，然后输出左子树，最后输出右子树；</li>
<li>对于其左子树来说，同样以这样的顺序，则先输出5，然后输出左子树4，最后输出右子树8；</li>
<li>对于其右子树，同样以这样的顺序，则先输出19，然后输出左子树13，最后输出右子树24；</li>
<li>最终得到前序遍历输出为：10,5,4,8,19,13,24。</li>
</ul>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/%E5%89%8D%E5%BA%8F.gif" alt="前序遍历"></p>
<p>前序遍历代码：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == tree)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,tree-&gt;value);</span><br><span class="line">    preOrder(tree-&gt;left);</span><br><span class="line">    preOrder(tree-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="中序遍历："><a href="#中序遍历：" class="headerlink" title="中序遍历："></a>中序遍历：</h4><ul>
<li>先输出左子树，然后输出当前节点10，最后输出右子树；</li>
<li>对于其左子树来说，同样以这样的顺序，则先输出左子树4，然后输出节点值5，最后输出右子树8；</li>
<li>对于其右子树，同样以这样的顺序，则先,输出左子树13，然后输出节点值19，最后输出右子树24；</li>
<li>最终得到中序遍历输出为：4,5,8,10,13,19,24。</li>
</ul>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/%E4%B8%AD%E5%BA%8F.gif" alt="中序遍历"></p>
<p>我们发现<strong>二叉查找树的中序遍历输出就是排序后的结果</strong>。还记得吗，二叉查找树也叫二叉搜索树或者二叉排序树。</p>
<p>中序遍历代码：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == tree)</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    inOrder(tree-&gt;left);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,tree-&gt;value);</span><br><span class="line">    inOrder(tree-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><ul>
<li>先输出左子树，然后输出右子树，最后输出节点值10</li>
<li>对于其左子树来说，同样以这样的顺序，则先输出左子树4，然后输出右子树8，最后输出节点值5；</li>
<li>对于其右子树，同样以这样的顺序，则先,输出左子树13，然后输出右子树24，最后输出节点值19</li>
<li>最终得到后序遍历输出为：4,8,5,13,24,19,10</li>
</ul>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/%E5%90%8E%E5%BA%8F.gif" alt="后序遍历"><br>后序遍历代码：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == tree)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    postOrder(tree-&gt;left);</span><br><span class="line">    postOrder(tree-&gt;right);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,tree-&gt;value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h4><ul>
<li>遍历第一层，输出10</li>
<li>遍历第二层，输出5,19</li>
<li>遍历第三层，输出4,8,13,24</li>
</ul>
<p>虽然看起来过程很简单，但是代码实现却不能像前面三种深度优先遍历方式那样<strong>直接</strong>使用递归，它更好的方式是借助一个具有<strong>先入先出</strong>特点的队列（队列可参考<a href="https://www.yanbinghu.com/2019/03/28/13055.html">队列-C语言实现</a>）。以三个节点为例，我们先将根节点入队，然后分别入队左右孩子节点，最后输出队列内容，那么它的顺序就是层次遍历的顺序了。</p>
<p>头结点入队：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>输出,队头元素10，并将它的左右孩子5,19入队：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>5</td>
<td>19</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>输出队头元素5，并将它的左右孩子4,8入队：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>19</td>
<td>4</td>
<td>8</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>输出队头元素19，并将它的左右孩子13,24入队：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>8</td>
<td>13</td>
<td>24</td>
</tr>
</tbody>
</table>
</div>
<p>由于队列中的元素都没有孩子节点，因此都直接出队，输出4,8,13,24</p>
<p>最终得到的输出顺序为：10,5,19,4,8,13,24.</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/%E5%B1%82%E6%AC%A1.gif" alt="层次遍历"></p>
<p>关键代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintNodeByLevel</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == root)</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/*初始化队列*/</span></span><br><span class="line">    QueueInfo <span class="built_in">queue</span>;</span><br><span class="line">    init_queue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">    TreeNode *node = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*头节点入队*/</span></span><br><span class="line">    queue_insert(&amp;<span class="built_in">queue</span>,root);</span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">    &#123;</span><br><span class="line">        queue_delete(&amp;<span class="built_in">queue</span>,&amp;node);</span><br><span class="line">        <span class="keyword">if</span> (node) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,node-&gt;value);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">                queue_insert(&amp;<span class="built_in">queue</span>,node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">                queue_insert(&amp;<span class="built_in">queue</span>,node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!queue_is_empty(&amp;<span class="built_in">queue</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="完整可运行代码"><a href="#完整可运行代码" class="headerlink" title="完整可运行代码"></a>完整可运行代码</h2><p>完整代码较长，请访问：<a href="https://github.com/yanbinghu/data-structures-and-algorithms-in-c/blob/master/tree/traversal.c" target="_blank" rel="noopener">traversal.c</a><br>运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert 10 to tree</span><br><span class="line">insert 5 to tree</span><br><span class="line">insert 19 to tree</span><br><span class="line">insert 4 to tree</span><br><span class="line">insert 8 to tree</span><br><span class="line">insert 13 to tree</span><br><span class="line">insert 24 to tree</span><br><span class="line"></span><br><span class="line">层次遍历：10 5 19 4 8 13 24 </span><br><span class="line">前序遍历：10 5 4 8 19 13 24 </span><br><span class="line">后序遍历：4 8 5 13 24 19 10 </span><br><span class="line">中序遍历：4 5 8 10 13 19 24</span><br></pre></td></tr></table></figure></p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>前面三种遍历方式都是直接printf输出，如果需要遍历返回一个数组呢？该如何实现？难点在哪？</p>
<p>具体实现可访问：<a href="https://github.com/yanbinghu/data-structures-and-algorithms-in-c/blob/master/tree/traversal.c" target="_blank" rel="noopener">traversal.c</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数据结构与算法</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>如何画一棵漂亮的二叉树</title>
    <url>/2019/04/10/9448.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不知道你有没有找过一些工具来画数据结构的图，我反正是找了不少。windows下的visio是挺强大的，不过在linux没法使用，当然你非要使用也可以安装wine；亿图也不错，支持画数据结构图，不过是收费的。然而前面这些都不是重点，重点是他们画图都是拖拽类型的，手残党实在把持不住。最后终于发现了一款程序员画图神器-graphviz。《<a href="https://www.yanbinghu.com/2019/04/07/55964.html">什么是二叉查找树</a>》文中的树图就是用该工具画的.<br><a id="more"></a></p>
<h2 id="graphviz简介"><a href="#graphviz简介" class="headerlink" title="graphviz简介"></a>graphviz简介</h2><p>Graphviz是开源图形可视化软件。图形可视化是一种将结构信息表示为抽象图和网络图的方法。 它在网络，生物信息学，软件工程，数据库和网页设计，机器学习以及其他技术领域的可视化界面中具有重要的应用。—来自Graphviz官网<a href="https://www.graphviz.org/。" target="_blank" rel="noopener">https://www.graphviz.org/。</a></p>
<p>实际上它和markdown类似，markdown用纯文本编写文档，而能够转化成格式丰富的html，而graphviz使用dot标记语言来编写，能够被转换成svg,png,jpg等图形格式。甚至可以说，它就是用纯文本来完成画图。</p>
<p>除此之外，它还提供多种语言的api接口，例如，C，python，java，ruby等，也就是说，你可以根据自己的需要通过编写代码来生成你需要的图形。不过文本不准备使用这种方式，而是直接使用dot语言来画我们需要的图。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>linux，windows，mac等系统都支持，安装包下载地址：<a href="https://www.graphviz.org/download/" target="_blank" rel="noopener">graphviz</a>。具体安装过程就不介绍了。安装完成后，windows下有一个gvedit.exe的程序可以用来编辑预览，但是关键使用的还是dot.exe。而linux执行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install graphviz</span><br></pre></td></tr></table></figure></p>
<p>安装完后就可以直接使用dot命令了。</p>
<h2 id="如何画二叉树"><a href="#如何画二叉树" class="headerlink" title="如何画二叉树"></a>如何画二叉树</h2><p>实际上，它<strong>能够画各种各样的数据结构图</strong>，后面也会随着数据结构的介绍而不断介绍各种数据结构的画法，本文仅介绍树的画法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">digraph binaryTree&#123;</span><br><span class="line">    node[shape=circle,color=red,fontcolor=blue,fontsize=10];</span><br><span class="line">    root[color=blue,fontcolor=black,fontsize=20];</span><br><span class="line">    root-&gt;a[style=dotted];</span><br><span class="line">    root-&gt;b;</span><br><span class="line">    a-&gt;c;</span><br><span class="line">    a-&gt;d;</span><br><span class="line">    b-&gt;e;</span><br><span class="line">    b-&gt;f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将上面的内容保存在一个文件，并以.dot结尾，例如tree.dot。然后在命令行执行命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ dot -Tpng -o tree.png tree.dot</span><br></pre></td></tr></table></figure></p>
<p>其中-Tpng表明要将该dot文件转换为png格式的图片，当然你也可以转换为svg,jpg等其他格式的图片。-o 后面是输出文件名。最后会在目录下发现下面的图片：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E5%A6%82%E4%BD%95%E7%94%BB%E4%B8%80%E6%A3%B5%E6%BC%82%E4%BA%AE%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/binaryTree.png" alt="随便一棵树"></p>
<p>是不是很简单？</p>
<p>当然在这里有必要对内容进行一些说明。</p>
<ul>
<li>digraph说明这是一个有向图，也就是后面的指向都是有方向的。</li>
<li>binaryTree只是起的一个名字。</li>
<li>node行可以用来说明节点的属性，本文例子说，表明它的节点形状是圆，边框颜色为红色，字体颜色为蓝色，字体大小20。当然你也可以指定单个节点的属性，例如后面的root节点单独设置。</li>
<li>文中用-&gt;来表明节点的指向。而style=dotted表明该箭头会是虚线箭头。</li>
<li>每行以分号结尾。</li>
</ul>
<h2 id="一棵漂亮的二叉树"><a href="#一棵漂亮的二叉树" class="headerlink" title="一棵漂亮的二叉树"></a>一棵漂亮的二叉树</h2><p>但是你有没有发现一个问题，二叉树各个节点分布并不是那么好看，如果再去掉一个节点，会变成下面这样：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E5%A6%82%E4%BD%95%E7%94%BB%E4%B8%80%E6%A3%B5%E6%BC%82%E4%BA%AE%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/binaryTree1.png" alt="歪脖子树"></p>
<p>完全没有左右孩子的感觉了对不对？那怎么办呢？所幸的是，有人已经做了一个优化。将下面的内容保存为文件binarytree.gvpr或从这里<a href="https://gist.github.com/Sciss/2878988" target="_blank" rel="noopener">https://gist.github.com/Sciss/2878988</a> 下载：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// from Emden Gansner</span><br><span class="line">// https://mailman.research.att.com/pipermail/graphviz-interest/2010q2/007101.html</span><br><span class="line">// requires GraphViz 2.28.0 (fails with 2.26.3 at least)</span><br><span class="line">BEGIN &#123;</span><br><span class="line">  double tw[node_t];    // width of tree rooted at node</span><br><span class="line">  double nw[node_t];    // width of node</span><br><span class="line">  double xoff[node_t];  // x offset of root from left side of its tree</span><br><span class="line">  double sp = 36;       // extra space between left and right subtrees</span><br><span class="line">  double wd, w, w1, w2; </span><br><span class="line">  double x, y, z;</span><br><span class="line">  edge_t e1, e2;</span><br><span class="line">  node_t n;</span><br><span class="line">&#125;</span><br><span class="line">BEG_G &#123;</span><br><span class="line">  $.bb = &quot;&quot;;</span><br><span class="line">  $tvtype=TV_postfwd;   // visit root after all children visited</span><br><span class="line">&#125;</span><br><span class="line">N &#123;</span><br><span class="line">  sscanf ($.width, &quot;%f&quot;, &amp;w);</span><br><span class="line">  w *= 72;  // convert inches to points</span><br><span class="line">  nw[$] = w;</span><br><span class="line">  if ($.outdegree == 0) &#123;</span><br><span class="line">    tw[$] = w;</span><br><span class="line">    xoff[$] = w/2.0;</span><br><span class="line">  &#125;</span><br><span class="line">  else if ($.outdegree == 1) &#123;</span><br><span class="line">    e1 = fstout($);</span><br><span class="line">    w1 = tw[e1.head];    </span><br><span class="line">    tw[$] = w1 + (sp+w)/2.0;</span><br><span class="line">    if (e1.side == &quot;left&quot;)</span><br><span class="line">      xoff[$] = tw[$] - w/2.0;</span><br><span class="line">    else</span><br><span class="line">      xoff[$] = w/2.0;</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    e1 = fstout($);</span><br><span class="line">    w1 = tw[e1.head];    </span><br><span class="line">    e2 = nxtout(e1);</span><br><span class="line">    w2 = tw[e2.head];    </span><br><span class="line">    wd = w1 + w2 + sp;</span><br><span class="line">    if (w &gt; wd)</span><br><span class="line">      wd = w;</span><br><span class="line">    tw[$] = wd;</span><br><span class="line">    xoff[$] = w1 + sp/2.0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">BEG_G &#123;</span><br><span class="line">  $tvtype=TV_fwd;   // visit root first, then children</span><br><span class="line">&#125;</span><br><span class="line">N &#123;</span><br><span class="line">  if ($.indegree == 0) &#123;</span><br><span class="line">    sscanf ($.pos, &quot;%f,%f&quot;, &amp;x, &amp;y);</span><br><span class="line">    $.pos = sprintf(&quot;0,%f&quot;, y);</span><br><span class="line">  &#125;</span><br><span class="line">  if ($.outdegree == 0) return;</span><br><span class="line">  sscanf ($.pos, &quot;%f,%f&quot;, &amp;x, &amp;y);</span><br><span class="line">  wd = tw[$];</span><br><span class="line">  e1 = fstout($);</span><br><span class="line">  n = e1.head;</span><br><span class="line">  sscanf (n.pos, &quot;%f,%f&quot;, &amp;z, &amp;y);</span><br><span class="line">  if ($.outdegree == 1) &#123;</span><br><span class="line">    if (e1.side == &quot;left&quot;)</span><br><span class="line">      n.pos = sprintf(&quot;%f,%f&quot;,  x - tw[n] - sp/2.0 + xoff[n], y);</span><br><span class="line">    else</span><br><span class="line">      n.pos = sprintf(&quot;%f,%f&quot;, x + sp/2.0 + xoff[n], y);</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    n.pos = sprintf(&quot;%f,%f&quot;, x - tw[n] - sp/2.0 + xoff[n], y);</span><br><span class="line">    e2 = nxtout(e1);</span><br><span class="line">    n = e2.head;</span><br><span class="line">    sscanf (n.pos, &quot;%f,%f&quot;, &amp;z, &amp;y);</span><br><span class="line">    n.pos = sprintf(&quot;%f,%f&quot;, x + sp/2.0 + xoff[n], y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样再次执行命令的时候，只要像下面这样的方式使用即可：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ dot tree.dot | gvpr -c -f binarytree.gvpr | neato -n -Tpng -o tree.png</span><br></pre></td></tr></table></figure></p>
<p>最后得到的图形如下：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E5%A6%82%E4%BD%95%E7%94%BB%E4%B8%80%E6%A3%B5%E6%BC%82%E4%BA%AE%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/binaryTree2.png" alt="凑合的二叉树"></p>
<p>增加一个节点后变成下面这样：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E5%A6%82%E4%BD%95%E7%94%BB%E4%B8%80%E6%A3%B5%E6%BC%82%E4%BA%AE%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/binaryTree3.png" alt="还行的二叉树"></p>
<p>去掉样式之后变成这样：<br><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/insert3.png" alt="漂亮的二叉树"></p>
<p>是不是好看很多呢？</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文仅介绍画简单的二叉树图，实际上它的属性非常非常多，可以满足你的绝大部分需求,非常适合自己调教。</p>
<h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>你有什么好的画图工具？欢迎留言分享。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>数据结构与算法</tag>
        <tag>dot</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉查找树-c语言实现</title>
    <url>/2019/04/07/55964.html</url>
    <content><![CDATA[<h2 id="树简介"><a href="#树简介" class="headerlink" title="树简介"></a>树简介</h2><p>对于树的基本认识，我们很容易通过我们平常所见到的树来理解：一棵树，有一个根，根往上又会分叉出大树枝，大树枝又会分叉出小树枝，以此往复，直到最后是叶子。而作为数据结构的树也是类似的，只不过我们通常将它倒着画。树的应用也相当广泛，例如在文件系统，数据库索引中的应用等。本文会对树的基本概念做介绍，但重点介绍二叉查找树。</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/naturetree.jpg" alt="现实中的树"></p>
<a id="more"></a>
<h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><p>树是<strong>一种无向图，其中任意两个节点间存在唯一一条路径</strong>。树常常用一种递归的方式来定义，它是一种数据结构，要么为空，要么具有一个值并且有零个或多个孩子，而每个孩子又是树。</p>
<p>例如下图一棵树，任意两个节点间只有一条路径可到达：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/tree.png" alt="树"></p>
<center>图一：树</center>

<p>但下图并非树：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/notTree.png" alt="树"></p>
<center>图二：非树</center>

<p>因为从节点root到节点b并非只有一条路径。</p>
<h2 id="树的种类"><a href="#树的种类" class="headerlink" title="树的种类"></a>树的种类</h2><p>我们可能已经听过很多树的名词，例如，红黑树，霍夫曼树，B树，B+树，平衡二叉树等等，而本文将要介绍二叉查找树，很多其他树都是它的变种，不像链表的线性访问，二叉查找树的大部分操作时间复杂度都为O(logN)。</p>
<h2 id="常见名词解释"><a href="#常见名词解释" class="headerlink" title="常见名词解释"></a>常见名词解释</h2><p>在学习二叉查找树之前，必须要先了解一些名词，我们借助下面的图来了解，如果已经清楚了可以跳过此节。</p>
<p>介绍树的基本名词：</p>
<ul>
<li>根节点：root节点没有父节点，我们把它称为<strong>根节点</strong></li>
<li>父节点：如b节点的父节点为root节点</li>
<li>子节点：在图三中，root有三个孩子，分别是b，c，d，它们都是root的子节点</li>
<li>兄弟节点：b有两个兄弟节点，c，d，<strong>因为它们有相同的父节点root</strong></li>
<li>叶子节点:e f等节点，<strong>它们没有子节点</strong>，因此是叶子节点。</li>
<li>树的深度:树的深度等于它的最深的树叶的深度，而树叶的深度为从根到本叶子节点的路径长（边数）。根节点的深度为0，例如，图三树的深度root-&gt;b-&gt;e（也可选其他树叶的深度）为2。</li>
<li>树的层：树的深度+1，根节点的层为1。</li>
<li>二叉树：如图四，<strong>每个节点最多两个子节点</strong>，</li>
</ul>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/tree.png" alt="树"></p>
<center>图三：树</center>

<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/binaryTree.png" alt="二叉树"></p>
<center>图四：二叉树</center>

<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>二叉树是一种树的特殊形式，它的每个节点最多两个孩子节点，分别为左孩子和右孩子。而二叉查找树在此基础上，还有一个特点，就是<strong>每个节点比它左子树的节点值都要大，而比右子树的节点值都要小</strong>。另外本文也排除了两个节点存在相同值的情况。</p>
<h2 id="二叉查找树操作"><a href="#二叉查找树操作" class="headerlink" title="二叉查找树操作"></a>二叉查找树操作</h2><p>二叉查找树常见操作有插入，查找，删除以及遍历。而实际上二叉查找树既可以使用数组来实现，也可以使用链表，本文采用链表来实现。</p>
<h4 id="节点定义"><a href="#节点定义" class="headerlink" title="节点定义"></a>节点定义</h4><p>我们使用一个结构体来定义它：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tree_Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType value;   <span class="comment">//节点值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Tree_Node</span> *<span class="title">left</span>;</span> <span class="comment">//左节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Tree_Node</span> *<span class="title">right</span>;</span> <span class="comment">//右节点</span></span><br><span class="line">&#125;TreeNode;</span><br></pre></td></tr></table></figure></p>
<h4 id="二叉查找树的插入"><a href="#二叉查找树的插入" class="headerlink" title="二叉查找树的插入"></a>二叉查找树的插入</h4><p>我们以数据 10,5,19，4,8，13,24为例，来看看二叉查找树的插入流程是怎样的。</p>
<ul>
<li>插入节点值10，由于原先无节点，因此10作为根节点</li>
<li><p>插入节点值5，与根节点比较，比根节点小，因此将插入到左子树，而19比根节点大，将插入右子树。<br><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/insert1.png" alt="二叉查找树插入"></p>
<center>图五：二叉查找树插入1</center>
</li>
<li><p>节点值4，与根节点10比较，比根节点小，因此将插入到左子树，继续与5比较，比5小，将插入左子树；节点8，与根节点10比较，比根节点小，因此插入到左子树，与5比较，比5大，因此插入到右子树。<br><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/insert2.png" alt="二叉查找树插入"></p>
<center>图六：二叉查找树插入2</center>
</li>
<li><p>节点值13，与根节点比较，比根节点大，因此将插入到右子树，继续与19比较，比19小，因此插入到左子树；节点值24，与根节点比较，比根节点大，因此将插入到右子树，与19比较，比19大，因此插入到右子树。<br><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/insert3.png" alt="二叉查找树插入"></p>
<center>图七：二叉查找树插入3</center>

</li>
</ul>
<p>最终完成了所有元素的插入。而观察插入后的二叉树可以发现，每个节点都要比左子树的值大，而比右子树的值小。另外，我们在插入的时候不断地与节点值比较，比它大，则将插入右子树，而比它小，则将插入左子树，因此这个过程非常容易用递归来实现。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*将value插入到树中*/</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">insertTree</span><span class="params">(ElementType value,TreeNode *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == tree)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*创建一个节点*/</span></span><br><span class="line">        tree = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == tree)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"malloc failed\n"</span>); </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*将节点信息存储在此叶子节点中*/</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"insert %d to tree\n"</span>,value);</span><br><span class="line">            tree-&gt;value = value;</span><br><span class="line">            tree-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">            tree-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*比当前节点小，则插入到左子树*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(value &lt; tree-&gt;value)</span><br><span class="line">    &#123;</span><br><span class="line">        tree-&gt;left = insertTree(value,tree-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*比当前节点大，则插入到右子树*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(value &gt; tree-&gt;value)</span><br><span class="line">    &#123;    </span><br><span class="line">        tree-&gt;right = insertTree(value,tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="二叉查找树的查找"><a href="#二叉查找树的查找" class="headerlink" title="二叉查找树的查找"></a>二叉查找树的查找</h4><p>实际上，我们在做插入操作的时候，已经在做查找动作了，因为为了将一个元素插入到正确的位置，我们需要从根节点开始，不断比较其值和要插入（查找）的值的大小，如果比该节点值小，则说明该值需要插入到左子树，否则插入到右子树，并且递归调用，最终找到插入的位置。</p>
<p>查找的思路有点像二分查找，我们知道根节点左子树的值都比根节点值小，而右子树的值都比根节点的值要大，以此递归调用，可以很容易找到：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*查找值为value的节点*/</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">findTree</span><span class="params">(ElementType value,TreeNode *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == tree)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*最后一层还没有找到*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*从左子树查找*/</span></span><br><span class="line">    <span class="keyword">if</span>(value &lt; tree-&gt;value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> findTree(value,tree-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*从右边子树查找*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(value &gt; tree-&gt;value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> findTree(value,tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">/*找到*/</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="二叉查找树的删除"><a href="#二叉查找树的删除" class="headerlink" title="二叉查找树的删除"></a>二叉查找树的删除</h4><p>相对来说，删除要比插入和查找复杂很多。因为它需要考虑很多情况：</p>
<ul>
<li>删除的节点为叶子节点，直接删除</li>
<li>删除的节点有一个子节点，可以将该子节点作为其父节点的子节点</li>
<li>删除的节点有两个子节点，我们可以采取这样的策略：用右子树最小值代替该节点，并递归删除那个节点值。需要递归删除是因为这个最小值的节点可能还有右子树，因此需要做同样的删除操作（它不会有左子树，因为它自己的值最小）。</li>
</ul>
<p>第一种情况很容易理解，我们来看第二种和第三种情况。</p>
<p>先看第三种情况，假如我们要从前面的二叉树中删除节点值为10的节点。首先我们可以找到节点值为10的节点的右子树的最小值，为13，因此，将13代替节点值为10的节点值，而幸运的是，节点值为13的节点没有右子树，因此释放根节点的内存，完成删除操作。删除前后如图所示：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/delete1.png" alt="二叉查找树删除"></p>
<center>图八：二叉查找树删除1</center>

<p>再看第二种情况，假如此时要删除值为19的节点，从图中可知，它有一个右儿子，因此删除该节点后，需要将其父节点指向它的右儿子，删除后如下图：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/delete2.png" alt="二叉查找树删除2"></p>
<center>图九：二叉查找树删除2</center>

<p>总体来说，删除操作并不是一次简单的查找就可以完成，甚至删除会使得整个二叉树变得非常不平衡，所以如果删除次数不多，完全可以采用懒惰删除，即当节点被删除时，仅做一个标记，表明它被删除了，而不是真的从树中移除，这样虽然表面上浪费了一点空间，但是如果后面又要插入该元素值，则为新元素分配内存的开销就免了。</p>
<p>根据上面的分析，代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">deleteTree</span><span class="params">(ElementType value,TreeNode *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode *tempNode = <span class="literal">NULL</span>;;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == tree)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"not found \n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*比当前节点值小，从左子树查找并删除*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(value &lt; tree-&gt;value)</span><br><span class="line">    &#123;</span><br><span class="line">        tree-&gt;left = deleteTree(value,tree-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*比当前节点值大，从右子树查找并删除*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(value &gt; tree-&gt;value)</span><br><span class="line">    &#123;</span><br><span class="line">        tree-&gt;right = deleteTree(value,tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*等于当前节点值，并且当前节点有左右子树*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="literal">NULL</span> != tree-&gt;left  &amp;&amp; <span class="literal">NULL</span> != tree-&gt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*用右子树的最小值代替该节点，并且递归删除该最小值节点*/</span></span><br><span class="line">        tempNode = findMin(tree-&gt;right);</span><br><span class="line">        tree-&gt;value = tempNode-&gt;value;</span><br><span class="line">        tree-&gt;right = deleteTree(tree-&gt;value,tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*要删除的节点只有一个子节点或没有子节点*/</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tempNode = tree; </span><br><span class="line">        <span class="comment">/*要删除节点有右孩子*/</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == tree-&gt;left)</span><br><span class="line">            tree=tree-&gt;right;</span><br><span class="line">        <span class="comment">/*要删除节点有左孩子*/</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="literal">NULL</span> == tree-&gt;right)</span><br><span class="line">            tree = tree-&gt;left;</span><br><span class="line">        <span class="built_in">free</span>(tempNode);</span><br><span class="line">        tempNode = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="完整代码及运行结果"><a href="#完整代码及运行结果" class="headerlink" title="完整代码及运行结果"></a>完整代码及运行结果</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//binarySearchTree.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElementType int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAILURE -1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tree_Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Tree_Node</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Tree_Node</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125;TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将value插入到树中*/</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">insertTree</span><span class="params">(ElementType value,TreeNode *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == tree)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*创建一个节点*/</span></span><br><span class="line">        tree = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == tree)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"malloc failed\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*将节点信息存储在此叶子节点中*/</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"insert %d to tree\n"</span>,value);</span><br><span class="line">            tree-&gt;value = value;</span><br><span class="line">            tree-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">            tree-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*比当前节点小，则插入到左子树*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(value &lt; tree-&gt;value)</span><br><span class="line">    &#123;</span><br><span class="line">        tree-&gt;left = insertTree(value,tree-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*比当前节点大，则插入到右子树*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(value &gt; tree-&gt;value)</span><br><span class="line">    &#123;    </span><br><span class="line">        tree-&gt;right = insertTree(value,tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*查找值为value的节点*/</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">findTree</span><span class="params">(ElementType value,TreeNode *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == tree)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*最后一层还没有找到*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*从左子树查找*/</span></span><br><span class="line">    <span class="keyword">if</span>(value &lt; tree-&gt;value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> findTree(value,tree-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*从右边子树查找*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(value &gt; tree-&gt;value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> findTree(value,tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*找到值*/</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*找到一棵树中最小的节点*/</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">findMin</span><span class="params">(TreeNode *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == tree)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="literal">NULL</span> == tree-&gt;left)</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> findMin(tree-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode *<span class="title">deleteTree</span><span class="params">(ElementType value,TreeNode *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode *tempNode = <span class="literal">NULL</span>;;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == tree)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"not found \n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*比当前节点值小，从左子树查找并删除*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(value &lt; tree-&gt;value)</span><br><span class="line">    &#123;</span><br><span class="line">        tree-&gt;left = deleteTree(value,tree-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*比当前节点值大，从右子树查找并删除*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(value &gt; tree-&gt;value)</span><br><span class="line">    &#123;</span><br><span class="line">        tree-&gt;right = deleteTree(value,tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*等于当前节点值，并且当前节点有左右子树*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="literal">NULL</span> != tree-&gt;left  &amp;&amp; <span class="literal">NULL</span> != tree-&gt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*用右子树的最小值代替该节点，并且递归删除该最小值节点*/</span></span><br><span class="line">        tempNode = findMin(tree-&gt;right);</span><br><span class="line">        tree-&gt;value = tempNode-&gt;value;</span><br><span class="line">        tree-&gt;right = deleteTree(tree-&gt;value,tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*要删除的节点只有一个子节点或没有子节点*/</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tempNode = tree; </span><br><span class="line">        <span class="comment">/*要删除节点有右孩子*/</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == tree-&gt;left)</span><br><span class="line">            tree=tree-&gt;right;</span><br><span class="line">        <span class="comment">/*要删除节点有左孩子*/</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="literal">NULL</span> == tree-&gt;right)</span><br><span class="line">            tree = tree-&gt;left;</span><br><span class="line">        <span class="built_in">free</span>(tempNode);</span><br><span class="line">        tempNode = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">10</span>,<span class="number">5</span>,<span class="number">19</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">24</span>&#125;;</span><br><span class="line">    TreeNode *tree = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">7</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tree = insertTree(a[i],tree);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode *temp = <span class="literal">NULL</span>;</span><br><span class="line">    temp = findTree(<span class="number">13</span>,tree);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != temp)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"find %d\n"</span>,temp-&gt;value);</span><br><span class="line">    </span><br><span class="line">    deleteTree(<span class="number">13</span>,tree);</span><br><span class="line"></span><br><span class="line">    deleteTree(<span class="number">19</span>,tree);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o binarySearchTree binarySearchTree.c</span><br><span class="line">$ ./binarySearchTree</span><br><span class="line">insert 10 to tree</span><br><span class="line">insert 5 to tree</span><br><span class="line">insert 19 to tree</span><br><span class="line">insert 4 to tree</span><br><span class="line">insert 8 to tree</span><br><span class="line">insert 13 to tree</span><br><span class="line">insert 24 to tree</span><br><span class="line">find 13</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文简单介绍了二叉查找树的插入，查找，删除操作，其中删除操作较为复杂，需要特别注意。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>如果待插入数据是已经排好序的，会发生什么情况？</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数据结构与算法</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB调试指南-单步调试</title>
    <url>/2019/03/30/36733.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面通过《<a href="https://www.yanbinghu.com/2019/01/08/62137.html">启动调试</a>》，《<a href="https://www.yanbinghu.com/2019/02/24/44483.html">断点设置</a>》，《<a href="https://www.yanbinghu.com/2019/03/10/50132.html">变量查看</a>》,我们已经了解了GDB基本的启动，设置断点，查看变量等，如果这些内容你还不知道，建议先回顾一下前面的内容。在启动调试设置断点观察之后，没有我们想要的信息怎么办呢？这个时候，就需要单步执行或者跳过当前断点继续执行等等。而本文所说的单步调试并非仅仅指单步执行，而是指在你的控制之下，按要求执行语句。<br><a id="more"></a></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>老规矩，先准备一个示例程序如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*gdbStep.c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/*计算简单乘法,这里没有考虑溢出*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*打印从0到num-1的数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> &gt; num)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">7</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"it will calc a + b\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> c = add(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d + %d = %d\n"</span>,a,b,c);</span><br><span class="line">    count(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -g -o gdbStep gdbStep.c</span><br></pre></td></tr></table></figure></p>
<p>程序的功能比较简单，这里不多做解释。</p>
<p>特别简单说明一条命令，list（可简写为l），它可以将源码列出来，例如：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="built_in">list</span></span><br><span class="line"><span class="number">1</span>	<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="number">2</span>	</span><br><span class="line"><span class="number">3</span>	<span class="comment">/*计算简单乘法,这里没有考虑溢出*/</span></span><br><span class="line"><span class="number">4</span>	<span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">5	</span>&#123;</span><br><span class="line"><span class="number">6</span>	    <span class="keyword">int</span> c = a * b;</span><br><span class="line"><span class="number">7</span>	    <span class="keyword">return</span> c;</span><br><span class="line"><span class="number">8</span>	&#125;</span><br><span class="line"><span class="number">9</span>	<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">10	</span>&#123;</span><br><span class="line">(gdb) l</span><br><span class="line"><span class="number">11</span>	    <span class="keyword">int</span> a = <span class="number">13</span>;</span><br><span class="line"><span class="number">12</span>	    <span class="keyword">int</span> b = <span class="number">57</span>;</span><br><span class="line"><span class="number">13</span>	    <span class="built_in">printf</span>(<span class="string">"it will calc a * b\n"</span>);</span><br><span class="line"><span class="number">14</span>	    <span class="keyword">int</span> c = add(a,b);</span><br><span class="line"><span class="number">15</span>	    <span class="built_in">printf</span>(<span class="string">"%d*%d = %d\n"</span>,a,b,c);</span><br><span class="line"><span class="number">16</span>	    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">17</span>	&#125;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<h2 id="单步执行-next"><a href="#单步执行-next" class="headerlink" title="单步执行-next"></a>单步执行-next</h2><p>next命令（可简写为n）用于在程序断住后，继续执行下一条语句，假设已经启动调试，并在第12行停住，如果要继续执行，则使用n执行下一条语句，如果后面跟上数字num，则表示执行该命令num次，就达到继续执行n行的效果了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gdb gdbStep   #启动调试</span><br><span class="line">(gdb)b 25       #将断点设置在12行</span><br><span class="line">(gdb)run        #运行程序</span><br><span class="line">Breakpoint 1, main () at gdbStep.c:25</span><br><span class="line">25	    int b = 7;</span><br><span class="line">(gdb) n     #单步执行</span><br><span class="line">26	    printf(&quot;it will calc a + b\n&quot;);</span><br><span class="line">(gdb) n 2   #执行两次</span><br><span class="line">it will calc a + b</span><br><span class="line">28	    printf(&quot;%d + %d = %d\n&quot;,a,b,c);</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>从上面的执行结果可以看到，我们在25行处断住，执行n之后，运行到26行，运行n 2之后，运行到28行，但是有没有发现一个问题，为什么不会进入到add函数内部呢？那就需要用到另外一个命令啦。</p>
<h2 id="单步进入-step"><a href="#单步进入-step" class="headerlink" title="单步进入-step"></a>单步进入-step</h2><p>对于上面的情况，如果我们想跟踪add函数内部的情况，可以使用step命令（可简写为s），它可以单步跟踪到函数内部，但前提是该函数有调试信息并且有源码信息。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gdb gdbStep    #启动调试</span><br><span class="line">(gdb) b 25       #在12行设置断点</span><br><span class="line">Breakpoint 1 at 0x4005d3: file gdbStep.c, line 25.</span><br><span class="line">(gdb) run        #运行程序</span><br><span class="line">Breakpoint 1, main () at gdbStep.c:25</span><br><span class="line">25	    int b = 7;</span><br><span class="line">(gdb) s          </span><br><span class="line">26	    printf(&quot;it will calc a + b\n&quot;);</span><br><span class="line">(gdb) s     #单步进入，但是并没有该函数的源文件信息</span><br><span class="line">_IO_puts (str=0x4006b8 &quot;it will calc a + b&quot;) at ioputs.c:33</span><br><span class="line">33	ioputs.c: No such file or directory.</span><br><span class="line">(gdb) finish    #继续完成该函数调用</span><br><span class="line">Run till exit from #0  _IO_puts (str=0x4006b8 &quot;it will calc a + b&quot;)</span><br><span class="line">    at ioputs.c:33</span><br><span class="line">it will calc a + b</span><br><span class="line">main () at gdbStep.c:27</span><br><span class="line">27	    int c = add(a,b);</span><br><span class="line">Value returned is $1 = 19</span><br><span class="line">(gdb) s        #单步进入，现在已经进入到了add函数内部</span><br><span class="line">add (a=13, b=57) at gdbStep.c:6</span><br><span class="line">6	    int c = a + b;</span><br></pre></td></tr></table></figure></p>
<p>从上面的过程可以看到，s命令会尝试进入函数，但是如果没有该函数源码，需要跳过该函数执行，可使用finish命令，继续后面的执行。如果没有函数调用，s的作用与n的作用并无差别，仅仅是继续执行下一行。它后面也可以跟数字，表明要执行的次数。</p>
<p>当然它还有一个选项，用来设置当遇到没有调试信息的函数，s命令是否跳过该函数，而执行后面的。默认情况下，它是会跳过的，即step-mode值是off：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) show step-mode </span><br><span class="line">Mode of the step operation is off.</span><br><span class="line">(gdb) set step-mode on</span><br><span class="line">(gdb) set step-mode off</span><br></pre></td></tr></table></figure></p>
<p>还有一个与step相关的命令是stepi（可简写为si），它与step不同的是，每次执行一条机器指令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) si</span><br><span class="line">0x0000000000400573	6	    int c = a + b;</span><br><span class="line">(gdb) display/i $pc</span><br><span class="line">1: x/i $pc</span><br><span class="line">=&gt; 0x400573 &lt;add+13&gt;:	mov    -0x18(%rbp),%eax</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<h2 id="继续执行到下一个断点-continue"><a href="#继续执行到下一个断点-continue" class="headerlink" title="继续执行到下一个断点-continue"></a>继续执行到下一个断点-continue</h2><p>我们可能打了多处断点，或者断点打在循环内，这个时候，想跳过这个断点，甚至跳过多次断点继续执行该怎么做呢？可以使用continue命令（可简写为c）或者fg，它会继续执行程序，直到再次遇到断点处：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gdb gdbStep</span><br><span class="line">(gdb)b 18    #在count函数循环内打断点</span><br><span class="line">(gdb)run</span><br><span class="line">Breakpoint 1, count (num=10) at gdbStep.c:18</span><br><span class="line">18	        i++;</span><br><span class="line">(gdb) c      #继续运行，直到下一次断住</span><br><span class="line">Continuing.</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">Breakpoint 1, count (num=10) at gdbStep.c:18</span><br><span class="line">18	        i++;</span><br><span class="line">(gdb) fg     #继续运行，直到下一次断住</span><br><span class="line">Continuing.</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">Breakpoint 1, count (num=10) at gdbStep.c:18</span><br><span class="line">18	        i++;</span><br><span class="line">(gdb) c 3    #跳过三次</span><br><span class="line">Will ignore next 2 crossings of breakpoint 1.  Continuing.</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">Breakpoint 1, count (num=10) at gdbStep.c:18</span><br><span class="line">18	        i++;</span><br></pre></td></tr></table></figure></p>
<h2 id="继续运行到指定位置-until"><a href="#继续运行到指定位置-until" class="headerlink" title="继续运行到指定位置-until"></a>继续运行到指定位置-until</h2><p>假如我们在25行停住了，现在想要运行到29行停住，就可以使用until命令（可简写为u）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gdb gdbStep</span><br><span class="line">(gdb)b 25</span><br><span class="line">(gdb)run</span><br><span class="line">(gdb) u 29</span><br><span class="line">it will calc a + b</span><br><span class="line">3 + 7 = 10</span><br><span class="line">main () at gdbStep.c:29</span><br><span class="line">29	    count(c);</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>可以看到，在执行u 29之后，它在29行停住了。它利用的是临时断点。</p>
<h2 id="跳过执行—skip"><a href="#跳过执行—skip" class="headerlink" title="跳过执行—skip"></a>跳过执行—skip</h2><p>skip可以在step时跳过一些不想关注的函数或者某个文件的代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gdb gdbStep</span><br><span class="line">(gdb) b 27</span><br><span class="line">Breakpoint 1 at 0x4005e4: file gdbStep.c, line 27.</span><br><span class="line">(gdb) skip function add    #step时跳过add函数</span><br><span class="line">Function add will be skipped when stepping.</span><br><span class="line">(gdb) info skip   #查看step情况</span><br><span class="line">Num     Type           Enb What</span><br><span class="line">1       function       y   add</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/hyb/workspaces/gdb/gdbStep </span><br><span class="line">it will calc a + b</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at gdbStep.c:27</span><br><span class="line">27	    int c = add(a,b);</span><br><span class="line">(gdb) s</span><br><span class="line">28	    printf(&quot;%d + %d = %d\n&quot;,a,b,c);</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>可以看到，再使用skip之后，使用step将不会进入add函数。<br>step也后面也可以跟文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb)skip file gdbStep.c</span><br></pre></td></tr></table></figure></p>
<p>这样gdbStep.c中的函数都不会进入。</p>
<p>其他相关命令：</p>
<ul>
<li>skip delete [num] 删除skip</li>
<li>skip enable [num] 使能skip</li>
<li>skip disable [num] 去使能skip</li>
</ul>
<p>其中num是前面通过info skip看到的num值，上面可以带或不带该值，如果不带num，则针对所有skip，如果带上了，则只针对某一个skip。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了一些简单情况的单步调试方法或常见命令使用，但这些已经够用了，毕竟大部分程序的执行或停止都在我们的掌控之中了。</p>
]]></content>
      <categories>
        <category>gdb</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>多个域名映射同一个github pages</title>
    <url>/2019/03/29/25951.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>可能由于某种原因，换了一个域名，之前又有一些被搜索引擎收录，但是又不想让原来的链接失效，就需要让两个域名都映射到github pages中。本文介绍几种当前可能的方法。欢迎提出更多有效方法。<br><a id="more"></a></p>
<h2 id="为什么用新的域名"><a href="#为什么用新的域名" class="headerlink" title="为什么用新的域名"></a>为什么用新的域名</h2><p>由于原来的www.huyanbing.me域名在微信中打开时，会提示非微信官方网页，不能直接访问，而且即便是点击继续访问，也可能出现由于转换手机预览模式，而导致网页显示不完全。只能通过右下角的访问原网页才能正常访问，因此才想到另外申请一个域名。而com/net等域名则不会有类似的提示。</p>
<h2 id="直接映射有什么问题？"><a href="#直接映射有什么问题？" class="headerlink" title="直接映射有什么问题？"></a>直接映射有什么问题？</h2><p>你可能会想，两个域名都映射到github pages不就可以了？然而事实并非如此。首先当前github 的CNAME中只支持一个域名。因此CNAME文件中只能有一个域名，而如果在域名映射中将两个域名都映射到username.github.io，那么其中有一个会出现404错误。</p>
<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>以下方法的前提是你已经明白如何为自己的github pages添加自定义域名。</p>
<h2 id="需要注意什么？"><a href="#需要注意什么？" class="headerlink" title="需要注意什么？"></a>需要注意什么？</h2><ul>
<li>需要给各大网站提交新的域名网址，重新被收录</li>
<li>域名变换前面网站的内容结构不能变，否则重定向也没有意义</li>
<li>当前单纯的域名没有办法进行备案</li>
<li>注意修改配置文件里的主域名为新的域名</li>
<li>由于更换了新的域名，导致原来leancloud统计的访问数据需要重新计算，也就是网站访问量被清零了，leancloud也需要更新域名</li>
<li>新的com域名可申请免费的SSL证书，保证https可访问，而不会提示不安全</li>
<li>301重定向会将旧地址的权重转义到新地址上</li>
<li>百度收录速度较慢</li>
</ul>
<h2 id="方法一：域名托管平台重定向"><a href="#方法一：域名托管平台重定向" class="headerlink" title="方法一：域名托管平台重定向"></a>方法一：域名托管平台重定向</h2><p>有的域名服务商提供重定向功能，以阿里云为例，在域名映射添加记录的时候，可以选择显性URL或隐性URL。但是自己在尝试这种方法的时候，会提示我URL备案异常。可能是由于这个时候已经用新的域名映射了博客地址，但是新的域名实际上是没有备案的。更无奈的是，目前貌似没有办法单独对域名进行备案。因此本人放弃了该方法。</p>
<p>如果你的博客也是部署在github上的，那么这种方法就不用尝试了，如果你的博客是部署在自己的服务器上的，那么网上都很多方法，这里就不介绍了。</p>
<h2 id="方法二：部署两个仓库"><a href="#方法二：部署两个仓库" class="headerlink" title="方法二：部署两个仓库"></a>方法二：部署两个仓库</h2><p>我们注意到，除了github pages，还有coding.net可用。它与github类似。原来的域名映射到这个地址就可以了。而在部署hexo的时候，是可以添加两个仓库地址的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- type: git</span><br><span class="line">  repository: git@github.com:username/username.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line">- type: git</span><br><span class="line">  repository: git@git.coding.net:username/username.git</span><br><span class="line">  branch: coding-pages</span><br></pre></td></tr></table></figure></p>
<p>这两个仓库内容唯一的差别就是域名不一样，即CNAME中的记录值不一样。这样当访问两个不同的域名的时候，是访问不同的两个平台仓库。但是原来域名的权重不会转到新的域名中去。</p>
<h2 id="方法三：新增项目重定向"><a href="#方法三：新增项目重定向" class="headerlink" title="方法三：新增项目重定向"></a>方法三：新增项目重定向</h2><p>假如你已经有username.github.io项目，新建一个名为blog(名字自定义)的项目，在项目的setting中，开启github pages服务，并且将旧的域名映射到username.github.io。</p>
<p>实际上，github pages并不是只能有一个，例如，你新创建的仓库访问地址为：username.github.io/blog。<br>由于旧的域名映射会导致404错误，那么在我们的新项目中增加一个404.html，在页面中进行跳转即可：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"> &lt;script language=&quot;javascript&quot;&gt;</span><br><span class="line">var domain = &quot;换成你自己的新域名&quot;;</span><br><span class="line">var src = window.location.href;</span><br><span class="line">var prtc = src.substring(0, src.indexOf(&apos;:&apos;));</span><br><span class="line">var target = src.substring(src.indexOf(&apos;/&apos;, src.indexOf(&apos;:&apos;) + 3));</span><br><span class="line">window.location.href = prtc + &quot;://&quot; + domain + target;</span><br><span class="line">location.href=prtc + &quot;://&quot; + domain + target;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"> &lt;h1&gt;&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>另外，需要利用google的地址更改功能，使得旧网址的权重往新网址转移。<br>找到search console中的地址更改工具（设置按钮中找到）。</p>
<p>除了增加404页面外，还需要增加CNAME文件，里面的内容是你原先的域名。具体内容可以参考：<a href="https://github.com/yanbinghu/blog" target="_blank" rel="noopener">https://github.com/yanbinghu/blog</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于我的hexo博客部署在github上，因此按照第三种方法操作，目前访问<a href="https://www.huyanbing.me" target="_blank" rel="noopener">www.huyanbing.me</a>将会重定向到<a href="https://www.yanbinghu.com">www.yanbinghu.com</a>的对应地址。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>队列-c语言实现</title>
    <url>/2019/03/28/13055.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>队列是一种先进先出的数据结构，也是常见的数据结构之一。日常生活中的排队买东西就是一种典型的队列，而在购票系统也需要一个队列处理用户的购票请求，当然这里的队列就复杂多了。本文介绍队列的基本概念和实现。<br><a id="more"></a></p>
<h2 id="队列常见操作"><a href="#队列常见操作" class="headerlink" title="队列常见操作"></a>队列常见操作</h2><p>队列最常见的操作是入队和出队，拿排队买东西来说，入队就是新来一个人排在队伍后面，而出队就是一个人已经结账离开。</p>
<h2 id="队列基本实现考虑"><a href="#队列基本实现考虑" class="headerlink" title="队列基本实现考虑"></a>队列基本实现考虑</h2><p>与实现栈不同，它需要两个指针，一个指向队头（front），一个指向队尾（rear），这样才能方便地进行入队或出队操作，因此队列的实现要比栈难一些。在说明如何实现一个队列之前，先看实现一个队列可能需要注意哪些问题。</p>
<p>假如我们使用数组按照实现栈的方式来实现队列。并且队列中的数据如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>11</td>
<td>12</td>
<td>13</td>
<td>14</td>
</tr>
<tr>
<td>front</td>
<td></td>
<td></td>
<td></td>
<td>rear</td>
</tr>
</tbody>
</table>
</div>
<p>这个时候从队头front处删除一个数据，这是很容易的。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>11</td>
<td>12</td>
<td>13</td>
<td>14</td>
</tr>
<tr>
<td></td>
<td>front</td>
<td></td>
<td></td>
<td>rear</td>
</tr>
</tbody>
</table>
</div>
<p>但是如果要入队一个数据呢？这个时候发现队尾已经没有空间了，为了入队一个元素，必须将所有元素都往队头移动，这似乎很符合我们排队的习惯，前面一个人走了，后面的人都往前一个位置。<strong>但是在数组中，将所有的元素都往队头移动的开销是不容忽略的！</strong></p>
<p>有人可能已经注意到了，原来删除的地方还有一个空位呢，不如把新的元素加入到这里，然后将尾指针rear指向该处即可。没错，这就相当于<strong>把该数组当成了一个循环数组</strong>，即可以看成数组尾部和头部是连着的。这个时候就变成了下面的情况：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>15</td>
<td>11</td>
<td>12</td>
<td>13</td>
<td>14</td>
</tr>
<tr>
<td>rear</td>
<td>front</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>此时，队列是满的，rear指向下标0处，而front指向下标1处。如果这个时候删除这五个元素，就变成下面的情况：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>rear</td>
<td>front</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>我们发现队列为空时，rear指向下标0处，而front指向下标1处，与队列满时是一样的，这样的话，如何区分队列是空还是满呢？</p>
<p>很明显，队列为空时与队列满时元素数量是不一样的，我们可以通过<strong>判断队列中元素的数量是否已达上限，来判断队列是否为空。</strong></p>
<p>还有一种方法，就是使得<strong>队列满时，不占满整个数组，而保留一个空位。这样的情况下，队列满时，两个指针相隔2</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>15</td>
<td></td>
<td>12</td>
<td>13</td>
<td>14</td>
</tr>
<tr>
<td>rear</td>
<td></td>
<td>front</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>队列空时：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>rear</td>
<td>front</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>两个指针相隔1。那么就可以通过指针的间隔来判断队列是否为空了。</p>
<p>这里就说明了队列实现需要考虑的两个问题：</p>
<ul>
<li>如何高效地将元素入队</li>
<li>如何判断队列为空或队列为满</li>
</ul>
<p>当然了，如果你使用链表实现队列，那么入队也完全不需要搬移数据。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>队列的实现有多种方式可以选择，例如：</p>
<ul>
<li>静态数组，容量固定，操作简便，效率高</li>
<li>动态数组，容量可自定义，操作简便，因为涉及内存的申请与释放，因此实现比静态数组稍微复杂一点点</li>
<li>链表，容量理论上只受限于内存，实现也较为复杂</li>
<li>其他</li>
</ul>
<p>因篇幅有限，本文只选择一种实现进行说明。</p>
<p>本文的代码实现采用了静态数组实现一个队列，并且为了避免数据频繁搬移，使用了前面介绍的循环队列；为了测试队满的情况，将队列的容量设置成了很小的值，另外，也通过保留一个空位的方式来解决队空和队满无法区分的问题。</p>
<p>队列的主要定义或操作解释如下。</p>
<ul>
<li>队列结构定义，定义一个结构体，包含存储队头位置和队尾位以及队列数组</li>
<li>队列初始化，初始时，队尾值为0，队头值为1，两者差值为1</li>
<li>队列是否为空，队尾和队头差值并取模为1时，表明队列为空</li>
<li>队列是否已满，队尾和队头差值取模为2时，表明队列满</li>
<li>入队，入队前检查队列是否已满，如未满，队尾加1取模，并赋值</li>
<li>出队，出队前检查队列是否为空，如不空，则取值，并加1取模</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>完整可运行代码实现如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//arrayQueue.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*为测试，将容量值定为较小值5*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义队列结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> front; <span class="comment">//队头位置</span></span><br><span class="line">    <span class="keyword">int</span> rear;  <span class="comment">//队尾位置</span></span><br><span class="line">    ElementType queueArr[MAX_SIZE];<span class="comment">//队列数组</span></span><br><span class="line">&#125;QueueInfo;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAILURE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断队列是否已满*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_is_full</span><span class="params">(QueueInfo *<span class="built_in">queue</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">queue</span>-&gt;rear + <span class="number">2</span>) % MAX_SIZE == <span class="built_in">queue</span>-&gt;front)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"queue is full\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*判断队列是否为空*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_is_empty</span><span class="params">(QueueInfo *<span class="built_in">queue</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">queue</span>-&gt;rear + <span class="number">1</span>) % MAX_SIZE == <span class="built_in">queue</span>-&gt;front)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"queue is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出队*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_delete</span><span class="params">(QueueInfo *<span class="built_in">queue</span>,ElementType *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(queue_is_empty(<span class="built_in">queue</span>))</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">    </span><br><span class="line">    *value = <span class="built_in">queue</span>-&gt;queueArr[<span class="built_in">queue</span>-&gt;front];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"get  value from front %d  is %d\n"</span>,<span class="built_in">queue</span>-&gt;front,*value);</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = (<span class="built_in">queue</span>-&gt;front + <span class="number">1</span>) % MAX_SIZE;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*入队*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_insert</span><span class="params">(QueueInfo *<span class="built_in">queue</span>,ElementType value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(queue_is_full(<span class="built_in">queue</span>))</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = (<span class="built_in">queue</span>-&gt;rear + <span class="number">1</span>) % MAX_SIZE;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;queueArr[<span class="built_in">queue</span>-&gt;rear] = value;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"insert %d  to %d\n"</span>,value,<span class="built_in">queue</span>-&gt;rear);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*队列初始化*/</span></span><br><span class="line">    QueueInfo <span class="built_in">queue</span>;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;<span class="built_in">queue</span>,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="built_in">queue</span>));</span><br><span class="line">    <span class="built_in">queue</span>.front = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">queue</span>.rear = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*入队6个数据，最后两个入队失败*/</span></span><br><span class="line">    queue_insert(&amp;<span class="built_in">queue</span>,<span class="number">5</span>);</span><br><span class="line">    queue_insert(&amp;<span class="built_in">queue</span>,<span class="number">4</span>);</span><br><span class="line">    queue_insert(&amp;<span class="built_in">queue</span>,<span class="number">3</span>);</span><br><span class="line">    queue_insert(&amp;<span class="built_in">queue</span>,<span class="number">2</span>);</span><br><span class="line">    queue_insert(&amp;<span class="built_in">queue</span>,<span class="number">1</span>);</span><br><span class="line">    queue_insert(&amp;<span class="built_in">queue</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*出队6个数据，最后两个出队失败*/</span></span><br><span class="line">    ElementType a = <span class="number">0</span>;</span><br><span class="line">    queue_delete(&amp;<span class="built_in">queue</span>,&amp;a);</span><br><span class="line">    queue_delete(&amp;<span class="built_in">queue</span>,&amp;a);</span><br><span class="line">    queue_delete(&amp;<span class="built_in">queue</span>,&amp;a);</span><br><span class="line">    queue_delete(&amp;<span class="built_in">queue</span>,&amp;a);</span><br><span class="line">    queue_delete(&amp;<span class="built_in">queue</span>,&amp;a);</span><br><span class="line">    queue_delete(&amp;<span class="built_in">queue</span>,&amp;a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc  -o arrayQueue arrayQueue.c</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert 5  to 1</span><br><span class="line">insert 4  to 2</span><br><span class="line">insert 3  to 3</span><br><span class="line">insert 2  to 4</span><br><span class="line">queue is full</span><br><span class="line">queue is full</span><br><span class="line">get  value from front 1  is 5</span><br><span class="line">get  value from front 2  is 4</span><br><span class="line">get  value from front 3  is 3</span><br><span class="line">get  value from front 4  is 2</span><br><span class="line">queue is empty</span><br><span class="line">queue is empty</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>与《<a href="https://www.yanbinghu.com/2019/03/16/31765.html">栈的实现</a>》相比，队列的数组实现相对来说稍微复杂一点，因为它需要考虑队空和对满的区别，以及考虑数据搬移的性能影响，但是从实现本身来看，代码并不复杂。关于队列的动态数组和链表实现可自己尝试。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数据结构与算法</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>如何用栈实现表达式求值</title>
    <url>/2019/03/24/57779.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>假如要你实现一个可以识别表达式的简易计算器，你会怎么实现？例如用户输入：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 + 5 * (2 - 4)</span><br></pre></td></tr></table></figure></p>
<p>可以直接得出计算结果：-7。对于人类来说，我们很容易计算出来，因为我们从左往右看，看到后面括号时，知道括号内的计算优先级最高，因此可以先计算括号内的，然后反过来计算乘法，最后计算加法，得到最终结果。<br><a id="more"></a></p>
<h2 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h2><p>而对于计算机来说，实际也可以采用类似的顺序，先记录存储3为a，然后存储5为b，计算2-4结果存入c，再然后计算b*c存储d，最终计算a+d得到最终结果。而这种计算过程的操作顺序可描述如下(把操作符号放在操作数后面)：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 5 2 4 - * +</span><br></pre></td></tr></table></figure></p>
<p>这种记法叫做后缀或逆波兰记法（而我们平常见到的叫中缀记法），它的特点是<strong>不需要用括号就能表示出整个表达式哪部分运算先进行，也就是说不需要考虑优先级，这非常符合计算机的处理方式。</strong>这种记法很容易使用我们前面介绍的栈来求值，但是前提是需要将中缀表达式先转换为后缀表达式。对于这种转换，我们也可以使用前面介绍的<a href="https://www.yanbinghu.com/2019/03/16/31765.html">栈-C语言实现</a>或者将要介绍的树来完成，因篇幅有限，本文不准备介绍。</p>
<p>接下来将会介绍如何利用中缀表达式进行求值。</p>
<h2 id="利用栈实现中缀表达式求值"><a href="#利用栈实现中缀表达式求值" class="headerlink" title="利用栈实现中缀表达式求值"></a>利用栈实现中缀表达式求值</h2><p>前面也说到，所谓中缀表达式，就是我们能看到的正常表达式，中缀表达式求值，也就是直接对输入的表达式进行求值。为简单起见，我们这里假设<strong>只涉及加减乘除和小括号，并且操作数都是正整数，不涉及更加复杂的数据或运算。</strong></p>
<p>计算思路：</p>
<ul>
<li>使用两个栈，stack0用于存储操作数，stack1用于存储操作符</li>
<li>从左往右扫描，遇到操作数入栈stack0</li>
<li>遇到操作符时，如果优先级低于或等于栈顶操作符优先级，则从stack0弹出两个元素进行计算，并压入stack0，继续与栈顶操作符的比较优先级</li>
<li>如果遇到操作符高于栈顶操作符优先级，则直接入栈stack1</li>
<li>遇到左括号，直接入栈stack1，遇到右括号，则直接出栈并计算，直到遇到左括号</li>
</ul>
<p>上面的思路可能看起来不是很明确，我们举一个简单的例子，假如要对下面的表达式求值：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 * (2 + 3 )* 8 + 5</span><br></pre></td></tr></table></figure></p>
<p>我们从左往右开始扫描。首先遇到操作数‘6’，和操作符‘*’，分别入栈<br>stack0:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>栈顶</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>6</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>stack1:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>栈顶</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>继续往后扫描，遇到‘(’直接入栈，‘2’入栈，栈顶是左括号，’+‘入栈，‘3’入栈<br>stack0:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>栈顶</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>6</td>
<td>2</td>
<td>3</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>stack1:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>栈顶</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>(</td>
<td>+</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>继续往后扫描，遇到右括号，它与栈顶操作符‘+’相比，优先级要高，因此，将‘+’出栈，弹出两个操作数‘3’,‘2’，计算结果得到‘5’，并入栈：</p>
<p>stack0:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>栈顶</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>6</td>
<td>5</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>stack1:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>栈顶</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>(</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>继续出栈，直到遇到左括号<br>stack0:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>栈顶</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>6</td>
<td>5</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>stack1:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>栈顶</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>继续往后扫描，遇到操作符‘<em>’,优先级与栈顶‘</em>’优先级相同，因此弹出操作数并计算得到30入栈，最后‘*’入栈</p>
<p>stack0:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>栈顶</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>30</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>stack1:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>栈顶</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>继续扫描，‘8’入栈，操作符‘+’优先级小于‘*’，弹出操作数计算得到结果‘240’，并将其入栈，最后‘+’也入栈</p>
<p>stack0:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>栈顶</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>240</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>stack1:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>栈顶</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>最后‘5’入栈，发现操作符栈不为空，弹出操作符‘+’和两个操作数，并进行计算，得到‘245’，入栈，得到最终结果。<br>stack0</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>栈顶</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>245</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>stack1:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE 64 <span class="comment">/*栈大小*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TOP_OF_STACK -1 <span class="comment">/*栈顶位置*/</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType; <span class="comment">/*栈元素类型*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAILURE -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义栈结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> topOfStack; <span class="comment">/*记录栈顶位置*/</span></span><br><span class="line">    ElementType <span class="built_in">stack</span>[STACK_SIZE]; <span class="comment">/*栈数组，也可以使用动态数组实现*/</span></span><br><span class="line">&#125;StackInfo_st;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数声明*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_push</span><span class="params">(StackInfo_st *s,ElementType value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_pop</span><span class="params">(StackInfo_st *s,ElementType *value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_top</span><span class="params">(StackInfo_st *s,ElementType *value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_is_full</span><span class="params">(StackInfo_st *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_is_empty</span><span class="params">(StackInfo_st *s)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*入栈，0表示成，非0表示出错*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_push</span><span class="params">(StackInfo_st *s,ElementType value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stack_is_full(s))</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">    <span class="comment">/*先增加topOfStack，再赋值*/</span></span><br><span class="line">    s-&gt;topOfStack++;</span><br><span class="line">    s-&gt;<span class="built_in">stack</span>[s-&gt;topOfStack] = value;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_pop</span><span class="params">(StackInfo_st *s,ElementType *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">/*首先判断栈是否为空*/</span></span><br><span class="line">    <span class="keyword">if</span>(stack_is_empty(s))</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">    *value = s-&gt;<span class="built_in">stack</span>[s-&gt;topOfStack];</span><br><span class="line">    s-&gt;topOfStack--;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*访问栈顶元素*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_top</span><span class="params">(StackInfo_st *s,ElementType *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*首先判断栈是否为空*/</span></span><br><span class="line">    <span class="keyword">if</span>(stack_is_empty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty"</span>);</span><br><span class="line">            <span class="keyword">return</span> FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    *value = s-&gt;<span class="built_in">stack</span>[s-&gt;topOfStack];</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断栈是否已满，满返回1，未满返回0*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_is_full</span><span class="params">(StackInfo_st *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;topOfStack == STACK_SIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*判断栈是否为空，空返回1，非空返回0*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_is_empty</span><span class="params">(StackInfo_st *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;topOfStack == - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*用于记录符号的优先级，这里浪费了一些内存，可以优化*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> priority[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">priorityInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*初始化优先级，值越小，优先级越高*/</span></span><br><span class="line">    priority[<span class="string">'+'</span>] = <span class="number">4</span>;</span><br><span class="line">    priority[<span class="string">'-'</span>] = <span class="number">4</span>;</span><br><span class="line">    priority[<span class="string">'*'</span>] = <span class="number">3</span>;</span><br><span class="line">    priority[<span class="string">'/'</span>] = <span class="number">3</span>;</span><br><span class="line">    priority[<span class="string">'('</span>] = <span class="number">1</span>;</span><br><span class="line">    priority[<span class="string">')'</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*比较运算符的优先级,op1优先级大于op2时，返回大于0的值*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">priorityCompare</span><span class="params">(<span class="keyword">char</span> op1,<span class="keyword">char</span> op2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> priority[op2] - priority[op1];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*出栈操作符和操作数进行计算*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calcOp</span><span class="params">(StackInfo_st *nums,StackInfo_st *ops,<span class="keyword">int</span> nowOp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a ,b,op;</span><br><span class="line">    stack_pop(ops,&amp;op);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"op %c is &lt;= %c\n"</span>,nowOp,op);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"get op from stack %c\n"</span>,op);</span><br><span class="line">    <span class="keyword">if</span>(SUCCESS != stack_pop(nums,&amp;b))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pop failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(SUCCESS != stack_pop(nums,&amp;a))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pop failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"get b from stack %d\n"</span>,b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"get a from stack %d\n"</span>,a);</span><br><span class="line">    <span class="keyword">switch</span>(op)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"push %d into stack\n"</span>,a+b);</span><br><span class="line">            stack_push(nums,a+b);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            stack_push(nums,a-b);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"push %d into stack\n"</span>,a*b);</span><br><span class="line">            stack_push(nums,a*b);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"push %d into stack\n"</span>,a/b);</span><br><span class="line">            stack_push(nums,a/b);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">exp</span>,<span class="keyword">int</span> *result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == <span class="built_in">exp</span> || <span class="literal">NULL</span> == result)</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">    <span class="comment">/*创建栈，用于保存数*/</span></span><br><span class="line">    StackInfo_st nums;</span><br><span class="line">    nums.topOfStack = TOP_OF_STACK;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*用于保存操作符*/</span></span><br><span class="line">    StackInfo_st ops;</span><br><span class="line">    ops.topOfStack = TOP_OF_STACK;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*用于标记，判断上一个是否为数字*/</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> op ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0</span> != *<span class="built_in">exp</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">/*如果是数字*/</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(*<span class="built_in">exp</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"char is %c\n"</span>,*<span class="built_in">exp</span>);</span><br><span class="line">             <span class="comment">/*如果上一个还是数字，则取出栈顶数据*/</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">1</span> == flag)</span><br><span class="line">               &#123;</span><br><span class="line">            </span><br><span class="line">                stack_pop(&amp;nums,&amp;temp);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"pop from stack num %d\n"</span>,temp);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                temp = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            temp = <span class="number">10</span> * temp + *<span class="built_in">exp</span>-<span class="string">'0'</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"push %d to stack\n"</span>,temp);</span><br><span class="line">            stack_push(&amp;nums,temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*如果是操作符*/</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">'/'</span> == *<span class="built_in">exp</span> || <span class="string">'*'</span> == *<span class="built_in">exp</span> || <span class="string">'+'</span> == *<span class="built_in">exp</span> || <span class="string">'-'</span> == *<span class="built_in">exp</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"OP is %c\n"</span>,*<span class="built_in">exp</span>);</span><br><span class="line">            <span class="keyword">while</span>((ops.topOfStack &gt; TOP_OF_STACK )&amp;&amp;(SUCCESS == stack_top(&amp;ops,&amp;op))&amp;&amp;<span class="string">'('</span> != op &amp;&amp; <span class="string">')'</span>!=op&amp;&amp;(priorityCompare(*<span class="built_in">exp</span>,op) &lt;= <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                calcOp(&amp;nums, &amp;ops,*<span class="built_in">exp</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"push %c to stack ops\n"</span>,*<span class="built_in">exp</span>);</span><br><span class="line">            stack_push(&amp;ops,*<span class="built_in">exp</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*左括号直接入栈*/</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">'('</span> == *<span class="built_in">exp</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"push ( to stack ops\n"</span>);</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            stack_push(&amp;ops,*<span class="built_in">exp</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*右括号，计算*/</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">')'</span> ==*<span class="built_in">exp</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"deal with  ) in ops\n"</span>);</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/*右括号时，不断计算，直到遇见左括号*/</span></span><br><span class="line">            <span class="keyword">while</span>(SUCCESS == stack_top(&amp;ops,&amp;op) &amp;&amp; <span class="string">'('</span> != op)</span><br><span class="line">            &#123;</span><br><span class="line">                calcOp(&amp;nums, &amp;ops,*<span class="built_in">exp</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            stack_pop(&amp;ops,&amp;op);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"flag is %d\n\n"</span>,flag);</span><br><span class="line">        <span class="built_in">exp</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*计算剩余两个栈的内容*/</span></span><br><span class="line">    <span class="keyword">while</span>((!stack_is_empty(&amp;ops)) &amp;&amp; (!stack_is_empty(&amp;nums)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!calcOp(&amp;nums, &amp;ops,<span class="number">0</span>))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"exp is error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    stack_pop(&amp;nums,&amp;temp);</span><br><span class="line">    <span class="comment">/*如果栈中还有内容，说明表达式错误*/</span></span><br><span class="line">    <span class="keyword">if</span>((!stack_is_empty(&amp;ops)) || (!stack_is_empty(&amp;nums)))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n\nexp is ok\n\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(SUCCESS == stack_pop(&amp;nums,&amp;temp))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"result is %d\n"</span>,temp);</span><br><span class="line">    *result = temp;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc ,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    priorityInit();</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">exp</span>[] = <span class="string">"6 * (2 + 3 * 3)* 8 + 5"</span>;</span><br><span class="line">    calc(<span class="built_in">exp</span>,&amp;result);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"result is %d\n"</span>,result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了利用栈对中缀表达式进行求值，而代码实现还有很多不足之处，例如对表达式的正确性校验不足，只能处理正整数等等，欢迎在此基础上完善补充。尽管如此，整个过程对使用栈进行中缀表达式的求值做了一个较为完整的介绍，因此具有一定的参考性。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数据结构与算法</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>这些linux小技巧大大提高你的工作效率</title>
    <url>/2019/03/24/44171.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>linux中的一些小技巧可以大大提高你的工作效率，本文就细数那些提高效率或者短小却有效的linux技巧。<br><a id="more"></a></p>
<h2 id="命令编辑及光标移动"><a href="#命令编辑及光标移动" class="headerlink" title="命令编辑及光标移动"></a>命令编辑及光标移动</h2><p>这里有很多快捷键可以帮我们修正自己的命令。接下来使用光标二字代替光标的位置。</p>
<h4 id="删除从开头到光标处的命令文本"><a href="#删除从开头到光标处的命令文本" class="headerlink" title="删除从开头到光标处的命令文本"></a>删除从开头到光标处的命令文本</h4><p>ctrl + u，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /proc/tty;ls -al光标</span><br></pre></td></tr></table></figure></p>
<p>如果此时使用ctrl + u快捷键，那么该条命令都会被清除，而不需要长按backspace键。</p>
<h4 id="删除从光标到结尾处的命令文本"><a href="#删除从光标到结尾处的命令文本" class="headerlink" title="删除从光标到结尾处的命令文本"></a>删除从光标到结尾处的命令文本</h4><p>ctrl+k，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /proc/tty光标;ls -al</span><br></pre></td></tr></table></figure></p>
<p>如果此时使用ctrl + k快捷键，那么从光标开始处到结尾的命令文本将会被删除。</p>
<p>还有其他的操作，不再举例，例如：</p>
<ul>
<li>ctrl + a:光标移动到命令开头</li>
<li>ctrl + e：光标移动到命令结尾 </li>
<li>alt  f:光标向前移动一个单词</li>
<li>alt  b：光标向后移动一个单词</li>
<li>ctrl w：删除一个词（以空格隔开的字符串）</li>
<li>esc u :将当前词转换为大写</li>
<li>etc l :将当前词转换为小写</li>
</ul>
<h2 id="历史命令快速执行"><a href="#历史命令快速执行" class="headerlink" title="历史命令快速执行"></a>历史命令快速执行</h2><p>我们都知道history记录了执行的历史命令，而使用!＋历史命令前的数字，可快速执行历史命令。具体可参考阅读：《<a href="https://www.yanbinghu.com/2018/12/22/40915.html">Linux中“!”的惊叹用法</a>》。另外，还可以使用ctrl+r搜索执行过的命令。</p>
<h2 id="部分历史命令查看"><a href="#部分历史命令查看" class="headerlink" title="部分历史命令查看"></a>部分历史命令查看</h2><p>history会显示大量的历史命令，而fc -l只会显示部分。</p>
<h2 id="实时查看日志"><a href="#实时查看日志" class="headerlink" title="实时查看日志"></a>实时查看日志</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tail -f filename.log</span><br></pre></td></tr></table></figure>
<p>tail -f 加文件名，可以实时显示日志文件内容。当然，使用less命令查看文件内容，并且使用shift+f键，也可达到类似的效果。</p>
<h2 id="磁盘或内存情况查看"><a href="#磁盘或内存情况查看" class="headerlink" title="磁盘或内存情况查看"></a>磁盘或内存情况查看</h2><h4 id="怎么知道当前磁盘是否满了呢？"><a href="#怎么知道当前磁盘是否满了呢？" class="headerlink" title="怎么知道当前磁盘是否满了呢？"></a>怎么知道当前磁盘是否满了呢？</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ df -h</span><br><span class="line">/dev/sda14      4.6G   10M  4.4G   1% /tmp</span><br><span class="line">/dev/sda11      454M  366M   61M  86% /boot</span><br><span class="line">/dev/sda15       55G   18G   35G  35% /home</span><br><span class="line">/dev/sda1       256M   31M  226M  12% /boot/efi</span><br><span class="line">tmpfs           786M   64K  786M   1% /run/user/1000</span><br></pre></td></tr></table></figure>
<p>使用df命令可以快速查看各挂载路径磁盘占用情况。</p>
<h4 id="当前目录各个子目录占用空间大小"><a href="#当前目录各个子目录占用空间大小" class="headerlink" title="当前目录各个子目录占用空间大小"></a>当前目录各个子目录占用空间大小</h4><p>如果你已经知道home目录占用空间较大了，你想知道home目录下各个目录占用情况：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ du -h –-max-depth=1 /home(或者-d 1)</span><br><span class="line">18G	/home/hyb</span><br><span class="line">16K	/home/lost+found</span><br><span class="line">18G	/home/</span><br></pre></td></tr></table></figure></p>
<p>这里指定了目录深度，否则的话，它会递归统计子目录占用空间大小，可自行尝试。</p>
<h4 id="当前内存使用情况"><a href="#当前内存使用情况" class="headerlink" title="当前内存使用情况"></a>当前内存使用情况</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           7.7G        3.5G        452M        345M        3.7G        3.5G</span><br><span class="line">Swap:          7.6G          0B        7.6G</span><br></pre></td></tr></table></figure>
<p>通过free的结果，很容易看到当前总共内存多少，剩余可用内存多少等等。</p>
<h4 id="使用-h参数"><a href="#使用-h参数" class="headerlink" title="使用-h参数"></a>使用-h参数</h4><p>不知道你是否注意到，我们在前面几个命令中，都使用了-h参数，它的作用是使得结果以人类可读的方式呈现，所以我们看到它呈现的单位是G,M等，如果不使用-h参数，可以自己尝试一下会是什么样的结果呈现。</p>
<h2 id="根据名称查找进程id"><a href="#根据名称查找进程id" class="headerlink" title="根据名称查找进程id"></a>根据名称查找进程id</h2><p>想快速直接查找进程id，可以使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pgrep hello</span><br><span class="line">22692</span><br></pre></td></tr></table></figure></p>
<p>或者：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pidof hello</span><br><span class="line">22692</span><br></pre></td></tr></table></figure></p>
<p>其中，hello是进程名称。</p>
<h2 id="根据名称杀死进程"><a href="#根据名称杀死进程" class="headerlink" title="根据名称杀死进程"></a>根据名称杀死进程</h2><p>一般我们可以使用kill　-9 pid方式杀死一个进程，但是这样就需要先找到这个进程的进程id，实际上我们也可以直接根据名称杀死进程，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ killall hello</span><br></pre></td></tr></table></figure></p>
<p>或者：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pkill hello</span><br></pre></td></tr></table></figure></p>
<h2 id="查看进程运行时间"><a href="#查看进程运行时间" class="headerlink" title="查看进程运行时间"></a>查看进程运行时间</h2><p>可以使用下面的命令查看进程已运行时间：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ps -p 24525 -o lstart,etime </span><br><span class="line">                 STARTED     ELAPSED</span><br><span class="line">Sat Mar 23 20:52:08 2019       02:45</span><br></pre></td></tr></table></figure></p>
<p>其中24525是你要查看进程的进程id。</p>
<h2 id="快速目录切换"><a href="#快速目录切换" class="headerlink" title="快速目录切换"></a>快速目录切换</h2><ul>
<li>cd -　回到上一个目录</li>
<li>cd  回到用户家目录</li>
</ul>
<h2 id="多条命令执行"><a href="#多条命令执行" class="headerlink" title="多条命令执行"></a>多条命令执行</h2><p>我们知道使用分号隔开可以执行多条命令，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd /temp/log/;rm -rf *</span><br></pre></td></tr></table></figure></p>
<p>但是如果当前目录是/目录，并且/temp/log目录不存在，那么就会发生激动人心的一幕：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash: cd: /temp/log: No such file or directory</span><br><span class="line">（突然陷入沉默）</span><br></pre></td></tr></table></figure></p>
<p>因为;可以执行多条命令，但是不会因为前一条命令失败，而导致后面的不会执行，因此，cd执行失败后，仍然会继续执行rm -rf <em>，由于处于/目录下，结果可想而知。<br>所以你还以为这种事故是对rf -rf </em>的力量一无所知的情况下产生的吗？</p>
<p>如果解决呢？很简单，使用&amp;&amp;，例如:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd /temp/log/&amp;&amp;rm -rf *</span><br></pre></td></tr></table></figure></p>
<p>这样就会确保前一条命令执行成功，才会执行后面一条。</p>
<h2 id="查看压缩日志文件"><a href="#查看压缩日志文件" class="headerlink" title="查看压缩日志文件"></a>查看压缩日志文件</h2><p>有时候日志文件是压缩的，那么能不能偷懒一下，不解压查看呢？当然可以啦。<br>例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ zcat test.gz</span><br><span class="line">test log</span><br></pre></td></tr></table></figure></p>
<p>或者：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ zless test.gz</span><br><span class="line">test log</span><br></pre></td></tr></table></figure></p>
<h2 id="删除乱码文件"><a href="#删除乱码文件" class="headerlink" title="删除乱码文件"></a>删除乱码文件</h2><p>无论是自己意外创建还是程序异常创建，难免会出现一些命名奇怪或者乱码的文件，如何删除呢？参考《<a href="https://www.yanbinghu.com/2019/01/19/8873.html">linux中删除特殊名称文件的多种方式</a>》。</p>
<h2 id="清空文件内容"><a href="#清空文件内容" class="headerlink" title="清空文件内容"></a>清空文件内容</h2><p>比如有一个大文件，你想快速删除，或者不想删除，但是想清空内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;filename</span><br></pre></td></tr></table></figure></p>
<h2 id="将日志同时记录文件并打印到控制台"><a href="#将日志同时记录文件并打印到控制台" class="headerlink" title="将日志同时记录文件并打印到控制台"></a>将日志同时记录文件并打印到控制台</h2><p>在执行shell脚本，常常会将日志重定向，但是这样的话，控制台就没有打印了，如何使得既能记录日志文件，又能将日志输出到控制台呢？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./test.sh |tee test.log</span><br></pre></td></tr></table></figure></p>
<h2 id="终止并恢复进程执行"><a href="#终止并恢复进程执行" class="headerlink" title="终止并恢复进程执行"></a>终止并恢复进程执行</h2><p>我们使用ctrl+z 暂停一个进程的执行，也可以使用fg恢复执行。例如我们使用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat filename</span><br></pre></td></tr></table></figure></p>
<p>当我们发现文件内容可能很多时，使用ctrl+z暂停程序，而如果又想要从刚才的地方继续执行，则只需要使用fg命令即可恢复执行。或者使用bg使得进程继续在后台执行。</p>
<h2 id="计算程序运行时间"><a href="#计算程序运行时间" class="headerlink" title="计算程序运行时间"></a>计算程序运行时间</h2><p>我们可能会进程写一些小程序，并且想要知道它的运行时间，实际上我们可以很好的利用time命令帮我们计算，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ time ./fibo 30</span><br><span class="line">the 30 result is 832040</span><br><span class="line"></span><br><span class="line">real	0m0.088s</span><br><span class="line">user	0m0.084s</span><br><span class="line">sys	0m0.004s</span><br></pre></td></tr></table></figure></p>
<p>它会显示系统时间，用户时间以及实际使用的总时间。</p>
<h2 id="查看内存占用前10的进程"><a href="#查看内存占用前10的进程" class="headerlink" title="查看内存占用前10的进程"></a>查看内存占用前10的进程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ps -aux|sort -k4nr |head -n 10</span><br></pre></td></tr></table></figure>
<p>这里综合使用了ps，sort，head命令，可分别参考《<a href="https://www.yanbinghu.com/2018/04/06/53515.html">ps命令详解</a>》，《<a href="https://www.yanbinghu.com/2018/11/06/43352.html">一个命令帮你对文本排序</a>》和《<a href="https://www.yanbinghu.com/2018/10/05/61779.html">linux常用命令－文本查看篇</a>》。</p>
<h2 id="快速查找你需要的命令"><a href="#快速查找你需要的命令" class="headerlink" title="快速查找你需要的命令"></a>快速查找你需要的命令</h2><p>我们都知道man可以查看命令的帮助手册，但是如果我们想要某个功能却不知道使用哪个命令呢？别着急，还是可以使用man：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ man -k &quot;copy files&quot;</span><br><span class="line">cp (1)               - copy files and directories</span><br><span class="line">cpio (1)             - copy files to and from archives</span><br><span class="line">git-checkout-index (1) - Copy files from the index to the working tree</span><br><span class="line">gvfs-copy (1)        - Copy files</span><br><span class="line">gvfs-move (1)        - Copy files</span><br><span class="line">install (1)          - copy files and set attributes</span><br></pre></td></tr></table></figure></p>
<p>使用-k参数，使得与copy files相关的帮助手册都显示出来了。</p>
<h2 id="命令行下的复制粘贴"><a href="#命令行下的复制粘贴" class="headerlink" title="命令行下的复制粘贴"></a>命令行下的复制粘贴</h2><p>我们知道，在命令行下，复制不能再是ctrl + c了，因为它表示终止当前进程，而命令行下的复制粘贴需要使用下面的快捷键：</p>
<ul>
<li>ctrl +  insert</li>
<li>shift + insert</li>
</ul>
<h2 id="搜索包含某个字符串的文件"><a href="#搜索包含某个字符串的文件" class="headerlink" title="搜索包含某个字符串的文件"></a>搜索包含某个字符串的文件</h2><p>例如，要在当前目录下查找包含test字符串的文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ grep -rn &quot;test&quot;</span><br><span class="line">test2.txt:1:test</span><br></pre></td></tr></table></figure></p>
<p>它便可以找到该字符串在哪个文件的第几行。</p>
<h2 id="屏幕冻结"><a href="#屏幕冻结" class="headerlink" title="屏幕冻结"></a>屏幕冻结</h2><p>程序运行时，终端可能输出大量的日志，你想简单查看一下，又不想记录日志文件，此时可以使用ctrl+s键，冻结屏幕，使得日志不再继续输出，而如果想要恢复，可使用ctrl+q退出冻结。</p>
<h2 id="无编辑器情况下编辑文本文件"><a href="#无编辑器情况下编辑文本文件" class="headerlink" title="无编辑器情况下编辑文本文件"></a>无编辑器情况下编辑文本文件</h2><p>如果在某些系统上连基本的vi编辑器都没有，那么可以使用下面的方式进行编辑内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat &gt;file.txt</span><br><span class="line">some words</span><br><span class="line">(ctrl+d)</span><br></pre></td></tr></table></figure></p>
<p>编辑完成后，ctrl+d即可保存。</p>
<h2 id="查看elf文件"><a href="#查看elf文件" class="headerlink" title="查看elf文件"></a>查看elf文件</h2><h4 id="查看elf文件头信息"><a href="#查看elf文件头信息" class="headerlink" title="查看elf文件头信息"></a>查看elf文件头信息</h4><p>例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ readelf -h filename</span><br></pre></td></tr></table></figure></p>
<p>我们在显示结果中，可以看到运行的平台，elf文件类型，大小端情况等。</p>
<h4 id="查看库中是否包含某个接口"><a href="#查看库中是否包含某个接口" class="headerlink" title="查看库中是否包含某个接口"></a>查看库中是否包含某个接口</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nm filename |grep interface</span><br></pre></td></tr></table></figure>
<p>这里是从文件filename中查看是否包含interface接口，前提是该文件包含符号表。<br>更多相关内容，可参考《<a href="https://www.yanbinghu.com/2018/09/26/61877.html">linux常用命令-开发调试篇</a>》</p>
<h2 id="过滤查看日志"><a href="#过滤查看日志" class="headerlink" title="过滤查看日志"></a>过滤查看日志</h2><p>例如想要查看包含test关键字的日志行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sed -n &quot;/test/p&quot; logfile</span><br></pre></td></tr></table></figure></p>
<p>这样只会显示那些包含test行的日志。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文所提到的内容建议自己上机操作，体验效果。本文总结了一些常用的linux小技巧，你还有哪些linux小技巧？欢迎留言分享。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>atoi函数实现</title>
    <url>/2019/03/21/59995.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们都知道，atoi函数用于将一个字符串转换成整数。atoi函数看起来似乎很容易实现，你甚至可以很快写出一个版本，但是是否符合要求呢？<br><a id="more"></a></p>
<h2 id="简易版本"><a href="#简易版本" class="headerlink" title="简易版本"></a>简易版本</h2><p>最简单的考虑，就是遍历字符串，每遇到一个数字就加上原来的值乘以10。例如字符串“1234”转整数是这样的计算流程：</p>
<ul>
<li>遇到字符1，得到结果1；</li>
<li>遇到字符2，得到结果1 * 10 + 2，即12；</li>
<li>遇到字符3，得到结果12 * 10 + 3，即123；</li>
<li>遇到字符4，得到结果123 * 10 + 4，即1234；</li>
</ul>
<p>代码实现如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_atoi</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == str)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0</span> != *str)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = ret * <span class="number">10</span> + *str - <span class="string">'0'</span>;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看起来既简洁又没有什么问题，输入数值时也似乎能得到正确结果。真的是这样吗？如果传入以下字符串参数，会是什么结果呢？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;-1&quot;</span><br><span class="line">&quot;+1&quot;</span><br><span class="line">&quot;  &quot;</span><br><span class="line">&quot;111111111111&quot;</span><br><span class="line">&quot;&quot;</span><br><span class="line">&quot;1aab&quot;</span><br></pre></td></tr></table></figure></p>
<p>是不是发现并不是想象中的那样？那么实现atoi到底需要注意什么呢？</p>
<h2 id="实现atoi函数需要注意什么"><a href="#实现atoi函数需要注意什么" class="headerlink" title="实现atoi函数需要注意什么"></a>实现atoi函数需要注意什么</h2><p>你可能已经注意到了，实现atoi需要考虑下面这些场景：</p>
<ul>
<li>输入正负号</li>
<li>开头有空格</li>
<li>转换后的数值超出int的表示范围</li>
<li>出错时返回0与正确转换0的区别</li>
<li>输入非数字</li>
<li>空字符串</li>
</ul>
<p>现在来看，前面的实现还能满足要求吗？</p>
<h2 id="再次实现"><a href="#再次实现" class="headerlink" title="再次实现"></a>再次实现</h2><p>那么重新考虑上面的要求，我们如何实现呢？我们需要考虑以下几种情况</p>
<ul>
<li>如果开头是负号，则标记为负数；正号或数值，则标记为正数</li>
<li>跳过开头的空格，从第一个有效字符开始</li>
<li>使用更大类型存储计算值，如果负数比INT_MIN还小或正数比INT_MAX还大，则表明溢出，返回INT_MIN或INT_MAX，或者在下次计算之前与INT_MIN/10或INT_MAX/10比较</li>
<li>使用全局变量记录出错情况，区别正常转换为0或最大最小值</li>
<li>遇到非数值时即退出</li>
</ul>
<p>根据上面这些考虑，我们重新实现代码：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL_PTR_ERR 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT_ERR 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERANGE 3</span></span><br><span class="line"><span class="keyword">int</span> errCode = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_atoi</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> negative = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> overflow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cutoff;</span><br><span class="line">    <span class="keyword">int</span> cutlim;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*计算结果存储*/</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    errCode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == str)</span><br><span class="line">    &#123;</span><br><span class="line">        errCode = NULL_PTR_ERR;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*跳过开始的空格*/</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="string">' '</span> == (*str))</span><br><span class="line">        str++;</span><br><span class="line">    <span class="comment">/*跳过空格之后，到达了字符串结尾，则退出*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == *str)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*负数*/</span></span><br><span class="line">    <span class="keyword">if</span>(*str == <span class="string">'-'</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        negative = <span class="number">1</span>;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*正数*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(*str == <span class="string">'+'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        negative = <span class="number">0</span>;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*正数*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isdigit</span>(*str))</span><br><span class="line">    &#123;</span><br><span class="line">        negative = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*如果不是以上内容，则直接退出*/</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        errCode = INPUT_ERR;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cutoff = INT_MAX /<span class="number">10</span>;</span><br><span class="line">    cutlim = INT_MAX % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(*str))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*如果当前结果已经大于int最大值除以10或者等于最大值除以10，并且当前数值大于其余数，则溢出*/</span></span><br><span class="line">		<span class="keyword">if</span> (ret &gt; cutoff || (ret == cutoff &amp;&amp; (<span class="keyword">int</span>)(*str-<span class="string">'0'</span>) &gt; cutlim))</span><br><span class="line">		&#123;</span><br><span class="line">			errCode = ERANGE;</span><br><span class="line">			overflow = <span class="number">1</span>;</span><br><span class="line">		&#125;       </span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123; </span><br><span class="line">			<span class="comment">/*计算结果*/</span></span><br><span class="line">        	ret = ret*<span class="number">10</span> + (*str -<span class="string">'0'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*如果溢出，则返回最值*/</span></span><br><span class="line">	<span class="keyword">if</span>(overflow)</span><br><span class="line">		<span class="keyword">return</span> negative?INT_MIN:INT_MAX;</span><br><span class="line">    <span class="comment">/*根据正负号返回正确的结果*/</span></span><br><span class="line">    <span class="keyword">return</span> negative?-ret:ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*只有一个负号*/</span></span><br><span class="line">    <span class="keyword">int</span> result = my_atoi(<span class="string">"-"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-:%d,errCode:%d\n"</span>,result,errCode);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*空指针*/</span></span><br><span class="line">    result = my_atoi(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"NULL:%d,errCode:%d\n"</span>,result,errCode);</span><br><span class="line">    <span class="comment">/*空字符串*/</span></span><br><span class="line">    result = my_atoi(<span class="string">"      "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"     :%d,errCode:%d\n"</span>,result,errCode);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*负数*/</span></span><br><span class="line">    result = my_atoi(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  -1:%d,errCode:%d\n"</span>,result,errCode);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*负数溢出*/</span></span><br><span class="line">    result = my_atoi(<span class="string">"   -11111111111"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"   -11111111111:%d,errCode:%d\n"</span>,result,errCode);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*正数*/</span></span><br><span class="line">    result = my_atoi(<span class="string">"+123"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"+123:%d,errCode:%d\n"</span>,result,errCode);</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/*正数溢出*/</span></span><br><span class="line">    result = my_atoi(<span class="string">"+123111111111111111"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"+123111111111111111:%d,errCode:%d\n"</span>,result,errCode);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-:0,errCode:0</span><br><span class="line">NULL:0,errCode:1</span><br><span class="line">     :0,errCode:0</span><br><span class="line">  -1:-1,errCode:0</span><br><span class="line">   -11111111111:-2147483648,errCode:2</span><br><span class="line">+123:123,errCode:0</span><br><span class="line">+123111111111111111:2147483647,errCode:2</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面的代码中errCode的设置需要根据需求而定，例如如果认为空字符串转换是非法的，那么前面的代码将不符合要求。但这些都不是重点，重点是我们在考虑实现atoi函数的时候，需要考虑多种异常场景，这在平常实现其他功能接口的时候也是一样的。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>前面的代码有什么不足？你忽略了哪些场景？</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>linux字词统计命令-wc</title>
    <url>/2019/03/21/27675.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>wc(world count)是一个统计文件字词，字节，行数的命令，它可以帮我们非常方便的统计以上信息。<br><a id="more"></a></p>
<h2 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h2><p>常见参数如下：</p>
<ul>
<li>-c 统计字节数。</li>
<li>-l 统计行数。</li>
<li>-m 统计字符数。这个标志不能与 -c 标志一起使用。</li>
<li>-w 统计字数。注意，这里的字指的是由空格，换行符等分隔的字符串。</li>
</ul>
<p>我们接下来直接看几个实例。</p>
<h2 id="统计文件行数，词数和字节数"><a href="#统计文件行数，词数和字节数" class="headerlink" title="统计文件行数，词数和字节数"></a>统计文件行数，词数和字节数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ wc test.txt </span><br><span class="line">1 1 7 test.txt</span><br></pre></td></tr></table></figure>
<p>打印结果表明该文件有1行，1个词，7字节。</p>
<p>要特别提醒的是，这里的词是以空格，换行符等分隔开的字符串，也就是说<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">words 字词</span><br></pre></td></tr></table></figure></p>
<p>这里只有两个词。</p>
<h2 id="仅统计文件行数，词数，字符数或字节数"><a href="#仅统计文件行数，词数，字符数或字节数" class="headerlink" title="仅统计文件行数，词数，字符数或字节数"></a>仅统计文件行数，词数，字符数或字节数</h2><p>仅统计单项内容时，仅需要带上对应的参数即可，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ wc -l test.txt</span><br><span class="line">1 test.txt</span><br></pre></td></tr></table></figure></p>
<p>使用-l参数，使得只显示行数。</p>
<p>但是这里特别要注意的是字符数和字节数的区别。字节数是数据占用的空间大小，而一个字符可能占多个字节，例如，UTF-8编码中，一个英文字母就是一个字符，占用空间一个字节，而一个中文，则占用3字节大小。<br>举个例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">编程</span><br></pre></td></tr></table></figure></p>
<p>编程，在这里是两个字符，而占用空间是6字节，但是使用wc -m统计会比两个多一个，是3个字符。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo 编程|wc -m</span><br><span class="line">3</span><br><span class="line">$ echo 编程|wc -c</span><br><span class="line">7</span><br></pre></td></tr></table></figure></p>
<p>各编码字符占用字符情况如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>编码</th>
<th>英文字母</th>
<th>中文</th>
</tr>
</thead>
<tbody>
<tr>
<td>UTF-8</td>
<td>1字节</td>
<td>3字节</td>
</tr>
<tr>
<td>Unicode</td>
<td>1字节</td>
<td>2字节</td>
</tr>
</tbody>
</table>
</div>
<p>你可以使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo $LANG</span><br><span class="line">en_GB.UTF-8</span><br></pre></td></tr></table></figure></p>
<p>查看编码格式。</p>
<p>有人可能问，为什么会多一个字节？实际上，你是用od命令查看二进制内容就会发现，文本最后还有一个换行符：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ od -A x -c test.txt</span><br><span class="line">000000 347 274 226 347 250 213  \n</span><br><span class="line">000007</span><br><span class="line">$ cat test.text</span><br><span class="line">编程</span><br><span class="line">$ wc -m test.txt</span><br><span class="line">3 test.txt</span><br></pre></td></tr></table></figure></p>
<h2 id="统计命令执行结果数量"><a href="#统计命令执行结果数量" class="headerlink" title="统计命令执行结果数量"></a>统计命令执行结果数量</h2><p>实际上个人认为，最常用的还是-l参数，它用来统计文件或标准输出有多少行，那么实际上就可以用来做很多统计的事情了。<br>例如，统计当前目录下有多少个普通文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">total 4</span><br><span class="line">-rw-rw-r-- 1 hyb hyb  0 3月  21 20:32 test2.txt</span><br><span class="line">-rw-rw-r-- 1 hyb hyb 13 3月  21 20:18 test.txt</span><br><span class="line">$ ls -l |grep &quot;^-&quot;|wc -l</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>
<p>可以得到文件数量为2。grep “^-“的意思是，获取哪些以-开头的行，因为普通文件都是以-开头的。</p>
<p>当然如果想统计包括子目录的总文件数量，可以加上-R参数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -lR |grep &quot;^-&quot;|wc -l</span><br></pre></td></tr></table></figure></p>
<p>再例如，查看chrome相关进程数量：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ps -ef|grep google|grep -v grep |wc -l</span><br><span class="line">23</span><br></pre></td></tr></table></figure></p>
<p>类似这样的用法还有很多，只要你想统计都可以做。</p>
<p>这里再多说两句：</p>
<ul>
<li>|是管道符，ls -l|wc -l表示将ls -l的结果传给wc命令处理</li>
<li>grep用于文本查找，grep “a”，表明查找包含a的行，而grep -v “b”，表明过滤包含b的行。<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>wc命令可用于统计行数，字节数和字符数等，而用于统计命令执行结果的数量的时候非常有效。</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-20.有效的括号</title>
    <url>/2019/03/17/62434.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>leetcode 20. 有效的括号 堆栈<br><a id="more"></a></p>
<h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>
<p>示例 1:</p>
<p>输入: “()”<br>输出: true<br>示例 2:</p>
<p>输入: “()[]{}”<br>输出: true<br>示例 3:</p>
<p>输入: “(]”<br>输出: false<br>示例 4:</p>
<p>输入: “([)]”<br>输出: false<br>示例 5:</p>
<p>输入: “{[]}”<br>输出: true</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>这道题就非常适合用我们之前介绍过的栈（<a href="https://www.yanbinghu.com/2019/03/16/31765.html">栈-C语言实现</a>）这种数据结构来解决。怎么处理呢？我们发现括号都是成对的，如果成对的括号，并且括号中间的括号也可以成对，那么整个字符串就是有效的。比如说：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&#123;[]&#125;&quot;</span><br></pre></td></tr></table></figure></p>
<p>在{}之间的[]是成对的，它们可以互相抵消掉，之后{}也是成对的。我们可以利用栈，遍历整个字符串，遇到左括号，入栈，遇到右括号，检查栈中是否是左括号，如果是，那么就将左括号出栈，右括号也不入栈。如果字符串的是合法的，那么最终栈为空，否则栈不为空。</p>
<p>我们来看一个例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">“&#123;[]&#125;”</span><br></pre></td></tr></table></figure></p>
<p>遇见左大括号，入栈：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>栈顶</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>{</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>遇见左方括号，入栈：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>栈顶</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>{</td>
<td>[</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>遇见右方括号，检查栈顶是左方括号，出栈：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>栈顶</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>{</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>遇见右大括号，检查栈顶是左大括号，出栈：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>此时扫描完毕，并且栈为空，因此该字符串合法。</p>
<p>我们再来看一个非法的例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">”([)]“</span><br></pre></td></tr></table></figure></p>
<p>首先遇到左小括号，入栈：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>栈顶</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>(</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>遇到左方括号,入栈：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>栈顶</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>(</td>
<td>[</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>遇到右小括号，检查栈顶是否有左小括号，发现没有，入栈(其实这个时候就可以判断字符串不合法了)：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>栈顶</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>(</td>
<td>[</td>
<td>)</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>遇到右中括号，检查栈顶是否有左方括号，发现没有，入栈：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th>栈顶</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>(</td>
<td>[</td>
<td>)</td>
<td>]</td>
</tr>
</tbody>
</table>
</div>
<p>扫描完成后，发现栈不为空，因此字符串不合法。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>在实现代码的时候，需要注意以下几点：</p>
<ul>
<li>遇见第一个右括号无匹配时即退出</li>
<li>由于输入字符串长度可能较大，因此不适合使用静态数组</li>
<li>判断是否有左括号前检查栈是否为空</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == s)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="comment">/*使用数组作为栈，申请内存*/</span></span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">stack</span> = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == <span class="built_in">stack</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> topOfStack = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0</span> != *s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*遇见左括号入栈*/</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">'&#123;'</span> == *s || <span class="string">'['</span> == *s || <span class="string">'('</span> == *s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//printf("push %c to stack\n",*s);</span></span><br><span class="line">            topOfStack++;</span><br><span class="line">            <span class="built_in">stack</span>[topOfStack] = *s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*如果此时栈为空，说明之前都没有左括号，因此肯定不匹配，直接退出*/</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(topOfStack == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            topOfStack++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*遇见右括号，栈顶是左括号，出栈*/</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((<span class="string">'&#125;'</span> == *s &amp;&amp; <span class="string">'&#123;'</span> == <span class="built_in">stack</span>[topOfStack] )||</span><br><span class="line">        (<span class="string">')'</span> == *s &amp;&amp; <span class="string">'('</span> == <span class="built_in">stack</span>[topOfStack]) ||</span><br><span class="line">        ( <span class="string">']'</span> == *s &amp;&amp; <span class="string">'['</span> == <span class="built_in">stack</span>[topOfStack]))</span><br><span class="line">        &#123;</span><br><span class="line">            topOfStack--;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">/*右括号，并且栈顶不是左括号，肯定不匹配，直接退出*/</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">'&#125;'</span> == *s || <span class="string">']'</span> == *s || <span class="string">')'</span> == *s )</span><br><span class="line">        &#123;</span><br><span class="line">            topOfStack++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="comment">/*判断栈是否为空*/</span></span><br><span class="line">    <span class="keyword">return</span> topOfStack == <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结<br>本文利用栈结构在O(n)时间复杂度,O(n)空间复杂度解决了括号匹配问题。你还有什么解法？欢迎留言。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>栈-c语言实现</title>
    <url>/2019/03/16/31765.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>栈是一种应用广泛的数据结构，例如函数的调用就需要使用栈，其实我们在介绍《<a href="https://www.yanbinghu.com/2019/02/21/28355.html">快速排序优化详解</a>》的时候也使用到了栈结构。栈最鲜明的特点就是后进先出，一碟盘子就是类似这样的结构，最晚放上去的，可以最先拿出来。本文将介绍的是如何自己实现一个栈结构。<br><a id="more"></a></p>
<h2 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h2><p>栈的常见操作有出栈(POP)，从栈中弹出一个元素；入栈(PUSH)，将一个元素压入栈中，访问栈顶元素(TOP)，判断栈是否为空等。</p>
<h2 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h2><p>栈是较容易实现的抽象数据结构之一。我们可以选择数组或者链表来实现，它们各有特点，前者容量有限且固定，但操作简单，而后者容量理论上不受限，但是操作并不如数组方便，每次入栈要进行内存申请，出栈要释放内存，稍有不慎便造成内存泄露。本文对两种实现都做介绍。</p>
<h2 id="数组实现栈"><a href="#数组实现栈" class="headerlink" title="数组实现栈"></a>数组实现栈</h2><p>用数组实现栈是比较容易的。这个时候的栈其实更像是访问受限的数组，数组可以通过下标访问，查找，插入等，但是栈只能从栈顶，或者说数组的末尾进行操作。我们只需要一个指针记录栈顶即可。有人可能问了，既然这里栈是访问受限的数组，为什么不直接使用数组呢？所谓能力越大，责任越大，而你暴露的越多，风险也越大就是如此。</p>
<p>我们来看一下数组实现栈的时候，栈的操作都是怎么实现的呢？</p>
<h4 id="定义栈"><a href="#定义栈" class="headerlink" title="定义栈"></a>定义栈</h4><p>用数组实现栈时是很容易定义的，只要定一个固定长度的数组即可，然后使用一个指针或者数组下标标记栈顶（topOfStack），栈为空时，它是-1：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE 64 <span class="comment">/*栈大小*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TOP_OF_STACK -1 <span class="comment">/*栈顶位置*/</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType <span class="comment">/*栈元素类型*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> topOfStack; <span class="comment">/*记录栈顶位置*/</span></span><br><span class="line">    ElementType <span class="built_in">stack</span>[STACK_SIZE]; <span class="comment">/*栈数组，也可以使用动态数组实现*/</span></span><br><span class="line">&#125;StackInfo_st;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建栈*/</span></span><br><span class="line">StackInfo_st <span class="built_in">stack</span>;</span><br><span class="line"><span class="built_in">stack</span>.topOfStack = TOP_OF_STACK;</span><br></pre></td></tr></table></figure></p>
<h4 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h4><p>入栈操作也很简单，只需要先将topOfStack加1，然后将元素放入数组即可。当然特别要注意检查此时栈是否已满。<br>topOfStack = -1</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>将1入栈，此时topOfStack = 0，</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>topOfStack</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>代码实现：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAILURE -1</span></span><br><span class="line"><span class="comment">/*入栈，0表示成功，非0表示出错*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_push</span><span class="params">(StackInfo_st *s, ElementType value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stack_is_full(s))</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">    <span class="comment">/*先增加topOfStack，再赋值*/</span></span><br><span class="line">    s-&gt;topOfStack++;</span><br><span class="line">    s-&gt;<span class="built_in">stack</span>[s-&gt;topOfStack] = value;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="出栈或访问栈顶元素"><a href="#出栈或访问栈顶元素" class="headerlink" title="出栈或访问栈顶元素"></a>出栈或访问栈顶元素</h4><p>与入栈相反，先访问元素，然后将topOfStack减1，但是此时要注意检查栈是否已空。访问栈顶元素可直接使用下标访问，而不用将topOfStack减1。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*出栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_pop</span><span class="params">(StackInfo_st *s,ElementType *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*首先判断栈是否为空*/</span></span><br><span class="line">    <span class="keyword">if</span>(stack_is_empty(s))</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">    *value = s-&gt;<span class="built_in">stack</span>[s-&gt;topOfStack];</span><br><span class="line">    s-&gt;topOfStack--;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*访问栈顶元素*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_top</span><span class="params">(StackInfo_st *s,ElementType *value)</span></span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*首先判断栈是否为空*/</span></span><br><span class="line">    <span class="keyword">if</span>(stack_is_empty(s))</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">    *value = s-&gt;<span class="built_in">stack</span>[s-&gt;topOfStack];</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="判断栈是否满"><a href="#判断栈是否满" class="headerlink" title="判断栈是否满"></a>判断栈是否满</h4><p>只要判断topOfStack与数组大小-1的大小即可。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*判断栈是否已满，满返回1，未满返回0*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_is_full</span><span class="params">(StackInfo_st *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;topOfStack == STACK_SIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="判断栈是否为空"><a href="#判断栈是否为空" class="headerlink" title="判断栈是否为空"></a>判断栈是否为空</h4><p>只需要判断topOfStack是否小于等于-1即可。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*判断栈是否为空，空返回1，非空返回0*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_is_empty</span><span class="params">(StackInfo_st *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;topOfStack ==  - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="完整可运行代码"><a href="#完整可运行代码" class="headerlink" title="完整可运行代码"></a>完整可运行代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE 64 <span class="comment">/*栈大小*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TOP_OF_STACK -1 <span class="comment">/*栈顶位置*/</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType; <span class="comment">/*栈元素类型*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAILURE -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义栈结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> topOfStack; <span class="comment">/*记录栈顶位置*/</span></span><br><span class="line">    ElementType <span class="built_in">stack</span>[STACK_SIZE]; <span class="comment">/*栈数组，也可以使用动态数组实现*/</span></span><br><span class="line">&#125;StackInfo_st;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数声明*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_push</span><span class="params">(StackInfo_st *s,ElementType value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_pop</span><span class="params">(StackInfo_st *s,ElementType *value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_top</span><span class="params">(StackInfo_st *s,ElementType *value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_is_full</span><span class="params">(StackInfo_st *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_is_empty</span><span class="params">(StackInfo_st *s)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*入栈，0表示成，非0表示出错*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_push</span><span class="params">(StackInfo_st *s,ElementType value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stack_is_full(s))</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">    <span class="comment">/*先增加topOfStack，再赋值*/</span></span><br><span class="line">    s-&gt;topOfStack++;</span><br><span class="line">    s-&gt;<span class="built_in">stack</span>[s-&gt;topOfStack] = value;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_pop</span><span class="params">(StackInfo_st *s,ElementType *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*首先判断栈是否为空*/</span></span><br><span class="line">    <span class="keyword">if</span>(stack_is_empty(s))</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">    *value = s-&gt;<span class="built_in">stack</span>[s-&gt;topOfStack];</span><br><span class="line">    s-&gt;topOfStack--;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*访问栈顶元素*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_top</span><span class="params">(StackInfo_st *s,ElementType *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*首先判断栈是否为空*/</span></span><br><span class="line">    <span class="keyword">if</span>(stack_is_empty(s))</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">    *value = s-&gt;<span class="built_in">stack</span>[s-&gt;topOfStack];</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断栈是否已满，满返回1，未满返回0*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_is_full</span><span class="params">(StackInfo_st *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;topOfStack == STACK_SIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断栈是否为空，空返回1，非空返回0*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_is_empty</span><span class="params">(StackInfo_st *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;topOfStack ==  - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*创建栈*/</span></span><br><span class="line">    StackInfo_st <span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">stack</span>.topOfStack = TOP_OF_STACK;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*如果栈为空，则压入元素1*/</span></span><br><span class="line">    <span class="keyword">if</span>(stack_is_empty(&amp;<span class="built_in">stack</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"push value 1\n"</span>);</span><br><span class="line">        stack_push(&amp;<span class="built_in">stack</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*访问栈顶元素*/</span></span><br><span class="line">    <span class="keyword">int</span> topVal;</span><br><span class="line">    stack_top(&amp;<span class="built_in">stack</span>, &amp;topVal);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"top value %d\n"</span>,topVal);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*出栈*/</span></span><br><span class="line">    <span class="keyword">int</span> popVal;</span><br><span class="line">    stack_pop(&amp;<span class="built_in">stack</span>, &amp;popVal);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pop value %d\n"</span>,popVal);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(SUCCESS == stack_push(&amp;<span class="built_in">stack</span>,i))</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"stack is full,topOfStack is %d\n"</span>,<span class="built_in">stack</span>.topOfStack);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push value 1</span><br><span class="line">top value 1</span><br><span class="line">pop value 1</span><br><span class="line">stack is full,topOfStack is 63</span><br></pre></td></tr></table></figure></p>
<h2 id="链表实现栈"><a href="#链表实现栈" class="headerlink" title="链表实现栈"></a>链表实现栈</h2><p>与数组实现栈不一样的地方是，链式栈可以动态扩容，基本没有长度限制（受限于内存）。另外，它在入栈以及出栈的时候需要申请或者释放内存。</p>
<h4 id="创建栈"><a href="#创建栈" class="headerlink" title="创建栈"></a>创建栈</h4><p>创建栈很容易，只需要声明一个头指针即可，它的next指针指向栈顶，初始时为空：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*定义栈结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType value; <span class="comment">/*记录栈顶位置*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackInfo</span> *<span class="title">next</span>;</span> <span class="comment">/*指向栈的下一个元素*/</span></span><br><span class="line">&#125;StackInfo_st;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建栈，外部释放内存*/</span></span><br><span class="line"><span class="function">StackInfo_st *<span class="title">createStack</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StackInfo_st *<span class="built_in">stack</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackInfo_st));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == <span class="built_in">stack</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"malloc failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; </span><br><span class="line">        <span class="comment">/*stack-next为栈顶指针*/</span></span><br><span class="line">    <span class="built_in">stack</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="入栈-1"><a href="#入栈-1" class="headerlink" title="入栈"></a>入栈</h4><p>入栈只需要为新的元素申请内存空间，并将栈顶指针指向新的节点即可。<br><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E6%A0%88-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/stack_push.png" alt="入栈操作"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*入栈，0表示成，非0表示出错*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_push</span><span class="params">(StackInfo_st *s,ElementType value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StackInfo_st *temp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackInfo_st));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == temp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"malloc failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*将新的节点添加s-&gt;next前，使得s-&gt;next永远指向栈顶*/</span></span><br><span class="line">    temp-&gt;value = value;</span><br><span class="line">      temp-&gt;next = s-&gt;next;</span><br><span class="line">    s-&gt;next = temp;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="出栈或访问栈顶元素-1"><a href="#出栈或访问栈顶元素-1" class="headerlink" title="出栈或访问栈顶元素"></a>出栈或访问栈顶元素</h4><p>出栈时，将栈顶指针指向下下个节点，返回元素值，并释放栈顶指针下个节点的内存。而访问栈顶元素只需要返回栈顶指针指向节点的元素值即可。<br><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/%E6%A0%88-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/stack_pop.png" alt="出栈"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*出栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_pop</span><span class="params">(StackInfo_st *s,ElementType *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*首先判断栈是否为空*/</span></span><br><span class="line">    <span class="keyword">if</span>(stack_is_empty(s))</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*找出栈顶元素*/</span></span><br><span class="line">    *value = s-&gt;next-&gt;value;</span><br><span class="line">    StackInfo_st *temp = s-&gt;next;</span><br><span class="line">    s-&gt;next = s-&gt;next-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*释放栈顶节点内存*/</span></span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    temp = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*访问栈顶元素*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_top</span><span class="params">(StackInfo_st *s,ElementType *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*首先判断栈是否为空*/</span></span><br><span class="line">    <span class="keyword">if</span>(stack_is_empty(s))</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">    *value = s-&gt;next-&gt;value;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="判断栈是否为空-1"><a href="#判断栈是否为空-1" class="headerlink" title="判断栈是否为空"></a>判断栈是否为空</h4><p>判断栈空也很简单，只需要判断栈顶指针是否为空即可。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*判断栈是否为空，空返回1，未空返回0*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_is_empty</span><span class="params">(StackInfo_st *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*栈顶指针为空，则栈为空*/</span></span><br><span class="line">    <span class="keyword">return</span> s-&gt;next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="完整可运行代码-1"><a href="#完整可运行代码-1" class="headerlink" title="完整可运行代码"></a>完整可运行代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType; <span class="comment">/*栈元素类型*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAILURE -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义栈结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType value; <span class="comment">/*记录栈顶位置*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackInfo</span> *<span class="title">next</span>;</span> <span class="comment">/*指向栈的下一个元素*/</span></span><br><span class="line">&#125;StackInfo_st;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数声明*/</span></span><br><span class="line"><span class="function">StackInfo_st *<span class="title">createStack</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_push</span><span class="params">(StackInfo_st *s,ElementType value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_pop</span><span class="params">(StackInfo_st *s,ElementType *value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_top</span><span class="params">(StackInfo_st *s,ElementType *value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_is_empty</span><span class="params">(StackInfo_st *s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建栈，外部释放内存*/</span></span><br><span class="line"><span class="function">StackInfo_st *<span class="title">createStack</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StackInfo_st *<span class="built_in">stack</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackInfo_st));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == <span class="built_in">stack</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"malloc failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">stack</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*入栈，0表示成，非0表示出错*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_push</span><span class="params">(StackInfo_st *s,ElementType value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StackInfo_st *temp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackInfo_st));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == temp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"malloc failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*将新的节点添加s-&gt;next前，使得s-&gt;next永远指向栈顶*/</span></span><br><span class="line">    temp-&gt;value = value;</span><br><span class="line">      temp-&gt;next = s-&gt;next;</span><br><span class="line">    s-&gt;next = temp;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_pop</span><span class="params">(StackInfo_st *s,ElementType *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*首先判断栈是否为空*/</span></span><br><span class="line">    <span class="keyword">if</span>(stack_is_empty(s))</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*找出栈顶元素*/</span></span><br><span class="line">    *value = s-&gt;next-&gt;value;</span><br><span class="line">    StackInfo_st *temp = s-&gt;next;</span><br><span class="line">    s-&gt;next = s-&gt;next-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*释放栈顶节点内存*/</span></span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    temp = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*访问栈顶元素*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_top</span><span class="params">(StackInfo_st *s,ElementType *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*首先判断栈是否为空*/</span></span><br><span class="line">    <span class="keyword">if</span>(stack_is_empty(s))</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">    *value = s-&gt;next-&gt;value;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断栈是否为空，空返回1，未空返回0*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_is_empty</span><span class="params">(StackInfo_st *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*栈顶指针为空，则栈为空*/</span></span><br><span class="line">    <span class="keyword">return</span> s-&gt;next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*创建栈*/</span></span><br><span class="line">    StackInfo_st *<span class="built_in">stack</span> = createStack();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*如果栈为空，则压入元素1*/</span></span><br><span class="line">    <span class="keyword">if</span>(stack_is_empty(<span class="built_in">stack</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"push value 1\n"</span>);</span><br><span class="line">        stack_push(<span class="built_in">stack</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*访问栈顶元素*/</span></span><br><span class="line">    <span class="keyword">int</span> topVal;</span><br><span class="line">    stack_top(<span class="built_in">stack</span>, &amp;topVal);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"top value %d\n"</span>,topVal);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*出栈*/</span></span><br><span class="line">    <span class="keyword">int</span> popVal;</span><br><span class="line">    stack_pop(<span class="built_in">stack</span>, &amp;popVal);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pop value %d\n"</span>,popVal);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(SUCCESS == stack_push(<span class="built_in">stack</span>,i) &amp;&amp; i &lt; <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"top if stack value is %d\n"</span>,<span class="built_in">stack</span>-&gt;next-&gt;value);</span><br><span class="line">    <span class="comment">/*最后记得将栈内存都释放，可自己尝试实现*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push value 1</span><br><span class="line">top value 1</span><br><span class="line">pop value 1</span><br><span class="line">top if stack value is 5</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了栈的基本操作以及栈的基本实现。后面将会介绍一些栈的具体应用。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>还记得如何使用GDB查看链表内容吗？参考《<a href="https://www.yanbinghu.com/2019/03/10/50132.html">GDB调试指南-变量查看</a>》。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数据结构与算法</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-122.买卖股票的最佳时机</title>
    <url>/2019/03/14/30893.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>leetcode题解-122.买卖股票的最佳时机<br><a id="more"></a></p>
<h2 id="题目详情"><a href="#题目详情" class="headerlink" title="题目详情"></a>题目详情</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br></pre></td></tr></table></figure></p>
<p>示例 2:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure></p>
<p>示例 3:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>暴力解法，我们从第一个买入开始计算，分别计算第二个卖出，加上后面可能的最大利润，第三个卖出，加上后面可能的最大利润，以此类推，得到这所有情况中，利润最大的一种；再计算第二个买入，分别计算第三个卖出，加上后面可能的最大利润，第四个卖出，加上后面可能的最大利润，得到买入第二个能得到的最大利润，最终得到所能得到的最大利润。该方式所实现的代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxProfit</span><span class="params">(<span class="keyword">int</span> *prices,<span class="keyword">int</span> pricesSize,<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*如果开始计算的下标等于数组大小，则计算结束*/</span></span><br><span class="line">    <span class="keyword">if</span>(start &gt;= pricesSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> s = start;</span><br><span class="line">    <span class="keyword">for</span>(;s &lt; pricesSize;s++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> maxPro = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = s + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; j &lt; pricesSize;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*有利可图*/</span></span><br><span class="line">            <span class="keyword">if</span>(prices[j] &gt; prices[s])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/*当前最大利润为后面部分最大利润加上当前利润*/</span></span><br><span class="line">                <span class="keyword">int</span> nowPro = getMaxProfit(prices,pricesSize,j+<span class="number">1</span>) + prices[j] - prices[s];</span><br><span class="line">                <span class="comment">/*本次买入利润为两者中较大的一个*/</span></span><br><span class="line">                maxPro = nowPro &gt; maxPro?nowPro:maxPro;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        max = maxPro &gt; max?maxPro:max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>* prices, <span class="keyword">int</span> pricesSize)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == prices || <span class="number">0</span> == pricesSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> getMaxProfit(prices, pricesSize,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该解法复杂度较高，其中时间复杂度O(n^n),而空间复杂度O(n)(递归深度)。</p>
<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>换个角度思考，我们其实就是在赚差价，既然如此，我们只要遇见一个阶段最大的差价赚它一笔就可以了，而且尽可能多的赚。也就是说其实一旦到了某个阶段的最低点（波谷），就可以买入，到了某个阶段的最高点（波峰），就可以卖出。以[7,1,5,3,6,4]为例，我们首先要找到一个波谷，从开始往后扫描，发现第一个波谷为1（左右两边比它大），而找到第一个波峰为5（左边两边都比它低），因此1为买入点，5为卖出点，利润为4。继续往后，发现第二个波谷为3(左右两边都比它大)，而找到波谷6,（左右两边都比它小），因此在3时买入，在6时卖出，利润为3。因此总利润为7。</p>
<p>按照这种思路我们的代码实现如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>* prices,<span class="keyword">int</span> pricesSize)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == prices || <span class="number">0</span> == pricesSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> low = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> hig = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; pricesSize - <span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*如果一直有比当前小的，继续往前扫描*/</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; pricesSize - <span class="number">1</span> &amp;&amp; prices[i] &gt;= prices[i + <span class="number">1</span>])</span><br><span class="line">            i++;</span><br><span class="line">        <span class="comment">/*得到波谷点*/</span></span><br><span class="line">        low = prices[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*找到波峰*/</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;pricesSize - <span class="number">1</span> &amp;&amp; prices[i] &lt;= prices[i + <span class="number">1</span>])</span><br><span class="line">            i++;</span><br><span class="line">        hig = prices[i];</span><br><span class="line">        <span class="comment">/*当前最大利润*/</span></span><br><span class="line">        maxprofit += hig - low;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxprofit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种解法的时间复杂度为O(n)，空间复杂度O(1)。</p>
<h2 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h2><p>既然通过波峰与波谷的差价可以得到利润，那么实际上可以在发现在上升期就开始计算利润了，也就是说不需要达到波峰时，才用波峰减去波谷计算利润。以[7,1,5,3,4,6]为例，从头开始，1大于7，无利可图，5大于1，有利可图，得利润4；3小于5，无利可图；4大于3，有利可图，得利润1；6大于4，有利可图，得利润2；总利润为7。</p>
<p>按照这种思路，我们实现的代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>* prices, <span class="keyword">int</span> pricesSize)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == prices || <span class="number">0</span> == pricesSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; pricesSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(prices[i] &gt; prices[i<span class="number">-1</span>])</span><br><span class="line">            profit += prices[i]-prices[i<span class="number">-1</span>];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种解法的时间复杂度为O(n)，空间复杂度O(1)。</p>
<h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>你还有什么解法？欢迎在留言区评论。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB调试指南-变量查看</title>
    <url>/2019/03/10/50132.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在启动调试以及设置断点之后，就到了我们非常关键的一步-查看变量。GDB调试最大的目的之一就是走查代码，查看运行结果是否符合预期。既然如此，我们就不得不了解一些查看各种类型变量的方法，以帮助我们进一步定位问题。<br><a id="more"></a></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在查看变量之前，需要先启动调试并设置断点，该部分内容可参考《<a href="https://www.yanbinghu.com/2019/01/08/62137.html">GDB调试指南－启动调试</a>》和《<a href="https://www.yanbinghu.com/2019/02/24/44483.html">GDB调试指南－断点设置</a>》。后面的内容都基于在某个位置已经断住。</p>
<p>本文辅助说明程序如下:<br>testGdb.c<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//testGdb.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"testGdb.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">//整型</span></span><br><span class="line">	<span class="keyword">int</span> b[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;  <span class="comment">//数组</span></span><br><span class="line">    <span class="keyword">char</span> c[] = <span class="string">"hello,shouwang"</span>;<span class="comment">//字符数组</span></span><br><span class="line">	<span class="comment">/*申请内存，失败时退出*/</span>    </span><br><span class="line">	<span class="keyword">int</span> *d = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(a*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == d)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"malloc error\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*赋值*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		d[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(d);</span><br><span class="line">	d = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">float</span> e = <span class="number">8.5f</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>testGdb.h<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">11</span>;</span><br></pre></td></tr></table></figure></p>
<p>编译：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -g -o testGdb testGdb.o</span><br></pre></td></tr></table></figure></p>
<h2 id="变量查看"><a href="#变量查看" class="headerlink" title="变量查看"></a>变量查看</h2><h4 id="打印基本类型变量，数组，字符数组"><a href="#打印基本类型变量，数组，字符数组" class="headerlink" title="打印基本类型变量，数组，字符数组"></a>打印基本类型变量，数组，字符数组</h4><p>最常见的使用便是使用print（可简写为p）打印变量内容。<br>例如，打印基本类型，数组，字符数组等直接使用p 变量名即可：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">(gdb) p a</span><br><span class="line">$1 = 10</span><br><span class="line">(gdb) p b</span><br><span class="line">$2 = &#123;1, 2, 3, 5&#125;</span><br><span class="line">(gdb) p c</span><br><span class="line">$3 = &quot;hello,shouwang&quot;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>当然有时候，多个函数或者多个文件会有同一个变量名，这个时候可以在前面加上文件名或者函数名来区分：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) p &apos;testGdb.h&apos;::a</span><br><span class="line">$1 = 11</span><br><span class="line">(gdb) p &apos;main&apos;::b</span><br><span class="line">$2 = &#123;1, 2, 3, 5&#125;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>这里所打印的a值是我们定义在testGdb.h文件里的，而b值是main函数中的b。</p>
<h4 id="打印指针指向内容"><a href="#打印指针指向内容" class="headerlink" title="打印指针指向内容"></a>打印指针指向内容</h4><p>如果还是使用上面的方式打印指针指向的内容，那么打印出来的只是指针地址而已，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) p d</span><br><span class="line">$1 = (int *) 0x602010</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>而如果想要打印指针指向的内容，需要解引用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) p *d</span><br><span class="line">$2 = 0</span><br><span class="line">(gdb) p *d@10</span><br><span class="line">$3 = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看到，仅仅使用*只能打印第一个值，如果要打印多个值，后面跟上@并加上要打印的长度。<br>或者@后面跟上变量值：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) p *d@a</span><br><span class="line">$2 = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>由于a的值为10，并且是作为整型指针数据长度，因此后面可以直接跟着a，也可以打印出所有内容。</p>
<p>另外值得一提的是，$可表示上一个变量，而假设此时有一个链表linkNode，它有next成员代表下一个节点，则可使用下面方式不断打印链表内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) p *linkNode</span><br><span class="line">(这里显示linkNode节点内容)</span><br><span class="line">(gdb) p *$.next</span><br><span class="line">(这里显示linkNode节点下一个节点的内容)</span><br></pre></td></tr></table></figure></p>
<p>如果想要查看前面数组的内容，你可以将下标一个一个累加，还可以定义一个类似UNIX环境变量，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) set $index=0</span><br><span class="line">(gdb) p b[$index++]</span><br><span class="line">$11 = 1</span><br><span class="line">(gdb) p b[$index++]</span><br><span class="line">$12 = 2</span><br><span class="line">(gdb) p b[$index++]</span><br><span class="line">$13 = 3</span><br></pre></td></tr></table></figure></p>
<p>这样就不需要每次修改下标去打印啦。</p>
<h2 id="按照特定格式打印变量"><a href="#按照特定格式打印变量" class="headerlink" title="按照特定格式打印变量"></a>按照特定格式打印变量</h2><p>对于简单的数据，print默认的打印方式已经足够了，它会根据变量类型的格式打印出来，但是有时候这还不够，我们需要更多的格式控制。常见格式控制字符如下：</p>
<ul>
<li>x 按十六进制格式显示变量。</li>
<li>d 按十进制格式显示变量。</li>
<li>u 按十六进制格式显示无符号整型。</li>
<li>o 按八进制格式显示变量。</li>
<li>t 按二进制格式显示变量。</li>
<li>a 按十六进制格式显示变量。</li>
<li>c 按字符格式显示变量。</li>
<li>f 按浮点数格式显示变量。</li>
</ul>
<p>还是以辅助程序来说明，正常方式打印字符数组c：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) p c</span><br><span class="line">$18 = &quot;hello,shouwang&quot;</span><br></pre></td></tr></table></figure></p>
<p>但是如果我们要查看它的十六进制格式打印呢？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) p/x c</span><br><span class="line">$19 = &#123;0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x73, 0x68, 0x6f, 0x75, 0x77, 0x61, </span><br><span class="line">  0x6e, 0x67, 0x0&#125;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>但是如果我们想用这种方式查看浮点数的二进制格式是怎样的是不行的，因为直接打印它首先会被转换成整型，因此最终会得到8：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) p e</span><br><span class="line">$1 = 8.5</span><br><span class="line">(gdb) p/t e</span><br><span class="line">$2 = 1000</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>那么就需要另外一种查看方式了。</p>
<h2 id="查看内存内容"><a href="#查看内存内容" class="headerlink" title="查看内存内容"></a>查看内存内容</h2><p>examine(简写为x)可以用来查看内存地址中的值。语法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x/[n][f][u] addr</span><br></pre></td></tr></table></figure></p>
<p>其中：</p>
<ul>
<li>n 表示要显示的内存单元数，默认值为1</li>
<li>f 表示要打印的格式，前面已经提到了格式控制字符</li>
<li>u 要打印的单元长度</li>
<li>addr 内存地址</li>
</ul>
<p>单元类型常见有如下：</p>
<ul>
<li>b 字节</li>
<li>h 半字，即双字节</li>
<li>w 字，即四字节</li>
<li>g 八字节</li>
</ul>
<p>我们通过一个实例来看，假如我们要把float变量e按照二进制方式打印，并且打印单位是一字节：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) x/4tb &amp;e</span><br><span class="line">0x7fffffffdbd4:	00000000	00000000	00001000	01000001</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>可以看到，变量e的四个字节都以二进制的方式打印出来了。</p>
<h2 id="自动显示变量内容"><a href="#自动显示变量内容" class="headerlink" title="自动显示变量内容"></a>自动显示变量内容</h2><p>假设我们希望程序断住时，就显示某个变量的值，可以使用display命令。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) display e</span><br><span class="line">1: e = 8.5</span><br></pre></td></tr></table></figure></p>
<p>那么每次程序断住时，就会打印e的值。要查看哪些变量被设置了display，可以使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb)info display</span><br><span class="line">Auto-display expressions now in effect:</span><br><span class="line">Num Enb Expression</span><br><span class="line">1:   y  b</span><br><span class="line">2:   y  e</span><br></pre></td></tr></table></figure></p>
<p>如果想要清除可以使用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete display num #num为前面变量前的编号,不带num时清除所有。</span><br></pre></td></tr></table></figure></p>
<p>或者去使能：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">disable display num  #num为前面变量前的编号，不带num时去使能所有</span><br></pre></td></tr></table></figure></p>
<h2 id="查看寄存器内容"><a href="#查看寄存器内容" class="headerlink" title="查看寄存器内容"></a>查看寄存器内容</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb)info registers</span><br><span class="line">rax            0x0	0</span><br><span class="line">rbx            0x0	0</span><br><span class="line">rcx            0x7ffff7dd1b00	140737351850752</span><br><span class="line">rdx            0x0	0</span><br><span class="line">rsi            0x7ffff7dd1b30	140737351850800</span><br><span class="line">rdi            0xffffffff	4294967295</span><br><span class="line">rbp            0x7fffffffdc10	0x7fffffffdc10</span><br><span class="line">(内容过多未显示完全)</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过不同方式查看变量值或者内存值能够极大的帮助我们判断程序的运行是否符合我们的预期，如果发现观察的值不是我们预期的时候，就需要检查我们的代码了。</p>
]]></content>
      <categories>
        <category>gdb</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>分享几个资源网站</title>
    <url>/2019/03/10/11388.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分享几个资源网站，包含了影视资源，电子书资源，软件资源，计算机公开课资源等。<br><a id="more"></a></p>
<h2 id="浏览器插件下载"><a href="#浏览器插件下载" class="headerlink" title="浏览器插件下载"></a>浏览器插件下载</h2><p>一些无法科学上网的朋友可能不方便下载chrome应用商店的插件，可以从下面的地址下载：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://www.crx4chrome.com/</span><br></pre></td></tr></table></figure></p>
<p>firefox可以从这里下载：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://addons.mozilla.org/zh-CN/firefox/</span><br></pre></td></tr></table></figure></p>
<p>祝你发现更大的世界！</p>
<h2 id="电脑软件下载"><a href="#电脑软件下载" class="headerlink" title="电脑软件下载"></a>电脑软件下载</h2><p>电脑软件下载建议都从该软件的官网下载。</p>
<h2 id="电子书"><a href="#电子书" class="headerlink" title="电子书"></a>电子书</h2><p>计算机类的电子书基本可以通过下面的网站找到。</p>
<h4 id="鸠摩搜书："><a href="#鸠摩搜书：" class="headerlink" title="鸠摩搜书："></a>鸠摩搜书：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://www.jiumodiary.com/</span><br></pre></td></tr></table></figure>
<h4 id="计算机书籍控："><a href="#计算机书籍控：" class="headerlink" title="计算机书籍控："></a>计算机书籍控：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://bestcbooks.com/</span><br></pre></td></tr></table></figure>
<h4 id="freetechbooks"><a href="#freetechbooks" class="headerlink" title="freetechbooks"></a>freetechbooks</h4><p>当然前面的网站大家可能都知道了，这里再分享一个英文计算机类电子书下载地址：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://www.freetechbooks.com/</span><br></pre></td></tr></table></figure></p>
<p>这里有很多计算机类书籍的英文电子版。</p>
<h2 id="影视资源"><a href="#影视资源" class="headerlink" title="影视资源"></a>影视资源</h2><p>相信留言区一定有大神！分享自己用到的：</p>
<h4 id="疯狂影视"><a href="#疯狂影视" class="headerlink" title="疯狂影视"></a>疯狂影视</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://ifkdy.com/?q=%20&amp;p=1</span><br></pre></td></tr></table></figure>
<p>它不提供影视资源，只是提供搜索功能。</p>
<h4 id="电影蜜蜂"><a href="#电影蜜蜂" class="headerlink" title="电影蜜蜂"></a>电影蜜蜂</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://www.dybee.tv</span><br></pre></td></tr></table></figure>
<p>整体资源比较丰富。</p>
<h4 id="飘花电影"><a href="#飘花电影" class="headerlink" title="飘花电影"></a>飘花电影</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://www.piaohua.com/</span><br></pre></td></tr></table></figure>
<h2 id="计算机视频课程"><a href="#计算机视频课程" class="headerlink" title="计算机视频课程"></a>计算机视频课程</h2><h4 id="coursera-amp-edx"><a href="#coursera-amp-edx" class="headerlink" title="coursera&amp;edx"></a>coursera&amp;edx</h4><p>有很多国外大学的公开课。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://zh.coursera.org/</span><br><span class="line">https://www.edx.org</span><br></pre></td></tr></table></figure></p>
<p>当然还有很多，这里仅列举一二，比如youtube上也有很多优质的公开课视频。欢迎留言区补充。</p>
<h2 id="软件-源码-工具资源"><a href="#软件-源码-工具资源" class="headerlink" title="软件/源码/工具资源"></a>软件/源码/工具资源</h2><p>不用说，大家都知道了，全球最大的××交友网站。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://github.com/</span><br></pre></td></tr></table></figure></p>
<p>这里分享几个小技巧：</p>
<ul>
<li>Awesome + 关键字 可以搜索关键字相关的优秀项目</li>
<li>假如你想搜索star大于10k的C项目，可以使用：language:C stars:&gt;10000进行搜索</li>
<li><a href="https://github.com/search/advanced" target="_blank" rel="noopener">https://github.com/search/advanced</a> 高级搜索<h2 id="终极法宝"><a href="#终极法宝" class="headerlink" title="终极法宝"></a>终极法宝</h2>搜索引擎：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://www.google.com/</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>搜索引擎是个好东西。另外，附上一份搜索技巧：《<a href="https://mp.weixin.qq.com/s?__biz=MzI2OTA3NTk3Ng==&amp;mid=2649284243&amp;idx=1&amp;sn=d1f4f9d62cc64958c65489ba23262e62&amp;chksm=f2f9adf4c58e24e2b5bee39c30702331bf4beb76223bf1a31df006ce4ffae94c3592435a44a6&amp;token=1676511405&amp;lang=zh_CN#rd" target="_blank" rel="noopener">那些相见恨晚的搜索技巧</a>》。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上资源网站仅供<strong>学习交流</strong>，不可用于商业用途，可自行体验。另外对于学习类的资源，建议是宁缺毋滥，重质量而轻数量，不要被资源的总量吸引了。</p>
]]></content>
      <categories>
        <category>resource</category>
      </categories>
      <tags>
        <tag>resource</tag>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title>解放你的双手-watch命令详解</title>
    <url>/2019/03/08/61352.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>是不是经常会遇到需要观察某个内容，为了持续观察而反复执行某个命令？也许你可以写一个简单的脚本帮你反复执行，但是有更简单方便的方法为什么不用呢？今天要介绍的便是watch命令。<br><a id="more"></a></p>
<h2 id="以固定时间反复执行某个命令"><a href="#以固定时间反复执行某个命令" class="headerlink" title="以固定时间反复执行某个命令"></a>以固定时间反复执行某个命令</h2><p>比如说，你需要使用cat查看某个文件内容，由于它不断更新，你需要反复执行并观察，那么你可以使用watch：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ watch -n 1 cat test.txt</span><br><span class="line">Every 1.0s: cat test.txt </span><br><span class="line">hello</span><br></pre></td></tr></table></figure></p>
<p>watch的<strong>-n参数</strong>指定了反复执行的间隔，上面表示每隔1秒就执行cat test.txt命令。</p>
<h2 id="高亮变化内容"><a href="#高亮变化内容" class="headerlink" title="高亮变化内容"></a>高亮变化内容</h2><p>除了能够反复执行某个命令之外，还可以高亮变化的内容。例如，你需要观察平均负载情况，可以使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ uptime</span><br><span class="line">20:12:12 up  1:46,  1 user,  load average: 0.77, 0.75, 0.87</span><br></pre></td></tr></table></figure></p>
<p>为了突出变化部分，你可以使用<strong>-d（difference）参数</strong>，它会高亮变化的内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watch -d uptime</span><br><span class="line">（这里省略，变化内容会高亮，非常便于观察）</span><br></pre></td></tr></table></figure></p>
<h2 id="执行出错时退出"><a href="#执行出错时退出" class="headerlink" title="执行出错时退出"></a>执行出错时退出</h2><p>假设你要运行某个命令，希望它的退出码不是0时，即命令执行出错时就结束，那么你可以使用-e（errexit）参数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ watch -n 1 -e cat test.txt</span><br></pre></td></tr></table></figure></p>
<p>此时若删掉test.txt文件，它将会停止执行该命令。</p>
<h2 id="执行结果变化时退出"><a href="#执行结果变化时退出" class="headerlink" title="执行结果变化时退出"></a>执行结果变化时退出</h2><p>前面我们说到可以观察高量变化内容，我们也可以利用<strong>-g(chgexit)参数</strong>使得结果发现变化时，退出执行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ watch -n 1 -g command</span><br></pre></td></tr></table></figure></p>
<p>例如，我们观察某个文件大小是否有变换，发生变化时停止观测，这个时候可以使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ watch -n 1 -g &apos;du -b test.txt&apos;</span><br></pre></td></tr></table></figure></p>
<p>这里需要注意，后面du的命令需要用引号引起来，以便被当成一个完整的命令，一旦test.txt文件大小变化了，将会退出执行。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前面的举例可能不恰当，但是却说明了watch的使用场景。在实际情况中，可以根据自己的场景情况，选择不同的使用方式。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>如何查看linux中文件打开情况-lsof命令</title>
    <url>/2019/03/05/61180.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们都知道，在linux下，“一切皆文件”，因此有时候查看文件的打开情况，就显得格外重要，而这里有一个命令能够在这件事上很好的帮助我们-它就是lsof。<br><a id="more"></a></p>
<h2 id="linux下有哪些文件"><a href="#linux下有哪些文件" class="headerlink" title="linux下有哪些文件"></a>linux下有哪些文件</h2><p>在介绍lsof命令之前，先简单说一下，linux主要有哪些文件：</p>
<ul>
<li>普通文件</li>
<li>目录</li>
<li>符号链接</li>
<li>面向块的设备文件</li>
<li>面向字符的设备文件</li>
<li>管道和命名管道</li>
<li>套接字</li>
</ul>
<p>以上各类文件类型不多做详细介绍。</p>
<h2 id="lsof命令实用用法介绍"><a href="#lsof命令实用用法介绍" class="headerlink" title="lsof命令实用用法介绍"></a>lsof命令实用用法介绍</h2><p>lsof，是list open files的简称。它的参数很多，但是我们这里只介绍一些实用的用法（注意有些情况需要root权限执行）。</p>
<h4 id="查看当前打开的所有文件"><a href="#查看当前打开的所有文件" class="headerlink" title="查看当前打开的所有文件"></a>查看当前打开的所有文件</h4><p>一般来说，直接输入lsof命令产生的结果实在是太多，可能很难找到我们需要的信息。不过借此说明一下一条记录都有哪些信息。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ lsof（这里选取一条记录显示）</span><br><span class="line">COMMAND   PID                      USER   FD             TYPE        DEVICE SIZE/OFF   NODE   NAME</span><br><span class="line">vi        27940                    hyb    7u      REG               8,15     16384     137573 /home/hyb/.1.txt.swp</span><br></pre></td></tr></table></figure></p>
<p>lsof显示的结果，从左往右分别代表：打开该文件的程序名，进程id，用户，文件描述符，文件类型，设备，大小，iNode号，文件名。</p>
<p>我们暂且先关注我们知道的列。这条记录，表明进程id为27940的vi程序，打开了文件描述值为7，且处于读写状态的，在/home/hyb目录下的普通文件(REG regular file).1.txt.swap，当前大小16384字节。</p>
<h4 id="列出被删除但占用空间的文件"><a href="#列出被删除但占用空间的文件" class="headerlink" title="列出被删除但占用空间的文件"></a>列出被删除但占用空间的文件</h4><p>在生产环境中，我们可能会使用df命令看到磁盘空间占满了，然而实际上又很难找到占满空间的文件，这常常是由于某个大文件被删除了，但是它却被某个进程打开，导致通过普通的方式找不到它的踪迹，最常见的就是日志文件。我们可以通过lsof来发现这样的文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ lsof |grep deleted</span><br><span class="line">Xorg      1131 root  125u      REG                0,5        4      61026 /memfd:xshmfence (deleted)</span><br><span class="line">Xorg      1131 root  126u      REG                0,5        4      62913 /memfd:xshmfence (deleted)</span><br><span class="line">Xorg      1131 root  129u      REG                0,5        4      74609 /memfd:xshmfence (deleted)</span><br></pre></td></tr></table></figure></p>
<p>可以看到这些被删除的但仍然被打开文件，最后查找出来的时候，会被标记deleted。这个时候就可以根据实际情况分析，到底哪些文件可能过大但是却被删除了，导致空间仍然占满。</p>
<h4 id="恢复打开但被删除的文件"><a href="#恢复打开但被删除的文件" class="headerlink" title="恢复打开但被删除的文件"></a>恢复打开但被删除的文件</h4><p>前面我们可以找到被删除但是仍然被打开的文件，实际上文件并没有真正的消失，如果是意外被删除的，我们还有手段恢复它。以/var/log/syslog文件为例，我们先删除它(root用户)：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$　rm /var/log/syslog</span><br></pre></td></tr></table></figure></p>
<p>然后使用lsof查看那个进程打开了该文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ lsof |grep syslog</span><br><span class="line">rs:main    993 1119           syslog    5w      REG               8,10     78419     528470 /var/log/syslog (deleted)</span><br></pre></td></tr></table></figure></p>
<p>可以找到进程id为993的进程打开了该文件，我们知道每个进程在/proc下都有文件描述符打开的记录：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -l /proc/993/fd</span><br><span class="line">lr-x------ 1 root   root   64 3月   5 18:30 0 -&gt; /dev/null</span><br><span class="line">l-wx------ 1 root   root   64 3月   5 18:30 1 -&gt; /dev/null</span><br><span class="line">l-wx------ 1 root   root   64 3月   5 18:30 2 -&gt; /dev/null</span><br><span class="line">lrwx------ 1 root   root   64 3月   5 18:30 3 -&gt; socket:[15032]</span><br><span class="line">lr-x------ 1 root   root   64 3月   5 18:30 4 -&gt; /proc/kmsg</span><br><span class="line">l-wx------ 1 root   root   64 3月   5 18:30 5 -&gt; /var/log/syslog (deleted)</span><br><span class="line">l-wx------ 1 root   root   64 3月   5 18:30 6 -&gt; /var/log/auth.log</span><br></pre></td></tr></table></figure></p>
<p>这里就找到了被删除的syslog文件,文件描述符是５，我们把它重定向出来：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat /proc/993/fd/5 &gt; syslog</span><br><span class="line">$ ls -al /var/log/syslog</span><br><span class="line">-rw-r--r-- 1 root root 78493 3月   5 19:22 /var/log/syslog</span><br></pre></td></tr></table></figure></p>
<p>这样我们就恢复了syslog文件。</p>
<h4 id="查看当前文件被哪些进程打开"><a href="#查看当前文件被哪些进程打开" class="headerlink" title="查看当前文件被哪些进程打开"></a>查看当前文件被哪些进程打开</h4><p>Windows下经常遇到要删除某个文件，然后告诉你某个程序正在使用，然而不告诉你具体是哪个程序。我们可以在资源管理器-性能-资源监视器-cpu-关联的句柄处搜索文件，即可找到打开该文件的程序，但是搜索速度感人。</p>
<p>linux就比较容易了，使用lsof命令就可以了，例如要查看当前哪些程序打开了hello.c:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ lsof hello.c</span><br><span class="line">COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF   NODE NAME</span><br><span class="line">tail    28731  hyb    3r   REG   8,15      228 138441 hello.c</span><br></pre></td></tr></table></figure></p>
<p>但是我们会发现，使用vi打开的hello.c并没有找出来，这是因为vi打开的是一个临时副本。我们换一种方式查找：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ lsof |grep hello.c</span><br><span class="line">tail      28906                    hyb    3r      REG               8,15       228     138441 /home/hyb/workspaces/c/hello.c</span><br><span class="line">vi        28933                    hyb    9u      REG               8,15     12288     137573 /home/hyb/workspaces/c/.hello.c.swp</span><br></pre></td></tr></table></figure></p>
<p>这样我们就找到了两个程序和hello.c文件相关。</p>
<p>这里grep的作用是从所有结果中只列出符合条件的结果。</p>
<h4 id="查看某个目录文件被打开情况"><a href="#查看某个目录文件被打开情况" class="headerlink" title="查看某个目录文件被打开情况"></a>查看某个目录文件被打开情况</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ lsof +D ./</span><br></pre></td></tr></table></figure>
<h4 id="查看当前进程打开了哪些文件"><a href="#查看当前进程打开了哪些文件" class="headerlink" title="查看当前进程打开了哪些文件"></a>查看当前进程打开了哪些文件</h4><p>使用方法：lsof -c 进程名<br>通常用于程序定位问题，例如用于查看当前进程使用了哪些库，打开了哪些文件等等。假设有一个循环打印字符的hello程序：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ lsof -c hello</span><br><span class="line">COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF   NODE NAME</span><br><span class="line">hello   29190  hyb  cwd    DIR   8,15     4096 134538 /home/hyb/workspaces/c</span><br><span class="line">hello   29190  hyb  rtd    DIR   8,10     4096      2 /</span><br><span class="line">hello   29190  hyb  txt    REG   8,15     9816 138314 /home/hyb/workspaces/c/hello</span><br><span class="line">hello   29190  hyb  mem    REG   8,10  1868984 939763 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">hello   29190  hyb  mem    REG   8,10   162632 926913 /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">hello   29190  hyb    0u   CHR 136,20      0t0     23 /dev/pts/20</span><br><span class="line">hello   29190  hyb    1u   CHR 136,20      0t0     23 /dev/pts/20</span><br><span class="line">hello   29190  hyb    2u   CHR 136,20      0t0     23 /dev/pts/20</span><br></pre></td></tr></table></figure></p>
<p>我们可以从中看到，至少它用到了/lib/x86_64-linux-gnu/libc-2.23.so以及hello文件。</p>
<p>也可以通过进程id查看,可跟多个进程id，使用逗号隔开：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ lsof -p 29190</span><br><span class="line">COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF   NODE NAME</span><br><span class="line">hello   29190  hyb  cwd    DIR   8,15     4096 134538 /home/hyb/workspaces/c</span><br><span class="line">hello   29190  hyb  rtd    DIR   8,10     4096      2 /</span><br><span class="line">hello   29190  hyb  txt    REG   8,15     9816 138314 /home/hyb/workspaces/c/hello</span><br><span class="line">hello   29190  hyb  mem    REG   8,10  1868984 939763 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">hello   29190  hyb  mem    REG   8,10   162632 926913 /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">hello   29190  hyb    0u   CHR 136,20      0t0     23 /dev/pts/20</span><br><span class="line">hello   29190  hyb    1u   CHR 136,20      0t0     23 /dev/pts/20</span><br><span class="line">hello   29190  hyb    2u   CHR 136,20      0t0     23 /dev/pts/20</span><br></pre></td></tr></table></figure></p>
<p>当然这里还有一种方式，就是利用proc文件系统，首先找到hello进程的进程id<br>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ps -ef|grep hello</span><br><span class="line">hyb      29190 27929  0 21:14 pts/20   00:00:00 ./hello 2</span><br><span class="line">hyb      29296 28848  0 21:18 pts/22   00:00:00 grep --color=auto hello</span><br></pre></td></tr></table></figure></p>
<p>可以看到进程id为29190，查看该进程文件描述记录目录：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -l /proc/29190/fd</span><br><span class="line">lrwx------ 1 hyb hyb 64 3月   2 21:14 0 -&gt; /dev/pts/20</span><br><span class="line">lrwx------ 1 hyb hyb 64 3月   2 21:14 1 -&gt; /dev/pts/20</span><br><span class="line">lrwx------ 1 hyb hyb 64 3月   2 21:14 2 -&gt; /dev/pts/20</span><br></pre></td></tr></table></figure></p>
<p>这种方式能够过滤很多信息，因为它只列出了该进程实际打开的，这里它只打开了0,1,2，即标准输入，标准输出和标准错误。</p>
<h4 id="查看某个端口被占用情况"><a href="#查看某个端口被占用情况" class="headerlink" title="查看某个端口被占用情况"></a>查看某个端口被占用情况</h4><p>在使用数据库或者启用web服务的时候，总能遇到端口占用问题，那么怎么查看某个端口是否被占用呢？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ lsof -i :6379</span><br><span class="line">COMMAND     PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">redis-ser 29389  hyb    6u  IPv6 534612      0t0  TCP *:6379 (LISTEN)</span><br><span class="line">redis-ser 29389  hyb    7u  IPv4 534613      0t0  TCP *:6379 (LISTEN)</span><br></pre></td></tr></table></figure></p>
<p>这里可以看到redis-ser进程占用了6379端口。</p>
<h4 id="查看所有的TCP-UDP连接"><a href="#查看所有的TCP-UDP连接" class="headerlink" title="查看所有的TCP/UDP连接"></a>查看所有的TCP/UDP连接</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ lsof -i tcp</span><br><span class="line">ava       2534  hyb    6u  IPv6  31275      0t0  TCP localhost:9614 (LISTEN)</span><br><span class="line">java       2534  hyb   22u  IPv6  96922      0t0  TCP localhost:9614-&gt;localhost:39004 (ESTABLISHED)</span><br><span class="line">java       2534  hyb   23u  IPv6 249588      0t0  TCP localhost:9614-&gt;localhost:45460 (ESTABLISHED)</span><br></pre></td></tr></table></figure>
<p>当然我们也可以使用netstat命令。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ netstat -anp|grep 6379</span><br></pre></td></tr></table></figure></p>
<p>这里的-i参数可以跟多种条件：</p>
<ul>
<li>-i 4  　　　#ipv4地址</li>
<li>-i 6  　　　#ipv6地址</li>
<li>-i tcp  　#tcp连接</li>
<li>-i :3306 　#端口</li>
<li>-i @ip  　#ip地址</li>
</ul>
<p>因此需要查看与某个ip地址建立的连接时，可以使用下面的方式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ lsof -i@127.0.0.1</span><br></pre></td></tr></table></figure></p>
<h4 id="查看某个用户打开了哪些文件"><a href="#查看某个用户打开了哪些文件" class="headerlink" title="查看某个用户打开了哪些文件"></a>查看某个用户打开了哪些文件</h4><p>linux是一个多用户操作系统，怎么知道其他普通用户打开了哪些文件呢？可使用－ｕ参数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ lsof -u hyb</span><br><span class="line">（内容太多，省略）</span><br></pre></td></tr></table></figure></p>
<h4 id="列出除了某个进程或某个用户打开的文件"><a href="#列出除了某个进程或某个用户打开的文件" class="headerlink" title="列出除了某个进程或某个用户打开的文件"></a>列出除了某个进程或某个用户打开的文件</h4><p>实际上和前面使用方法类似，只不过，在进程id前面或者用户名前面加^，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsof -p ^1     #列出除进程id为１的进程以外打开的文件</span><br><span class="line">lsof -u ^root  #列出除root用户以外打开的文件</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上介绍基于一个条件，实际上多个条件可以组合，例如列出进程id为１的进程打开的tcp套接字文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsof -p 1 -i tcp</span><br></pre></td></tr></table></figure></p>
<p>lsof参数很多，具体的可以使用man命令查看，但是对于我们来说，知道这些实用的基本足够。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>lsof</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer：调整数组顺序使奇数位于偶数前面</title>
    <url>/2019/02/28/31098.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。<br><a id="more"></a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>事实上，这个题比较简单，很多种方式都可以实现，但是其时间复杂度或空间复杂度不尽相同。</p>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>书中作者提到一种初始的做法是，从头扫描整个数组，如果遇到偶数，则拿出这个数，并且把整个数组的数据都向前挪动一位，再把拿出的数放到末尾。每碰到一个偶数就需要移动O(N)次，这样总的<strong>时间复杂度为O(n^2),空间复杂度为O(1)</strong>。</p>
<p>这种方式很简单，如果已经很清楚是怎么回事，可以跳过例子说明，继续阅读下一个解法。但是<strong>可以尝试自己写一下代码，发现有些细节部分并不是那么容易写出来</strong>。</p>
<p>举个例子，假设有数据1,2,3,4,5,6：</p>
<p>从左往右扫描，找到第一个偶数2，并临时保存：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td></td>
<td>&uarr;</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><strong>取出</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>将2后面的所有数往前移动一个位置，并将2放到最后一个位置：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>2</td>
</tr>
<tr>
<td></td>
<td>&uarr;</td>
<td></td>
<td></td>
<td></td>
<td>移动后</td>
</tr>
</tbody>
</table>
</div>
<p>继续扫描<strong>当前位置</strong>，发现3为奇数，继续，发现4为偶数，将从3之后位置的数开始，到倒数第二个位置，所有数往前移动一个位置，并将4放到最后：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>3</td>
<td>5</td>
<td>6</td>
<td>4</td>
<td>2</td>
</tr>
<tr>
<td></td>
<td></td>
<td>&uarr;</td>
<td></td>
<td>移动后</td>
</tr>
</tbody>
</table>
</div>
<p>继续扫描当前位置数5，6，至此，偶数有2两个，当前指向位置为,所在下标为4，总数 - 位置  &lt;= 偶数 ,结束。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>3</td>
<td>5</td>
<td>6</td>
<td>4</td>
<td>2</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>&uarr;</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>根据该思路，C语言代码实现如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//reorder.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorder</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == arr || <span class="number">0</span> == len)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/*统计偶数数量，减少移动次数*/</span></span><br><span class="line">    <span class="keyword">int</span> evenNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> loop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">int</span> inLoop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(loop &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*如果是偶数，则需要开始移动*/</span></span><br><span class="line">        temp = arr[loop];</span><br><span class="line">        <span class="comment">/*如果已经达到了*/</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == (temp &amp; <span class="number">1</span>) &amp;&amp; (len - loop  &gt; evenNum))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*从当前位置开始移动，直到遇到剩下的数量是偶数的个数*/</span></span><br><span class="line">            <span class="keyword">for</span>(inLoop = loop + <span class="number">1</span>;inLoop &lt; len - evenNum;inLoop++)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[inLoop<span class="number">-1</span>] = arr[inLoop];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*把空出来的位填充上*/</span></span><br><span class="line">            arr[len  - evenNum - <span class="number">1</span>] = temp;</span><br><span class="line">            evenNum++;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*交换后继续*/</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*继续循环下一个*/</span></span><br><span class="line">        <span class="keyword">else</span>        </span><br><span class="line">        &#123;        </span><br><span class="line">            loop++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"too much，will not print\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,A[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage:reorder num\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"reorder for %d numbers\n"</span>,len);</span><br><span class="line">    <span class="comment">/*随机产生输入数量的数据*/</span></span><br><span class="line">    <span class="keyword">int</span> *A = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*len);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">while</span>(i &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">       A[i] = rand()%<span class="number">100</span>;</span><br><span class="line">       i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"before reorder:"</span>);</span><br><span class="line">    printArray(A,len);</span><br><span class="line">    <span class="comment">/*对数据进行排序*/</span></span><br><span class="line">    reorder(A,len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"after  reorder:"</span>);</span><br><span class="line">    printArray(A,len);</span><br><span class="line">    <span class="built_in">free</span>(A);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>很多人其实最先想到的解法可能是，创建一个新的数组，从头扫描，遇到偶数放后边，遇到奇数放前边。扫描结束后，再将数组内容拷贝到原数组，这样整个<strong>时间复杂度为(n）,而空间复杂度也为O(n)</strong>，这样的方法实现简单，也不容易出错。C语言代码实现如下（省略了main函数以及printArr函数）：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//reorder1.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorder</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == arr || <span class="number">0</span> == len)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/*记录奇偶的数量*/</span></span><br><span class="line">    <span class="keyword">int</span> oddNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> evenNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> loop = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*创建一个新的数组*/</span></span><br><span class="line">    <span class="keyword">int</span> *temp = <span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == temp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"malloc memory failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*拷贝数组，并遍历*/</span></span><br><span class="line">    <span class="built_in">memcpy</span>(temp,arr,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*len);</span><br><span class="line">    <span class="keyword">for</span>(;loop &lt; len;loop++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*偶数放到数组末尾*/</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == (temp[loop] &amp; <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            arr[len<span class="number">-1</span>-evenNum] = temp[loop];</span><br><span class="line">            evenNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*奇数放到数组末尾*/</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            arr[oddNum] = temp[loop];</span><br><span class="line">            oddNum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h2><p>还记得我们之前介绍过的《<a href="https://www.yanbinghu.com/2019/02/21/28355.html">快速排序优化详解</a>》吗？快速排序中，有一个分区操作，是将整个数组大于等于基准的部分放右边，而小于等于基准的部分放左边，即根据基准，将数组一分为二。其实在这里，同样可以参考这个思路，只不过跟基准比大小，变成了判断是奇还是偶。<br>这里简单描述一下该思路，更多细节可以参考《<a href="https://www.yanbinghu.com/2019/02/21/28355.html">快速排序优化详解</a>》中如何将元素移动到基准两侧一节：</p>
<ul>
<li>定义下标i和j，分别从开头和结尾开始扫描</li>
<li>当i遇到偶数时，停止扫描</li>
<li>当j遇到奇数时，停止扫描</li>
<li>此时交换i和j位置的值</li>
<li>继续前面的操作，直到i和j交错或相等</li>
</ul>
<p>举个例子，假设有数据1,2,3,4,5,6,7,8：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
</tr>
<tr>
<td>&uarr;</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&uarr;</td>
</tr>
<tr>
<td><strong>i</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>j</strong></td>
</tr>
</tbody>
</table>
</div>
<p>i和j继续扫描，i遇到2停止，j遇到5停止，交换两处的值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>7</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>2</td>
<td>8</td>
</tr>
<tr>
<td></td>
<td>&uarr;</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&uarr;</td>
<td></td>
</tr>
<tr>
<td></td>
<td><strong>i</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>j</strong></td>
</tr>
</tbody>
</table>
</div>
<p>i和j继续扫描，i遇到4停止，j遇到5停止，交换两处的值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>7</td>
<td>3</td>
<td>5</td>
<td>4</td>
<td>6</td>
<td>2</td>
<td>8</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>&uarr;</td>
<td>&uarr;</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><strong>i</strong></td>
<td><strong>j</strong></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>继续扫描，此时，i和j交错，扫描结束：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>7</td>
<td>3</td>
<td>5</td>
<td>4</td>
<td>6</td>
<td>2</td>
<td>8</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>&uarr;</td>
<td>&uarr;</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><strong>j</strong></td>
<td><strong>i</strong></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>基于该思路的算法<strong>时间复杂度为O(n)，空间复杂度为O(1)</strong>，C语言代码实现如下（省略了main函数以及printArr函数）：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//reorder2.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorder</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == arr || <span class="number">0</span> == len)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*i j分别向右和向左移动，i遇到偶数停止，j遇到奇数停止？*/</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span> == (arr[i] &amp; <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">0</span> == (arr[j] &amp; <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*交错时停止*/</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="运行效率比较"><a href="#运行效率比较" class="headerlink" title="运行效率比较"></a>运行效率比较</h2><p>编译后，对一百万数据进行操作，运行时间结果如下。<br>解法一：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ time ./reorder 1000000</span><br></pre></td></tr></table></figure></p>
<p>并没有耐心等到结果出来。<br>解法二：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ time ./reorder1 100000000</span><br><span class="line">reorder for 100000000 numbers</span><br><span class="line">before reorder:too much，will not print</span><br><span class="line">after  reorder:too much，will not print</span><br><span class="line"></span><br><span class="line">real    0m2.425s</span><br><span class="line">user    0m2.141s</span><br><span class="line">sys    0m0.284s</span><br></pre></td></tr></table></figure></p>
<p>对1亿数据进行操作，耗时很短，只是内存占用较多。<br>解法三：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ time ./reorder2 100000000</span><br><span class="line">reorder for 100000000 numbers</span><br><span class="line">before reorder:too much，will not print</span><br><span class="line">after  reorder:too much，will not print</span><br><span class="line"></span><br><span class="line">real    0m2.146s</span><br><span class="line">user    0m2.018s</span><br><span class="line">sys    0m0.128s</span><br></pre></td></tr></table></figure></p>
<p>耗时很短，内存占用少。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>在本题中，只是对整数是奇还是偶进行分开，那么如果是别的条件呢？例如是否为素数，是否为正数等等。我们可以让调用者传入一个条件函数，让它决定到底是放在后半部分，还是前半部分。这是不是很向库函数qsort需要传入一个比较函数的做法？这部分内容可以参考《<a href="https://www.yanbinghu.com/2019/01/03/3593.html">函数指针</a>》，根据这个思路，我们修改解法三的代码：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//reorder3.c</span></span><br><span class="line"><span class="comment">/*定义函数指针类型*/</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*CheckFun)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isMatch</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == (num &amp; <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorder</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len,CheckFun isMatch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == arr || <span class="number">0</span> == len || <span class="literal">NULL</span> == isMatch)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*i j分别向右和向左移动，i遇到偶数停止，j遇到奇数停止？*/</span></span><br><span class="line">        <span class="keyword">while</span>(!(*isMatch)(arr[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>((*isMatch)(arr[j]))</span><br><span class="line">        &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*交错时停止*/</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个时候通过传入函数指针，可以对任意条件进行处理了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们发现，一些基本算法的思想，通常可以用到其他问题上，而不同的思路，带来的效率可能天差地别。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>尝试自己实现上面的算法。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB调试指南-断点设置</title>
    <url>/2019/02/24/44483.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上篇《<a href="https://www.yanbinghu.com/2019/01/08/62137.html">GDB调试指南-启动调试</a>》我们讲到了GDB启动调试的多种方式，分别应用于多种场景。今天我们来介绍一下断点设置的多种方式。<br><a id="more"></a></p>
<h2 id="为何要设置断点"><a href="#为何要设置断点" class="headerlink" title="为何要设置断点"></a>为何要设置断点</h2><p>在介绍之前，我们首先需要了解，为什么需要设置断点。我们在指定位置设置断点之后，程序运行到该位置将会“暂停”，这个时候我们就可以对程序进行更多的操作，比如查看变量内容，堆栈情况等等，以帮助我们调试程序。</p>
<h2 id="查看已设置的断点"><a href="#查看已设置的断点" class="headerlink" title="查看已设置的断点"></a>查看已设置的断点</h2><p>在学习断点设置之前，我们可以使用info breakpoints查看已设置断点：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">info breakpoints</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x00000000004005fc in printNum2 at test.c:17</span><br><span class="line">    breakpoint already hit 1 time</span><br><span class="line">2       hw watchpoint  keep y                      a</span><br><span class="line">    breakpoint already hit 1 time</span><br><span class="line">    ignore next 3 hits</span><br></pre></td></tr></table></figure></p>
<p>它将会列出所有已设置的断点，每一个断点都有一个标号，用来代表这个断点。例如，第2个断点设置是一个观察点，并且会忽略三次。</p>
<h2 id="断点设置"><a href="#断点设置" class="headerlink" title="断点设置"></a>断点设置</h2><p>断点设置有多种方式，分别应用于不同的场景。借助示例程序进行一一介绍：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNum</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"printNum\n"</span>);</span><br><span class="line">    <span class="keyword">while</span>(a &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a);</span><br><span class="line">        a--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNum2</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"printNum\n"</span>);</span><br><span class="line">    <span class="keyword">while</span>(a &gt; num &amp;&amp; a&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a);</span><br><span class="line">        a--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d,b=%d\n"</span>,a,b);</span><br><span class="line">    <span class="keyword">int</span> temp = a/b;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printNum2(<span class="number">12</span>,<span class="number">5</span>);</span><br><span class="line">    printNum(<span class="number">10</span>);</span><br><span class="line">    div(<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -g -o test test.c</span><br></pre></td></tr></table></figure></p>
<p>注意，编译时需要带上-g参数，具体原因参见《<a href="https://www.yanbinghu.com/2019/01/08/62137.html">GDB调试指南-启动调试</a>》。</p>
<h4 id="根据行号设置断点"><a href="#根据行号设置断点" class="headerlink" title="根据行号设置断点"></a>根据行号设置断点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b 10  #break 可简写为b</span><br></pre></td></tr></table></figure>
<p>或者<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b test.c:10</span><br></pre></td></tr></table></figure></p>
<p>程序运行到第10行的时候会断住。</p>
<h4 id="根据函数名设置断点"><a href="#根据函数名设置断点" class="headerlink" title="根据函数名设置断点"></a>根据函数名设置断点</h4><p>同样可以将断点设置在函数处：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b printNum</span><br></pre></td></tr></table></figure></p>
<p>程序在调用到printNum函数的时候会断住。</p>
<h4 id="根据条件设置断点"><a href="#根据条件设置断点" class="headerlink" title="根据条件设置断点"></a>根据条件设置断点</h4><p>假设程序某处发生崩溃，而崩溃的原因怀疑是某个地方出现了非期望的值，那么你就可以在这里断点观察，当出现该非法值时，程序断住。这个时候我们可以借助gdb来设置条件断点，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">break test.c:23 if b==0</span><br></pre></td></tr></table></figure></p>
<p>当在b等于0时，程序将会在第23行断住。<br>它和condition有着类似的作用，假设上面的断点号为1，那么：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">condition 1 b==0</span><br></pre></td></tr></table></figure></p>
<p>会使得b等于0时，产生断点1。而实际上可以很方便地用来改变断点产生的条件，例如，之前设置b==0时产生该断点，那么使用condition可以修改断点产生的条件。</p>
<h4 id="根据规则设置断点"><a href="#根据规则设置断点" class="headerlink" title="根据规则设置断点"></a>根据规则设置断点</h4><p>例如需要对所有调用printNum函数都设置断点，可以使用下面的方式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rbreak printNum*</span><br></pre></td></tr></table></figure></p>
<p>所有以printNum开头的函数都设置了断点。而下面是对所有函数设置断点：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#用法：rbreak file:regex</span><br><span class="line">rbreak . </span><br><span class="line">rbreak test.c:. #对test.c中的所有函数设置断点</span><br><span class="line">rbreak test.c:^print #对以print开头的函数设置断点</span><br></pre></td></tr></table></figure></p>
<h4 id="设置临时断点"><a href="#设置临时断点" class="headerlink" title="设置临时断点"></a>设置临时断点</h4><p>假设某处的断点只想生效一次，那么可以设置临时断点，这样断点后面就不复存在了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tbreak test.c:l0  #在第10行设置临时断点</span><br></pre></td></tr></table></figure></p>
<h4 id="跳过多次设置断点"><a href="#跳过多次设置断点" class="headerlink" title="跳过多次设置断点"></a>跳过多次设置断点</h4><p>假如有某个地方，我们知道可能出错，但是前面30次都没有问题，虽然在该处设置了断点，但是想跳过前面30次，可以使用下面的方式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ignore 1 30</span><br></pre></td></tr></table></figure></p>
<p>其中，1是你要忽略的断点号，可以通过前面的方式查找到，30是需要跳过的次数。这样设置之后，会跳过前面30次。再次通过info breakpoints可以看到：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x00000000004005e8 in printNum2 at test.c:16</span><br><span class="line">    ignore next 30 hits</span><br></pre></td></tr></table></figure></p>
<h4 id="根据表达式值变化产生断点"><a href="#根据表达式值变化产生断点" class="headerlink" title="根据表达式值变化产生断点"></a>根据表达式值变化产生断点</h4><p>有时候我们需要观察某个值或表达式，知道它什么时候发生变化了，这个时候我们可以借助watch命令。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watch a</span><br></pre></td></tr></table></figure></p>
<p>这个时候，让程序继续运行，如果a的值发生变化，则会打印相关内容，如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hardware watchpoint 2: a</span><br><span class="line">Old value = 12</span><br><span class="line">New value = 11</span><br></pre></td></tr></table></figure></p>
<p>但是这里要特别注意的是，程序必须运行起来，否则会出现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">No symbol &quot;a&quot; in current context.</span><br></pre></td></tr></table></figure></p>
<p>因为程序没有运行，当前上下文也就没有相关变量信息。</p>
<p>rwatch和awatch同样可以设置观察点前者是当变量值被读时断住，后者是被读或者被改写时断住。</p>
<h2 id="禁用或启动断点"><a href="#禁用或启动断点" class="headerlink" title="禁用或启动断点"></a>禁用或启动断点</h2><p>有些断点暂时不想使用，但又不想删除，可以暂时禁用或启用。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">disable  #禁用所有断点</span><br><span class="line">disable bnum #禁用标号为bnum的断点</span><br><span class="line">enable  #启用所有断点</span><br><span class="line">enable bnum #启用标号为bnum的断点</span><br><span class="line">enable delete bnum  #启动标号为bnum的断点，并且在此之后删除该断点</span><br></pre></td></tr></table></figure></p>
<h2 id="断点清除"><a href="#断点清除" class="headerlink" title="断点清除"></a>断点清除</h2><p>断点清除主要用到clear和delete命令。常见使用如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clear   #删除当前行所有breakpoints</span><br><span class="line">clear function  #删除函数名为function处的断点</span><br><span class="line">clear filename:function #删除文件filename中函数function处的断点</span><br><span class="line">clear lineNum #删除行号为lineNum处的断点</span><br><span class="line">clear f:lename：lineNum #删除文件filename中行号为lineNum处的断点</span><br><span class="line">delete  #删除所有breakpoints,watchpoints和catchpoints</span><br><span class="line">delete bnum #删除断点号为bnum的断点</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了常见的断点设置方法，断点设置之后，可以便于我们后期观察变量，堆栈等信息，为进一步的定位与调试做准备。</p>
]]></content>
      <categories>
        <category>gdb</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序优化详解</title>
    <url>/2019/02/21/28355.html</url>
    <content><![CDATA[<p>正如它的名字所体现，快速排序是在实践中最快的已知排序算法，平均运行时间为O(NlogN)，最坏的运行时间为O(N^2)。算法的基本思想很简单，然而想要写出一个<strong>高效</strong>的快速排序算法并不是那么简单。基准的选择，元素的分割等都至关重要，如果你不清楚如何优化快速排序算法，本文你不该错过。<br><a id="more"></a></p>
<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>快速排序利用了分治的策略。而分治的基本基本思想是：将原问题划分为若干与原问题类似子问题，解决这些子问题，将子问题的解组成原问题的解。</p>
<p>那么如何利用分治的思想对数据进行排序呢？假如有一个元素集合A：</p>
<ul>
<li>选择A中的任意一个元素pivot，该元素作为基准</li>
<li>将小于基准的元素移到左边，大于基准的元素移到右边（分区操作）</li>
<li>A被pivot分为两部分，继续对剩下的两部分做同样的处理</li>
<li>直到所有子集元素不再需要进行上述步骤</li>
</ul>
<p>可以看到算法思想比较简单，然而上述步骤实际又该如何处理呢？</p>
<h2 id="如何选择基准"><a href="#如何选择基准" class="headerlink" title="如何选择基准"></a>如何选择基准</h2><p>实际上无论怎么选择基准，都不会影响排序结果，<strong>但是不同的选择却可能影响整体排序时间</strong>，因为基准选择不同，会导致分割的两个集合大小不同，如果分割之后，两个集合大小是几乎相等的，那么我们整体分割的次数显然也会减少，这样整体耗费的时间也相应降低。我们来看一下有哪些可选择策略。</p>
<h4 id="选择第一个或者最后一个"><a href="#选择第一个或者最后一个" class="headerlink" title="选择第一个或者最后一个"></a>选择第一个或者最后一个</h4><p>如果待排序数是随机的，那么选择第一个或者最后一个作基准是没有什么问题的，这也是我们最常见到的选择方案。但如果待排序数据已经排好序的，就<strong>会产生一个很糟糕的分割</strong>。几乎所有的数据都被分割到一个集合中，而另一个集合没有数据。这样的情况下，<strong>时间花费了，却没有做太多实事</strong>。而它的时间复杂度就是最差的情况O(N^2)。<strong>因此这种策略是绝对不推荐的</strong>。</p>
<h4 id="随机选择"><a href="#随机选择" class="headerlink" title="随机选择"></a>随机选择</h4><p>随机选择基准是一种比较安全的做法。因为它不会总是产生劣质的分割。<br>C语言实现参考：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">randomPivot</span><span class="params">(ElementType A[],<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">int</span> randIndex = rand()%(end -start)+start;</span><br><span class="line">    <span class="keyword">return</span> A[randIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="选择三数中值"><a href="#选择三数中值" class="headerlink" title="选择三数中值"></a>选择三数中值</h4><p>从前面的描述我们知道，如果能够选择到数据的中值，那是最好的，因为它能够将集合近乎等分为二。但是很多时候很难算出中值，并且会耗费计算时间。因此我们随机选取三个元素，并用它们的中值作为整个数据中值的估计值。在这里，我们选择最左端，最右端和中间位置的三个元素的中值作为基准。</p>
<p>假如有以下数组：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 9 10 3 8 7 6 2 4</span><br></pre></td></tr></table></figure></p>
<p>左端元素为1，位置为0，右端元素为4，位置为8，则中间位置为[0+8]/2=4，中间元素为8。那么三数中值就为4（1，4，8的中值）。</p>
<h2 id="如何将元素移动到基准两侧"><a href="#如何将元素移动到基准两侧" class="headerlink" title="如何将元素移动到基准两侧"></a>如何将元素移动到基准两侧</h2><p>选好基准之后，如何将元素移动到基准两侧呢？通常的做法如下：</p>
<ul>
<li>将基准元素与最后的元素交换，使得基准元素不在被分割的数据范围</li>
<li>i和j分别从第一个元素和倒数第二个元素开始。i在j的左边时，将i右移，直到发现大于等于基准的元素，然后将j左移，直到发现小于等于基准的元素。i和j停止时，元素互换。这样就把大于等于基准的移到了右边，小于等于基准的移到了左边</li>
<li>重复上面的步骤，直到i和j交错</li>
<li>将基准元素与i所指向的元素交换，使得基准元素将整个元素集合分割为小于基准和大于基准的元素集合</li>
</ul>
<p><strong>在们采用三数中值得方法选择基准的情况下</strong>，既然基准是中值，实际上只要保证左端，右端，中间值是从小到大即可。还是以前面提到的数组为例，我们找到三者后，对三者进行排序如下：<br>排序前</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>&darr;</th>
<th></th>
<th></th>
<th></th>
<th>&darr;</th>
<th></th>
<th></th>
<th></th>
<th>&darr;</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>9</td>
<td>10</td>
<td>3</td>
<td>8</td>
<td>7</td>
<td>6</td>
<td>2</td>
<td>4</td>
</tr>
</tbody>
</table>
</div>
<p>排序后</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>&darr;</th>
<th></th>
<th></th>
<th></th>
<th>&darr;</th>
<th></th>
<th></th>
<th></th>
<th>&darr;</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>9</td>
<td>10</td>
<td>3</td>
<td>4</td>
<td>7</td>
<td>6</td>
<td>2</td>
<td>8</td>
</tr>
</tbody>
</table>
</div>
<p>如果是这样的情况，那么实际上不需要把基准元素和最后一个元素交换，而只需要和倒数第二个元素交换即可，因为最后一个元素肯定大于基准，这样可以<strong>减少交换次数</strong>。</p>
<p>如果前面的描述还不清楚，我们看一看实际中一趟完整的流程是什么样的。</p>
<p>第一步，将左端，右端和中间值排序，中值作为基准：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>&darr;</th>
<th></th>
<th></th>
<th></th>
<th>&darr;</th>
<th></th>
<th></th>
<th></th>
<th>&darr;</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>9</td>
<td>10</td>
<td>3</td>
<td>4</td>
<td>7</td>
<td>6</td>
<td>2</td>
<td>8</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>基准</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>第二步，将中值与倒数第二个数交换位置：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th>交</th>
<th>换</th>
<th>位</th>
<th>置</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&darr;</td>
<td></td>
<td></td>
<td>&darr;</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>9</td>
<td>10</td>
<td>3</td>
<td>2</td>
<td>7</td>
<td>6</td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>基准</td>
</tr>
</tbody>
</table>
</div>
<p>第三步，i向右移动，直到发现大于等于基准的元素9：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>9</td>
<td>10</td>
<td>3</td>
<td>2</td>
<td>7</td>
<td>6</td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td></td>
<td>&uarr;</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&uarr;</td>
<td>&uarr;</td>
<td></td>
</tr>
<tr>
<td></td>
<td><strong>i</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>j</strong></td>
<td>基准</td>
</tr>
</tbody>
</table>
</div>
<p>第四步，j向左移动，直到发现小于等于基准的元素2：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>9</td>
<td>10</td>
<td>3</td>
<td>2</td>
<td>7</td>
<td>6</td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td></td>
<td>&uarr;</td>
<td></td>
<td></td>
<td>&uarr;</td>
<td></td>
<td></td>
<td>&uarr;</td>
<td></td>
</tr>
<tr>
<td></td>
<td><strong>i</strong></td>
<td></td>
<td></td>
<td><strong>j</strong></td>
<td></td>
<td></td>
<td>基准</td>
</tr>
</tbody>
</table>
</div>
<p>第五步，交换i和j：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
<td>10</td>
<td>3</td>
<td>9</td>
<td>7</td>
<td>6</td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td></td>
<td>&uarr;</td>
<td></td>
<td></td>
<td>&uarr;</td>
<td></td>
<td></td>
<td>&uarr;</td>
<td></td>
</tr>
<tr>
<td></td>
<td><strong>i</strong></td>
<td>交</td>
<td>换</td>
<td><strong>j</strong></td>
<td></td>
<td></td>
<td>基准</td>
</tr>
</tbody>
</table>
</div>
<p>第六步，重复上述步骤，i右移，j左移：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
<td>10</td>
<td>3</td>
<td>9</td>
<td>7</td>
<td>6</td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td></td>
<td></td>
<td>&uarr;</td>
<td>&uarr;</td>
<td></td>
<td></td>
<td></td>
<td>&uarr;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td><strong>i</strong></td>
<td><strong>j</strong></td>
<td></td>
<td></td>
<td></td>
<td>基准</td>
</tr>
</tbody>
</table>
</div>
<p>第七步，交换i和j指向的值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>10</td>
<td>9</td>
<td>7</td>
<td>6</td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td></td>
<td></td>
<td>&uarr;</td>
<td>&uarr;</td>
<td></td>
<td></td>
<td></td>
<td>&uarr;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td><strong>i</strong></td>
<td><strong>j</strong></td>
<td></td>
<td></td>
<td></td>
<td>基准</td>
</tr>
</tbody>
</table>
</div>
<p>第八步，重复上述步骤，i右移，j左移，此时i和j已经交错：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>10</td>
<td>9</td>
<td>7</td>
<td>6</td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td></td>
<td></td>
<td>&uarr;</td>
<td>&uarr;</td>
<td></td>
<td></td>
<td></td>
<td>&uarr;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td><strong>j</strong></td>
<td><strong>i</strong></td>
<td></td>
<td></td>
<td></td>
<td>基准</td>
</tr>
</tbody>
</table>
</div>
<p>第九步，i和j已经交错，因此最后将基准元素与i所指元素交换：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>9</td>
<td>7</td>
<td>6</td>
<td>10</td>
<td>8</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>&uarr;</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><strong>i</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>到这一步的时候，我们发现i的左边都是小于i指向的元素，而右边都是大于i的元素。最后在对子集进行同样的操作即可。</p>
<h2 id="如何对子集进行排序"><a href="#如何对子集进行排序" class="headerlink" title="如何对子集进行排序"></a>如何对子集进行排序</h2><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><p>最常见的便是递归法了。递归的好处是代码简洁易懂，但是不可忽略的是，当递归嵌套过深时，它的效率问题以及栈溢出的风险<strong>可能</strong>会迫使你选择非递归法。在前面对整个集合一分为二之后，对剩下的两个集合递归调用，直到完成排序。简单描述如下(非可运行代码)：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Qsort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*分区操作*/</span></span><br><span class="line">    <span class="keyword">int</span> i = partition(A,left,right);</span><br><span class="line">    <span class="comment">/*对子集递归调用*/</span></span><br><span class="line">    Qsort(A,left,i<span class="number">-1</span>);</span><br><span class="line">    Qsort(A,i+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>递归最需要注意的便是递归结束调用，否则会产生无限递归，从而发生栈溢出。</p>
<p>后面我们会看到，递归法的代码非常简洁。（相关阅读《<a href="https://www.yanbinghu.com/2019/01/07/16863.html">重新看递归</a>》）</p>
<h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>在递归版本中，Qsort分别递归调用计算左右两个子集合，而第二个递归其实并非必须，完全可以用循环来替代，以下代码模拟实现了尾递归，（并非是真的尾递归）：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Qsort</span><span class="params">(ElementType A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">/*分割操作*/</span></span><br><span class="line">            i = partition(A,left,right);</span><br><span class="line">            <span class="comment">/*递归调用*/</span></span><br><span class="line">            Qsort(A,left,i<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">/*右半部分通过循环实现*/</span></span><br><span class="line">            left = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="非递归法"><a href="#非递归法" class="headerlink" title="非递归法"></a>非递归法</h2><p>那么有没有方法可以不用递归呢？既然递归每次都进行压栈操作，那么我们能不能分区后仅仅将区间信息存储到栈里，然后从栈中取出区间再继续分区呢？显然是可以的。实际上我们每次分区时，只需要知道区间即可，那么将这些区间信息存储起来，就可以不用递归了，按照分好的区间不断分区即可。</p>
<p>例如对于前面提到的数组，首先对区间[0,8]进行分区操作，之后得到两个新的分区，1,2,3和9，7，6，10，8，假设两个区间仍然可以使用快速排序，那么需要将区间[0,2]和[5,8]的其中一个压栈，另一个继续分区操作。</p>
<p>按照这种思路，代码简单描述如下（非可运行代码）：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Qsort</span><span class="params">(A,left,right)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">while</span>(STACK_IS_NOT_EMPTY)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*分区操作*/</span></span><br><span class="line">        POP(lo,hi);</span><br><span class="line">        <span class="keyword">int</span> mid = partition(A,lo,hi);</span><br><span class="line">        <span class="comment">/*存储新的边界*/</span></span><br><span class="line">        PUSH(lo,mid<span class="number">-1</span>);</span><br><span class="line">        PUSH(mid+<span class="number">1</span>,hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然这里面没有体现分区终止条件。我们需要在数据量小于一定值的时候，就不再继续进行分区操作了，而是选择插入排序（为什么？）。</p>
<p>那么问题来了，如何选择栈的大小呢？查看qsort.c的源码发现，它选择了如下的值：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE (8* sizeof(unsigned long int));</span></span><br></pre></td></tr></table></figure></p>
<p>为什么会是这个值呢？设想一下，假设待排序数组长度使用unsigned long int来表示，并且假设每次都将集合分为二等分。那么即便数组长度达到最大值，实际上最多只需要分割8 *(sizeof(unsigned long  int))次，也就将它分割完了。然而由于以下几个原因，需要存储在栈中的区间信息很难超出栈空间，因为：</p>
<ul>
<li>数组长度不会接近unsigned long int，否则内存也撑不住了</li>
<li>区间足够小时，不采用快速排序</li>
<li>每做一个分区，只会增加一个区间PUSH到栈中，增长速度慢</li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>至此，快速排序所有的主要步骤已经介绍完毕。但是有以下注意事项：</p>
<ul>
<li>有大量重复元素时避免产生糟糕分区，因此在发现大于等于基准或者小于等于基准时，便停止扫描。</li>
<li>通常会将基准一开始移动到最后位置或倒数第二个位置，避免基准在待分区区间。</li>
<li>对于很小的数组（N&lt;=20），插入排序要比快速排序更好。因为快速排序有递归开销，并且插入排序是稳定排序。</li>
<li>如果函数本身的局部变量很少，那么递归带来的开销也就越小；如果递归发生栈溢出了，首先需要排除代码设计问题。因此如果你设计的非递归版本效率低于递归版本，也不要惊讶。</li>
</ul>
<p>注：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。—来自百科</p>
<h2 id="递归版代码实现"><a href="#递归版代码实现" class="headerlink" title="递归版代码实现"></a>递归版代码实现</h2><p>C语言代码实现如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="comment">/*使用快速排序的区间大小临界值，可根据实际情况选择*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_THRESH 4</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="comment">/*元素交换*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(ElementType *a,ElementType *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElementType temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*插入排序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(ElementType A[],<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*优化后的插入排序*/</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = <span class="number">1</span>;p&lt;N;p++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = A[p];</span><br><span class="line">        <span class="keyword">for</span>(j = p;j&gt;<span class="number">0</span> &amp;&amp; A[j<span class="number">-1</span>] &gt; temp;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            A[j] = A[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        A[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*三数中值法选择基准*/</span></span><br><span class="line"><span class="function">ElementType <span class="title">medianPivot</span><span class="params">(ElementType A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> center = (left + right)/<span class="number">2</span> ;</span><br><span class="line">    <span class="comment">/*对三数进行排序*/</span></span><br><span class="line">    <span class="keyword">if</span>(A[left] &gt; A[center])</span><br><span class="line">        swap(&amp;A[left],&amp;A[center]);</span><br><span class="line">    <span class="keyword">if</span>(A[left] &gt; A[right])</span><br><span class="line">        swap(&amp;A[left],&amp;A[right]);</span><br><span class="line">    <span class="keyword">if</span>(A[center] &gt; A[right])</span><br><span class="line">        swap(&amp;A[center],&amp;A[right]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*交换中值和倒数第二个元素*/</span>    </span><br><span class="line">    swap(&amp;A[center],&amp;A[right<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> A[right<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*分区操作*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(ElementType A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="keyword">int</span> j = right<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/*获取基准值*/</span></span><br><span class="line">    ElementType pivot = medianPivot(A,left,right);</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*i j分别向右和向左移动，为什么不直接先i++？*/</span></span><br><span class="line">        <span class="keyword">while</span>(A[++i] &lt; pivot)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">        <span class="keyword">while</span>(A[--j] &gt; pivot)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(&amp;A[i],&amp;A[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*交错时停止*/</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*交换基准元素和i指向的元素*/</span></span><br><span class="line">    swap(&amp;A[i],&amp;A[right<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Qsort</span><span class="params">(ElementType A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> ElementType *arr = A;</span><br><span class="line">    <span class="keyword">if</span>(right-left &gt;= MAX_THRESH)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*分割操作*/</span></span><br><span class="line">        i = partition(arr,left,right);</span><br><span class="line">        <span class="comment">/*递归*/</span></span><br><span class="line">        Qsort(arr,left,i<span class="number">-1</span>);</span><br><span class="line">        Qsort(arr,i+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*数据量较小时，使用插入排序*/</span></span><br><span class="line">        insertSort(arr+left,right-left+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*打印数组内容*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(ElementType A[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"too much，will not print\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,A[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage:qsort num\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sort for %d numbers\n"</span>,len);</span><br><span class="line">    <span class="comment">/*随机产生输入数量的数据*/</span></span><br><span class="line">    <span class="keyword">int</span> *A = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*len);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">while</span>(i &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">       A[i] = rand();</span><br><span class="line">       i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"before sort:"</span>);</span><br><span class="line">    printArray(A,len);</span><br><span class="line">    <span class="comment">/*对数据进行排序*/</span></span><br><span class="line">    Qsort(A,<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"after  sort:"</span>);</span><br><span class="line">    printArray(A,len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="尾递归版代码实现"><a href="#尾递归版代码实现" class="headerlink" title="尾递归版代码实现"></a>尾递归版代码实现</h2><p>略。</p>
<h2 id="非递归版代码实现"><a href="#非递归版代码实现" class="headerlink" title="非递归版代码实现"></a>非递归版代码实现</h2><p>非递归版与递归版大部分代码相同，Qsort函数有所不同，并且增加栈相关内容定义：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*存储区间信息*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack_node_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> lo;</span><br><span class="line">    <span class="keyword">int</span> hi;</span><br><span class="line">&#125;struct_node;</span><br><span class="line"><span class="comment">/*最大栈长度*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE 8 * sizeof(unsigned int)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*入栈，出栈*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_PUSH( low, hig )    ( (top-&gt;lo = low), (top-&gt;hi = hig), top++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_POP( low, hig )    (top--, (low = top-&gt;lo), (hig = top-&gt;hi) )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*快速排序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Qsort</span><span class="params">( ElementType A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == A)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/*使用寄存器指针*/</span></span><br><span class="line">    <span class="keyword">register</span> ElementType *arr = A;</span><br><span class="line">    <span class="keyword">if</span> ( right - left &gt;= MAX_THRESH )</span><br><span class="line">    &#123;</span><br><span class="line">        struct_node    <span class="built_in">stack</span>[STACK_SIZE]    = &#123; &#123; <span class="number">0</span> &#125; &#125;;</span><br><span class="line">        <span class="keyword">register</span> struct_node    *top            = <span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*最大区间压栈*/</span></span><br><span class="line">        <span class="keyword">int</span> lo = left;</span><br><span class="line">        <span class="keyword">int</span> hi = right;</span><br><span class="line">        STACK_PUSH( <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="built_in">stack</span> &lt; top )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*出栈，取出一个区间进行分区操作*/</span></span><br><span class="line">            </span><br><span class="line">            mid = partition( arr, lo, hi );</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*分情况处理，左边小于阈值*/</span></span><br><span class="line">            <span class="keyword">if</span> ( (mid - <span class="number">1</span> - lo) &lt;= MAX_THRESH)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 左右两个数据段的元素都小于阈值，取出栈中数据段进行划分*/</span></span><br><span class="line">                <span class="keyword">if</span> ( (hi - (mid+<span class="number">1</span>)) &lt;= MAX_THRESH)</span><br><span class="line">                    <span class="comment">/* 都小于阈值，从栈中取出数据段 */</span></span><br><span class="line">                    STACK_POP (lo, hi);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">/* 只有右边大于阈值，右边继续分区*/</span></span><br><span class="line">                    lo =  mid <span class="number">-1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*右边小于阈值，继续计算左边*/</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((hi - (mid+<span class="number">1</span>)) &lt;= MAX_THRESH)</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">/*左右两边都大于阈值，且左边大于右边，左边入栈，右边继续分区*/</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((mid <span class="number">-1</span> - lo) &gt; (hi - (mid + <span class="number">1</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                STACK_PUSH (lo, mid - <span class="number">1</span>);</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*左右两边都大于阈值，且右边大于左边，右边入栈，左边继续分区*/</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                STACK_PUSH (mid + <span class="number">1</span>, hi);</span><br><span class="line">                hi = mid  <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*最后再使用插入排序，对于接近有序状态的数据，插入排序速度很快*/</span></span><br><span class="line">    insertSort(arr,right-left+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>我们随机产生1亿个整数，并对其进行排序：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o qsort qsort.c</span><br><span class="line">$ time ./qsort 100000000</span><br></pre></td></tr></table></figure></p>
<p>递归版运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort for 100000000 numbers</span><br><span class="line">before sort:too much，will not print</span><br><span class="line">after  sort:too much，will not print</span><br><span class="line"></span><br><span class="line">real    0m16.753s</span><br><span class="line">user    0m16.623s</span><br><span class="line">sys    0m0.132s</span><br></pre></td></tr></table></figure></p>
<p>非递归版结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort for 100000000 numbers</span><br><span class="line">before sort:too much，will not print</span><br><span class="line">after  sort:too much，will not print</span><br><span class="line"></span><br><span class="line">real    0m16.556s</span><br><span class="line">user    0m16.421s</span><br><span class="line">sys    0m0.137s</span><br></pre></td></tr></table></figure></p>
<p>可以看到，实际上两种方法的效率差距并不是很大。至于原因，前面我们已经说过了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文所写的示例实现与glibc的实现相比，还有很多可优化的地方，例如，本文实现仅对int类型实现了排序或交换值，如果待排序内容是其他类型，就显得力不从心，读者可参考《高级指针话题函数指针》思考如何实现对任意数据类型进行排序，。但快速排序的优化主要从以下几个方面考虑：</p>
<ul>
<li>优化基准选择</li>
<li>优化小数组排序效率</li>
<li>优化交换次数</li>
<li>优化递归</li>
<li>优化最差情况，避免糟糕分区</li>
<li>元素聚合</li>
</ul>
<p>有兴趣地也可以进一步阅读qsort源码，进一步了解其中丧心病狂的优化。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul>
<li>为什么要在遇到相同元素时就进行扫描？</li>
<li>插入排序最好的情况时间复杂度是多少，在什么情况下出现？</li>
<li>文中实现的代码还有哪些可以优化的地方？</li>
</ul>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ul>
<li>采用第一种基准选择策略实现快速排序，并测试对有序数组的排序性能</li>
<li>实现通用快速排序算法，参考《<a href="https://www.yanbinghu.com/2019/01/03/3593.html">C语言函数指针</a>》</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《数据结构与算法分析》</li>
<li>《算法导论》</li>
<li>glibc qsort.c源码</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>父进程退出时如何确保子进程退出？</title>
    <url>/2019/02/14/37859.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>子进程退出的时候，父进程能够收到子进程退出的信号，便于管理，但是有时候又需要在父进程退出的时候，子进程也退出，该怎么办呢？<br><a id="more"></a></p>
<h2 id="父进程退出时，子进程会如何？"><a href="#父进程退出时，子进程会如何？" class="headerlink" title="父进程退出时，子进程会如何？"></a>父进程退出时，子进程会如何？</h2><p>一般情况下，父进程退出后，是不会通知子进程的，这个时候子进程会成为<strong>孤儿进程</strong>，最终被init进程收养。我们先来看一下这种情况。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="comment">//fork一个进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="comment">//创建失败</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork error:"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子进程</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"child process.\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child  pid:%d,parent pid:%d\n"</span>,getpid(),getppid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"sleep 10 seconds.\n"</span>);</span><br><span class="line">        <span class="comment">//sleep一段时间，让父进程先退出，为了便于观察，sleep 10s</span></span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">		</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"now child pid: %d parent pid:%d\n"</span>,getpid(),getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父进程</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent process.\n"</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个程序中，我们为了让父进程先退出，子进程sleep了10秒。<br>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parent process.</span><br><span class="line">child process.</span><br><span class="line">child  pid:17433,parent pid:17432</span><br><span class="line">sleep 10 seconds.</span><br><span class="line">now child pid: 17433 parent pid:1658</span><br></pre></td></tr></table></figure></p>
<p>从结果中可以看到，一开始子进程17433的父进程id是17432，但是在10秒后，它的父进程变成了1658。1685是什么进程呢？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -al /proc/1658/exe </span><br><span class="line">/proc/1658/exe -&gt; /sbin/upstart</span><br></pre></td></tr></table></figure></p>
<p>由于我使用的环境是<strong>带有图形界面的ubuntu系统</strong>，所以最终并不是被我们所熟知的init进程收养，而是被一个名为/sbin/upstart的进程所收养。另外还可以观察到，该进程也是其他系统进程的父进程。</p>
<h2 id="如何确保父进程退出的同时，子进程也退出？"><a href="#如何确保父进程退出的同时，子进程也退出？" class="headerlink" title="如何确保父进程退出的同时，子进程也退出？"></a>如何确保父进程退出的同时，子进程也退出？</h2><p>既然如此，如何确保父进程退出的同时，子进程也退出呢？或许我们可以在子进程和父进程之间建立通信管道，一旦通信异常，则认为父进程退出，子进程自己也回收资源退出。但是这样做总觉得不是很正经。有没有已有的函数帮我们做这件事呢？prctl函数可以帮助我们。第一个参数中，有一个选项，叫做PR_GET_PDEATHSIG:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PR_SET_PDEATHSIG (since Linux 2.1.57)</span><br><span class="line">       Set  the  parent  death signal of the calling process to arg2 (either a signal value in the range 1..maxsig, or 0 to clear).</span><br><span class="line">       This is the signal that the calling process will get when its parent dies.  This value is cleared for the child of a fork(2)</span><br><span class="line">       and (since Linux 2.4.36 / 2.6.23) when executing a set-user-ID or set-group-ID binary, or a binary that has associated capa‐</span><br><span class="line">       bilities (see capabilities(7)).  This value is preserved across execve(2).</span><br></pre></td></tr></table></figure></p>
<p>内容很多，主要意思为：设置一个信号，当父进程退出的时候，子进程将会收到该信号。</p>
<p>那么根据这个，我们完全可以在父进程退出时，也给子进程一个退出的信号。程序代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="comment">//fork一个进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="comment">//创建失败</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork error:"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子进程</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">/*父进程退出时，会收到SIGKILL信号*/</span></span><br><span class="line">		prctl(PR_SET_PDEATHSIG,SIGKILL);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"child process.\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child  pid:%d,parent pid:%d\n"</span>,getpid(),getppid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"sleep 10 seconds.\n"</span>);</span><br><span class="line">        <span class="comment">//sleep一段时间，让父进程先退出，为了便于观察，sleep 10s</span></span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">		</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"now child pid: %d parent pid:%d\n"</span>,getpid(),getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父进程</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent process.\n"</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parent process.</span><br><span class="line">child process.</span><br><span class="line">child  pid:17625,parent pid:17624</span><br><span class="line">sleep 10 seconds.</span><br></pre></td></tr></table></figure></p>
<p>可以看到，由于加入了<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">prctl(PR_SET_PDEATHSIG,SIGKILL);</span><br></pre></td></tr></table></figure></p>
<p>在父进程退出时，子进程将会收到SIGKILL信号，而进程收到该信号的默认动作则是退出。因而最后不会看到它成为孤儿进程，被其他进程所收养。需要注意的是，该函数并非所有系统都支持。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有些情况下，我们常常需要父子进程共存亡，子进程退出时，父进程可以通过wait捕捉子进程的退出状态，但是父进程退出时，子进程却难以得知。因此，在最初fork子进程的时候，便表明了，当父进程退出的时候，子进程收到SIGKILL信号，最终也退出。以此达到同生共死的目的。<strong>但这并不适用于所有操作系统</strong>。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>尝试将上面的代码在非图形界面的linux操作系统中运行，看看最终被收养的是否为init进程。</p>
<h2 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h2><p>虽然本文方法可行，但并不适用于所有操作系统，你有什么更好的办法解决上面的问题？</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>const关键字到底该怎么用？</title>
    <url>/2019/01/28/7442.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们都知道使用const关键字限定一个变量为只读，但它是真正意义上的只读吗？实际中又该如何使用const关键字？在解答这些问题之前，我们需要先理解const关键字的基本使用。本文说明C中的const关键字，不包括C++。<br><a id="more"></a></p>
<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>const是constant的简写，是不变的意思。但并不是说它修饰常量，而是说它限定一个变量为只读。</p>
<h4 id="修饰普通变量"><a href="#修饰普通变量" class="headerlink" title="修饰普通变量"></a>修饰普通变量</h4><p>例如：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NUM = <span class="number">10</span>; <span class="comment">//与int const NUM等价</span></span><br><span class="line">NUM = <span class="number">9</span>;  <span class="comment">//编译错误，不可再次修改</span></span><br></pre></td></tr></table></figure></p>
<p>由于使用了const修饰NUM，使得NUM为只读，因此尝试对NUM再次赋值的操作是非法的，编译器将会报错。正因如此，如果需要使用const修饰一个变量，那么它只能<strong>在开始声明时就赋值，否则后面就没有机会了</strong>（后面会讲到一个特殊情况）。</p>
<h4 id="修饰数组"><a href="#修饰数组" class="headerlink" title="修饰数组"></a>修饰数组</h4><p>例如使用const关键字修饰数组，使其元素不允许被改变：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> arr[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; <span class="comment">//与int const arr[]等价</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">1</span>; <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure></p>
<p>试图修改arr的内容的操作是非法的，编译器将会报错：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: assignment of read-only location ‘arr[2]’</span><br></pre></td></tr></table></figure></p>
<h4 id="修饰指针"><a href="#修饰指针" class="headerlink" title="修饰指针"></a>修饰指针</h4><p>修饰指针的情况比较多，主要有以下几种情况：<br>1.const 修饰 *p，指向的对象只读，指针的指向可变：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a;<span class="comment">//p是一个指向int类型的const值,与int const *p等价</span></span><br><span class="line">*p = <span class="number">11</span>;    <span class="comment">//编译错误，指向的对象是只读的，不可通过p进行改变</span></span><br><span class="line">p = &amp;b;     <span class="comment">//合法，改变了p的指向</span></span><br></pre></td></tr></table></figure></p>
<p>这里为了便于理解，可认为const修饰的是*p，通常使用*对指针进行解引用来访问对象，因而，该对象是只读的。</p>
<p>2.const修饰p，指向的对象可变，指针的指向不可变：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;a;<span class="comment">//p是一个const指针</span></span><br><span class="line">*p = <span class="number">11</span>;    <span class="comment">//合法，</span></span><br><span class="line">p = &amp;b;     <span class="comment">//编译错误，p是一个const指针，只读，不可变</span></span><br></pre></td></tr></table></figure></p>
<p>3.指针不可改变指向，指向的内容也不可变<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;a;<span class="comment">//p既是一个const指针，同时也指向了int类型的const值</span></span><br><span class="line">*p = <span class="number">11</span>;    <span class="comment">//编译错误，指向的对象是只读的，不可通过p进行改变</span></span><br><span class="line">p = &amp;b;     <span class="comment">//编译错误，p是一个const指针，只读，不可变</span></span><br></pre></td></tr></table></figure></p>
<p>看完上面几种情况之后是否会觉得混乱，并且难以记忆呢？我们使用一句话总结：<br><strong>const放在*的左侧任意位置，限定了该指针指向的对象是只读的；const放在*的右侧，限定了指针本身是只读的，即不可变的。</strong></p>
<p>如果还不是很好理解，我们可以这样来看，去掉类型说明符，查看const修饰的内容，上面三种情况去掉类型说明符int之后，如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> *p; <span class="comment">//修饰*p，指针指向的对象不可变</span></span><br><span class="line">* <span class="keyword">const</span> p; <span class="comment">//修饰p，指针不可变</span></span><br><span class="line"><span class="keyword">const</span> * <span class="keyword">const</span> p; <span class="comment">//第一个修饰了*p，第二个修饰了p，两者都不可变</span></span><br></pre></td></tr></table></figure></p>
<p>const右边修饰谁，就说明谁是不可变的。上面的说法仅仅是帮助理解和记忆。借助上面这种理解，就会发现以下几种等价情况：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NUM = <span class="number">10</span>; <span class="comment">//与int const NUM等价</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p  = &amp;a;<span class="comment">//与int const *p等价</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> arr[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; <span class="comment">//与int const arr[]等价</span></span><br></pre></td></tr></table></figure></p>
<h2 id="const关键字到底有什么用"><a href="#const关键字到底有什么用" class="headerlink" title="const关键字到底有什么用"></a>const关键字到底有什么用</h2><p>前面介绍了这么多内容，是不是都常用呢？const关键字到底有什么用？</p>
<h4 id="修饰函数形参"><a href="#修饰函数形参" class="headerlink" title="修饰函数形参"></a>修饰函数形参</h4><p>实际上，为我们可以经常发现const关键字的身影，例如很多库函数的声明：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncpy</span><span class="params">(<span class="keyword">char</span> *dest,<span class="keyword">const</span> <span class="keyword">char</span> *src,<span class="keyword">size_t</span> n)</span></span>;<span class="comment">//字符串拷贝函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  *<span class="title">strncmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1,<span class="keyword">const</span> <span class="keyword">char</span> *s2,<span class="keyword">size_t</span> n)</span></span>;<span class="comment">//字符串比较函数</span></span><br></pre></td></tr></table></figure></p>
<p>通过看strncpy函数的原型可以知道，源字符串src是只读的，不可变的，而dest并没有该限制。我们通过一个小例子继续观察：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    str[<span class="number">0</span>] = <span class="string">'H'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"my print:%s\n"</span>,str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">"hello world"</span>;</span><br><span class="line">    myPrint(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，我们不希望myPrint函数修改传入的字符串内容，因此入参使用了const限定符，表明传入的字符串是只读的，因此，如果myPrint函数内部如果尝试对str进行修改，将会报错:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o test test.c</span><br><span class="line">test.c:6:12: error: assignment of read-only location ‘*str’</span><br><span class="line">     str[0] = &apos;H&apos;;</span><br></pre></td></tr></table></figure></p>
<p>因此，我们自己在编码过程中，<strong>如果确定传入的指针参数仅用于访问数据，那么应该将其声明为一个指向const限定类型的指针，避免函数内部对数据进行意外地修改</strong>。</p>
<h4 id="修饰全局变量"><a href="#修饰全局变量" class="headerlink" title="修饰全局变量"></a>修饰全局变量</h4><p>我们知道，使用全局变量是一种不安全的做法，因为程序的任何部分都能够对全局数据进行修改。而如果对全局变量增加const限定符（假设该全局数据不希望被修改），就可以避免被程序其他部分修改。这里有两种使用方式。<br>第一种，在a文件中定义，其他文件中使用外部声明，例如：<br>a.h<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.h</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ARR[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;  <span class="comment">//定义int数组</span></span><br></pre></td></tr></table></figure></p>
<p>b.c<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//b.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> ARR[];   <span class="comment">//注意，这里不能再对ARR进行赋值</span></span><br><span class="line"><span class="comment">//后面可以使用ARR</span></span><br></pre></td></tr></table></figure></p>
<p>第二种，在a文件中定义，并<strong>使用static修饰</strong>，b文件包含a文件，例如：<br>a.h<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//a.h</span><br><span class="line">static const int ARR[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;  //定义int数组</span><br></pre></td></tr></table></figure></p>
<p>b.c<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//b.c</span><br><span class="line">#include&lt;a.h&gt;</span><br><span class="line">//后面可以使用ARR</span><br></pre></td></tr></table></figure></p>
<p>注意，这里必须使用static修饰，否则多个文件包含导致编译会出现重复定义的错误。有兴趣的可以尝试一下。</p>
<h2 id="const修饰的变量是真正的只读吗？"><a href="#const修饰的变量是真正的只读吗？" class="headerlink" title="const修饰的变量是真正的只读吗？"></a>const修饰的变量是真正的只读吗？</h2><p>使用const修饰之后的变量真的是完全的只读吗？看下面这个例子：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">2018</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">    *p = <span class="number">2019</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019</span><br></pre></td></tr></table></figure></p>
<p>可以看到，我们通过另外定义一个指针变量，将被const修饰的a的值改变了。那么我们不禁要问，const到底做了什么呢？它修饰的变量是真正意义上的只读吗?为什么它修饰的变量的值仍然可以改变？<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2019</span>;</span><br><span class="line">    <span class="comment">//const int a = 2019;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们分别获取有const修饰和无const修饰的汇编代码。<br>无const修饰，汇编代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">.LC0:</span><br><span class="line">        .string &quot;%d\n&quot;</span><br><span class="line">main:</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        sub     rsp, 16</span><br><span class="line">        mov     DWORD PTR [rbp-4], 2019</span><br><span class="line">        mov     eax, DWORD PTR [rbp-4]</span><br><span class="line">        mov     esi, eax</span><br><span class="line">        mov     edi, OFFSET FLAT:.LC0</span><br><span class="line">        mov     eax, 0</span><br><span class="line">        call    printf</span><br><span class="line">        mov     eax, 0</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure></p>
<p>有const修饰，汇编代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.LC0:</span><br><span class="line">        .string &quot;%d\n&quot;</span><br><span class="line">main:</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        sub     rsp, 16</span><br><span class="line">        mov     DWORD PTR [rbp-4], 2019</span><br><span class="line">        mov     eax, DWORD PTR [rbp-4]</span><br><span class="line">        mov     esi, eax</span><br><span class="line">        mov     edi, OFFSET FLAT:.LC0</span><br><span class="line">        mov     eax, 0</span><br><span class="line">        call    printf</span><br><span class="line">        mov     eax, 0</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure></p>
<p>我们发现，并没有任何差异！当然这一个例子并不能说明所有的问题。但是我们要知道的是，const关键字告诉了编译器，它修饰的变量不能被改变，如果代码中发现有类似改变该变量的操作，那么编译器就会捕捉这个错误。</p>
<p>那么它在实际中的意义之一是什么呢？<strong>帮助程序员提前发现问题，避免不该修改的值被意外地修改</strong>，但是无法完全保证不被修改！例如我们可以通过对指针进行强转：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *b = (<span class="keyword">char</span> *)str;</span><br><span class="line">    b[<span class="number">0</span>] = <span class="string">'H'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"my print:%s\n"</span>,b);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">"hello world"</span>;</span><br><span class="line">    myPrint(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my print:Hello world</span><br></pre></td></tr></table></figure></p>
<p>也就是说，const关键字是给编译器用的，帮助程序员提早发现可能存在的问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>介绍了这么多，关键点如下：</p>
<ul>
<li>const关键字让编译器帮助我们发现变量不该被修改却被意外修改的错误。</li>
<li>const关键字修饰的变量并非真正意义完完全全的只读。</li>
<li><strong>对于不该被修改的入参，应该用const修饰，这是const使用的常见姿势。</strong></li>
<li>const修饰的变量只能正常赋值一次。</li>
<li>不要试图将const数据的地址赋给普通指针。</li>
<li>不要忽略编译器的警告，除非你很清楚在做什么。</li>
<li>虽然可以通过某种不正规途径修改const修饰的变量，但是<strong>永远不要这么做</strong>。</li>
</ul>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul>
<li>与#define相比，const有什么优点？</li>
<li>const关键字到底该什么时候用？</li>
</ul>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言学习-初识</title>
    <url>/2019/01/20/30277.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Go（又称Golang）是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。<br><a id="more"></a></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>相比于其他语言，它有以下特点（内容来源于网络）：</p>
<ul>
<li>可直接编译成机器码，不依赖其他库，便于部署</li>
<li><strong>语言层面支持并发</strong></li>
<li>丰富的标准库</li>
<li>内置runtime，支持垃圾回收</li>
<li>内置强大的工具，gofmt工具统一了编码风格</li>
<li>内嵌C支持，同时有C基础，学Golang也较轻松</li>
<li>原生支持Unicode</li>
</ul>
<h2 id="Go主要应用"><a href="#Go主要应用" class="headerlink" title="Go主要应用"></a>Go主要应用</h2><ul>
<li>服务器开发</li>
<li>网络应用开发</li>
<li>分布式系统</li>
<li>数据库</li>
<li>云平台</li>
<li>…</li>
</ul>
<h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><p>以Linux平台为例，从<a href="https://golang.org/dl/下载linux版本的安装包，假设你要安装到/usr/local目录下：" target="_blank" rel="noopener">https://golang.org/dl/下载linux版本的安装包，假设你要安装到/usr/local目录下：</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tar -C /usr/local -xzf go$VERSION.$OS-$ARCH.tar.gz</span><br><span class="line"># go$VERSION.$OS-$ARCH.tar.gz为前面下载好的安装包</span><br></pre></td></tr></table></figure></p>
<p>为了直接使用go命令，需要将go所在bin路径加入到PATH环境变量中，<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/go/bin</span><br></pre></td></tr></table></figure></p>
<p>注意这种方式只对当前shell有效，想要永久生效，需要修改/etc/profile或者～/.bashrc文件，具体不作介绍。</p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>环境准备好之后，我们来编写第一个go程序：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hellogo.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"Hello world"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译并运行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ go build hellogo.go</span><br><span class="line">$ ./hellogo.go</span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure></p>
<p>虽然很简单，但是我们仍然一行一行弄清楚。</p>
<ul>
<li>第一个声明了当前文件位于main包</li>
<li>第二行导入了fmt包，导入之后就可以使用包中的接口了</li>
<li>第三行定义了main函数，这个与其他编程语言类似，但没有返回类型</li>
<li>第四行使用了fmt包中的Println函数打印了“Hello world”</li>
<li>大括号结束</li>
</ul>
<p>包类似于其它语言里的库（libraries）或者模块（modules）一个包由位于单个目录下的一个或多个.go源代码文件组成。同时每个源文件都以一条package声明语句开始。但是这里要注意，对于可运行的go程序，main函数必须在main包中。</p>
<p>还需要注意的是：</p>
<ul>
<li>缺少了必要的包或者导入了不需要的包，程序都无法编译通过</li>
<li>import声明必须跟在文件的package声明之后</li>
<li>main包特殊，它定义了一个独立可执行的程序</li>
<li><strong>每行程序结束后不需要撰写分号，除非一行上有多条语句</strong></li>
<li><strong>大括号不能够换行放置</strong></li>
</ul>
<h2 id="进一步的思考"><a href="#进一步的思考" class="headerlink" title="进一步的思考"></a>进一步的思考</h2><p>无意中发现，编译出来的bin文件足足有2.2M，即便是使用strip命令处理之后，仍然有1.6M。而C语言版的只有8.5K。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -lh</span><br><span class="line">total 2.3M</span><br><span class="line">8.5K 1月  20 16:45 helloc</span><br><span class="line">  75 1月  20 16:45 helloc.c</span><br><span class="line">2.2M 1月  20 16:45 hellogo</span><br><span class="line">  70 1月  20 16:35 hellogo.go</span><br></pre></td></tr></table></figure></p>
<p>即便使用strip处理之后，hellogo仍然有1.6M:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ strip hellogo</span><br><span class="line">$ ls -lh hellogo</span><br><span class="line">1.6M 1月  20 16:48 hellogo</span><br></pre></td></tr></table></figure></p>
<p>当然我们使用ldd命令看到：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ldd hellogo</span><br><span class="line">	not a dynamic executable</span><br><span class="line">$ ldd helloc</span><br><span class="line">	linux-vdso.so.1 =&gt;  (0x00007ffcffbe2000)</span><br><span class="line">	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007ff8d5798000)</span><br><span class="line">	/lib64/ld-linux-x86-64.so.2 (0x00007ff8d5b62000)</span><br></pre></td></tr></table></figure></p>
<p>可以看到，C程序默认使用了动态链接，而go程序并没有默认使用动态链接，而是静态链接。这不禁让我们想到开始所说的go程序便于部署。由于不需要依赖其他动态库，go程序能够很方便的在机器上部署。</p>
<p>关于静态库和动态库的优劣不在本文的讨论范围之内。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如今go语言在很多方面都有应用，甚至被称为“21世纪的c语言”。本人初学go，如有描述不当之处，还请各位多多指教。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>编程技巧-跳转表</title>
    <url>/2019/01/20/6807.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面我们讲到了《<a href="https://www.yanbinghu.com/2019/01/03/3593.html">函数指针</a>》，今天我们看一个编程技巧-函数跳转表。我们先来看如何实现一个简易计算器。<br><a id="more"></a></p>
<h2 id="初始版本"><a href="#初始版本" class="headerlink" title="初始版本"></a>初始版本</h2><p>让我们实现一个简易计算器，我们首先能想到的方式是什么？switch语句或者if else语句。没错，初学就会想到的两种方式，我们来看看这种实现方式。这里我们选择switch语句，定义一个操作类型，用户选择操作类型与操作类型匹配时，选择对应的处理函数进行处理，calc1.c代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*calc1.c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*将操作定义为枚举类型*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">	OP_ADD = <span class="number">0</span>,</span><br><span class="line">	OP_SUB,</span><br><span class="line">	OP_MUL,</span><br><span class="line">	OP_DIV,</span><br><span class="line">&#125;OP_TYPE;</span><br><span class="line"><span class="comment">/*加减乘除处理函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ADD</span><span class="params">(<span class="keyword">double</span> op1,<span class="keyword">double</span> op2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> op1+op2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">SUB</span><span class="params">(<span class="keyword">double</span> op1,<span class="keyword">double</span> op2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> op1-op2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">MUL</span><span class="params">(<span class="keyword">double</span> op1,<span class="keyword">double</span> op2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> op1*op2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">DIV</span><span class="params">(<span class="keyword">double</span> op1,<span class="keyword">double</span> op2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> op1/op2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> op,<span class="keyword">double</span> op1,<span class="keyword">double</span> op2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*使用switch，根据操作类型，选择操作*/</span></span><br><span class="line">	<span class="keyword">double</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span>(op)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> OP_ADD:</span><br><span class="line">		&#123;</span><br><span class="line">			result = ADD(op1,op2);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> OP_SUB:</span><br><span class="line">		&#123;</span><br><span class="line">			result = SUB(op1,op2);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> OP_MUL:</span><br><span class="line">		&#123;</span><br><span class="line">			result = MUL(op1,op2);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> OP_DIV:</span><br><span class="line">		&#123;</span><br><span class="line">			result = DIV(op1,op2);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#123;</span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">"unsupport opration\n"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	<span class="keyword">if</span>(<span class="number">4</span> &gt; argc)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"usage:op num1 num2\n"</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"op[0:add,1:sub,2:mul;3:div]\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> op = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">double</span> op1 = atof(argv[<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">double</span> op2 = atof(argv[<span class="number">3</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"op:%d,op1:%.1f,op2:%.1f\n"</span>,op,op1,op2);</span><br><span class="line">	<span class="keyword">double</span> result = calc(op,op1,op2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"result is %.1f\n"</span>,result);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>除去编译器对switch进行优化的情况</strong>，这种设计方式有以下几个缺点：</p>
<ul>
<li>操作增加时，代码增加，case语句将变得冗长。</li>
<li>操作增加时，分支增加，处理对应操作的时间将会增长。</li>
<li>代码可维护性较差。</li>
</ul>
<p>我们观察代码会发现，每增加一种操作，就需要增加一个分支，当操作越来越多的时候calc函数将会变得冗长且不易维护。并且如果没有编译器优化，由于在找到最终匹配的之前，每一个case语句都需要执行，因此可能将导致运行时间变长。</p>
<h2 id="函数跳转表版本"><a href="#函数跳转表版本" class="headerlink" title="函数跳转表版本"></a>函数跳转表版本</h2><p>既然每一个操作对应一个函数，那么完全可以定义一个函数指针数组，而每个操作对应一个下标值，只要知道下标值，很快就可以找到对应的函数。我们都知道，数组下标方式访问数据效率是很高的。该版本实现如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">calc2.c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*将操作定义为枚举类型*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">	OP_ADD = <span class="number">0</span>,</span><br><span class="line">	OP_SUB,</span><br><span class="line">	OP_MUL,</span><br><span class="line">	OP_DIV,</span><br><span class="line">&#125;OP_TYPE;</span><br><span class="line"><span class="comment">/*入参为double，出参为double的函数指针*/</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">double</span> <span class="params">(*OP_FUNC)</span><span class="params">(<span class="keyword">double</span>,<span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">OP_STRUCT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	OP_TYPE opType;<span class="comment">//操作类型</span></span><br><span class="line">	OP_FUNC opFun; <span class="comment">//操作函数</span></span><br><span class="line">&#125;OP_STRUCT;</span><br><span class="line"><span class="comment">/*加减乘除处理函数与calc1.c相同，这里省略，可自行添加*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数跳转表*/</span></span><br><span class="line"><span class="keyword">static</span> OP_STRUCT g_opStruct[] = </span><br><span class="line">&#123;</span><br><span class="line">	&#123;OP_ADD ,ADD&#125;,</span><br><span class="line">	&#123;OP_SUB ,SUB&#125;,</span><br><span class="line">	&#123;OP_MUL ,MUL&#125;,</span><br><span class="line">	&#123;OP_DIV ,DIV&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*最大操作数量*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g_opNum = <span class="keyword">sizeof</span>(g_opStruct)/<span class="keyword">sizeof</span>(OP_STRUCT);</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> op,<span class="keyword">double</span> op1,<span class="keyword">double</span> op2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(op &gt;= g_opNum || op &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;  </span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"unknow opration\n"</span>);</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*根据操作类型直接选择操作函数*/</span></span><br><span class="line">    <span class="keyword">return</span> g_opStruct[op].opFun(op1,op2);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">/*main函数与calc1.c相同，这里省略*/</span></span><br></pre></td></tr></table></figure></p>
<p>calc函数中，直接根据操作类型而选择需要的操作处理函数。时间复杂度为O(1)。另外，当需要新增一种操作时，不需要修改calc函数，只需要在函数表g_opStruct中增加一种操作即可。而操作处理是一个返回值为double，入参为两个double的函数，因此使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef double (*OP_FUNC)(double,double);</span><br></pre></td></tr></table></figure></p>
<p>将该类型函数指针定义为OP_FUNC，方面后面的使用。</p>
<p>另外，还可以看到calc函数很简洁，关键代码只有一行。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文的例子有很多可以优化的地方，例如异常时返回0，可能被当成结果等等，这里只是用switch语句和跳转表作简单的示例。而对于同类型的分支处理，完全可以考虑使用跳转表的方式，<strong>使用跳转表还需要注意的一点就是数组越界</strong>。<br>跳转表只是一种思路，它并不是在所有情况下都可以替代switch语句，可根据实际情况决定是否需要使用。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>为什么在说明第一个版本的简易计算器的时候，强调：除去编译器对switch进行优化的情况？</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>linux中删除特殊名称文件的多种方式</title>
    <url>/2019/01/19/8873.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们都知道，在linux删除一个文件可以使用rm命令，但是有一些特殊名称的文件使用普通的rm方式却没法删除，本文介绍linux中删除特殊名称文件的多种方式。<br><a id="more"></a></p>
<h2 id="linux文件命名规则"><a href="#linux文件命名规则" class="headerlink" title="linux文件命名规则"></a>linux文件命名规则</h2><p>在介绍之前，简单说明一下linux中文件命名规则。文件或目录名由除“/”和空字符“\0”之外的任意ASCII字符序列组成。当然很多操作系统允许更多类型的字符组成文件名。但对于我们来说，从来不建议使用一些特殊字符来命名文件。不幸的是，我们可能无意中创建了一些特殊名称的文件，或者由程序意外的创建了一些由特殊字符组成的文件。这个时候，要删除它们，似乎没有想象中的那么简单。</p>
<h2 id="删除时带上路径"><a href="#删除时带上路径" class="headerlink" title="删除时带上路径"></a>删除时带上路径</h2><p>假设有一个名为-static文件，我们使用普通方式将它删除：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> rm -static</span><br><span class="line">rm: invalid option -- 's'</span><br><span class="line">Try 'rm ./-static' to remove the file '-static'.</span><br><span class="line">Try 'rm --help' for more information.</span><br></pre></td></tr></table></figure></p>
<p>非常可惜，这种方式提示出错，并不能成功地删除-static文件。这是为什么？我们知道在linux中，通常以-开头，后面跟一些字符，作为一个命令的选项，而不巧的，-static就被rm命令认为是一个参数选项，更不幸的是，实际上并没有该选项，因此最终提示invalid option — ‘s’，导致-static文件无法删除。</p>
<p>那么有没有什么办法删除呢？我们注意到，除了提示非法选项外，还让我们尝试rm ./-static，是否可以呢？我们试一下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> rm ./-static</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure></p>
<p>最终发现，我们将-static文件成功删除了。因此得到我们的第一种方式，<strong>删除文件时带上路径</strong>。</p>
<h2 id="删除时使用"><a href="#删除时使用" class="headerlink" title="删除时使用 --"></a>删除时使用 --</h2><p>前面除了提示让我们使用rm ./-static之外，还让我们使用rm —help获取更多信息，那么我们就看一下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> rm --help</span><br><span class="line">(省略部分内容)</span><br><span class="line">To remove a file whose name starts with a '-', for example '-foo',</span><br><span class="line">use one of these commands:</span><br><span class="line">  rm -- -foo</span><br><span class="line">  rm ./-foo</span><br><span class="line">(省略部分内容)</span><br></pre></td></tr></table></figure></p>
<p>内容较多，但是可以注意到上面的内容，对于以-开头的文件，提供了两种删除方式，第二种是前面提到的，而第二种，是在删除的文件前面再加—：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> rm -- -static</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure></p>
<p>我们发现这种方式也是可以删除以-开头的文件。</p>
<h2 id="删除时用引号引起来"><a href="#删除时用引号引起来" class="headerlink" title="删除时用引号引起来"></a>删除时用引号引起来</h2><p>对于特殊字符，如&lt;&gt;!*等组成的文件如何删除呢？例如：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> rm &lt;&gt;\!*</span><br><span class="line">rm: missing operand</span><br><span class="line">Try 'rm --help' for more information.</span><br></pre></td></tr></table></figure></p>
<p>对于这种类型的文件，我们需要用引号将文件名包含起来：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> rm "&lt;&gt;\!*"</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure></p>
<p>这样就可以删除掉了，但是这种方式并不能针对所有该类型的文件，例如，文件名为!*的文件就不能通过这样的方式删除，因为!*是有其他含义的，具体可参看《<a href="https://www.yanbinghu.com/2018/12/22/40915.html">linux中！的惊叹用法</a>》。</p>
<h2 id="增加转义字符删除文件"><a href="#增加转义字符删除文件" class="headerlink" title="增加转义字符删除文件"></a>增加转义字符删除文件</h2><p>既然!*无法通过加引号的方式删除，那还有什么办法吗？有！删除时，增加转义字符：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> rm \!*</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure></p>
<p>这样便可以删除。在linux中，很多字符有着特殊的含义，因此当你需要把它当普通字符使用时，就需要在前面加上\转义字符，这和C语言中的转义有点类似。再举个例子，要删除以空格开头的abc文件，可以使用下面的方式：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> rm \ abc</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure></p>
<p>即可成功删除。</p>
<h2 id="按照i节点号删除"><a href="#按照i节点号删除" class="headerlink" title="按照i节点号删除"></a>按照i节点号删除</h2><p>很多时候，文件名压根没法输入，因为它们都是一堆乱码。因此也完全无法通过前面介绍的方法进行删除，那还有办法吗？有！通过查找文件的i节点，按照i节点进行删除。<br>例如：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> ls -i #找到乱码文件的i节点号</span><br><span class="line">1703907 ç¼?ç¨?ç? ç??é«?æ¸?pdfç??.pdf </span><br><span class="line"><span class="meta">$</span> find ./ -inum 1703907 -exec rm &#123;&#125; \; #或者使用-delete参数</span><br></pre></td></tr></table></figure></p>
<p>关于find命令用法，可参考《<a href="https://www.yanbinghu.com/2018/12/15/21083.html">find命令高级用法</a>》。这种通过i节点号进行删除的方式适用于前面所提到的任何类型文件。</p>
<p>这里扩展说几句。在操作系统中，它是如何识别一个文件的呢？它并不是通过文件名，而是通过一个iNode号，即i节点号来识别不同的文件，文件名不过是这个文件其中的一个属性而已。</p>
<h2 id="使用通配符删除"><a href="#使用通配符删除" class="headerlink" title="使用通配符删除"></a>使用通配符删除</h2><p>不多解释：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rm *.pdf</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>但是这种方式可能存在误删，因为只要文件名结尾为.pdf就会被删除，因此根据实际情况慎重使用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>删除特殊文件名称的方法有很多，总结如下：</p>
<ul>
<li>删除时带上路径</li>
<li>删除时使用 --</li>
<li>删除时用引号引起来</li>
<li>使用转义字符辅助删除</li>
<li>按照i节点号删除</li>
<li>使用通配符删除</li>
</ul>
<p>不同类型文件可选择使用上面所提较方便的方式进行删除。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB调试指南-启动调试</title>
    <url>/2019/01/08/62137.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>GDB（GNU Debugger）是UNIX及UNIX-like下的强大调试工具，可以调试ada, c, c++, asm, minimal, d, fortran, objective-c, go, java,pascal等语言。本文以C程序为例，介绍GDB启动调试的多种方式。<br><a id="more"></a></p>
<h2 id="哪类程序可被调试"><a href="#哪类程序可被调试" class="headerlink" title="哪类程序可被调试"></a>哪类程序可被调试</h2><p>对于C程序来说，需要在编译时加上-g参数，保留调试信息，否则不能使用GDB进行调试。<br>但如果不是自己编译的程序，并不知道是否带有-g参数，如何判断一个文件是否带有调试信息呢？</p>
<h4 id="gdb-文件"><a href="#gdb-文件" class="headerlink" title="gdb 文件"></a>gdb 文件</h4><p>例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gdb helloworld</span><br><span class="line">Reading symbols from helloWorld...(no debugging symbols found)...done.</span><br></pre></td></tr></table></figure></p>
<p>如果没有调试信息，会提示no debugging symbols found。<br>如果是下面的提示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Reading symbols from helloWorld...done.</span><br></pre></td></tr></table></figure></p>
<p>则可以进行调试。</p>
<h4 id="readelf查看段信息"><a href="#readelf查看段信息" class="headerlink" title="readelf查看段信息"></a>readelf查看段信息</h4><p>例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ readelf -S helloWorld|grep debug</span><br><span class="line">  [28] .debug_aranges    PROGBITS         0000000000000000  0000106d</span><br><span class="line">  [29] .debug_info       PROGBITS         0000000000000000  0000109d</span><br><span class="line">  [30] .debug_abbrev     PROGBITS         0000000000000000  0000115b</span><br><span class="line">  [31] .debug_line       PROGBITS         0000000000000000  000011b9</span><br><span class="line">  [32] .debug_str        PROGBITS         0000000000000000  000011fc</span><br></pre></td></tr></table></figure></p>
<p>helloWorld为文件名，如果没有任何debug信息，则不能被调试。</p>
<h4 id="file查看strip状况"><a href="#file查看strip状况" class="headerlink" title="file查看strip状况"></a>file查看strip状况</h4><p>下面的情况也是不可调试的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file helloWorld</span><br><span class="line">helloWorld: (省略前面内容) stripped</span><br></pre></td></tr></table></figure></p>
<p>如果最后是stripped，则说明该文件的符号表信息和调试信息已被去除，不能使用gdb调试。但是not stripped的情况并不能说明能够被调试。</p>
<h2 id="调试方式运行程序"><a href="#调试方式运行程序" class="headerlink" title="调试方式运行程序"></a>调试方式运行程序</h2><p>程序还未启动时，可有多种方式启动调试。</p>
<h4 id="调试启动无参程序"><a href="#调试启动无参程序" class="headerlink" title="调试启动无参程序"></a>调试启动无参程序</h4><p>例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gdb helloWorld</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>输入run命令，即可运行程序</p>
<h4 id="调试启动带参程序"><a href="#调试启动带参程序" class="headerlink" title="调试启动带参程序"></a>调试启动带参程序</h4><p>假设有以下程序，启动时需要带参数：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> &gt;= argc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage:hello name\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World %s!\n"</span>,argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -g -o hello hello.c</span><br></pre></td></tr></table></figure></p>
<p>这种情况如何启动调试呢？需要设置参数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gdb hello</span><br><span class="line">(gdb)run 编程珠玑</span><br><span class="line">Starting program: /home/shouwang/workspaces/c/hello 编程珠玑</span><br><span class="line">Hello World 编程珠玑!</span><br><span class="line">[Inferior 1 (process 20084) exited normally]</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>只需要run的时候带上参数即可。<br>或者使用set args，然后在用run启动：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb hello</span><br><span class="line">(gdb) set args 编程珠玑</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/hyb/workspaces/c/hello 编程珠玑</span><br><span class="line">Hello World 编程珠玑!</span><br><span class="line">[Inferior 1 (process 20201) exited normally]</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<h4 id="调试core文件"><a href="#调试core文件" class="headerlink" title="调试core文件"></a>调试core文件</h4><p>当程序core dump时，可能会产生core文件，它能够很大程序帮助我们定位问题。但前提是系统没有限制core文件的产生。可以使用命令limit -c查看：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ulimit -c</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p>
<p>如果结果是0，那么恭喜你，即便程序core dump了也不会有core文件留下。我们需要让core文件能够产生：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ulimit -c unlimied  #表示不限制core文件大小</span><br><span class="line">ulimit -c 10        #设置最大大小，单位为块，一块默认为512字节</span><br></pre></td></tr></table></figure></p>
<p>上面两种方式可选其一。第一种无限制，第二种指定最大产生的大小。<br>调试core文件也很简单：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb 程序文件名 core文件名</span><br></pre></td></tr></table></figure></p>
<p>具体可参看《<a href="https://www.yanbinghu.com/2018/09/26/61877.html">linux常用命令-开发调试篇</a>》gdb部分。</p>
<h2 id="调试已运行程序"><a href="#调试已运行程序" class="headerlink" title="调试已运行程序"></a>调试已运行程序</h2><p>如果程序已经运行了怎么办呢？<br>首先使用ps命令找到进程id：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef|grep 进程名</span><br></pre></td></tr></table></figure></p>
<h4 id="attach方式"><a href="#attach方式" class="headerlink" title="attach方式"></a>attach方式</h4><p>假设获取到进程id为20829，则可用下面的方式调试进程：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gdb</span><br><span class="line">(gdb) attach 20829</span><br></pre></td></tr></table></figure></p>
<p>接下来就可以继续你的调试啦。</p>
<p>可能会有下面的错误提示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Could not attach to process.  If your uid matches the uid of the target</span><br><span class="line">process, check the setting of /proc/sys/kernel/yama/ptrace_scope, or try</span><br><span class="line">again as the root user.  For more details, see /etc/sysctl.d/10-ptrace.conf</span><br><span class="line">ptrace: Operation not permitted.</span><br></pre></td></tr></table></figure></p>
<p>解决方法，切换到root用户：<br>将/etc/sysctl.d/10-ptrace.conf中的<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kernel.yama.ptrace_scope = 1</span><br></pre></td></tr></table></figure></p>
<p>修改为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kernel.yama.ptrace_scope = 0</span><br></pre></td></tr></table></figure></p>
<h4 id="直接调试相关id进程"><a href="#直接调试相关id进程" class="headerlink" title="直接调试相关id进程"></a>直接调试相关id进程</h4><p>还可以是用这样的方式gdb program pid，例如:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb hello 20829</span><br></pre></td></tr></table></figure></p>
<p>或者：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb hello --pid 20829</span><br></pre></td></tr></table></figure></p>
<h4 id="已运行程序没有调试信息"><a href="#已运行程序没有调试信息" class="headerlink" title="已运行程序没有调试信息"></a>已运行程序没有调试信息</h4><p>为了节省磁盘空间，已经运行的程序通常没有调试信息。但如果又不能停止当前程序重新启动调试，那怎么办呢？还有办法，那就是同样的代码，再编译出一个带调试信息的版本。然后使用和前面提到的方式操作。对于attach方式，在attach之前，使用file命令即可：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gdb</span><br><span class="line">(gdb) file hello</span><br><span class="line">Reading symbols from hello...done.</span><br><span class="line">(gdb)attach 20829</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了两种类型的GDB启动调试方式，分别是调试未运行的程序和已经运行的程序。对于什么样的程序能够进行调试也进行了简单说明。</p>
<p>欢迎留言补充。</p>
]]></content>
      <categories>
        <category>gdb</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>斐波那契数列求解-重新看递归</title>
    <url>/2019/01/07/16863.html</url>
    <content><![CDATA[<p><head><meta name="generator" content="Hexo 3.9.0">
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
<link rel="stylesheet" href="/css/prism-atom-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>假如面试官让你编写求斐波那契数列的代码时，是不是心中暗喜?不就是递归么，早就会了。如果真这么想，那就危险了。<br><a id="more"></a></p>
<h2 id="递归求斐波那契数列"><a href="#递归求斐波那契数列" class="headerlink" title="递归求斐波那契数列"></a>递归求斐波那契数列</h2><p>递归，在数学与计算机科学中，是指在函数的定义中使用函数自身的方法。<br>斐波那契数列的计算表达式很简单：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F(n) = n; n = 0,1</span><br><span class="line">F(n) = F(n-1) + F(n-2),n &gt;= 2;</span><br></pre></td></tr></table></figure></p>
<p>因此，我们能很快根据表达式写出递归版的代码：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*fibo.c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*求斐波那契数列递归版*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">fibo</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> fibo(n<span class="number">-1</span>) + fibo(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> &gt;= argc)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"usage:./fibo num\n"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>  n = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>  fiboNum = fibo(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the %lu result is %lu\n"</span>,n,fiboNum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关键代码为3~9行。简洁明了，一气呵成。<br>编译：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -o fibo fibo.c</span><br></pre></td></tr></table></figure></p>
<p>运行计算第5个斐波那契数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ time ./fibo 5</span><br><span class="line">the 5 result is 5</span><br><span class="line"></span><br><span class="line">real    0m0.001s</span><br><span class="line">user    0m0.001s</span><br><span class="line">sys    0m0.000s</span><br></pre></td></tr></table></figure></p>
<p>看起来并没有什么不妥，运行时间也很短。<br>继续计算第50个斐波那契数列：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ time ./fibo 50</span><br><span class="line">the 50 result is 12586269025</span><br><span class="line"></span><br><span class="line">real    1m41.655s</span><br><span class="line">user    1m41.524s</span><br><span class="line">sys    0m0.076s</span><br></pre></td></tr></table></figure></p>
<p>计算第50个斐波那契数的时候，竟然将近两多钟！</p>
<h2 id="递归分析"><a href="#递归分析" class="headerlink" title="递归分析"></a>递归分析</h2><p>为什么计算第50个的时候竟然需要1分多钟。我们仔细分析我们的递归算法，就会发现问题，当我们计算fibo(5)的时候，是下面这样的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                         |--F(1)</span><br><span class="line">                  |--F(2)|</span><br><span class="line">           |--F(3)|      |--F(0)</span><br><span class="line">           |      |</span><br><span class="line">    |--F(4)|      |--F(1)</span><br><span class="line">    |      |      </span><br><span class="line">    |      |      |--F(1)</span><br><span class="line">    |      |--F(2)|</span><br><span class="line">    |             |--F(0)</span><br><span class="line">F(5)|             </span><br><span class="line">    |             |--F(1)</span><br><span class="line">    |      |--F(2)|</span><br><span class="line">    |      |      |--F(0)</span><br><span class="line">    |--F(3)|</span><br><span class="line">           |</span><br><span class="line">           |--F(1)</span><br></pre></td></tr></table></figure></p>
<p>为了计算fibo(5)，需要计算fibo(3)，fibo(4)；而为了计算fibo(4)，需要计算fibo(2)，fibo(3)……最终为了得到fibo(5)的结果，fibo(0)被计算了3次，fibo(1)被计算了5次，fibo(2)被计算了2次。可以看到，它的计算次数几乎是指数级的！</p>
<p>因此，虽然递归算法简洁，但是在这个问题中，它的时间复杂度却是难以接受的。除此之外，递归函数调用的越来越深，它们在不断入栈却迟迟不出栈，空间需求越来越大，虽然访问速度高，但大小是有限的，<strong>最终可能导致栈溢出</strong>。<br>在linux中，我们可以通过下面的命令查看栈空间的软限制：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ulimit -s</span><br><span class="line">8192</span><br></pre></td></tr></table></figure></p>
<p>可以看到，默认栈空间大小只有8M。一般来说，8M的栈空间对于一般程序完全足够。如果8M的栈空间不够使用，那么就需要重新审视你的代码设计了。</p>
<h2 id="递归改进版"><a href="#递归改进版" class="headerlink" title="递归改进版"></a>递归改进版</h2><p>既然我们知道最初版本的递归存在大量的重复计算，那么我们完全可以考虑将已经计算的值保存起来，从而<strong>避免重复计算</strong>，该版本代码实现如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*fibo3.c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*求斐波那契数列，避免重复计算版本*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">fiboProcess</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> *<span class="built_in">array</span>,<span class="keyword">unsigned</span> <span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*递归保存值*/</span></span><br><span class="line">        <span class="built_in">array</span>[n] = fiboProcess(<span class="built_in">array</span>,n<span class="number">-1</span>) + <span class="built_in">array</span>[n<span class="number">-2</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">array</span>[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span>  <span class="title">fibo</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span>  n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*申请数组用于保存已经计算过的内容*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *<span class="built_in">array</span> = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">calloc</span>(n+<span class="number">1</span>,<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == <span class="built_in">array</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">array</span>[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    ret = fiboProcess(<span class="built_in">array</span>,n);</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">array</span>);</span><br><span class="line">    <span class="built_in">array</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**main函数部分与fibo.c相同，这里省略*/</span></span><br></pre></td></tr></table></figure></p>
<p>效率如何呢？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o fibo0 fibo3.c</span><br><span class="line">$ time ./fibo0 50</span><br><span class="line">the 50 result is 12586269025</span><br><span class="line"></span><br><span class="line">real    0m0.002s</span><br><span class="line">user    0m0.002s</span><br><span class="line">sys    0m0.001s</span><br></pre></td></tr></table></figure></p>
<p>可见其效率还是不错的，时间复杂度为O(n)。但是特别注意的是，这种改进版的递归，虽然避免了重复计算，但是调用链仍然比较长。</p>
<h2 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h2><p>既然递归法不够优雅，我们换一种方法。如果不用计算机计算，让你去算第n个斐波那契数，你会怎么做呢？我想最简单直接的方法应该是：知道第一个和第二个后，计算第三个；知道第二个和第三个后，计算第四个，以此类推。最终可以得到我们需要的结果。这种思路，没有冗余的计算。基于这个思路，我们的C语言实现如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*fibo1.c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*求斐波那契数列迭代版*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span>  <span class="title">fibo</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span>  n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>  preVal = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>  prePreVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>  loop = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>  returnVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(loop &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        returnVal = preVal +prePreVal;</span><br><span class="line">        <span class="comment">/*更新记录结果*/</span></span><br><span class="line">        prePreVal = preVal;</span><br><span class="line">        preVal = returnVal;</span><br><span class="line">        loop++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnVal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**main函数部分与fibo.c相同，这里省略*/</span></span><br></pre></td></tr></table></figure></p>
<p>编译并计算第50个斐波那契数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o fibo1 fibo1.c</span><br><span class="line">$ time ./fibo1 50</span><br><span class="line">the 50 result is 12586269025</span><br><span class="line"></span><br><span class="line">real    0m0.002s</span><br><span class="line">user    0m0.001s</span><br><span class="line">sys    0m0.002s</span><br></pre></td></tr></table></figure></p>
<p>可以看到，计算第50个斐波那契数只需要0.002s！时间复杂度为O(n)。</p>
<h2 id="尾递归解法"><a href="#尾递归解法" class="headerlink" title="尾递归解法"></a>尾递归解法</h2><p>同样的思路，但是采用尾递归的方法来计算。要计算第n个斐波那契数，我们可以先计算第一个，第二个，如果未达到n，则继续递归计算，尾递归C语言实现如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*fibo2.c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*求斐波那契数列尾递归版*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">fiboProcess</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> n,<span class="keyword">unsigned</span> <span class="keyword">long</span>  prePreVal,<span class="keyword">unsigned</span> <span class="keyword">long</span>  preVal,<span class="keyword">unsigned</span> <span class="keyword">long</span> begin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*如果已经计算到我们需要计算的，则返回*/</span></span><br><span class="line">    <span class="keyword">if</span>(n == begin)</span><br><span class="line">        <span class="keyword">return</span> preVal+prePreVal;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        begin++;</span><br><span class="line">        <span class="keyword">return</span> fiboProcess(n,preVal,prePreVal+preVal,begin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span>  <span class="title">fibo</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span>  n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> fiboProcess(n,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**main函数部分与fibo.c相同，这里省略*/</span></span><br></pre></td></tr></table></figure></p>
<p>效率如何呢？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o fibo2 fibo2.c</span><br><span class="line">$ time ./fibo2 50</span><br><span class="line">the 50 result is 12586269025</span><br><span class="line"></span><br><span class="line">real    0m0.002s</span><br><span class="line">user    0m0.001s</span><br><span class="line">sys    0m0.002s</span><br></pre></td></tr></table></figure></p>
<p>可见，其效率并不逊于迭代法。尾递归在函数返回之前的最后一个操作仍然是递归调用。尾递归的好处是，进入下一个函数之前，已经获得了当前函数的结果，因此不需要保留当前函数的环境，内存占用自然也是比最开始提到的递归要小。时间复杂度为O(n)。</p>
<h2 id="矩阵快速幂解法"><a href="#矩阵快速幂解法" class="headerlink" title="矩阵快速幂解法"></a>矩阵快速幂解法</h2><p>这是一种高效的解法，需要推导，对此不感兴趣的可直接看最终推导结果。下面的式子成立是显而易见的，不多做解释。</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/fibo/fibo0.png" alt></p>
<p>如果a为矩阵，等式同样成立，后面我们会用到它。<br>假设有矩阵2*2矩阵A，满足下面的等式：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/fibo/fibo1.png" alt></p>
<p>可以得到矩阵A：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/fibo/fibo2.png" alt></p>
<p>因此也就可以得到下面的矩阵等式：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/fibo/fibo3.png" alt></p>
<p>再进行变换如下：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/fibo/fibo4.png" alt></p>
<p>以此类推，得到：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/fibo/fibo5.png" alt></p>
<p>实际上f(n)就是矩阵$ A^{n-1} $中的A[0][0],或者是矩阵$ A^{n} $中的A[0][1]。</p>
<p>那么现在的问题就归结为，如何求解$A^n$，其中A为2*2的矩阵。根据我们最开始的公式，很容易就有思路，代码实现如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*fibo3.c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_COL 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ROW 2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> MatrixType;</span><br><span class="line"><span class="comment">/*计算2*2矩阵乘法，这里没有写成通用形式，有兴趣的可以自己实现通用矩阵乘法*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">matrixDot</span><span class="params">(MatrixType A[MAX_ROW][MAX_COL],MatrixType B[MAX_ROW][MAX_COL],MatrixType C[MAX_ROW][MAX_COL])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/*C为返回结果，由于A可能和C相同，因此使用临时矩阵存储*/</span></span><br><span class="line">    MatrixType tempMa[MAX_ROW][MAX_COL] ;</span><br><span class="line">    <span class="built_in">memset</span>(tempMa,<span class="number">0</span>,<span class="keyword">sizeof</span>(tempMa));</span><br><span class="line">    <span class="comment">/*这里简便处理*/</span></span><br><span class="line">    tempMa[<span class="number">0</span>][<span class="number">0</span>] = A[<span class="number">0</span>][<span class="number">0</span>] * B[<span class="number">0</span>][<span class="number">0</span>] + A[<span class="number">0</span>][<span class="number">1</span>] * B [<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    tempMa[<span class="number">0</span>][<span class="number">1</span>] = A[<span class="number">0</span>][<span class="number">0</span>] * B[<span class="number">0</span>][<span class="number">1</span>] + A[<span class="number">0</span>][<span class="number">1</span>] * B [<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    tempMa[<span class="number">1</span>][<span class="number">0</span>] = A[<span class="number">1</span>][<span class="number">0</span>] * B[<span class="number">0</span>][<span class="number">0</span>] + A[<span class="number">1</span>][<span class="number">1</span>] * B [<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    tempMa[<span class="number">1</span>][<span class="number">1</span>] = A[<span class="number">1</span>][<span class="number">0</span>] * B[<span class="number">0</span>][<span class="number">1</span>] + A[<span class="number">1</span>][<span class="number">1</span>] * B [<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(C,tempMa,<span class="keyword">sizeof</span>(tempMa));</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">MatrixType <span class="title">fibo</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    MatrixType result[][MAX_COL] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    MatrixType A[][<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*判断最后一位是否为1，即可知奇偶*/</span></span><br><span class="line">        <span class="keyword">if</span> (n&amp;<span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            matrixDot(result,A,result);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        n /= <span class="number">2</span>;</span><br><span class="line">        matrixDot(A,A,A);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**main函数部分与fibo.c相同，这里省略*/</span></span><br></pre></td></tr></table></figure></p>
<p>该算法的关键部分在于对$A^n$的计算,它利用了我们开始提到的等式，对奇数和偶数分别处理。假设n为9，初始矩阵为INIT则计算过程如下：</p>
<ul>
<li>9为奇数，则计算INIT*A，随后A变为A*A，n变为9/2，即为4</li>
<li>4为偶数，则结果仍为INIT*A，随后A变为$(A^2)*(A^2)=A^4$，n变为4/2，即2</li>
<li>2为偶数，则结果仍未INIT*A,随后变A变为 $(A^4)*(A^4)=A^8$,n变为2/2，即1</li>
<li>1为奇数，则结果为INIT*(A^8)*A</li>
</ul>
<p>可以看到，计算次数类似与二分查找次数，其时间复杂度为O(logn)。<br>运行试试看：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o fibo3 fibo3.c</span><br><span class="line">$ time ./fibo3 50</span><br><span class="line">the 50 result is 12586269025</span><br><span class="line"></span><br><span class="line">real    0m0.002s</span><br><span class="line">user    0m0.002s</span><br><span class="line">sys    0m0.000s</span><br></pre></td></tr></table></figure></p>
<h2 id="通项公式解法"><a href="#通项公式解法" class="headerlink" title="通项公式解法"></a>通项公式解法</h2><p>斐波那契数列的通项公式为：</p>
<p><img src="https://github.com/yanbinghu/BlogImages/raw/master/articles/fibo/fibo6.png" alt></p>
<p>关于通项公式的求解，可以当成一道高考数列大题，有兴趣的可以尝试一下（提示：两次构造等比数列）。C语言代码实现如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*fibo4.c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">fibo</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;=<span class="number">1</span> )</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>)((<span class="built_in">pow</span>((<span class="number">1</span>+<span class="built_in">sqrt</span>(<span class="number">5</span>))/<span class="number">2</span>,n)-<span class="built_in">pow</span>((<span class="number">1</span>-<span class="built_in">sqrt</span>(<span class="number">5</span>))/<span class="number">2</span>,n))/<span class="built_in">sqrt</span>(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**main函数部分与fibo.c相同，这里省略*/</span></span><br></pre></td></tr></table></figure></p>
<p>来看一下效率：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o fibo4 fibo4.c -lm</span><br><span class="line">$ time ./fibo4</span><br><span class="line">the 50 result is 12586269025</span><br><span class="line"></span><br><span class="line">real    0m0.002s</span><br><span class="line">user    0m0.002s</span><br><span class="line">sys    0m0.000s</span><br></pre></td></tr></table></figure></p>
<p>计算第50个，速度还不错。</p>
<h2 id="列表法"><a href="#列表法" class="headerlink" title="列表法"></a>列表法</h2><p>如果需要求解的斐波那契数列的第n个在有限范围内，那么完全可以将已知的斐波那契数列存储起来，在需要的时候读取即可，时间复杂度可以为O(1)。</p>
<h2 id="斐波那契数列应用"><a href="#斐波那契数列应用" class="headerlink" title="斐波那契数列应用"></a>斐波那契数列应用</h2><p>关于斐波那契数列在实际中很常见，数学上也有很多奇特的性质，有兴趣的可在百科中查看。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下递归的优缺点：<br>优点：</p>
<ul>
<li>实现简单</li>
<li>可读性好</li>
</ul>
<p>缺点：</p>
<ul>
<li>递归调用，占用空间大</li>
<li>递归太深，易发生栈溢出</li>
<li>可能存在重复计算</li>
</ul>
<p>可以看到，对于求斐波那契数列的问题，使用一般的递归并不是一种很好的解法。<br>所以，当你使用递归方式实现一个功能之前，<strong>考虑一下使用递归带来的好处是否抵得上它的代价。</strong></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言函数指针</title>
    <url>/2019/01/03/3593.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>函数指针是什么？如何使用函数指针？函数指针到底有什么大用？本文将一一介绍。<br><a id="more"></a></p>
<h2 id="如何理解函数指针"><a href="#如何理解函数指针" class="headerlink" title="如何理解函数指针"></a>如何理解函数指针</h2><p>如果有int *类型变量，它存储的是int类型变量的地址；那么对于函数指针来说，它存储的就是函数的地址。函数也是有地址的，函数实际上由载入内存的一些指令组成，而指向函数的指针存储了函数指令的起始地址。如此看来，函数指针并没有什么特别的。我们可以查看程序中函数的地址：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"this is test function"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -o testFun testFun.c</span><br></pre></td></tr></table></figure></p>
<p>查看test函数相对地址(并非实际运行时的地址)：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nm testFun |grep test  #查看test函数的符号表信息</span><br><span class="line">0000000000400526 T test</span><br></pre></td></tr></table></figure></p>
<h2 id="如何声明函数指针"><a href="#如何声明函数指针" class="headerlink" title="如何声明函数指针"></a>如何声明函数指针</h2><p>声明普通类型指针时，需要指明指针所指向的数据类型，而声明函数指针时，也就要指明指针所指向的函数类型，即需要指明函数的返回类型和形参类型。例如对于下面的函数原型：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>它是一个返回值为int类型，参数是两个int类型的函数，那么如何声明该类型函数的指针呢？很简单，将函数名替换成(*pf)形式即可，即我们把sum替换成(*fp)即可，fp为函数指针名，结果如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> （*fp）(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure></p>
<p>这样就声明了和sum函数类型相同的函数指针fp。这里说明两点，第一，*和fp为一体，说明了fp为指针类型，第二，*fp需要用括号括起来，否则就会变成下面的情况：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">fp</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>这种情况下，意思就大相径庭了，它声明了一个参数为两个int类型，返回值为int类型的指针的函数，而不再是一个函数指针了。</p>
<p>在经常使用函数指针之后，我们很快就会发现，每次声明函数指针都要带上长长的形参和返回值，非常不便。这个时候，我们应该想到使用typedef，即为某类型的函数指针起一个别名，使用起来就方便许多了。例如，对于前面提到的函数可以使用下面的方式声明：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*myFun)</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;<span class="comment">//为该函数指针类型起一个新的名字</span></span><br><span class="line">myFun f1;       <span class="comment">//声明myFun类型的函数指针f1</span></span><br></pre></td></tr></table></figure></p>
<p>上面的myFun就是一个函数指针类型，在其他地方就可以很方便地用来声明变量了。typedef的使用不在本文的讨论范围，但是特别强调一句，<strong>typedef中声明的类型在变量名的位置出现</strong>，理解了这一句，也就很容易使用typedef了。因而下面的方式是错误的：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">myFun</span> <span class="params">(<span class="keyword">int</span>)</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;   <span class="comment">//错误</span></span><br><span class="line"><span class="keyword">typedef</span> (<span class="keyword">int</span>)(<span class="keyword">int</span>,<span class="keyword">int</span>)  *myFun;   <span class="comment">//错误</span></span><br></pre></td></tr></table></figure></p>
<h2 id="为函数指针赋值"><a href="#为函数指针赋值" class="headerlink" title="为函数指针赋值"></a>为函数指针赋值</h2><p>赋值也很简单，既然是指针，将对应指针类型赋给它既可。例如：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*do something*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>(*fp)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fp f1 = test; <span class="comment">//表达式1</span></span><br><span class="line">    fp f2 = &amp;test;<span class="comment">//表达式2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,f1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,f2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里，声明了返回类型为int，接受两个int类型参数的函数指针f1和f2，分别给它们进行了赋值。表达式1和表达式2在作用上并没有什么区别。因为函数名在被使用时总是由编译器把它转换为函数指针，而前面加上&amp;不过显式的说明了这一点罢了。</p>
<h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><p>调用也很容易，把它看成一个普通的函数名即可：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*do something*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d\n"</span>,a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>(*fp)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fp f = test; </span><br><span class="line">    f(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//表达式1</span></span><br><span class="line">    (*f)(<span class="number">3</span>,<span class="number">4</span>);<span class="comment">//表达式2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在函数指针后面加括号，并传入参数即可调用，其中表达式1和表达式2似乎都可以成功调用，但是哪个是正确的呢？ANSI C认为这两种形式等价。</p>
<h4 id="函数指针有何用"><a href="#函数指针有何用" class="headerlink" title="函数指针有何用"></a>函数指针有何用</h4><p>函数指针的应用场景比较多，以库函数qsort排序函数为例，它的原型如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">void</span> *base,<span class="keyword">size_t</span> nmemb,<span class="keyword">size_t</span> size , <span class="keyword">int</span>(*compar)(<span class="keyword">const</span> <span class="keyword">void</span> *,<span class="keyword">const</span> <span class="keyword">void</span> *))</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>看起来很复杂对不对？拆开来看如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">void</span> *base, <span class="keyword">size_t</span> nmemb, <span class="keyword">size_t</span> size, )</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>拿掉第四个参数后，很容易理解，它是一个无返回值的函数，接受4个参数，第一个是void*类型，代表原始数组，第二个是size_t类型，代表数据数量，第三个是size_t类型，代表单个数据占用空间大小，而第四个参数是函数指针。这第四个参数，即函数指针指向的是什么类型呢？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int(*compar)(const void *,const void *)</span><br></pre></td></tr></table></figure></p>
<p>很显然，这是一个接受两个const void*类型入参，返回值为int的函数指针。<br>到这里也就很清楚了。这个参数告诉qsort，应该使用哪个函数来比较元素，即只要我们告诉qsort比较大小的规则，它就可以帮我们对任意数据类型的数组进行排序。</p>
<p>在这里函数指针作为了参数，而他同样可以作为返回值，创建数组，作为结构体成员变量等等，它们的具体应用我们在后面的文章中会介绍，本文不作展开。本文只介绍一个简单实例。</p>
<h2 id="实例介绍"><a href="#实例介绍" class="headerlink" title="实例介绍"></a>实例介绍</h2><p>我们通过一个实例来看函数指针怎么使用。假设有一学生信息，需要按照学生成绩进行排序，该如何处理呢？<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STU_NAME_LEN 16</span></span><br><span class="line"><span class="comment">/*学生信息*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student_tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[STU_NAME_LEN];  <span class="comment">//学生姓名</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> id;          <span class="comment">//学生学号</span></span><br><span class="line">    <span class="keyword">int</span> score;                <span class="comment">//学生成绩</span></span><br><span class="line">&#125;<span class="keyword">student_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">studentCompare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *stu1,<span class="keyword">const</span> <span class="keyword">void</span> *stu2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="comment">/*强转成需要比较的数据结构*/</span></span><br><span class="line">    <span class="keyword">student_t</span> *value1 = (<span class="keyword">student_t</span>*)stu1;</span><br><span class="line">    <span class="keyword">student_t</span> *value2 = (<span class="keyword">student_t</span>*)stu2;</span><br><span class="line">    <span class="keyword">return</span> value1-&gt;score-value2-&gt;score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*创建三个学生信息*/</span></span><br><span class="line">    <span class="keyword">student_t</span> stu1 = &#123;<span class="string">"one"</span>,<span class="number">1</span>,<span class="number">99</span>&#125;;</span><br><span class="line">    <span class="keyword">student_t</span> stu2 = &#123;<span class="string">"two"</span>,<span class="number">2</span>,<span class="number">77</span>&#125;;</span><br><span class="line">    <span class="keyword">student_t</span> stu3 = &#123;<span class="string">"three"</span>,<span class="number">3</span>,<span class="number">88</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">student_t</span> stu[] = &#123;stu1,stu2,stu3&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*排序，将studentCompare作为参数传入qsort*/</span></span><br><span class="line">    qsort((<span class="keyword">void</span>*)stu,<span class="number">3</span>,<span class="keyword">sizeof</span>(<span class="keyword">student_t</span>),studentCompare);</span><br><span class="line">    <span class="keyword">int</span> loop = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**遍历输出*/</span></span><br><span class="line">    <span class="keyword">for</span>(loop = <span class="number">0</span>; loop &lt; <span class="number">3</span>;loop++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"name:%s,id:%u,score:%d\n"</span>,stu[loop].name,stu[loop].id,stu[loop].score);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们创建了一个学生信息结构，结构成员包括名字，学号和成绩。main函数中创建了一个包含三个学生信息的数组，并使用qsort函数对数组按照学生成绩进行排序。qsort函数第四个参数是函数指针，因此我们需要传入一个函数指针，并且这个函数指针的入参是cont void *类型，返回值为int。我们通过前面的学习知道了函数名本身就是指针，因此只需要将我们自己实现的studentCompare作为参数传入即可。</p>
<p>最终运行结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name:two,id:2,score:77</span><br><span class="line">name:three,id:3,score:88</span><br><span class="line">name:one,id:1,score:99</span><br></pre></td></tr></table></figure></p>
<p>可以看到，最终学生信息按照分数从低到高输出。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了函数指针的声明和简单使用。更多使用将在后面的文章介绍，本文总结如下：</p>
<ul>
<li>函数指针与其他指针类型无本质差异，不过它指向的是函数的地址罢了。</li>
<li>声明函数指针需要指明函数的返回类型和形参类型。</li>
<li>函数名在被使用时总是由编译器把它转换为函数指针。</li>
<li>要想声明函数指针，只需写出函数原型，然后将函数名用(*fp)代替即可。这里fp是声明的函数指针变量。</li>
<li>typedef中声明的类型在变量名的位置出现。</li>
</ul>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之旅-彻底理清重载函数匹配</title>
    <url>/2019/01/01/6209.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面我们讲到了《<a href="https://www.yanbinghu.com/2018/11/27/34641.html">函数重载</a>》，有了函数重载之后，就需要确定某次调用需要选用哪个函数。这个过程可以称之为函数匹配或者重载确定。大多数情况下，我们都很容易能够确定某次调用需要选用哪个函数，但事实上不尽然。但通过本文将彻底理清重载函数匹配<br><a id="more"></a></p>
<h2 id="匹配过程"><a href="#匹配过程" class="headerlink" title="匹配过程"></a>匹配过程</h2><p>为便于说明，将函数匹配分为三个阶段，确定候选函数，确定可行函数，确定最佳匹配函数。</p>
<h4 id="确定候选函数"><a href="#确定候选函数" class="headerlink" title="确定候选函数"></a>确定候选函数</h4><p>候选函数也就是<strong>和被调用的函数同名，并且其声明在调用点可见</strong>。举个简单的例子。<br>假设有两个文件，1.cpp和2.cpp，内容分别如下：<br>1.cpp：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//函数1</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a,short b)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">"func0"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>2.cpp：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> <span class="comment">//函数2</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">"func1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//函数3</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt; <span class="string">"func2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//函数4</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">"func3"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     f(<span class="number">3</span>,<span class="number">4.5</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里，候选函数其实只有两个，其中第一个函数在其调用点不可见，而第四个函数和被调用的函数不同名，因此这两个都不是候选函数。</p>
<h4 id="确定可行函数"><a href="#确定可行函数" class="headerlink" title="确定可行函数"></a>确定可行函数</h4><p> 可行函数指的是本次调用传入的实参能够被候选函数使用。它要满足两个条件， <strong>一是形参数量和实参数量相同，二是每个实参的类型和对应形参类型相同或者能够转换成形参的类型。</strong></p>
<p>还是前面的例子，实参的个数和类型与第二个函数完全匹配，而在经过算术转换之后，也能够与第三个函数匹配。</p>
<h4 id="确定最佳匹配函数"><a href="#确定最佳匹配函数" class="headerlink" title="确定最佳匹配函数"></a>确定最佳匹配函数</h4><p>最佳匹配的函数是最终调用的。最佳匹配最基本的思想是认为，<strong>实参类型越接近，它们就越匹配</strong>。还是前面的例子，实参要与第三个函数匹配，需要进行算术转换，而与第二个函数完全匹配，因此第二个函数是最佳匹配函数。最终的运行结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func1</span><br></pre></td></tr></table></figure></p>
<h2 id="最佳匹配原则"><a href="#最佳匹配原则" class="headerlink" title="最佳匹配原则"></a>最佳匹配原则</h2><p>一般来说，精确匹配肯定比需要类型转换的匹配要更好，但是当形参有多个，并且无法完全精确匹配的时候，要确定最佳匹配函数就有点困难了。<br>但是有下面的原则：</p>
<ul>
<li>函数的每个实参的匹配都不能比其他可行函数更差</li>
<li>函数至少有一个实参的匹配要比其他可行函数更好</li>
</ul>
<p>那么问题又来了，什么是更好，什么又是更差呢？编译器将实参类型到形参类型的转换划分了等级：</p>
<ul>
<li>1.精确匹配，包括实参类型和形参类型相同，实参从数组或函数转换成对应的指针类型，向实参添加顶层const或从实参删除顶层const</li>
<li>2.通过const转换实现的匹配</li>
<li>3.通过类型提升实现的匹配</li>
<li>4.通过算数类型转换实现的匹配</li>
<li>5.通过类类型转换实现的匹配</li>
</ul>
<p>等级越前，匹配也就越好。接下来对上面的内容做一些解释。</p>
<h4 id="精确匹配"><a href="#精确匹配" class="headerlink" title="精确匹配"></a>精确匹配</h4><p>精确匹配比较容易理解。关于顶层const问题，可以参考《<a href="https://www.yanbinghu.com/2018/11/27/34641.html">函数重载</a>》</p>
<h4 id="通过const转换实现的匹配"><a href="#通过const转换实现的匹配" class="headerlink" title="通过const转换实现的匹配"></a>通过const转换实现的匹配</h4><p>所谓通过const转换实现的匹配，指的是通过加const限定词，能够与可行函数精确匹配。例如：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//函数1</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int f(string &amp;a)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;"call function 1"&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="comment">//函数2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"call function 2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> test = <span class="string">"test"</span>;</span><br><span class="line">    f(test);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里，test可以通过const转换，从而匹配函数2，将能够找到最佳匹配函数2（当前情况它也只有一个可选了）。<br>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call function 2</span><br></pre></td></tr></table></figure></p>
<p>如果把函数1的注释去掉再运行，就会发现，虽然第一个调用既能匹配函数1，也能匹配函数2，但是由于匹配函数2的时候，需要const转换，因此比精确匹配要差，最终，它会调用函数1。<br>去掉函数1的注释后，运行结果如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">call function <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h4 id="通过类型提升实现的匹配"><a href="#通过类型提升实现的匹配" class="headerlink" title="通过类型提升实现的匹配"></a>通过类型提升实现的匹配</h4><p>关于类型提升，这里不多做介绍。简单说明类型提升规则：</p>
<ul>
<li>float将提升到double</li>
<li>char、short和相应的signed、unsigned类型将提升到int</li>
</ul>
<p>我们来看一个示例：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//函数1</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int f(short a)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;"call function 1"&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="comment">//函数2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"call function 2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    short a = <span class="number">2</span>;</span><br><span class="line">    f(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样地，我们暂时把函数1注释掉。由于a是short类型，但是通过类型提升，可以转换为int，因为它也能调用函数2。运行结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call function 2</span><br></pre></td></tr></table></figure></p>
<p>但去掉函数1注释后，由于精确匹配优于通过类型提升的匹配，因此将会调用函数1，运行结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call function 1</span><br></pre></td></tr></table></figure></p>
<h4 id="通过算术类型转换实现的匹配"><a href="#通过算术类型转换实现的匹配" class="headerlink" title="通过算术类型转换实现的匹配"></a>通过算术类型转换实现的匹配</h4><p>short int和float，double等之间的转换，都是算术类型之间的转换。我们仍然来看一个例子：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//函数1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"call function 1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"call function 2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    short a = <span class="number">2</span>;</span><br><span class="line">    f(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里，short类型的a既可以通过类型提升转换为int，也可以通过算术类型转换成为double。这个时候，哪个才是最佳匹配呢？我们看运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call function 1</span><br></pre></td></tr></table></figure></p>
<p>对于这个结果，并不意外，因为前面我们已经说到，通过类型提升的转换是优于算术转换的，因而函数1是它的最佳匹配函数。</p>
<h4 id="通过类类型转换实现的匹配"><a href="#通过类类型转换实现的匹配" class="headerlink" title="通过类类型转换实现的匹配"></a>通过类类型转换实现的匹配</h4><p>这里不多做介绍。我们也很容易理解。诸如父类和子类之间的转换都是如此。</p>
<h2 id="二义性示例"><a href="#二义性示例" class="headerlink" title="二义性示例"></a>二义性示例</h2><p>前面基本能够找到最佳匹配，我们来看一个有多个可行函数，最后却没有最佳匹配的情况。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//函数1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"function 1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"function 2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数1和函数2都是可行函数，但它们都没有在任意一个参数上比对方更好，因此将会产生二义性，编译时将会报错：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: call of overloaded ‘f(int, int)’ is ambiguous</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>调用重载函数时，应当避免强制类型转换。</li>
<li>设计重载函数时应避免可能产生的二义性。</li>
<li>如果无法找到可行函数，编译器将报错。</li>
<li>设计重载函数的时候，希望避免需要用到上面的知识，而在定位问题时能够利用上面的知识很快定位问题。</li>
</ul>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>从40亿个整数中找到不存在的一个</title>
    <url>/2018/12/25/10757.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>给定一个最多包含40亿个随机排列的32位的顺序整数的顺序文件，找出一个不在文件中的32位整数。（在文件中至少确实一个这样的数-为什么？）。在具有足够内存的情况下，如何解决该问题？如果有几个外部的“临时”文件可用，但是仅有几百字节的内存，又该如何解决该问题？<br><a id="more"></a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这仍然是《编程珠玑》中的一个问题。前面我们曾经提到过《<a href="https://www.yanbinghu.com/2018/12/08/34927.html">位图法</a>》，我们使用位图法解决了这个问题。32位整型最多有4294967296个整数，而很显然40亿个数中必然会至少缺一个。我们同样也可以尝试使用位图法解决该问题，使用536 870 912个字节，约512M内存存储这40亿整数，存在该整数的位置1，最后遍历比特位，输出第一个比特位为0的位置即可。那如果仅借助几个“临时”文件，使用几百字节的内存的情况下该如何处理呢？</p>
<p>能否使用二分搜索呢？这40亿个整数是随机排列的，因此普通的二分搜索不能找到那个不存在的数。但是我们可以基于二分搜索的思想。</p>
<p>一个整数有32位，我们按照每个比特位是0还是1，将要查找的数据范围一分为二。从最高比特位开始：</p>
<ul>
<li>将最高比特位为0的放在一堆，为1的放在另外一堆</li>
<li>如果一样多，则随意选择一堆，例如选0，则该位为0</li>
<li>如果不一样多，选择少的一堆继续，如1更少，则该位为1</li>
</ul>
<p>这里需要做一些解释：</p>
<ul>
<li>由于2^32个整数中，每一个比特位是1还是0的个数是相同的。如果在这40亿个整数中，某比特位为1和0的个数是相同的，则说明两边都有不存在的数。因此选择任意一堆即可。</li>
<li>如果比特位1的整数比0的整数多，则说明，比特位为0的一堆数中，肯定缺少了一些数。而比特位为1的一堆数中，可能缺少一些数。因此，我们选择少的，也就是比特位为0的那一堆数。</li>
<li>每一次选择，都记录选择的是0还是1，最多32次选择后，便可以至少找到一个整数，不存在这40亿数中。</li>
</ul>
<h2 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h2><p>由于32位的整型数据量太多，不便说明，我们用一个<strong>4比特</strong>的数据对上面的思路再做一个说明。4比特最多有16个数。<br>假设有以下源数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 5 2 6 7 -1 -4 -6 -3 1 -5</span><br></pre></td></tr></table></figure>
<p>对应二进制形式如下(负数在内存中以补码形式存储)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0011 0101 0010 0110 0111 1111 1100 1010 1101 0001 1011</span><br></pre></td></tr></table></figure>
<p>1.处理第1比特位被分为两部分数据，分别为：</p>
<ul>
<li>比特位为0的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0011 0101 0010 0110 0111 0001</span><br></pre></td></tr></table></figure>
<ul>
<li>比特位为1的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1111 1100 1010 1101 1011</span><br></pre></td></tr></table></figure>
<p>可以看到，第一比特位为1的数为5个，比比特位为0的数要少，因此选择比特位为1的数，继续处理。且第一比特位，获得<strong>1</strong>.</p>
<p>3.处理第2比特位仍然分为两部分数据，分别为：</p>
<ul>
<li>比特位为0的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1010 1011</span><br></pre></td></tr></table></figure>
<ul>
<li>比特位为1的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1111 1100  1101</span><br></pre></td></tr></table></figure>
<p>可以看到，第一比特位为1的数为3个，比比特位为0的数要多，因此选择比特位为0的数，继续处理。且第二比特位，获得<strong>0</strong>。</p>
<p>2.处理第3比特位仍然被分为两部分数据，分别为：</p>
<ul>
<li>比特位为0的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">无</span><br></pre></td></tr></table></figure>
<ul>
<li>比特位为1的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1010 1011</span><br></pre></td></tr></table></figure>
<p>明显看到第三比特位为0的数没有，因此选择比特位0，获得<strong>0</strong>。至此，已经没有必要继续查找了。</p>
<p>我们最终得到了前三个比特位100，因此不存在于这些数中至少有1000,1001，即-8,-7。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>C语言实现：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//binarySearch.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_STR 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOURCE_FILE <span class="meta-string">"source.txt"</span> <span class="comment">//最原始文件，需要保留</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRC_FILE <span class="meta-string">"src.txt"</span>       <span class="comment">//需要分类的文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT_1_FILE <span class="meta-string">"bit1.txt"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT_0_FILE <span class="meta-string">"bit0.txt"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_BIT_NUM  32</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">FILE *src   源数据文件指针</span></span><br><span class="line"><span class="comment">FILE *fpBit1 存储要处理的比特位为1的数据</span></span><br><span class="line"><span class="comment">FILE *fpBit0 存储要处理的比特位为0的数据</span></span><br><span class="line"><span class="comment">int bit     要处理的比特位</span></span><br><span class="line"><span class="comment">返回值</span></span><br><span class="line"><span class="comment">0：选择比特位为0的数据继续处理</span></span><br><span class="line"><span class="comment">1：选择比特位为1的数据继续处理</span></span><br><span class="line"><span class="comment">-1：出错</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">splitByBit</span><span class="params">(FILE *src,FILE *fpBit1,FILE *fpBit0,<span class="keyword">int</span> bit,<span class="keyword">int</span> *nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*入参检查*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == src || <span class="literal">NULL</span> == fpBit1 || <span class="literal">NULL</span> == fpBit0 || <span class="literal">NULL</span> == nums)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"input para is NULL"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*bit位检查*/</span></span><br><span class="line">    <span class="keyword">if</span>(bit &lt; <span class="number">0</span> || bit &gt; INT_BIT_NUM )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"the bit is wrong"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">string</span>[MAX_STR] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> mask = <span class="number">1</span>&lt;&lt; bit;</span><br><span class="line">    <span class="keyword">int</span> bit0num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bit1num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//printf("mask is %x\n",mask);</span></span><br><span class="line">    <span class="comment">/*循环读取源数据*/</span></span><br><span class="line">    <span class="keyword">while</span>(fgets(<span class="built_in">string</span>, MAX_STR, src ) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        num = atoi(<span class="built_in">string</span>);</span><br><span class="line">        <span class="comment">//printf("%d&amp;%d %d\n",num,mask, num&amp;mask);</span></span><br><span class="line">        <span class="comment">/*根据比特位的值，将数据写到不同的位置，注意优先级问题*/</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == (num&amp;mask))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//printf("bit 0 %d\n",num);</span></span><br><span class="line">            <span class="built_in">fprintf</span>(fpBit0, <span class="string">"%d\n"</span>, num);</span><br><span class="line">            bit0num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//printf("bit 1 %d\n",num);</span></span><br><span class="line">            <span class="built_in">fprintf</span>(fpBit1, <span class="string">"%d\n"</span>, num);</span><br><span class="line">            bit1num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf("bit0num:%d,bit1num:%d\n",bit0num,bit1num);</span></span><br><span class="line">    <span class="keyword">if</span>(bit0num &gt; bit1num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*说明比特位为1的数少*/</span></span><br><span class="line">        *nums = bit1num;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *nums = bit0num;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> *关闭所有文件描述符</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">closeAllFile</span><span class="params">(FILE **src,FILE **bit0,FILE **bit1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != src &amp;&amp; <span class="literal">NULL</span> != *src)</span><br><span class="line">    &#123;</span><br><span class="line">        fclose(*src);</span><br><span class="line">        *src = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != bit1 &amp;&amp; <span class="literal">NULL</span> != *bit1)</span><br><span class="line">    &#123;</span><br><span class="line">        fclose(*bit1);</span><br><span class="line">        *bit1 = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != bit0 &amp;&amp; <span class="literal">NULL</span> != *bit0)</span><br><span class="line">    &#123;</span><br><span class="line">        fclose(*bit0);</span><br><span class="line">        *bit0 = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findNum</span><span class="params">(<span class="keyword">int</span> *findNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> loop = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*打开最原始文件*/</span></span><br><span class="line">    FILE *src = fopen(SOURCE_FILE,<span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == src)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"failed to open %s"</span>,SOURCE_FILE);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FILE *bit1 = <span class="literal">NULL</span>;</span><br><span class="line">    FILE *bit0 = <span class="literal">NULL</span>;</span><br><span class="line">       <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bitNums = <span class="number">0</span>; <span class="comment">//得到比特位的数字数量</span></span><br><span class="line">    <span class="keyword">int</span> findBit = <span class="number">0</span>; <span class="comment">//当前得到的比特位</span></span><br><span class="line">    <span class="keyword">for</span>(loop = <span class="number">0</span>; loop &lt; INT_BIT_NUM;loop++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*第一次循环不会打开，保留源文件*/</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == src)</span><br><span class="line">        &#123;</span><br><span class="line">            src = fopen(SRC_FILE,<span class="string">"r"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == src)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**打开失败时，注意关闭所有打开的文件描述符**/</span></span><br><span class="line">        bit1 = fopen(BIT_1_FILE,<span class="string">"w+"</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == bit1)</span><br><span class="line">        &#123;</span><br><span class="line">            closeAllFile(&amp;src,&amp;bit1,&amp;bit0);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"failed to open %s"</span>,BIT_1_FILE);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bit0 = fopen(BIT_0_FILE,<span class="string">"w+"</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == bit0)</span><br><span class="line">        &#123;</span><br><span class="line">            closeAllFile(&amp;src,&amp;bit1,&amp;bit0);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"failed to open %s"</span>,BIT_0_FILE);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        findBit = splitByBit(src,bit1,bit0,loop,&amp;bitNums);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == findBit)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"process error\n"</span>);</span><br><span class="line">            closeAllFile(&amp;src,&amp;bit1,&amp;bit0);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        closeAllFile(&amp;src,&amp;bit1,&amp;bit0);</span><br><span class="line">        <span class="comment">//printf("find bit %d\n",findBit);</span></span><br><span class="line">        <span class="comment">/*将某比特位数量少的文件重命名为新的src.txt，以便进行下一次处理*/</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == findBit)</span><br><span class="line">        &#123;</span><br><span class="line">            rename(BIT_1_FILE,SRC_FILE);</span><br><span class="line">            num |=  (<span class="number">1</span> &lt;&lt; loop);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"mv bit1 file to src file\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"mv bit0 file to src file\n"</span>);</span><br><span class="line">            rename(BIT_0_FILE,SRC_FILE);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*如果某个文件数量为0，则没有必要继续寻找下去*/</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == bitNums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"no need to continue\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *findNum = num;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    findNum(&amp;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"final num is %d or 0x%x\n"</span>,num,num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明：</p>
<ul>
<li>这里的splitByBit函数根据比特位将数据分为两部分</li>
<li>closeAllFile用于关闭文件描述符</li>
<li>findNum函数循环32个比特位，每处理一次得到一个比特位，最终可以得到不存在其中的整数。</li>
</ul>
<p>利用脚本产生了约2000万个整数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wc -l source.txt </span><br><span class="line">20000001 source.txt</span><br></pre></td></tr></table></figure></p>
<p>编译运行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o binarySearch binarySearch.c</span><br><span class="line">$ time ./binarySearch</span><br><span class="line">final num is 18950401 or 0x1212901</span><br><span class="line"></span><br><span class="line">real    0m8.001s</span><br><span class="line">user    0m6.466s</span><br><span class="line">sys    0m0.445s</span><br></pre></td></tr></table></figure></p>
<p>程序的主要时间花在了读写文件，且占用内存极小。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从一个特别的角度用最常见的二分搜索解决了该问题，最多拆分32次，便可从中找到不存在的整数。你有什么更好的思路或优化点，欢迎留言。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中“!”的惊叹用法</title>
    <url>/2018/12/22/40915.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>实际上，不起眼的“!”在linux中有着很多让你惊叹的妙用。本文就来细数那些“!”的神奇用法。<br><a id="more"></a></p>
<h2 id="执行上一条命令"><a href="#执行上一条命令" class="headerlink" title="执行上一条命令"></a>执行上一条命令</h2><p>例如，在执行完上面一条命令后，可以使用下面的方式再次执行上一条命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ whereis bash  #执行命令</span><br><span class="line">bash: /bin/bash /etc/bash.bashrc /usr/share/man/man1/bash.1.gz</span><br><span class="line"></span><br><span class="line">$ !!            #再次执行上一条命令</span><br><span class="line">whereis bash</span><br><span class="line">bash: /bin/bash /etc/bash.bashrc /usr/share/man/man1/bash.1.gz</span><br></pre></td></tr></table></figure></p>
<p>!!代表了上一条执行的命令。可以看到，当输入两个感叹号时，它显示上条命令的同时会执行上一条命令。当然了，通常我们还会想到使用“UP”键来完成这个事情。但是如果是基于上条命令扩充，!!就来得更加方便了。<br>比如，你想查看某个文件，但是忘了输入more：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$  /opt/user/test.txt  #忘记输入more</span><br><span class="line">$  more !!      #这样是不是快多了？</span><br></pre></td></tr></table></figure></p>
<p>使用!!是不是方便多了？</p>
<h2 id="使用上个命令第一个或最后一个的参数执行命令"><a href="#使用上个命令第一个或最后一个的参数执行命令" class="headerlink" title="使用上个命令第一个或最后一个的参数执行命令"></a>使用上个命令第一个或最后一个的参数执行命令</h2><h4 id="使用上条命令最后一个参数"><a href="#使用上条命令最后一个参数" class="headerlink" title="使用上条命令最后一个参数"></a>使用上条命令最后一个参数</h4><p>比如，你在使用ls列出目录内容时，没有带任何参数，但是想再次执行，带上-al参数，又不想输入长长的参数，可以使用下面的方式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls /proc/1/task/1/net/tcp</span><br><span class="line">/proc/1/task/1/net/tc</span><br><span class="line">$ ls -al !$</span><br><span class="line">ls -al /proc/1/task/1/net/tcp</span><br><span class="line">-r--r--r-- 1 root root 0 12月 22 17:30 /proc/1/task/1/net/tcp</span><br></pre></td></tr></table></figure></p>
<p>这里的!$代表了上一条命令的最后一个参数。</p>
<h4 id="使用上条命令第一个参数"><a href="#使用上条命令第一个参数" class="headerlink" title="使用上条命令第一个参数"></a>使用上条命令第一个参数</h4><p>而使用上条命令的第一个参数只需要使用!^，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -al !^</span><br></pre></td></tr></table></figure></p>
<h2 id="去掉最后一个参数执行上一个命令"><a href="#去掉最后一个参数执行上一个命令" class="headerlink" title="去掉最后一个参数执行上一个命令"></a>去掉最后一个参数执行上一个命令</h2><p>如果想执行上条命令，但不想带上最后一个参数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -al dir  #假设dir是一个很长的字符串</span><br><span class="line">$ !:-</span><br><span class="line">ls -al</span><br></pre></td></tr></table></figure></p>
<p>什么场景下可能会用呢？比如你上一条命令最后一个参数是一个长长的字符串，而你恰好不想不用它，并且退格键删除又慢的时候，可以使用上面的方法。</p>
<h2 id="使用上条命令的所有参数"><a href="#使用上条命令的所有参数" class="headerlink" title="使用上条命令的所有参数"></a>使用上条命令的所有参数</h2><p>前面说了使用上条命令的最后一个参数，那如果不是最后一个参数，该如何使用呢？很简单，使用!*即可。例如我们在输入find命令输错了，想要纠正的时候：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ fin -name &quot;test.zip&quot;  #这里find输错了。</span><br><span class="line">$ find !*</span><br><span class="line">find ./ -name &quot;test.zip&quot;</span><br><span class="line">./workspaces/shell/find/test.zip</span><br><span class="line">./workspaces/shell/test.zip</span><br></pre></td></tr></table></figure></p>
<h2 id="使用上条命令指定的参数"><a href="#使用上条命令指定的参数" class="headerlink" title="使用上条命令指定的参数"></a>使用上条命令指定的参数</h2><p>有的读者可能会问了，如果我只想用其中某个参数呢？按照![命令名]:[参数号]的规则即可。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cp -rf dira dirb/   #将dira拷贝到dirb</span><br><span class="line">$ ls -l !cp:2        #查看dira的内容</span><br><span class="line">ls -l dira</span><br><span class="line">total 0</span><br><span class="line">-rw-rw-r-- 1 hyb hyb 0 12月 22 17:45 testfile</span><br></pre></td></tr></table></figure></p>
<p>当上条命令的参数很长，而你需要取用中间的某个参数时，效果就比较明显了。</p>
<h2 id="执行history中的命令"><a href="#执行history中的命令" class="headerlink" title="执行history中的命令"></a>执行history中的命令</h2><p>我们都知道可以通过history命令可以查看之前执行过的命令，但是如何再次执行history中的命令呢？我们可以通过“UP”键可以查看，但是历史命令很长的时候，并不是很方便，这个时候“!”便派上了用场：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ history</span><br><span class="line">(这里省略更多内容)</span><br><span class="line">2043  touch ./dira/testfile</span><br><span class="line"> 2044  cp -rf dira dirb/</span><br><span class="line"> 2045  ls -al dira</span><br><span class="line"> 2046  ls -l dira</span><br><span class="line"> 2047  ls -al dira</span><br><span class="line"> 2048  ls -l dira</span><br><span class="line"> 2049  ls -al dira</span><br><span class="line"> 2050  ls -l dira</span><br><span class="line"> 2051  history</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到，history命令出来可以看到之前执行过的命令，也会看到它前面带了一个数值。如果我们想执行前面的cp -rf dira dirb/命令，实际上只要用下面的方式即可：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ !2044   #2044是执行的第n条命令</span><br><span class="line">cp -rf dira dirb/</span><br></pre></td></tr></table></figure></p>
<p>即通过![历史命令数值]的方式执行历史命令。<br>当然了，如果我们想执行倒数第二条命令，也是有方法的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ !-2   #感叹号后面跟着一个负数，负几代表倒数第几条</span><br></pre></td></tr></table></figure></p>
<h2 id="按照关键字执行历史命令"><a href="#按照关键字执行历史命令" class="headerlink" title="按照关键字执行历史命令"></a>按照关键字执行历史命令</h2><p>!可以根据关键字执行命令。</p>
<h4 id="执行上一条以关键字开头的命令"><a href="#执行上一条以关键字开头的命令" class="headerlink" title="执行上一条以关键字开头的命令"></a>执行上一条以关键字开头的命令</h4><p>例如，执行上一条find命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ !find    #执行上条以find开头的命令</span><br></pre></td></tr></table></figure></p>
<h4 id="执行上一条包含关键字的命令"><a href="#执行上一条包含关键字的命令" class="headerlink" title="执行上一条包含关键字的命令"></a>执行上一条包含关键字的命令</h4><p>再例如，执行上一条包含name的命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find ./ -name &quot;test&quot;</span><br><span class="line">./test</span><br><span class="line">./find/test</span><br><span class="line">$ !?name?</span><br><span class="line">find ./ -name &quot;test&quot;</span><br><span class="line">./test</span><br><span class="line">./find/test</span><br></pre></td></tr></table></figure></p>
<h2 id="替换上条命令的参数"><a href="#替换上条命令的参数" class="headerlink" title="替换上条命令的参数"></a>替换上条命令的参数</h2><p>例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find ./ -name &quot;old*&quot; -a -name &quot;*.zip&quot;</span><br></pre></td></tr></table></figure></p>
<p>如果我们需要将这条命令中的old更换为new：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ !!:gs/old/new</span><br></pre></td></tr></table></figure></p>
<h2 id="逻辑非的作用"><a href="#逻辑非的作用" class="headerlink" title="逻辑非的作用"></a>逻辑非的作用</h2><p>这个是它最为人所熟悉的作用，例如删除除了cfg结尾以外的所有文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm !(*.cfg)  #删除需谨慎</span><br></pre></td></tr></table></figure></p>
<p>这里就不再详述。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>惊叹号”!”的作用确实有时候让人惊叹。前面可能只是提到!结合其他字符代表某个特定的含义的某种使用，实际上，我们可以组合或者扩展发现更多的妙用。这里不再展开。你还有什么好的发现？欢迎留言！</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-66.加一</title>
    <url>/2018/12/16/26832.html</url>
    <content><![CDATA[<h2 id="原题地址"><a href="#原题地址" class="headerlink" title="原题地址"></a>原题地址</h2><p><a href="https://leetcode.com/problems/plus-one/" target="_blank" rel="noopener">https://leetcode.com/problems/plus-one/</a><br><a id="more"></a></p>
<h2 id="题目-66-Plus-One"><a href="#题目-66-Plus-One" class="headerlink" title="题目-66. Plus One"></a>题目-66. Plus One</h2><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。<br>最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。<br>你可以假设除了整数 0 之外，这个整数不会以零开头。<br>示例 1:</p>
<p>输入: [1,2,3]<br>输出: [1,2,4]<br>解释: 输入数组表示数字 123。<br>示例 2:</p>
<p>输入: [4,3,2,1]<br>输出: [4,3,2,2]<br>解释: 输入数组表示数字 4321。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>实际上这个问题相当于是对一个整数加1，特别的是，这个整数的每一位都存储在了一个数组中。那么只需要按照加法的运算法则计算就可以了。从后往前遍历，如果该位是9，则置0进位，继续计算。直到最后该位不是9，退出循环。最后检查循环终止，如果没有循环到第一位，说明最终不需要增加1位，例如，98+1=99；如果循环到了第一位，说明最后需要进位，则数组长度需要加1，例如99+1=100。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>C语言实现代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an array of size *returnSize.</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">plusOne</span><span class="params">(<span class="keyword">int</span>* digits, <span class="keyword">int</span> digitsSize, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == digits)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> loop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *ret = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/*按照普通加法计算，9+1进1，当前位置0*/</span></span><br><span class="line">    <span class="keyword">for</span>(loop = digitsSize<span class="number">-1</span>; loop &gt;= <span class="number">0</span>;loop--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">9</span> != digits[loop] )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*当前不等于9，加1后退出即可*/</span></span><br><span class="line">            digits[loop]+=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*等于9时，进位，当前位置0*/</span></span><br><span class="line">            digits[loop] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*没有循环到最后，说明结果位数不变*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> &lt;= loop)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*这里直接返回原数组，是否不太好？*/</span></span><br><span class="line">        *returnSize = digitsSize;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*全为9，需要增加一位*/</span></span><br><span class="line">        ret = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>(digitsSize +<span class="number">1</span> ,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == ret)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        *returnSize = digitsSize +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h2><p>Runtime: 0 ms</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-53.最大子序和</title>
    <url>/2018/12/16/32321.html</url>
    <content><![CDATA[<h2 id="原题地址"><a href="#原题地址" class="headerlink" title="原题地址"></a>原题地址</h2><p><a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-subarray/</a><br><a id="more"></a></p>
<h2 id="题目-53-Maximum-Subarray"><a href="#题目-53-Maximum-Subarray" class="headerlink" title="题目-53. Maximum Subarray"></a>题目-53. Maximum Subarray</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。<br>进阶:</p>
<p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>
<p>分析</p>
<p>题目意思应该比较清晰了，我们也能很快想到一种方法，那就是计算所有可能的组合，然后比较所有组合的结果，选出结果最大的那个即可。这确实是一个可行的犯法，但是当数组越来越大时，其组合的可能性也越来越多，这显然是一个很低效的算法。那么有没有更好的办法呢？有!<br>思路也很简单，我们把整个序列分为两部分，前面一部分是已知最大子序列和的，后面的是还没有参与计算最大子序列和的。既然我们已经知道前面部分的最大子序列和，如果前部分最大子序列和小于0，则加上一个数，将会小于这个数。所以当前最大数就是当前数，否则的话，当前最大数是前部分的序列和加上该数。再将当前数与之前的最大和比较，取较大值即可，直到遍历所有数，找到最终的最大序列和。</p>
<p>还是以题目中给出的输入为例，首先，最大子序列和为-2，-2小于0，因此当前最大数为1，它与-2比较,1更大，因此最大子序列和为1；此时1大于0，因此需要加上后面的-3，因此当前最大子序列和为-2，但是它仍然比之前的最大子序列和1小，因此最大子序列和仍然为1，以此循环，最终会得到该数组的最大子序列和为6.</p>
<p>我们可以看到这种动态规划的解答方法的时间复杂度为O(N)。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>c语言实现的代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == nums)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxSum = INT_MIN;  <span class="comment">//初始最大和赋为int的最小值</span></span><br><span class="line">    <span class="keyword">int</span> loop  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(loop;loop &lt; numsSize;loop++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(curMax &gt; <span class="number">0</span>) </span><br><span class="line">            <span class="comment">////如果当前最大和大于0，则当前最大和需要加上当前值</span></span><br><span class="line">            curMax = curMax+nums[loop];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//如果当前最大和小于0，则当前最大和重新计算</span></span><br><span class="line">            curMax = nums[loop];</span><br><span class="line">        <span class="keyword">if</span>(curMax &gt; maxSum)</span><br><span class="line">            <span class="comment">//如果当前最大和大于前面的最大和，则更新最大和的值</span></span><br><span class="line">            maxSum = curMax;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h2><p>Runtime: 4 ms</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言中常见内存错误</title>
    <url>/2018/12/16/20648.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>C语言强大的原因之一在于几乎能掌控所有的细节，包括对内存的处理，什么时候使用内存，使用了多少内存，什么时候该释放内存，这都在程序员的掌控之中。而不像Java中，程序员是不需要花太多精力去处理垃圾回收的事情，因为有JVM在背后做着这一切。但是同样地，能力越大，责任越大。不恰当地操作内存，经常会引起难以定位的灾难性问题。今天我们就来看看有哪些常见的内存问题。<br><a id="more"></a></p>
<h2 id="初始化堆栈中的数据"><a href="#初始化堆栈中的数据" class="headerlink" title="初始化堆栈中的数据"></a>初始化堆栈中的数据</h2><p>对申请的内存或自动变量进行初始化是一个好习惯，例如：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *a = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">/*判断是否申请成功*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*将其初始化为0*/</span></span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="comment">/*do something*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们经常需要在使用前将其初始化为0或使用calloc申请内存。关于初始化，在《<a href="https://www.yanbinghu.com/2018/11/13/9002.html">C语言入坑指南-被遗忘的初始化</a>》一文中，有更详细的阐述。</p>
<h2 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h2><p>缓冲区溢出通常指的是向缓冲区写入了超过缓冲区所能保存的最大数据量的数据。同样的，缓冲区溢出通常也伴随着难以定位的问题。例如下面的代码就存在缓冲区溢出的可能：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*bad code*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="string">"0123456789"</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(buff,p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buff);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于缓冲区溢出，可以通过《<a href="https://www.yanbinghu.com/2018/11/03/12764.html">C语言入坑指南-缓冲区溢出</a>》一文了解更多。</p>
<h2 id="指针不等同于其指向的对象"><a href="#指针不等同于其指向的对象" class="headerlink" title="指针不等同于其指向的对象"></a>指针不等同于其指向的对象</h2><p>我们可能常常错误性地认为指针对象的大小就是数据本身的大小，最常错误使用的就是下面的情况：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*bad code*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">size_t</span> len = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">   <span class="comment">/*do something*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里计算数组a的长度偶尔能够如愿，但实际上是错误的，因为数组名作为参数时，是指向该数组下标为0的元素的指针。因此sizeof(a)的值会是4或者8（取决于程序的位数）。</p>
<h2 id="指针运算以指向对象大小为单位"><a href="#指针运算以指向对象大小为单位" class="headerlink" title="指针运算以指向对象大小为单位"></a>指针运算以指向对象大小为单位</h2><p>对于下面的代码，ptr1 + 1之后，到底移动了多少个字节？ptr2 + 1呢？<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *ptr1 = arr;</span><br><span class="line"><span class="keyword">char</span> *ptr2 = (<span class="keyword">char</span>*)arr;</span><br></pre></td></tr></table></figure></p>
<p>实际上，它们移动的字节数，是以其指向对象大小为单位的。即ptr1 + 1会移动4字节（int类型），而ptr2 + 1 会移动1字节（char类型）。<br>下面的代码运行结果是什么？<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span>*)(&amp;a+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d"</span>,*(a+<span class="number">1</span>),*(p<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>问题的答案也可在《<a href="https://www.yanbinghu.com/2018/10/23/2660.html">C语言入坑指南-数组之谜</a>》中找到。</p>
<h2 id="不可引用已释放的内存"><a href="#不可引用已释放的内存" class="headerlink" title="不可引用已释放的内存"></a>不可引用已释放的内存</h2><p>对于下面的代码：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*bad code*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getHelloString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">string</span>[] = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在其他地方调用getHelloString之后，如果再使用printf打印string，显然是不可取的。因为在调用返回之后，string所指向的内存已经释放了。有人可能会问了，为什么返回int类型就可以使用呢？比如：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用getInt显然能够得到a的值，这是为什么呢？因为你实际上返回的就是值10，而前面返回的是string的地址，这个值你也能获取，但是要获取这个地址值指向的内存，已经不可行了。</p>
<p>下面的情况也是应该避免的：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*bad code*/</span></span><br><span class="line"><span class="keyword">int</span> *a = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">/*do something*/</span></span><br><span class="line"><span class="built_in">free</span>(a)；</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">10</span>; <span class="comment">//内存已经被释放，不可再引用</span></span><br></pre></td></tr></table></figure></p>
<p>在这个例子中可能很容易发现问题，但是在大型程序中，这样的问题可能很难发现，一个建议就是在释放a的内存后，显式地将a置为NULL。即：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line">a = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="避免对NULL解引用"><a href="#避免对NULL解引用" class="headerlink" title="避免对NULL解引用"></a>避免对NULL解引用</h2><p>对于上面的例子，a置NULL之后还不够，我们需要经常对入参进行检查，避免对NULL解引用。这样就避免引用已经释放的内存。例如：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calcSum</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*入惨检查，避免引用空指针*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == arr || <span class="number">0</span> == len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*do something*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然了，在C++中可以传引用，而避免这种重复的检查性代码。<br>下面的代码，同样也是有问题的：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,str);</span><br></pre></td></tr></table></figure></p>
<p>这里str为NULL，却将其作为字符串打印，后果将是灾难性的。</p>
<h2 id="申请的内存不使用时需要释放"><a href="#申请的内存不使用时需要释放" class="headerlink" title="申请的内存不使用时需要释放"></a>申请的内存不使用时需要释放</h2><p>使用malloc等申请的内存如果不使用free进行释放，将会引起内存泄露。长期运行将会导致可用内存越来越少，程序也将会变得越来越卡顿。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*bad code*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">void</span> *data,<span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(len);</span><br><span class="line">    <span class="comment">/*do something*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里，doSomething中申请了内存却没有释放，多次调用之后，将导致内存泄露。也就是说，malloc或calloc与free经常是成对出现的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果控制不当，强大的同时，也会造成更多的危害。上面所列出的仅仅是一些比较常见的内存相关问题，总结如下：</p>
<ul>
<li>自动变量或申请的内存需要初始化</li>
<li>避免缓冲区溢出</li>
<li>指针不等同于指向的对象</li>
<li>指针运算以指向大小为单位</li>
<li>避免对NULL或已释放的内存进行引用</li>
<li>申请的内存不使用时及时释放</li>
<li>使用printf打印字符串时避免使用空指针</li>
</ul>
<p>你踩过哪些坑？欢迎留言评论。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>下面的代码有什么问题？<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *arr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">/*do something*/</span></span><br><span class="line">arr++;</span><br><span class="line"><span class="built_in">free</span>(arr);</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>find命令高级用法</title>
    <url>/2018/12/15/21083.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在《<a href="https://www.yanbinghu.com/2018/11/24/18359.html">Linux中的文件查找技巧</a>》一文中，我们已经知道了文件查找的基本方法，今天我们介绍find命令的一些高级使用技巧。它能满足我们一些更加复杂的需求。</p>
<a id="more"></a>
<h2 id="查找空文件或空目录"><a href="#查找空文件或空目录" class="headerlink" title="查找空文件或空目录"></a>查找空文件或空目录</h2><p>有时候需要清理一些空的文件或者文件夹。这个时候就需要先找到它们。</p>
<h4 id="1-查找空文件"><a href="#1-查找空文件" class="headerlink" title="1.查找空文件"></a>1.查找空文件</h4><p>我们利用之前介绍过的size参数，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find ./ -size 0 #查找当前目录下大小为0的文件</span><br><span class="line">./size_0_file</span><br></pre></td></tr></table></figure></p>
<p>当然也可以利用-empty参数，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find -type f -empty # -type f指明了要查找的是文件</span><br><span class="line">./size_0_file</span><br></pre></td></tr></table></figure></p>
<h4 id="2-查找空目录"><a href="#2-查找空目录" class="headerlink" title="2.查找空目录"></a>2.查找空目录</h4><p>查找空目录只需要利用-empty参数即可。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find -type d -empty</span><br><span class="line">./test3</span><br><span class="line">./find/test3</span><br><span class="line">./find/test2</span><br><span class="line">./test2</span><br></pre></td></tr></table></figure></p>
<p>查找出这些空文件或者文件夹，通常要对其进行处理，最常见的操作就是删除。如何删除呢？我们后面再说。</p>
<h2 id="查找时排除文件或目录"><a href="#查找时排除文件或目录" class="headerlink" title="查找时排除文件或目录"></a>查找时排除文件或目录</h2><h4 id="查找时排除文件"><a href="#查找时排除文件" class="headerlink" title="查找时排除文件"></a>查找时排除文件</h4><p>例如，我们在按照名字查找某一类文件，但是又不想找到其中的.log文件时，可以使用!逻辑运算符查找，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find ./ -name &quot;*test*&quot;  ! -name &quot;*.log&quot; #排除.log文件</span><br><span class="line">./find/test.sh</span><br><span class="line">./find/test.zip</span><br></pre></td></tr></table></figure></p>
<h4 id="查找时排除目录"><a href="#查找时排除目录" class="headerlink" title="查找时排除目录"></a>查找时排除目录</h4><p>我们在查找某些文件时，可能已经知道某个目录有，但又不想浪费时间再次查找，可以使用-prune参数和-path参数，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find .  -path ./test -prune -o -name &quot;*.txt&quot;</span><br></pre></td></tr></table></figure></p>
<p>这里查找txt文件，但是排除test目录下的txt文件。但是注意<strong>./test不能写成./test/</strong>，否则结果将不正确。测试的时候，发现./test仍然会出现在查找结果中。另外-prune不要和-depth（-delete）一起使用，否则-prune将不起作用。</p>
<p>如果需要排除多个目录呢？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find ./ \( -path &quot;./test&quot; -o -path &quot;./home&quot; \) -prune -o -name &quot;*.txt&quot;</span><br></pre></td></tr></table></figure></p>
<p>注意，这里(和\）前后都有空格。它是告诉shell后面的字符不解释，让find命令自己解释其作用。</p>
<p>当然了，排除目录还可以使用！逻辑符号。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find ./ -name &quot;*.txt&quot; ! -path &quot;./test&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="对查找到的文件执行命令操作"><a href="#对查找到的文件执行命令操作" class="headerlink" title="对查找到的文件执行命令操作"></a>对查找到的文件执行命令操作</h2><p>在查找到文件之后，我们可能需要对它进行操作，例如删除，移动等。我们可以利用<strong>xargs</strong>。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find -name &quot;*.log&quot; |xargs rm -f #找到.log文件后，删除</span><br><span class="line">find -name &quot;*test&quot; |xargs chmod 755 #将找到文件的权限修改为755</span><br><span class="line">find -name &quot;*test&quot; |xargs grep &quot;hello&quot; #查找包含hello字符串的test文件</span><br></pre></td></tr></table></figure></p>
<p>xargs后面跟的是要执行的命令，这里只是简单举例。</p>
<p>我们还可以利用-exec参数。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find ./ -name &quot;*txt&quot;  -exec rm -f &#123;&#125; \;#找到后删除</span><br><span class="line">find ./ -name &quot;*txt&quot;  -exec cp &#123;&#125; ./test \;#找到后复制至test目录下</span><br></pre></td></tr></table></figure></p>
<p>这里的{}指代了查找到的内容。\;作为命令参数结束的标志，因此是必要的。小编提醒一下，删除需谨慎，都是泪啊。rm 带上-i参数，可进行交互式删除，即需要询问。</p>
<p>我们也可以利用-ok参数，它与-exec的差别在于，它会询问用户，很适合用于删除：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find ./ -name &quot;*.log&quot; -ok ls -al &#123;&#125; \;</span><br><span class="line">&lt; ls ... ./locate/locate.log &gt; ?</span><br></pre></td></tr></table></figure></p>
<h2 id="删除查找到的文件"><a href="#删除查找到的文件" class="headerlink" title="删除查找到的文件"></a>删除查找到的文件</h2><p>除了前面介绍的利用xargs和exec删除文件之外，还可以利用-delete参数。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find ./ -name &quot;*.log&quot; -delete #删除以log为后缀的文件</span><br></pre></td></tr></table></figure></p>
<h2 id="多条件组合查找"><a href="#多条件组合查找" class="headerlink" title="多条件组合查找"></a>多条件组合查找</h2><p>在前面其实我们已经看到了条件组合的使用。常用的条件组合参数有-a(and),-o(or),!(not)。我们来看几个实例：<br>实例1.查找普通文件和符号链接文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find ./ -type f -o -type l #查找普通文件和符号链接文件</span><br></pre></td></tr></table></figure></p>
<p>实例2.在当前目录下查找zip包和gz包：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find ./ -name &quot;*.zip&quot; -o -name &quot;*.gz&quot;</span><br></pre></td></tr></table></figure></p>
<p>实例3.查找名为test的符号链接文件:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find ./ -name &quot;*test&quot; -a -type l</span><br></pre></td></tr></table></figure></p>
<p>实例4.查找log文件以外的文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find ./ ! -name &quot;*.log&quot;</span><br></pre></td></tr></table></figure></p>
<p>以上几个实例简单介绍了条件的组合使用。更丰富的用法可以自行探索。</p>
<h2 id="查找比某文件新或某文件旧的文件"><a href="#查找比某文件新或某文件旧的文件" class="headerlink" title="查找比某文件新或某文件旧的文件"></a>查找比某文件新或某文件旧的文件</h2><p>环境上日志文件太多，想删除某个时间之前的文件，该怎么处理？<br>可以利用以下参数：</p>
<ul>
<li>newer 修改时间更新的</li>
<li>anewer 访问时间更新的</li>
<li>ctime 修改时间更新的，包括属性的修改<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find ./ ! -newer 1.log |xargs ls -al #列出比1.log更旧的文件</span><br><span class="line">find ./  -newer 1.log |xargs ls -al #列出比1.log更新的文件</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里我只是列出，并没有删除，删除可参考前面介绍的删除找到的文件。而如果要查找出比文件1更新，比文件2旧的文件，只需要利用组合条件即可。</p>
<h2 id="查找结果以特定格式输出"><a href="#查找结果以特定格式输出" class="headerlink" title="查找结果以特定格式输出"></a>查找结果以特定格式输出</h2><p>前面的多数查找结果只是列出路径和文件名，如何获取更多信息呢？当然我们可以利用xargs或者exec，结合ls -al获取文件的更多信息，但是我们还有更好的方法。例如，将查找到的log文件的文件名，访问时间，权限信息，大小等信息输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find ./ -name &quot;*.log&quot; -printf &quot;%f %a %M %s\n&quot;</span><br><span class="line">locate.log Sat Nov 24 09:44:22.3078519090 2018 -rw-rw-r-- 69</span><br><span class="line">test.log Sat Dec 15 15:09:33.9905929210 2018 -rw-rw-r-- 0</span><br></pre></td></tr></table></figure></p>
<p>常见的格式控制输出如下：</p>
<ul>
<li>%f 文件名</li>
<li>%a 访问时间</li>
<li>%c 修改时间</li>
<li>%M 权限信息</li>
<li>%m 权限位信息</li>
<li>%s 文件大小，单位为字节</li>
<li>%d 文件所在目录层级</li>
<li>%u 文件所属用户</li>
<li>%p 带相对路径的完整名</li>
<li>%y 文件类型</li>
<li>…</li>
</ul>
<p>还有很多，这里不一一列举，有兴趣的读者可以查看find的帮助手册。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>find命令用法很丰富，本文仅列出一些实用的find命令高级用法。有哪些特殊场景没有在本文体现的也欢迎读者在文末留言。</p>
<p>注意：</p>
<ul>
<li>-prune参数与-depth或-delete参数一起使用时，-prune将失效。</li>
<li>\后面的字符串表明shell不解释该字符串，留给命令本身去解释处理。</li>
<li>基本使用可参考《<a href="https://www.yanbinghu.com/2018/11/24/18359.html">Linux中的文件查找技巧</a>》</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>位图法</title>
    <url>/2018/12/08/34927.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>输入：一个最多包含n个正整数的文件，每个数都小于n，其中n=10^7。如果在输入文件中有任何正数重复出现就是致命错误。没有其他数据与该正数相关联。</p>
<p>输出：按升序排列的输入整数的列表。</p>
<p>约束：最多有（大约）1MB的内存空间可用，有充足的磁盘存储空间可用。运行时间最多几分钟，运行时间为10秒就不需要进一步优化。</p>
<p>这是《编程珠玑》中很有意思的一个问题。今天给大家分享一下并附上自己的代码实现。<br><a id="more"></a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这个问题的限制在于，大约只有1MB的内存空间可用，而存储10^7个整数却大约需要4*10^7字节即大约需要40M内存，显然是不够用的。<br>一种思路是，既然总的内存不够，我们可以读取40次，例如，第一次读取0至249 999之间的数，并对其进行排序输出，第二次读取250 000 至499 999之间的数，并对其排序输出。以次类推，在进行了多次排序之后就完成了对所有数据的排序，并输出到文件中。</p>
<p>另外一种思路是，既然有充足的磁盘存储空间可用，那么我们可以借助中间文件。读入一次输入文件，利用中间文件进行归并排序写入输出文件。</p>
<p>那么能否结合两种思路呢？即只需要读取一次，也不借助中间文件？或者说，如何用大约1MB内存空间，即大约８00万个比特位最多表示10^７个互异的数呢？</p>
<h2 id="位图法"><a href="#位图法" class="headerlink" title="位图法"></a>位图法</h2><p>借助位图法当然是可以的。我们可以用一个比特位来代表一个数。例如，对于整数集合{1,2,5,6,7}，可以使用下面的比特位表示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 1 1 0 0 1 1 1</span><br></pre></td></tr></table></figure></p>
<p>数值存在的比特位置为1，其他位为0，对应上面的即可。分别在第1，2，5，6，7比特位置1即可。而上面的比特位转换为整数值为103，只需要一个字节便可存储。</p>
<p>回到我们之前的问题。对于最多10^7个整数，我们大约需要10^7个比特位，即10^7/(8*1024*1024)MB，约1.2M的内存即可存储。</p>
<p>至此，我们可以梳理出算法大体流程：<br>1.对给定大小的数组所有比特位置0<br>2.循环读取输入文件的数据，并将对应数值大小的比特位置1<br>3.遍历数组各比特位，如果位为1，则输出对应比特位的位置整数</p>
<h2 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h2><p>C语言实现代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHAR_BIT    8            <span class="comment">// char类型占用的bit位数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHIFT        3            <span class="comment">//右移的位数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_NUM        10000000/8     </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT_SIZE    10000000   <span class="comment">//所需比特位总数量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_STR     10           <span class="comment">//一个整数所需最大字符数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT_FILE  <span class="meta-string">"srcNum.txt"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OUTPUT_FILE <span class="meta-string">"dstNum.txt"</span></span></span><br><span class="line"><span class="comment">/*将整数对应的比特位置1*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putIntoBitMap</span><span class="params">(<span class="keyword">char</span> *bitmap, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>    byte = num &gt;&gt; SHIFT;</span><br><span class="line">    <span class="keyword">char</span> bit = <span class="number">1</span> &lt;&lt; num % CHAR_BIT;</span><br><span class="line">    bitmap[byte] |= (<span class="keyword">char</span>) bit;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断整数是否在位图中*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isInBitMap</span><span class="params">(<span class="keyword">char</span> *bitmap, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>    byte = num &gt;&gt; SHIFT;</span><br><span class="line">    <span class="keyword">char</span> bit    = <span class="number">1</span> &lt;&lt; num % CHAR_BIT;</span><br><span class="line">    <span class="keyword">if</span> (bitmap[byte] &amp; (<span class="keyword">char</span>) bit)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*打开源文件*/</span></span><br><span class="line">    FILE *in = fopen( INPUT_FILE, <span class="string">"r"</span> );</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == in)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"open src num failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*申请位图相关内存，并初始化为0*/</span></span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">string</span>[MAX_STR]    = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">char</span> *bitmap = (<span class="keyword">char</span>*)<span class="built_in">calloc</span>(MAX_NUM,<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == bitmap)</span><br><span class="line">    &#123;</span><br><span class="line">        fclose(in);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>    num    = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*循环读取文件中的整数，并将对应位置1*/</span></span><br><span class="line">    <span class="keyword">while</span>(fgets(<span class="built_in">string</span>, MAX_STR, in ) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        num = atoi(<span class="built_in">string</span>);</span><br><span class="line">        putIntoBitMap(bitmap, num);</span><br><span class="line">        <span class="comment">//printf("%d\n",num);</span></span><br><span class="line">    &#125;</span><br><span class="line">    fclose(in);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*遍历位图中的比特位，为1，则输出整数到文件中*/</span></span><br><span class="line">    FILE *out = fopen(OUTPUT_FILE, <span class="string">"w+"</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == out)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"open dst num failed"</span>);</span><br><span class="line">        <span class="built_in">free</span>(bitmap);</span><br><span class="line">        bitmap = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BIT_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isInBitMap(bitmap , i))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(out, <span class="string">"%d\n"</span>, i);</span><br><span class="line">            <span class="comment">//printf("%d\n",i);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    fclose(out);</span><br><span class="line">    <span class="built_in">free</span>(bitmap);</span><br><span class="line">    bitmap = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>srcNum.txt中存放了早已生成好的小于10^7的大量无重复整数，编译运行结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -o bitmap bitmap.c</span><br><span class="line">time ./bitmap</span><br><span class="line"></span><br><span class="line">real    0m1.830s</span><br><span class="line">user    0m1.729s</span><br><span class="line">sys    0m0.100s</span><br></pre></td></tr></table></figure></p>
<p>可以看到运行时间为秒级。<br>关键点说明：</p>
<ul>
<li>putIntoBitMap和isInBitMap函数是该算法的关键函数</li>
<li>putIntoBitMap将整数对应的比特位置1</li>
<li>isInBitMap 判断整数所在比特位是否为1</li>
<li>例如对于整数81，它所在的字节数是81/8 = 10，第10字节（从0开始数），所在的比特位为81%8=1，第1个比特位。那么我们只需要将第10字节的第1个比特位置1即可。</li>
<li>如何将第n个比特位置1？先将1左移n位（n小于8），得到一个值，再将这个值与该字节进行相或即可。例如，如果需要将第4个比特位置1，则1左移4位，得到二进制的00010000即16，若原来该字节值为01000000，即64时，只需将64与16逻辑或即可。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00010000</span><br><span class="line">01000000   </span><br><span class="line">01010000  #逻辑或之后的结果</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面的程序还有很多不足之处，包括未对输入做任何检查，未对输入数量做校验等等。这一切都基于输入数据都是正确的，但这丝毫不影响我们对该算法思想的理解。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>位图法适用于大规模数据，但数据状态又不是很多的情况。对于上面的程序，几乎是做完读取操作之后，排序就完成了，效率惊人。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>给定一个最多包含40亿个随机排列的32位整数的文件，如何快速判断给出的一个数是否在其中？</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令-man</title>
    <url>/2018/12/04/41455.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于一些新的或者不常用的命令和函数，我们常常需要查询使用方法或者参数详情，在linux下我们不需要去网上查询，完全可以利用linux自带的手册查看帮助信息。这就是我们今天要介绍的man命令。<br><a id="more"></a></p>
<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>实际上man命令并非仅仅能查看命令或者函数的介绍，在linux中，有丰富的帮助手册信息，并且每一个手册都有一个编号。编号和对应内容如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>编号</th>
<th>代表内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>可执行程序或shell命令，如ls</td>
</tr>
<tr>
<td>2</td>
<td>系统调用，如chdir</td>
</tr>
<tr>
<td>3</td>
<td>库函数，如printf</td>
</tr>
<tr>
<td>4</td>
<td>设备或特殊文件，如tty</td>
</tr>
<tr>
<td>5</td>
<td>配置文件格式或约定</td>
</tr>
<tr>
<td>6</td>
<td>游戏</td>
</tr>
<tr>
<td>7</td>
<td>杂项</td>
</tr>
<tr>
<td>8</td>
<td>管理命令，通常只有root用户可以使用</td>
</tr>
<tr>
<td>9</td>
<td>内核例程</td>
</tr>
<tr>
<td>n</td>
<td>内置命令，如cd</td>
</tr>
</tbody>
</table>
</div>
<p>对于内置命令，还可以使用help命令查看帮助手册，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">help cd</span><br></pre></td></tr></table></figure></p>
<p>判断命令是什么类型可使用type命令，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type cd </span><br><span class="line">cd is a shell builtin</span><br></pre></td></tr></table></figure></p>
<h2 id="手册内容"><a href="#手册内容" class="headerlink" title="手册内容"></a>手册内容</h2><p>多数手册包含以下几部分内容：</p>
<ul>
<li>NAME 功能的简单描述</li>
<li>SYNOPSIS 语法格式</li>
<li>DESCRIPTION 描述</li>
<li>OPTIONS 选项 </li>
<li>ERRORS 描述出错场景，<strong>这在排查错误时很有帮助</strong></li>
<li>NOTES 注意事项</li>
<li>FILES 相关文件，例如对于man命令的FILES部分内容显示了它的配置文件位置等信息</li>
<li>EXAMPLES 使用示例，会提供一些简单的示例</li>
<li>BUGS 存在的bug，<strong>当遇到奇怪的问题时，不妨看看当前命令是否有已知的bug</strong></li>
</ul>
<h2 id="基本查看"><a href="#基本查看" class="headerlink" title="基本查看"></a>基本查看</h2><p>手册的查看和less查看文本类似，可以参考《文本查看篇》或查看less命令的使用，这里介绍基本操作：</p>
<ul>
<li>空格 向下翻页</li>
<li>Home 回到第一页</li>
<li>End 跳到最后一页</li>
<li>/string 向前搜索string字符串</li>
<li>?string 向后搜索string字符串</li>
<li>n 下一个匹配字符</li>
<li>N 上一个匹配字符</li>
<li>q 退出</li>
</ul>
<h2 id="工作流程简述"><a href="#工作流程简述" class="headerlink" title="工作流程简述"></a>工作流程简述</h2><p>man命令所展示的帮助信息都是存在于linux系统中的，流程是怎样的呢？</p>
<p>1.搜索$PATH环境变量指定路径。</p>
<p>2.搜索/etc/manpath.config文件中MANPATH中指定的路径。</p>
<p>3.使用指定的解压工具进行解压处理。</p>
<p>4.使用文本查看命令显示手册内容。</p>
<p>配置文件的位置可通过查看FILES部分内容找到：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">man man</span><br><span class="line">FILES</span><br><span class="line">       /etc/manpath.config</span><br><span class="line">              man-db configuration file.</span><br><span class="line"></span><br><span class="line">       /usr/share/man</span><br><span class="line">              A global manual page hierarchy.</span><br><span class="line"></span><br><span class="line">       /usr/share/man/index.(bt|db|dir|pag)</span><br><span class="line">              A traditional global index database cache.</span><br><span class="line"></span><br><span class="line">       /var/cache/man/index.(bt|db|dir|pag)</span><br><span class="line">              An FHS compliant global index database cache.</span><br></pre></td></tr></table></figure></p>
<p>这里简单说明一下manpath.config中的SECTION，它指定了优先输出的手册顺序。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SECTION 1 n l 8 3 2 3posix 3pm 3perl 5 4 9 6 7</span><br></pre></td></tr></table></figure></p>
<p>这里它最先显示的是1，即shell命令的帮助手册，其次是n，即内置命令的帮助手册。以此类推。当然，前提是这些手册都有。</p>
<p>我们也可以通过manpath命令查看man手册所在路径：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">manpath</span><br><span class="line">/usr/local/man:/usr/local/share/man:/usr/share/man:/usr/lib/jvm/java-8-oracle/man</span><br></pre></td></tr></table></figure></p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h4 id="查找指定章节手册"><a href="#查找指定章节手册" class="headerlink" title="查找指定章节手册"></a>查找指定章节手册</h4><p>一般的命令或者库函数的帮助手册都很好查看，但是如果你想查看write函数的帮助手册，使用下面的命令是看不到的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">man write</span><br></pre></td></tr></table></figure></p>
<p>因为它既是一个用户命令也是一个系统调用名称，按照前面所设置的顺序，它会优先显示用户命令的帮助手册。因此，如果我们想直接查看作为系统调用的write的帮助手册，直接使用下面的方式即可：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">man 2 write  #2表明从系统调用手册中查找</span><br></pre></td></tr></table></figure></p>
<h4 id="查找手册所在位置"><a href="#查找手册所在位置" class="headerlink" title="查找手册所在位置"></a>查找手册所在位置</h4><p>如果仅仅是想查看手册在什么位置，可使用-w参数，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">man -w ls</span><br><span class="line">/usr/share/man/man1/ls.1.gz</span><br></pre></td></tr></table></figure></p>
<h4 id="查找包含关键字的手册"><a href="#查找包含关键字的手册" class="headerlink" title="查找包含关键字的手册"></a>查找包含关键字的手册</h4><p>有时候我们需要查看包含某些关键字的手册，但是又不知道具体是那个手册，这个时候可以使用下面的方式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">man -k touch  #查找包含touch关键字的手册（模糊匹配）</span><br><span class="line">git-merge-tree (1)   - Show three-way merge without touching index</span><br><span class="line">synaptics (4)        - touchpad input driver</span><br><span class="line">syndaemon (1)        - a program that monitors keyboard activity and disables...</span><br><span class="line">touch (1)            - change file timestamps</span><br></pre></td></tr></table></figure></p>
<h4 id="查看简短描述信息"><a href="#查看简短描述信息" class="headerlink" title="查看简短描述信息"></a>查看简短描述信息</h4><p>如果只想简单知道该命令的作用，可使用-f参数，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">man -f ls</span><br><span class="line">ls (1)               - list directory contents</span><br></pre></td></tr></table></figure></p>
<h4 id="查看所有手册"><a href="#查看所有手册" class="headerlink" title="查看所有手册"></a>查看所有手册</h4><p>使用-a参数即可，它会展示所有相关手册<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">man -a open</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>man命令是你最该学会使用的一个命令。借助man命令，可以帮助我们快速的学会使用其他命令或函数的使用。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>你可能不知道的printf</title>
    <url>/2018/12/02/10796.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>printf可能是我们在学习C语言的过程中最早接触的库函数了。其基本使用想必我们都已经非常清楚了。但是下面的这些情况你是否已经清楚地知道了呢？<br><a id="more"></a></p>
<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>我们来看一个示例程序，看看你能否对下面的结果输出有非常清晰的认识。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a/b;</span><br><span class="line">    <span class="keyword">float</span> d =  *(<span class="keyword">float</span>*)(&amp;c);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> e = <span class="number">0xffffffffffffffff</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a/b:%f，a:%d\n"</span>,a/b,a,b);          <span class="comment">//打印0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"(float)a/b:%f\n"</span>,((<span class="keyword">float</span>)a)/b);   <span class="comment">//打印1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"(double)a/b:%lf\n"</span>,((<span class="keyword">double</span>)a)/b);<span class="comment">//打印2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"d:%f\n"</span>,d);                       <span class="comment">//打印3</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.*f\n"</span>,<span class="number">20</span>,(<span class="keyword">double</span>)a/b);          <span class="comment">//打印4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"e:%d,a:%d\n"</span>,e,a);                <span class="comment">//打印5</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a:%d,++a:%d,a++:%d\n"</span>,a,++a,a++); <span class="comment">//打印6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译为32位程序：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -m32 -o test test.c</span><br></pre></td></tr></table></figure></p>
<p>在运行之前，你可以自己先猜想一下打印结果会是什么。实际运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a/b:0.000000，a:3        //打印0的结果</span><br><span class="line">(float)a/b:1.333333      //打印1的结果</span><br><span class="line">(double)a/b:1.333333     //打印2的结果</span><br><span class="line">d:0.000000               //打印3的结果</span><br><span class="line">1.33333333333333325932   //打印4的结果</span><br><span class="line">e:-1,a:-1                //打印5的结果</span><br><span class="line">a:6,++a:6,a++:4          //打印6的结果</span><br></pre></td></tr></table></figure></p>
<p>你的猜想是否都正确呢？如果猜想错误，那么接下来的内容你就不应该错过了。</p>
<p>你是否会有以下疑问：</p>
<ul>
<li>0.打印0的a/b为什么不是1，a为什么不是4？</li>
<li>1.打印1和打印2有什么区别呢？</li>
<li>2.打印3为什么结果会是0.000000?</li>
<li>3.打印4的结果为什么最后的小数位不对？其中的*是什么意思？</li>
<li>4.打印5中，为什么a的值是-1而不是4？</li>
<li>5.打印6中，结果为什么分别是6，6，4？ </li>
</ul>
<p>在解答这些问题之前，我们需要先了解一些基本内容。</p>
<h2 id="可变参数中的类型提升"><a href="#可变参数中的类型提升" class="headerlink" title="可变参数中的类型提升"></a>可变参数中的类型提升</h2><p>printf是接受变长参数的函数，传入printf中的参数个数可以不定。而我们在《变长参数探究》中说到：<br>调用者会对每个参数执行“默认实际参数提升”，提升规则如下:<br>——float将提升到double<br>——char、short和相应的signed、unsigned类型将提升到int</p>
<p>也就是说<strong>printf实际上只会接受到double，int，long int等类型的参数。而从来不会实际接受到float，char，short等类型参数</strong>。<br>我们可以通过一个示例程序来检验：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//bad code</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%f,%c\n"</span>,p,p,p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译报错如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printf.c: In function ‘main’:</span><br><span class="line">printf.c:5:12: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘char *’ [-Wformat=]</span><br><span class="line">     printf(&quot;%d,%f,%c\n&quot;,p,p,p);</span><br><span class="line">            ^</span><br><span class="line">printf.c:5:12: warning: format ‘%f’ expects argument of type ‘double’, but argument 3 has type ‘char *’ [-Wformat=]</span><br><span class="line">printf.c:5:12: warning: format ‘%c’ expects argument of type ‘int’, but argument 4 has type ‘char *’ [-Wformat=]</span><br></pre></td></tr></table></figure></p>
<p>我们可以从报错信息中看到：</p>
<ul>
<li>%d 期望的是 int 类型参数</li>
<li>%f 期望的是 double 类型参数</li>
<li>%c 期望的也是 int 类型参数</li>
</ul>
<p>而编译之所以有警告是因为，char *类型无法通过默认实际参数提升，将其提升为int或double。</p>
<h2 id="参数入栈顺序以及计算顺序"><a href="#参数入栈顺序以及计算顺序" class="headerlink" title="参数入栈顺序以及计算顺序"></a>参数入栈顺序以及计算顺序</h2><p>在C语言中，参数入栈顺序是确定的，从右往左。而参数的计算顺序却是没有规定的。也就是说，编译器可以实现从右往左计算，也可以实现从左往右计算。</p>
<h2 id="浮点数的有效位"><a href="#浮点数的有效位" class="headerlink" title="浮点数的有效位"></a>浮点数的有效位</h2><p>对于double类型，其有效位为15～~16位（参考：对浮点数的一些理解）。</p>
<h2 id="可变域宽和精度"><a href="#可变域宽和精度" class="headerlink" title="可变域宽和精度"></a>可变域宽和精度</h2><p>printf中，*的使用可实现可变域宽和精度，使用时只需要用*替换域宽修饰符和精度修饰符即可。在这样的情况下，printf会从参数列表中取用实际值作为域宽或者精度。示例程序如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a = <span class="number">1.33333333</span>;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.*f\n"</span>,<span class="number">6</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%*s\n"</span>,<span class="number">8</span>,p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.333333</span><br><span class="line">   hello</span><br></pre></td></tr></table></figure></p>
<p>而这里的6或者8完全可以是一个宏定义或者变量，从而做到了动态地格式控制。</p>
<h2 id="格式控制符是如何处理参数的"><a href="#格式控制符是如何处理参数的" class="headerlink" title="格式控制符是如何处理参数的"></a>格式控制符是如何处理参数的</h2><p>printf有很多格式控制符，例如%d，它在处理输入时，会从堆栈中取其对应大小，即4个字节作为对应的参数值。也就是说，当你传入参数和格式控制符匹配或者在经过类型提升后和格式控制符匹配的时候，参数处理是没有任何问题的。但是不匹配时，可能会出现未定义行为（有两种情况例外,我们后面再说）。例如，%f期望一个double（8字节）类型，但是传入的参数是int（4字节），那么在处理这个int参数值，可能会多处理4个字节，并且也会造成处理数据错误。</p>
<h2 id="真相大白"><a href="#真相大白" class="headerlink" title="真相大白"></a>真相大白</h2><p>有了前面这些内容的铺垫，我们再来解答开始的疑问：</p>
<ul>
<li>对于问题0，a/b的结果显然为4字节的int类型1，而%f期望的是8字节的double，而计算结果只有4个字节，因此会继续格式化后面4个字节的a，而整型1和后面a组合成的8字节数据，按照浮点数的方式解释时，它的值就是0.000000了。由于前面已经读取解释了a的内容，因此第二个%d只能继续读取4个字节，也就是b的值3，最终就会出现打印a的值是3，而不是4。</li>
<li>对于问题1，实际上在printf中，是不需要%lf的，%f期望的就是double类型，在编译最开始的示例程序其实就可以发现这个事实。当然了在scanf函数中，这两者是有区别的。</li>
<li>对于问题2，也很简单，2的二进制存储形式按照浮点数方式解释读取时，就是该值。</li>
<li>对于问题3，double的有效位为15~16位，也就是之外的位数都是不可靠的。printf中的*可用于实现可变域宽和精度，前面已经解释过了。</li>
<li>对于问题4，这里不给出，留给读者思考，欢迎大家可留言区给出原因。</li>
<li>对于问题5，虽然参数计算顺序没有规定，但是实际上至少对于gcc来说，它是从右往左计算的。也就是说，先计算a++，而a++是先用在加，即压入a=4，其后，a的值变为5;再计算++a，先加再用，即压入a=5+1=6；最后a=6，压入栈。最终从左往右压入栈的值就分别为6，6，4。也就是最终的打印结果。但是实际情况中，这样的代码绝对不该出现！</li>
</ul>
<p>至此，真相大白。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然我们前面解释了那些难以理解的现象，同时读者可以参考《》和《》找到更多的信息。但是我们在实际编程中应该注意以下几点：</p>
<ul>
<li>格式控制符应该与对应参数类型匹配或者与类型提升后的参数类型匹配。</li>
<li>绝对避免出现计算结果与参数计算顺序有关的代码。</li>
<li>*在printf中实现可变域宽和精度。</li>
<li>printf不会实际接受到char，short和float类型参数。</li>
<li>如果%s对应的参数可能为NULL或者对应整型，那将是一场灾难。</li>
<li>不要忽略编译器的任何警告，除非你很清楚你在做什么。</li>
<li>例外情况指的是有符号整型和无符号整型之间，以及void*和char*之间</li>
</ul>
<h2 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h2><p>如果编译为64位程序运行，结果还是一样吗？为什么？</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之旅-函数重载</title>
    <url>/2018/11/27/34641.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>函数重载指的是一个作用域内的几个函数名字相同但是形参列表不同。这些函数执行操作类似，但是接受的形参类型不一样，编译器会根据传递的实参类型选择对应的函数调用。本文将简单介绍C++中的函数重载。<br><a id="more"></a></p>
<h2 id="定义重载函数"><a href="#定义重载函数" class="headerlink" title="定义重载函数"></a>定义重载函数</h2><p>假设有一个计算图形面积的函数，它可以是计算三角形，圆形或正方形的面积。函数的名字都相同，只是根据传入的图形类型来选择不同的函数来计算面积，程序清单如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Triangle</span>//定义三角形结构</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> high;<span class="comment">//高</span></span><br><span class="line">    <span class="keyword">double</span> baseLen;<span class="comment">//底边长</span></span><br><span class="line">&#125;Triangle;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Circle</span> //定义圆形结构</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> radius;<span class="comment">//半径</span></span><br><span class="line">&#125;Circle;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Square</span>//定义正方形结构</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> sideLen;<span class="comment">//边长</span></span><br><span class="line">&#125;Square;</span><br><span class="line"><span class="comment">//函数1.计算三角形面积</span></span><br><span class="line"><span class="function"><span class="keyword">double</span>  <span class="title">calcArea</span><span class="params">(<span class="keyword">const</span> Triangle&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"calcute triangle area"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数2.计算圆形面积</span></span><br><span class="line"><span class="function"><span class="keyword">double</span>  <span class="title">calcArea</span><span class="params">(<span class="keyword">const</span> Circle&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"calcute circle area"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数3，计算三角形面积</span></span><br><span class="line"><span class="function"><span class="keyword">double</span>  <span class="title">calcArea</span><span class="params">(<span class="keyword">const</span> Square&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"calcute square area"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Triangle triangle;</span><br><span class="line">    Circle circle;</span><br><span class="line">    Square square;</span><br><span class="line">    calcArea(triangle);<span class="comment">//调用函数1</span></span><br><span class="line">    calcArea(circle);<span class="comment">//调用函数2</span></span><br><span class="line">    calcArea(square);<span class="comment">//调用函数3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，定义的三个函数名calcArea都相同，只是形参类型不同。当分别传入三角形，圆形和正方形类型时，会调用对应的函数。<br>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">calcute triangle area                                                                                                                                                                       </span><br><span class="line">calcute circle area                                                                                                                                                                         </span><br><span class="line">calcute square area</span><br></pre></td></tr></table></figure></p>
<p>可以看到，当分别传入Triangle ，Circle，Square类型时，分别调用了对应的函数。</p>
<h2 id="为什么要重载"><a href="#为什么要重载" class="headerlink" title="为什么要重载"></a>为什么要重载</h2><p>函数重载在一定程序上可以减轻程序员起名字的负担。最常见的一个例子就是构造函数的重载。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      Test(<span class="keyword">void</span>);  <span class="comment">// 无参构造函数</span></span><br><span class="line">      Test(<span class="keyword">int</span> a);<span class="comment">//构造函数</span></span><br><span class="line">      Test(<span class="keyword">int</span> a,<span class="keyword">int</span> b);<span class="comment">//两个整型参数的构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，类Test的三个构造函数名都为Test。如果没有重载，要实现三个构造函数就可能需要三个不同的构造函数名区分，这也就增加了类的使用者的负担，使用者需要传入不同参数构造对象时，就需要使用不同的构造函数名称。而有函数重载之后，类的使用者可以使用同一个函数名传入不同的参数即可。</p>
<p>当然了，如果单纯地为了减轻起名字的负担而去使用函数重载，而使得函数失去了本来的信息，则是一个不明智的选择。我们可以为那些操作确实极其相似的函数进行重载。</p>
<h2 id="不能重载的情况"><a href="#不能重载的情况" class="headerlink" title="不能重载的情况"></a>不能重载的情况</h2><p>以下几种情况下，是不能重载或者说是非法的。</p>
<h4 id="main函数不能重载"><a href="#main函数不能重载" class="headerlink" title="main函数不能重载"></a>main函数不能重载</h4><p>这是在C++ 11标准中说明的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A program shall contain a global function called main, which is the designated start of the program....</span><br><span class="line">This function shall not be overloaded.</span><br></pre></td></tr></table></figure></p>
<p>试想如果作为用户程序入口函数的main函数被重载了，那么加载的时候该以哪个为入口呢？</p>
<h4 id="只有返回值不同"><a href="#只有返回值不同" class="headerlink" title="只有返回值不同"></a>只有返回值不同</h4><p>例如下面两个声明只有返回值不同，函数名和形参都相同：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calcArea</span><span class="params">(<span class="keyword">const</span> Square&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calcArea</span><span class="params">(<span class="keyword">const</span> Square&amp;)</span></span>;  <span class="comment">//非法，仅有返回值不同，不可重载</span></span><br><span class="line"><span class="comment">/*以上声明同时出现会报错*/</span></span><br></pre></td></tr></table></figure></p>
<p>试想一下，当你传入Square类型参数，而不去使用返回值时，应该调用上面的哪个函数呢？</p>
<h4 id="形参列表看似不同，实则相同"><a href="#形参列表看似不同，实则相同" class="headerlink" title="形参列表看似不同，实则相同"></a>形参列表看似不同，实则相同</h4><p>例如使用typedef给Triangle起了一个“别名”：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Triangle MyTri;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calcArea</span><span class="params">(<span class="keyword">const</span> Triangle&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calcArea</span><span class="params">(<span class="keyword">const</span> MyTri&amp;)</span></span>;</span><br><span class="line"><span class="comment">/*以上声明同时出现会报错*/</span></span><br></pre></td></tr></table></figure></p>
<p>上面这种情况的形参看似不一样，本质上来说它们并没有什么不同。</p>
<h4 id="形参名不同"><a href="#形参名不同" class="headerlink" title="形参名不同"></a>形参名不同</h4><p>例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calcArea</span><span class="params">(<span class="keyword">const</span> Circle &amp;circle )</span></span>;<span class="comment">//形参名为circle</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calcArea</span><span class="params">(<span class="keyword">const</span> Circle&amp; cir)</span></span>;<span class="comment">//形参名为cir</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calcArea</span><span class="params">(<span class="keyword">const</span> Circle&amp; )</span></span>;<span class="comment">//省略形参名</span></span><br><span class="line"><span class="comment">/*以上声明同时出现会报错*/</span></span><br></pre></td></tr></table></figure></p>
<p>这里形参的名字仅仅是起到说明或者记忆的作用，因此对于上面三个声明，它们的形参名可以随意起，但不会影响形参列表的内容。</p>
<h4 id="仅有顶层const的差异"><a href="#仅有顶层const的差异" class="headerlink" title="仅有顶层const的差异"></a>仅有顶层const的差异</h4><p>例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calcArea</span><span class="params">(<span class="keyword">const</span> Circle)</span></span>;<span class="comment">//函数1</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calcArea</span><span class="params">(Circle)</span></span>;<span class="comment">//重复声明了函数1</span></span><br><span class="line"><span class="comment">/*以上声明同时出现会报错*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calcArea</span><span class="params">(Circle* <span class="keyword">const</span>)</span></span>;<span class="comment">//函数2</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calcArea</span><span class="params">(Circle*)</span></span>;<span class="comment">//重复声明了函数2</span></span><br><span class="line"><span class="comment">/*以上声明同时出现会报错*/</span></span><br></pre></td></tr></table></figure></p>
<p>但需要特别注意的是，如果形参是指针或引用，是可以通过区分指向大到底是常量对象还是非常量对象来实现函数重载。例如下面的情况是可以实现函数重载的：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calcArea</span><span class="params">(<span class="keyword">const</span> Circle&amp;)</span></span>;<span class="comment">//作用于常量引用</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calcArea</span><span class="params">(Circle&amp;)</span></span>;<span class="comment">//</span></span><br><span class="line"><span class="comment">/*以上声明同时出现不会报错*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calcArea</span><span class="params">(<span class="keyword">const</span> Circle*)</span></span>;<span class="comment">//作用于常量指针</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calcArea</span><span class="params">(Circle*)</span></span>;</span><br><span class="line"><span class="comment">/*以上声明同时出现不会报错*/</span></span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在定义了重载函数后，我们需要以合理的实参进行调用。大多数情况下，我们很容易判断传入的对应实参需要调用哪个函数，但是有些时候却并不那么容易。我们将会在后面的文章中看到如何进行<strong>函数匹配</strong>。</p>
<p>我们对前面的内容做一个总结：</p>
<ul>
<li>函数重载能够减轻程序员命名的负担，但这不应该以丢失可读性为代价。</li>
<li>main函数不能重载。</li>
<li>重载函数的形参在数量或者类型上要有不同。</li>
<li>不能以返回值作为函数重载要素。</li>
<li>C语言没有函数重载。</li>
</ul>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中的文件查找技巧</title>
    <url>/2018/11/24/18359.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Linux常用命令中，有些命令可以帮助我们查找二进制文件，帮助手册或源文件的位置，也有的命令可以帮助我们查找磁盘上的任意文件，今天我们就来看看这些命令如何使用。<br><a id="more"></a></p>
<h2 id="which"><a href="#which" class="headerlink" title="which"></a>which</h2><p>which命令会在PATH变量指定的路径中，搜索某个系统命令的位置。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">which -a which  #查看命令which所在位置，-a参数表示找出所有</span><br><span class="line">/usr/bin/which</span><br><span class="line">/bin/which</span><br></pre></td></tr></table></figure></p>
<p>PATH变量有哪些内容呢？我们来看一下(不同电脑可能不同)：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $PATH</span><br><span class="line">/home/hyb/bin:/home/hyb/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/usr/lib/jvm/java-8-oracle/bin:/usr/lib/jvm/java-8-oracle/db/bin:/usr/lib/jvm/java-8-oracle/jre/bin</span><br></pre></td></tr></table></figure></p>
<p>PATH环境变量存放着一些路径信息，例如/usr/bin，当你在shell终端敲入一个命令，但是在PATH中包含的路径下没有时并且也不是内置命令时，就会提示：command not found。</p>
<p>当你已经安装了一个命令，但是使用时却提示找不到该命令，可以查看该环境变量，是否有你安装命令的路径。</p>
<p>所以是不是明白了为什么有些命令或程序需要添加环境变量才能直接使用了吧？</p>
<h2 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h2><p>whereis命令用于搜索程序的二进制文件，源代码文件或帮助文档。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">whereis ls  #如果上述三者有，则三者都会显示。</span><br><span class="line">ls: /bin/ls /usr/share/man/man1/ls.1.gz</span><br><span class="line"></span><br><span class="line">whereis -m ls #只查看ls的帮助手册</span><br><span class="line">ls: /usr/share/man/man1/ls.1.gz</span><br><span class="line"></span><br><span class="line">whereis -b ls #只查找ls的二进制文件</span><br><span class="line">ls: /bin/ls</span><br><span class="line"></span><br><span class="line">whereis stdio.h #查找stdio.h头文件，和帮助手册</span><br><span class="line">stdio: /usr/include/stdio.h /usr/share/man/man3/stdio.3.gz</span><br></pre></td></tr></table></figure></p>
<p>同样地，它不能查找到内置命令。</p>
<h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>type用于查看命令类型，一般有以下类型：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alias：别名</span><br><span class="line">keyword：关键字</span><br><span class="line">builtin：内置命令</span><br><span class="line">file：外部命令</span><br></pre></td></tr></table></figure></p>
<p>而常见参数如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-t 输出类型名，如file</span><br><span class="line">-p 如果是外部命令，则显示其所在路径</span><br><span class="line">-a 对于外部命令，它会显示命令路径，命令类型等信息</span><br></pre></td></tr></table></figure></p>
<p>我们来看几个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type ls   #ls是一个别名</span><br><span class="line">ls is aliased to `ls --color=auto&apos;</span><br><span class="line"></span><br><span class="line">type cd    #cd是一个内置命令</span><br><span class="line">cd is a shell builtin</span><br><span class="line"></span><br><span class="line">type find</span><br><span class="line">find is /usr/bin/find</span><br><span class="line"></span><br><span class="line">type  function  #function是一个shell关键字</span><br><span class="line">function is a shell keyword</span><br><span class="line"></span><br><span class="line">type -a which  #显示所有路径</span><br><span class="line">which is /usr/bin/which</span><br><span class="line">which is /bin/which</span><br></pre></td></tr></table></figure>
<h2 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h2><p>前面所说的命令都限于查找命令，帮助手册或源文件，而locate用于快速查找任何文件。它从一个系统数据库进行文件查找，而不需要遍历磁盘，因此速度极快。通常该系统数据库每天更新一次（可以查看系统的/etc/cron.daily/mlocate，不同系统可能不一样）。<br>常见选项如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-e  仅查找存在的文件</span><br><span class="line">-q  安静模式，不会显示任何错误讯息</span><br><span class="line">-n  至多显示 n个输出</span><br><span class="line">-r  使用正规运算式</span><br><span class="line">-i  查找忽略大小写</span><br><span class="line">-c  打印匹配结果数量</span><br></pre></td></tr></table></figure></p>
<p>假设当前目录早已存在以下文件:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">locate.txt  locate.log  LOCATE.zip</span><br></pre></td></tr></table></figure></p>
<p>我们来看一些实例。</p>
<h4 id="快速查找文件"><a href="#快速查找文件" class="headerlink" title="快速查找文件"></a>快速查找文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">locate locate.txt  #查找locate.txt</span><br><span class="line">/home/hyb/workspaces/shell/locate/locate.txt</span><br></pre></td></tr></table></figure>
<h4 id="查找存在的文件"><a href="#查找存在的文件" class="headerlink" title="查找存在的文件"></a>查找存在的文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">locate locate.txt  #查找之前删除locate.txt</span><br><span class="line">#虽然文件不存在，但是仍然被查找出来</span><br><span class="line">/home/hyb/workspaces/shell/locate/locate.txt </span><br><span class="line"></span><br><span class="line">locate -e locate.txt  #-e参数可以查找只存在的文件</span><br><span class="line">(由于该文件不存在，因此也不会被查找出来)</span><br></pre></td></tr></table></figure>
<h4 id="查找计算文件的数量"><a href="#查找计算文件的数量" class="headerlink" title="查找计算文件的数量"></a>查找计算文件的数量</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">locate -c locate.log #只计算查找到的数量</span><br><span class="line"> 1</span><br></pre></td></tr></table></figure>
<h4 id="忽略大小写查找"><a href="#忽略大小写查找" class="headerlink" title="忽略大小写查找"></a>忽略大小写查找</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">locate -i locate.zip</span><br><span class="line">/home/hyb/workspaces/shell/locate/LOCATE.zip</span><br></pre></td></tr></table></figure>
<h4 id="使用正则表达式"><a href="#使用正则表达式" class="headerlink" title="使用正则表达式"></a>使用正则表达式</h4><p>普通的查找是模糊匹配的，因此只要目标名称中包含要搜索的名称，都会被搜索出来，但是我们可以利用正则表达式，来精确查找。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">locate -r /locate.log$  #查找以/locate.log结尾的文件</span><br></pre></td></tr></table></figure></p>
<p>结合正则表达式，locate有更丰富的查找方式，这里不展开。</p>
<p>locate查找存在的一个问题是，如果最近有文件被删除，它仍然能找出来，最近有文件增加，它却找不到。也就是说，它的查找并不具备实时性。当然我们可以手动执行updatedb命令来更新数据库（可能需要root权限）。</p>
<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>find命令是linux下一个强大的查找命令。与locate命令相比，它需要遍历磁盘文件，因此查找速度较慢，但正因如此，它的实时性比locate好得多。另外一方面，find命令的查找条件比locate丰富得多。</p>
<h4 id="以名称为条件"><a href="#以名称为条件" class="headerlink" title="以名称为条件"></a>以名称为条件</h4><p>最常用的恐怕就是以文件名为条件了，涉及参数-name，-iname，例如：<br>当前目录下查找以sort开头的文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find ./ -name &quot;sort*&quot;</span><br><span class="line">./sort4.txt</span><br><span class="line">./sort2.txt</span><br><span class="line">./sort3.txt</span><br><span class="line">./sort.txt</span><br><span class="line"></span><br><span class="line">find ./ -iname &quot;SORT.txt&quot; #忽略大小写</span><br><span class="line">./sort.txt</span><br></pre></td></tr></table></figure></p>
<h4 id="以权限为条件"><a href="#以权限为条件" class="headerlink" title="以权限为条件"></a>以权限为条件</h4><p>有时候需要查找特定权限的文件，可以使用-perm参数，例如查找当前目录下权限为777的文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find ./ -perm 777</span><br><span class="line">./test</span><br><span class="line">./sort.txt</span><br></pre></td></tr></table></figure></p>
<h4 id="以文件类型为条件"><a href="#以文件类型为条件" class="headerlink" title="以文件类型为条件"></a>以文件类型为条件</h4><p>涉及参数-type，例如要查找当前目录下的符号链接文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find ./ -type l</span><br><span class="line">./test</span><br><span class="line">ls -al test</span><br><span class="line">lrwxrwxrwx 1 hyb hyb 8 11月 24 10:10 test -&gt; home.zip</span><br></pre></td></tr></table></figure></p>
<p>主要类型有：</p>
<ul>
<li>f 普通文件</li>
<li>d 目录</li>
<li>b 块设备文件</li>
<li>c 字符设备文件</li>
<li>l 符号链接</li>
<li>s 套接字</li>
<li>p 管道文件</li>
</ul>
<h4 id="以文件大小为条件"><a href="#以文件大小为条件" class="headerlink" title="以文件大小为条件"></a>以文件大小为条件</h4><p>涉及参数-size，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find ./ -size 1k  #查找当前目录下小于1k的文件</span><br><span class="line">./test</span><br><span class="line">./sort4.txt</span><br><span class="line">./sort2.txt</span><br><span class="line">./sort3.txt</span><br><span class="line">./test.sh</span><br><span class="line">./sort.txt</span><br><span class="line"></span><br><span class="line">find -size +1M  #查找当前目录下大于1M的文件</span><br><span class="line">./test.zip</span><br></pre></td></tr></table></figure></p>
<p>常用单位有：</p>
<ul>
<li>k 千字节</li>
<li>M 兆字节</li>
<li>G 吉字节</li>
<li>c 字节</li>
<li>b 块，一般为512字节</li>
<li>w 字大小，两个字节</li>
</ul>
<h4 id="以归属为条件"><a href="#以归属为条件" class="headerlink" title="以归属为条件"></a>以归属为条件</h4><p>涉及参数-user，-nouser，-group，-nogroup等，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find ./ -user root  #查找当前目录下root用户的文件</span><br><span class="line">find ./ -nouser   #查找当前目录下root用户的被删除的文件</span><br></pre></td></tr></table></figure></p>
<p>-group，-nogroup类似的用法，只不过条件是用户组。</p>
<h4 id="以时间为条件"><a href="#以时间为条件" class="headerlink" title="以时间为条件"></a>以时间为条件</h4><p>涉及参数-mtime，-atime，-ctime，-newer，-anewer，-cnewer，-amin，-cmin等，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find ./ -mtime 3 #查找3天前更改过的文件</span><br><span class="line">find ./ -mtime -3 #查找3天内更改过的文件</span><br><span class="line">find ./ -mtime 0 #查找今天更改过的文件</span><br><span class="line">find ./ -newer sort.txt #查找比sort.txt修改时间更新的文件</span><br><span class="line">find ./ -anewer sort.txt #查找比sort.txt访问时间更新的文件</span><br><span class="line">find ./ -amin  5 #查找5分钟之前访问过的文件</span><br></pre></td></tr></table></figure></p>
<p>注：</p>
<ul>
<li>atime 最后访问时间</li>
<li>mtime 最后修改时间</li>
<li>ctime 最后修改时间，这里包括属性和权限</li>
</ul>
<p>find命令的查找条件比较多，而其用法也非常丰富，本文仅简单介绍，后面的文章将会介绍find的一些高级用法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>which命令可用于查找命令位置。</li>
<li>whereis可查找命令的位置，手册，源文件等。</li>
<li>which和whereis都不能查找内置命令位置。</li>
<li>locate优点：查找速度块；缺点：模糊匹配，匹配路径，实时性差。</li>
<li>find优点：准确查找，功能丰富；缺点：速度较慢。</li>
<li>find高级用法将在后面的文章介绍。</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>find</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐一款强大的浏览器插件</title>
    <url>/2018/11/19/10475.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>和vim一样，这款插件生命力的强大不在于它本身有多么强大的功能，而是其扩展性，让它有更多的可能。Tampermonkey（油猴）就是我们今天要介绍的主角。<br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Tampermonkey可以通过安装各类功能的脚本以实现对浏览器不同功能的需求。是的，实际上它本身没有太强大的功能，但是可以安装很多功能强大的脚本。</p>
<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>下载地址：<br><a href="https://tampermonkey.net/" target="_blank" rel="noopener">https://tampermonkey.net/</a></p>
<p>安装（以chrome为例）：</p>
<ul>
<li>1.浏览器访问chrome://extensions/（或设置-更多工具-扩展程序）</li>
<li>2.将下载好的文件拖动至浏览器的前面打开的页面</li>
<li>3.安装完成</li>
</ul>
<h2 id="有何神用"><a href="#有何神用" class="headerlink" title="有何神用"></a>有何神用</h2><p>至此，插件还不能发挥出什么特别的作用，我们需要去“商场”逛一圈，看看有什么我们需要的。<br>“商场”地址：<a href="https://greasyfork.org/zh-CN" target="_blank" rel="noopener">https://greasyfork.org/zh-CN</a></p>
<p>引用油猴子网站对脚本的介绍<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用户脚本是一段代码，它们能够优化您的网页浏览体验。</span><br><span class="line">安装之后，有些脚本能为网站添加新的功能，有些能使网站的界面更加易用，有些则能隐藏网站上烦人的部分内容。</span><br><span class="line">在 Greasy Fork 上的用户脚本都是由用户编写并向全世界发表的，您可以免费安装，轻松体验。</span><br></pre></td></tr></table></figure></p>
<p>有哪些脚本可用呢？<br>简单列举一下：</p>
<ul>
<li>去视频广告</li>
<li>下载百度云盘大文件</li>
<li>自动比价</li>
<li>无需登录查看知乎完整回答</li>
<li>…</li>
</ul>
<p>只有你想不到，没有找不到。自行探索吧，总之不会让你失望。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不能再多说了。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中不可错过的信息宝库</title>
    <url>/2018/11/18/43716.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>proc文件系统是一个虚拟文件系统，它存储了当前内核运行状态相关文件，并且文件的内容都是动态创建的。用户可以通过查看这些文件获取系统状态以及当前正在运行的进程信息。而通过了解这些信息，能够帮助我们帮助我们定位疑难问题。本文将简单介绍通过proc文件系统能够获取哪些有用的信息。<br><a id="more"></a></p>
<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>我们进入到/proc目录下，查看所有文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /proc</span><br><span class="line">ls -al</span><br><span class="line">774  acpi         iomem        mtrr           uptime</span><br><span class="line">775  asound       ioports      net            version</span><br><span class="line">781  buddyinfo    irq          pagetypeinfo   version_signature</span><br><span class="line">782  bus          kallsyms     partitions     vmallocinfo</span><br><span class="line">8    cgroups      kcore        sched_debug    vmstat</span><br><span class="line">813  cmdline      keys         schedstat      zoneinfo</span><br><span class="line">9    consoles     key-users    scsi</span><br><span class="line">973  cpuinfo      kmsg         self</span><br><span class="line">974  crypto       kpagecgroup  slabinfo</span><br><span class="line">978  devices      kpagecount   softirqs</span><br><span class="line">98   diskstats    kpageflags   stat</span><br><span class="line">983  dma          loadavg      swaps</span><br><span class="line">984  driver       locks        sys</span><br><span class="line">987  execdomains  mdstat       sysrq-trigger</span><br><span class="line">99   fb           meminfo      sysvipc</span><br><span class="line">994  filesystems  misc         thread-self</span><br><span class="line">996  fs           modules      timer_list</span><br><span class="line">998  interrupts   mounts       tty</span><br><span class="line">（列出部分内容）</span><br></pre></td></tr></table></figure></p>
<p>可以看到有三类内容：</p>
<ul>
<li>普通文件，如version，它存放的是内核版本相关信息</li>
<li>以数值命名的文件夹，如1，它存放的是init进程相关信息</li>
<li>非数字命名的文件夹，如drivers，它存放的是驱动相关信息</li>
</ul>
<p>事实上，很多获取系统信息的命令都是通过读取/proc下相关文件内容获取的，例如uname，df，ps等。多数情况下，它们能满足我们对系统状态的查看需求，但是并不尽然，因此我们需要简单了解/proc下的文件，帮助我们获取更多信息。毕竟它是一个巨大的信息宝库。接下来会通过使用不同的文本查看命令进行内容查看，朋友们也可以查看<a href="https://www.yanbinghu.com/2018/10/05/61779.html">linux常用命令—文本查看篇</a>来复习相关内容。</p>
<h2 id="查看系统状态信息"><a href="#查看系统状态信息" class="headerlink" title="查看系统状态信息"></a>查看系统状态信息</h2><h4 id="查看cpu信息-cpuinfo"><a href="#查看cpu信息-cpuinfo" class="headerlink" title="查看cpu信息-cpuinfo"></a>查看cpu信息-cpuinfo</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo</span><br></pre></td></tr></table></figure>
<p>列出的内容较多，这里不展示。举例说明几点，其他内容可自行查阅：</p>
<ul>
<li>processor，逻辑CPU。例如本人的电脑的逻辑CPU有4个，那么cpuinfo中会有4条CPU信息记录。</li>
<li>model name，CPU信息。例如本人的CPU信息为：Intel(R) Core(TM) i5-5200U CPU @ 2.20GHz，表明是intel的i5 低压处理器，主频为2.2GHz。</li>
<li>cache size，CPU二级缓存大小。</li>
</ul>
<h4 id="查看物理内存，交换空间信息-meminfo"><a href="#查看物理内存，交换空间信息-meminfo" class="headerlink" title="查看物理内存，交换空间信息-meminfo"></a>查看物理内存，交换空间信息-meminfo</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">head -2 meminfo #读取前两行内容</span><br><span class="line">MemTotal:        8039600 kB #可支配内存</span><br><span class="line">MemFree:         2762872 kB #尚未使用内存</span><br></pre></td></tr></table></figure>
<h4 id="查看网络流量情况-dev"><a href="#查看网络流量情况-dev" class="headerlink" title="查看网络流量情况-dev"></a>查看网络流量情况-dev</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watch -n 1 cat /proc/net/dev #实时刷新网络流量信息</span><br></pre></td></tr></table></figure>
<p>因篇幅有限，系统状态(参考<a href="https://www.yanbinghu.com/2018/10/01/26218.html">Linux常用命令—系统状态篇</a>)信息文件不再一一介绍，它们所包含内容大致如下：</p>
<ul>
<li>loadavg 负载均衡</li>
<li>swaps 交换空间使用情况</li>
<li>mounts 已加载的文件系统列表</li>
<li>iomem 物理地址分配情况</li>
<li>version 内核版本信息</li>
<li>partitions 分区表</li>
<li>diskstats 每块磁盘设备的磁盘I/O统计信息列表</li>
<li>interrupts  中断的使用及触发情况</li>
<li>zoneinfo 内存区域的详细信息列表</li>
</ul>
<h2 id="查看进程相关信息"><a href="#查看进程相关信息" class="headerlink" title="查看进程相关信息"></a>查看进程相关信息</h2><p>以数字命名的文件夹中存储着进程的相关信息。而数字本身就是该进程的pid。也就是说，如果想要知道某个进程当前更多的状态信息，只需要知道该进程的pid(如何获取进程的进程id可参考<a href="https://www.yanbinghu.com/2018/04/06/53515.html">常见linux命令介绍－ps</a>)，然后读取/proc/pid下的文件夹或文件内容即可。</p>
<p>我们随意进入一个进程id的进程信息文件夹，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /proc/7263</span><br><span class="line">ls</span><br><span class="line">attr             exe        mounts         projid_map    status</span><br><span class="line">autogroup        fd         mountstats     root          syscall</span><br><span class="line">auxv             fdinfo     net            sched         task</span><br><span class="line">cgroup           gid_map    ns             schedstat     timers</span><br><span class="line">clear_refs       io         numa_maps      sessionid     timerslack_ns</span><br><span class="line">cmdline          limits     oom_adj        setgroups     uid_map</span><br><span class="line">comm             loginuid   oom_score      smaps         wchan</span><br><span class="line">coredump_filter  map_files  oom_score_adj  smaps_rollup</span><br><span class="line">cpuset           maps       pagemap        stack</span><br><span class="line">cwd              mem        patch_state    stat</span><br><span class="line">environ          mountinfo  personality    statm</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到该进程的很多内容，包括：</p>
<ul>
<li>cmdline 用于开始进程的命令 </li>
<li>cwd 当前进程工作目录的一个符号链接 </li>
<li>environ 可用进程环境变量的列表 </li>
<li>exe 正在进程中运行的程序链接</li>
<li>fd/ 这个目录包含了进程打开的文件描述符</li>
<li>mem 进程在内存中的内容</li>
<li>status 进程的状态信息</li>
<li>statm 进程的内存使用信息</li>
<li>limits 进程的软限制，硬限制等信息</li>
<li>maps 进程的内存区域映射信息</li>
<li>stack 当前进程的内核调用栈信息</li>
<li>syscall 进程正在执行的系统调用</li>
<li>task 进程下的线程信息</li>
<li>…</li>
</ul>
<p>/proc/pid下的内容很多，我们不一一列举。那么这些内容有什么用呢？我们举几个简单的例子。例如我们发现程序运行时打开一个文件失败，并且没有足够的信息判断失败原因，那么我们就可以考虑查看该进程打开的文件描述符是否已达到上限。这里我们可以查看/proc/pid下的limits中的文件描述符限制数量：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -n &quot;/open/p&quot; limits</span><br><span class="line">Max open files            1024                 1048576              files</span><br></pre></td></tr></table></figure></p>
<p>可以看到最大可打开的文件数量的软限制为1024，而再次进入到fd目录，计算总的打开的文件数量（参考<a href="https://www.yanbinghu.com/2018/09/16/51043.html">ls命令常见实用用法</a>）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -lR | grep &quot;^l&quot; | wc -l</span><br><span class="line">4</span><br></pre></td></tr></table></figure></p>
<p>这里得到的大小为4，很显然没有超出打开的最大文件数量限制。我们甚至还可以看到到底打开了哪些文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -al</span><br><span class="line">lrwx------ 1 hyb hyb 64 11月 18 11:36 0 -&gt; /dev/pts/2</span><br><span class="line">lrwx------ 1 hyb hyb 64 11月 18 11:36 1 -&gt; /dev/pts/2</span><br><span class="line">lrwx------ 1 hyb hyb 64 11月 18 11:18 2 -&gt; /dev/pts/2</span><br><span class="line">(列出部分内容)</span><br></pre></td></tr></table></figure></p>
<p>注：文件描述符0，1，2分别代表了标准输入，标准输出和标准错误输出。</p>
<p>再比如，进程在当前目录创建一个文件失败，而又无更多异常信息，可以查看进程的cwd链接指向，如果指向了一个不在预期内的目录，那么可能是工作目录被意外更改掉了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>proc文件系统相关内容过于丰富，本文仅仅做简单介绍。每一项的具体内容含义，以及在实际中的应用，本文不做过多阐述，后面的文章将会继续介绍。/proc/pid下的内容对于问题的定位也十分地有帮助，本文只有简单举例，更多的使用也会在后续文章中不断应用。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>令人疑惑的引用和指针</title>
    <url>/2018/11/15/44287.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在C++ 11中，新增了一种引用（本文都指左值引用）。从作用上来讲，它和指针类似，都可以用来间接引用对象，他们之间到底有什么异同呢？<br><a id="more"></a></p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>在分析之前我们先介绍一下引用。引用为对象起了一个别名。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a = 1024；</span><br><span class="line">int &amp;b = a;</span><br></pre></td></tr></table></figure></p>
<p>这里的b就是指向a，相当于a的另外一个名字。b是一个引用，但并非一个对象，同时引用的类型都要和对象的类型严格匹配（在具有继承关系的类中是例外，这里不展开），因此有下面的操作：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a = 1024；</span><br><span class="line">int &amp;b = a;</span><br><span class="line">int &amp;(&amp;c) = b;      //非法，b在此之前已经是引用，不能定义引用的引用</span><br><span class="line">int &amp;d = 1024;  //非法，引用类型的初始值必须是对象，而不能是字面值</span><br><span class="line">const int &amp;e = 1024 //合法，e为常量引用，只要能够转换成引用的类型，可以使用任何表达式作为初始值</span><br><span class="line">double f = 1.024；</span><br><span class="line">int &amp;g = f;       //非法，类型不匹配</span><br></pre></td></tr></table></figure></p>
<p>而对引用赋值，实际上是将值赋给了与引用绑定的对象，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int h = 1024；</span><br><span class="line">int &amp;i = h;</span><br><span class="line">i = 256;//将256赋给了h</span><br></pre></td></tr></table></figure></p>
<p>同时，引用必须被初始化，下面的操作是非法的:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int &amp;j;//非法，没有初始化</span><br></pre></td></tr></table></figure></p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>学习过C的朋友可能对指针已经比较熟悉了，这里不占用较大篇幅。它存储的是一个地址，地址指向的是一个对象。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a = 0; //定义变量a</span><br><span class="line">int *ptr = &amp;a;定义int类型指针ptr，它存放变量a的地址</span><br></pre></td></tr></table></figure></p>
<p>与引用类似，指针也实现了对其他对象的间接访问。同样的，它也要求指针的类型和指向的类型严格匹配。</p>
<h2 id="引用和指针比较"><a href="#引用和指针比较" class="headerlink" title="引用和指针比较"></a>引用和指针比较</h2><h4 id="引用不可为空，而指针可以"><a href="#引用不可为空，而指针可以" class="headerlink" title="引用不可为空，而指针可以"></a>引用不可为空，而指针可以</h4><p>例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int &amp;a; //非法，必须被初始化</span><br><span class="line">int *p;//合法，但如果是非静态的指针变量，将拥有一个不确定的值</span><br></pre></td></tr></table></figure></p>
<p>声明一个指针变量而不初始化是合法的，但是不建议这么做，原因可参见《被遗忘的初始化》。正因如此，使用引用而非指针作为函数的入参是一个不错的选择，因为引用永远不为空，函数入口也就不需要做过多的检查，引用也就更富效率。</p>
<h4 id="引用不是对象，而指针本身是对象"><a href="#引用不是对象，而指针本身是对象" class="headerlink" title="引用不是对象，而指针本身是对象"></a>引用不是对象，而指针本身是对象</h4><p>引用不是对象，它不能被再次赋值，而指针是可以的。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a = 1024;</span><br><span class="line">int b = 2048;</span><br><span class="line">int &amp;c = a;</span><br><span class="line">int *d = &amp;a;</span><br><span class="line">c = b; //引用C仍然绑定的是a</span><br><span class="line">d = &amp;b;//合法，指针可以指向另外一个对象</span><br></pre></td></tr></table></figure></p>
<p>也就是说，一旦引用了引用，就没法让它绑定到其他的对象。看起来引用还挺从一而终啊。</p>
<p>另外，可以有指向指针的指针，而不存在引用的引用。因为引用不是对象。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a = 1024;</span><br><span class="line">int &amp;b = a;</span><br><span class="line">int &amp;&amp;c = b;//非法</span><br><span class="line">int *d = &amp;a;</span><br><span class="line">int **e = &amp;d;//合法</span><br></pre></td></tr></table></figure></p>
<h4 id="引用指向对象本身，而指针指向的是对象的地址"><a href="#引用指向对象本身，而指针指向的是对象的地址" class="headerlink" title="引用指向对象本身，而指针指向的是对象的地址"></a>引用指向对象本身，而指针指向的是对象的地址</h4><p>定义一个指针的时候，编译器为他分配内存，而引用不会单独分配空间。<br>引用所代表的就是最初绑定的那个对象，因此使用sizeof分别作用于引用和指针时，前者得到的是引用所绑定对象大小，而后者得到的是指针占用空间大小（4或8字节），例如在64位的程序中：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**假设有以下结构*/</span><br><span class="line">typedef struct INFO</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">    char c;</span><br><span class="line">&#125;INFO;</span><br><span class="line"></span><br><span class="line">INFO info = &#123;0&#125;;//定义结构info</span><br><span class="line">INFO &amp;ref = info;//定义引用ref</span><br><span class="line">INFO *ptr = &amp;info;//定义指针ptr</span><br><span class="line">sizeof(ref); //大小为INFO结构体占用空间大小，即12字节</span><br><span class="line">sizeof(ptr); //占用大小为指针占用空间大小，即8字节</span><br></pre></td></tr></table></figure></p>
<h4 id="引用使用时无需解引用，而指针需要"><a href="#引用使用时无需解引用，而指针需要" class="headerlink" title="引用使用时无需解引用，而指针需要"></a>引用使用时无需解引用，而指针需要</h4><p>例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a = 1024;</span><br><span class="line">int &amp;ref = a;</span><br><span class="line">int *p = &amp;a;</span><br><span class="line">ref = 10; //使用引用可直接使用，将所绑定对象的值修改</span><br><span class="line">*p = 11;//使用指针需要解引用</span><br></pre></td></tr></table></figure></p>
<h4 id="作为参数时的差别"><a href="#作为参数时的差别" class="headerlink" title="作为参数时的差别"></a>作为参数时的差别</h4><p>指针作为参数时，看起来是地址传参，实际上仍然传值，即将指针的一个拷贝作为实参，而由于指针指向的是一个对象，因此在函数内可以实现对指针所指向对象的内容进行改变。而引用作为参数时，实际上传递的对象本身，但又不需要拷贝，因为引用绑定的就是对象。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从前面的内容来看，除了使用方法的差异意外，引用似乎像是弱化版的指针，是不是有点像指针常量呢？当然了，当你知道需要指向某个东西，而且绝不对改变其指向时，引用是一个不错的选择。</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言入坑指南-被遗忘的初始化</title>
    <url>/2018/11/13/9002.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>什么是初始化？为什么要初始化？静态变量和局部变量的初始化又有什么区别？实际应用中应该怎么做？本文将一一回答这些问题。<br><a id="more"></a></p>
<h2 id="什么是初始化"><a href="#什么是初始化" class="headerlink" title="什么是初始化"></a>什么是初始化</h2><p>初始化指的是对数据对象或者变量赋予初始值。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int value = 8; //声明整型变量并初始化为8</span><br><span class="line">int arr[] = &#123;1,2,3&#125;; //声明整型数组arr，并初始化其值为1,2,3</span><br></pre></td></tr></table></figure></p>
<h2 id="为什么要初始化"><a href="#为什么要初始化" class="headerlink" title="为什么要初始化"></a>为什么要初始化</h2><p>我们来看一个示例程序。<br>test0.c程序清单如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">int</span> randNum;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">10</span> &gt; sum)</span><br><span class="line">    &#123;</span><br><span class="line">        randNum =  rand() % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        sum += randNum;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"rand num is %d,sum is %d\n"</span>,randNum,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the final sum is %d\n"</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序随机产生0到9的数字，使得sum的值大于或等于10时，退出程序。<br>编译并运行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc  -o test0 test0.c</span><br><span class="line">./test0</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下（每次运行结果可能不同）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rand num is 3,sum is -4040865</span><br><span class="line">rand num is 6,sum is -4040859</span><br><span class="line">rand num is 7,sum is -4040852</span><br><span class="line">rand num is 5,sum is -4040847</span><br><span class="line">rand num is 3,sum is -4040844</span><br><span class="line">rand num is 5,sum is -4040839</span><br><span class="line">（省略其他内容）</span><br></pre></td></tr></table></figure></p>
<p>从运行结果来看，程序并没有达到我们的预期，这是为什么呢？</p>
<p>很多读者可能已经知道，问题在于声明sum之后，没有为其赋初始值，在这样的情况下，sum的值是随机的，因此在一开始sum可能是一个很小的负数，导致多次循环出现。很显然，<strong>初始化避免使用了变量的“脏值”</strong>。而将sum的声明改成如下定义即可：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sum = 0；</span><br></pre></td></tr></table></figure></p>
<p>如果将sum声明为静态变量，情况又会如何呢？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test1.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">int</span> randNum;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">10</span> &gt; sum)</span><br><span class="line">    &#123;</span><br><span class="line">        randNum =  rand() % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        sum += randNum;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"rand num is %d,sum is %d\n"</span>,randNum,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the final sum is %d\n"</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译并运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rand num is 3,sum is 3</span><br><span class="line">rand num is 6,sum is 9</span><br><span class="line">rand num is 7,sum is 16</span><br><span class="line">the final sum is 16</span><br></pre></td></tr></table></figure>
<p>在这种情况下，程序是能够符合我们预期的结果的，这又是为什么呢？原因在于<strong>静态变量会被默认初始化</strong>.例如，int类型会被初始化为0。那么问题来了：</p>
<ul>
<li>为什么局部变量未初始化的时候的值是“脏值”？</li>
<li>静态变量和局部变量为什么又不一样呢？</li>
</ul>
<p>在解答上面这两个问题之前，我们需要简单了解一下程序的存储空间布局。</p>
<h2 id="程序的存储空间布局"><a href="#程序的存储空间布局" class="headerlink" title="程序的存储空间布局"></a>程序的存储空间布局</h2><p>C程序主要由以下几部分组成：</p>
<ul>
<li>正文段。即机器指令部分，为防止意外被修改，设为只读。</li>
<li>初始化数据段。它包含了程序中需要明确赋初值的静态变量。</li>
<li>未初始化数据段。它包含了程序中未赋初值的或初始化为0的静态变量，在程序开始执行之前，内核将此段中的数据初始化为0。</li>
<li>栈。它保存了自动（局部）变量以及函数调用所要的信息。</li>
<li>堆。用于动态内存分配。例如使用malloc函数进行内存分配。</li>
</ul>
<p>其中，正文段和数据段的内容是“静态”的，因为在程序被编译出来之后，在整个程序地址就确定了，而堆栈中的内容是”动态”变化的，它随着进行的运行而不断变化着，再加上栈随机化的策略，使得程序每次运行时，栈的地址也是不确定的。</p>
<h2 id="局部变量和静态变量的初始化有何不同"><a href="#局部变量和静态变量的初始化有何不同" class="headerlink" title="局部变量和静态变量的初始化有何不同"></a>局部变量和静态变量的初始化有何不同</h2><p>有了前面的铺垫，就很好理解两者的差别了。<br>未初始化的局部变量位于栈中，它的位置是不确定的，因此其值也是不确定的。当然，在windows下它的值是0xcccccccc，而“烫”字在MBCS字符集中的值为0xcccccccc，你说巧不巧？而静态变量就不一样的，它的地址是确定的，并且存放在了数据段，而程序在运行之前，未初始化数据段的内容可以<strong>很方便地统一</strong>被初始化为0。这也就解释了前面的两个示例程序的结果为什么会不一样。我们加上一些打印，来看一看是否真的如此？<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test2.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">int</span> randNum;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">10</span> &gt; sum)</span><br><span class="line">    &#123;</span><br><span class="line">        randNum =  rand() % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        sum += randNum;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"rand num is %d,sum is %d\n"</span>,randNum,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the final sum is %d\n"</span>,sum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sum addr %p,randNum addr %p\n"</span>,&amp;sum,&amp;randNum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译并运行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -o test2 test2.c</span><br></pre></td></tr></table></figure></p>
<p>运行结果1：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rand num is 3,sum is 3</span><br><span class="line">rand num is 6,sum is 9</span><br><span class="line">rand num is 7,sum is 16</span><br><span class="line">the final sum is 16</span><br><span class="line">sum addr 0x60104c,randNum addr 0x7ffd0ea8cf54</span><br></pre></td></tr></table></figure></p>
<p>运行结果2：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rand num is 3,sum is 3</span><br><span class="line">rand num is 6,sum is 9</span><br><span class="line">rand num is 7,sum is 16</span><br><span class="line">the final sum is 16</span><br><span class="line">sum addr 0x60104c,randNum addr 0x7ffff5e3ddb4</span><br></pre></td></tr></table></figure></p>
<p>在这里，sum是静态局部变量，而randNun是局部变量（自动变量），因此可以发现，sum的地址值总是不变的，而randNum的值却不断变化着。我们也可以通过nm命令查看sum的地址:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nm test2 |grep sum</span><br><span class="line">000000000060104c b sum.2805</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们来总结一下本文的主要内容：</p>
<ul>
<li>如果变量是静态的，它会被初始化为0；如果变量是自动的，它不会被初始化。</li>
<li>静态的变量包括全局变量、静态全局变量、静态局部变量。</li>
<li>使用局部变量之前对其进行初始化，避免使用“脏值”。</li>
<li>从可读性考虑，静态变量也建议显示初始化。</li>
<li>初始化为0的静态变量仍然存在未初始化数据段中（BSS段）。</li>
</ul>
<p>送几句熟悉的话给大家：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">手持两把锟斤拷,</span><br><span class="line">口中疾呼烫烫烫。</span><br><span class="line">脚踏千朵屯屯屯，</span><br><span class="line">笑看万物锘锘锘。</span><br></pre></td></tr></table></figure></p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>test1.c的代码运行结果每次都一样吗？为什么？该如何修改才能使得每次的运行结果不一样？</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之旅-vector</title>
    <url>/2018/11/08/58236.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>标准库类型vector表示对象集合，并且所有的对象类型相同。由于它常常“容纳”其他对象，因此常称作容器。vector也是一个类模板。编译器根据模板创建类型或函数的过程称为实例化，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。<br><a id="more"></a></p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>与string类型一样，vector也有很多种方式进行初始化：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; v1;    //v1是一个空的vector，它包含的元素是int类型</span><br><span class="line">vector&lt;int&gt; v2(v1);  //v2包含了v1中的副本</span><br><span class="line">vector&lt;int&gt; v2 = v1; //等价于v2(v1)</span><br><span class="line">vector&lt;string&gt; v3(3,&quot;hello&quot;); //包含3个重复string元素，每个元素的值为“hello”</span><br><span class="line">vector&lt;string&gt; v4(8);         //包含8个string类型的vector，执行8次初始化   </span><br><span class="line">vector&lt;char&gt; v5&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;&#125;;   //包含了三个char类型的元素，并都有相应的初始值</span><br><span class="line">vector&lt;T&gt; v5=&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;&#125;;       //等价于v5&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;&#125;</span><br></pre></td></tr></table></figure></p>
<p>通常情况，我们可以只提供元素数量，而不需要提供初始值，库会根据类型自动进行一个值初始化，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; v6(6);   //6个元素，并且每个元素都初始化为0</span><br></pre></td></tr></table></figure></p>
<p>以下是一些常见错误的初始化：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; a = &quot;hello&quot;; //错误,vector a只能存储int类型</span><br><span class="line">vector&lt;int&gt; b = 8;     //错误，如果需要使得元素值为8，则需要使用直接初始化的方式并且指定元素个数</span><br><span class="line">vector&lt;string&gt; c(&quot;hello&quot;); //错误，字符串字面值不能用于构建vector的对象</span><br></pre></td></tr></table></figure></p>
<p>特别注意，以下几种情况是有区别的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; v1(8)    //包含8个元素，每个元素被初始化为0</span><br><span class="line">vector&lt;int&gt; v2&#123;8&#125;   //包含一个函数，元素值为8</span><br><span class="line">vector&lt;int&gt; v3(8,1)  //包含8个元素，值都为1</span><br><span class="line">vector&lt;int&gt; v3&#123;8,1&#125;  //包含两个元素，值分别为8和1</span><br></pre></td></tr></table></figure></p>
<h2 id="vector基本操作"><a href="#vector基本操作" class="headerlink" title="vector基本操作"></a>vector基本操作</h2><p>vector有以下基本操作<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; v;</span><br><span class="line">v.push_back(10); //将10添加到v</span><br><span class="line">v.push_back(8);  //将8添加到v的尾部</span><br><span class="line">v.empty();      //如果v不包含任何元素，返回真</span><br><span class="line">v.size()        //返回元素个数</span><br><span class="line">v[1]             //返回第2个元素的引用</span><br></pre></td></tr></table></figure></p>
<p>注意：<strong>定义一个空vector，再在运行向其中添加元素，会比创建时指定容量大小，再添加，会更加高效</strong>。<br>解释：通常vector将元素连续存储，当添加的元素超出了原先分配的大小时，就需要重新申请空间，并把原来的元素移到新的位置。vector实现通常会比空间需求分配更大的空间，以避免在添加元素时频繁地重新分配空间并进行移动。既然如此，在一开始就设定大小，并且对其进行初始化就显得没有必要，初始化反而会影响效率，除非vector将要保存的元素都是一样的。</p>
<p>特别注意，<strong>不能使用下标形式添加元素</strong>，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v[2] = 10;</span><br></pre></td></tr></table></figure></p>
<p>因为添加之前，不存在下标为2的元素。<strong>下标运算符只能用于访问已经存在的元素</strong>。</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>所有的标准容器都可以使用迭代器。这些容器类型都拥有名为begin和end的成员，分别返回指向第一个元素和尾元素的下一个位置。<br>例如，可以像下面的方式使用begin和end：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*将字符串中的字母都转换为大写*/</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s</span> <span class="params">(<span class="string">"hello world"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = s.begin (); it != s.end (); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">      *it = <span class="built_in">toupper</span> (*it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>声明迭代器类型it指向s.begin()，遍历每一个元素，将其转换为大写。其中++it让迭代器类型指向下一个元素，直到it指向s.end()。这里使用!=作为循环判断条件是因为很多迭代器并没有&lt;运算符，因此并非所有的标准库类型都可以使用它。但是==和!=是所有标准库容器都定义了的。</p>
<p>对于迭代器之间，可以使用算数运算，例如it=it+2迭代器it的位置向前移动了两个元素，而两个迭代器相减，得到它们之间的元素间隔数。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>vector是模板而不是类型，不存在包含引用的vector，因为引用不是对象。</li>
<li>下标运算符只能用于访问已经存在的元素。</li>
<li>不能使用下标形式添加元素。</li>
<li>定义一个空vector，再在运行向其中添加元素，会比创建时指定容量大小，再添加，会更加高效。</li>
</ul>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>一个命令帮你对文本排序</title>
    <url>/2018/11/06/43352.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Linux下，有时候需要对文本内容进行排序，例如每行按照字典顺序排序，按照数字排序或者按照特定列排序等等。今天我们就借助一个命令-sort来满足我们对文本排序的需求。<br><a id="more"></a></p>
<h2 id="按照字典顺序排序"><a href="#按照字典顺序排序" class="headerlink" title="按照字典顺序排序"></a>按照字典顺序排序</h2><p>假如有文本内容test1.txt如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Debian </span><br><span class="line">Gentoo</span><br><span class="line">Gentoo</span><br><span class="line">CentOS</span><br><span class="line">Fedora</span><br><span class="line">ubuntu</span><br><span class="line">Kali</span><br><span class="line">redhat</span><br><span class="line">Arch</span><br><span class="line">OpenSuse</span><br></pre></td></tr></table></figure></p>
<p>现在要对文本内容按照字典升序排序，只需使用下面的命令即可：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort test1.txt</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch</span><br><span class="line">CentOS</span><br><span class="line">Debian </span><br><span class="line">Fedora</span><br><span class="line">Gentoo</span><br><span class="line">Gentoo</span><br><span class="line">Kali</span><br><span class="line">OpenSuse</span><br><span class="line">redhat</span><br><span class="line">ubuntu</span><br></pre></td></tr></table></figure></p>
<p>可以看到输出结果按照字典顺序的升序进行了排序。如果需要降序输出只需要使用-r参数，如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort -r test1.txt</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ubuntu</span><br><span class="line">redhat</span><br><span class="line">OpenSuse</span><br><span class="line">Kali</span><br><span class="line">Gentoo</span><br><span class="line">Gentoo</span><br><span class="line">Fedora</span><br><span class="line">Debian </span><br><span class="line">CentOS</span><br><span class="line">Arch</span><br></pre></td></tr></table></figure></p>
<h2 id="去除重复行"><a href="#去除重复行" class="headerlink" title="去除重复行"></a>去除重复行</h2><p>我们看到前面有两行的内容是重复的，即Gentoo行，使用-u参数可以去掉重复的行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort -u test1.txt</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch</span><br><span class="line">CentOS</span><br><span class="line">Debian </span><br><span class="line">Fedora</span><br><span class="line">Gentoo</span><br><span class="line">Kali</span><br><span class="line">OpenSuse</span><br><span class="line">redhat</span><br><span class="line">ubuntu</span><br></pre></td></tr></table></figure></p>
<p>在输出结果中，重复的Gentoo行被去掉了。</p>
<h2 id="按照数字排序"><a href="#按照数字排序" class="headerlink" title="按照数字排序"></a>按照数字排序</h2><p>假设有文本内容test2.txt如下，第一列为市值排名，第二列为公司名称，第三列为公司创建时间：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 google 1998</span><br><span class="line">10 icbc  1984</span><br><span class="line">5 tencent 1998</span><br><span class="line">1 apple 1976</span><br><span class="line">16 samsung 1938</span><br></pre></td></tr></table></figure></p>
<p>按照前面的介绍，我们对内容排序结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 icbc  1984</span><br><span class="line">16 samsung 1938</span><br><span class="line">1 apple 1976</span><br><span class="line">2 google 1998</span><br><span class="line">5 tencent 1998</span><br></pre></td></tr></table></figure></p>
<p>这不对啊，16怎么在1前面呢？很显然这是因为前面的排序都是字典排序，而我们实际需要的是按照数值大小进行排序，因此需要用到-n参数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort -n test2.txt</span><br></pre></td></tr></table></figure></p>
<p>最后的输出结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 apple 1976</span><br><span class="line">2 google 1998</span><br><span class="line">5 tencent 1998</span><br><span class="line">10 icbc  1984</span><br><span class="line">16 samsung 1938</span><br></pre></td></tr></table></figure></p>
<p>可以看到，最终结果按照市值排名打印出来。</p>
<h2 id="按照指定列排序"><a href="#按照指定列排序" class="headerlink" title="按照指定列排序"></a>按照指定列排序</h2><p>假如我们不想按照市值排名排序，而是按照公司名称排序呢？那么就需要按照指定列排序了。这里需要用到两个参数：</p>
<ul>
<li>-t 指定分隔符，未指定时，默认分隔符为空白</li>
<li>-k 指定列排序</li>
</ul>
<p>需要按照第二列，公司名称排序，因此排序命令如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort -k 2 test2.txt #默认以空白作为分隔符</span><br><span class="line">sort -k 2 -t &apos; &apos; sort2.txt #以空格为分隔符</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 apple 1976</span><br><span class="line">2 google 1998</span><br><span class="line">10 icbc  1984</span><br><span class="line">16 samsung 1938</span><br><span class="line">5 tencent 1998</span><br></pre></td></tr></table></figure></p>
<p>可以看到，最后会以第二列，即公司名称为依据排序输出。</p>
<h2 id="以多列为依据排序"><a href="#以多列为依据排序" class="headerlink" title="以多列为依据排序"></a>以多列为依据排序</h2><p>假设我们按照公司创建年份排序，如果年份相同，则按照公司名称排序，即分别以第三列，第二列为依据排序：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort -n -k 3 -k 2 test2.txt</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">16 samsung 1938</span><br><span class="line">1 apple 1976</span><br><span class="line">10 icbc  1984</span><br><span class="line">2 google 1998</span><br><span class="line">5 tencent 1998</span><br></pre></td></tr></table></figure></p>
<p>如果要按照年份降序排序，则只需加-r参数即可：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort -n -k 3r -k 2 test2.txt</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 google 1998</span><br><span class="line">5 tencent 1998</span><br><span class="line">10 icbc  1984</span><br><span class="line">1 apple 1976</span><br><span class="line">16 samsung 1938</span><br></pre></td></tr></table></figure></p>
<h2 id="按照特定列的特定字符排序"><a href="#按照特定列的特定字符排序" class="headerlink" title="按照特定列的特定字符排序"></a>按照特定列的特定字符排序</h2><p>假如我们想要按照公司名称的第二至第三个字符排序，可以使用下面的方式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort -t &apos; &apos; -k 2.2,2.3 test2.txt</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">16 samsung 1938</span><br><span class="line">10 icbc  1984</span><br><span class="line">5 tencent 1998</span><br><span class="line">2 google 1998</span><br><span class="line">1 apple 1976</span><br></pre></td></tr></table></figure></p>
<p>-k 2.2,2.2指定了按照第二列排序，并且是第二列的第二个字符开始，到第三个字符结束。可以看到，由于samsung的第二个字母是a而排在开头。如果是以第二个字符开始，到最后一个字符结束，则用下面的命令即可：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort -t &apos; &apos; -k 2.2 test2.txt</span><br></pre></td></tr></table></figure></p>
<h2 id="保存排序结果"><a href="#保存排序结果" class="headerlink" title="保存排序结果"></a>保存排序结果</h2><p>前面的排序命令仅仅是将排序结果打印到控制台，并没有修改源文件，如果想要将排序结果保存在文件中，需要使用-o参数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort test1.txt -o test1.txt #直接修改源文件</span><br><span class="line">sort test1.txt -o output.txt #输出到另外一个文件</span><br><span class="line">sort test1.txt &gt; output.txt #重定向到output.txt中</span><br></pre></td></tr></table></figure></p>
<p>如果想将排序结果保存在源文件中，只能使用-o参数，而如果是其他文件，既可以使用-o参数，也可以使用重定向。</p>
<h2 id="检查是否乱序"><a href="#检查是否乱序" class="headerlink" title="检查是否乱序"></a>检查是否乱序</h2><p>sort同样也可以用来检查文本内容是否已经是排好序的。<br>例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort -c test1.txt #打印结果，并告知无序开始的行数</span><br><span class="line">sort -C test1.txt #不打印结果，但是命令的返回结果为1</span><br></pre></td></tr></table></figure></p>
<h2 id="合并已排序的文本"><a href="#合并已排序的文本" class="headerlink" title="合并已排序的文本"></a>合并已排序的文本</h2><p>可以使用-m选项来合并已经排好序的文本，但不会重新排序。<br>例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort -m file1 file2</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是使用sort命令对文本进行排序的常见使用方法，更多内容可使用man命令进行查看。常见选项如下：</p>
<ul>
<li>-r 按照降序排列</li>
<li>-n 按照数值大小排列</li>
<li>-k 按照指定列排列</li>
<li>-t 指定分隔符</li>
<li>-u 去重</li>
<li>-o 输出结果到文件中</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言入坑指南-缓冲区溢出</title>
    <url>/2018/11/03/12764.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>缓冲区溢出通常指的是向缓冲区写入了超过缓冲区所能保存的最大数据量的数据。如果说之前所提到的一些问题可能只是影响部分功能的实现，那么缓冲区溢出将可能会造成程序运行终止，被不安全代码攻击等严重问题，因此我们不得不特别重视。<br><a id="more"></a></p>
<h2 id="一个缓冲区溢出的例子"><a href="#一个缓冲区溢出的例子" class="headerlink" title="一个缓冲区溢出的例子"></a>一个缓冲区溢出的例子</h2><p>对于下面的程序：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="string">"0123456789"</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(buff,p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buff);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义一个字符数组buff，数组长度为8，使用strcpy函数将p所指向的字符串常量拷贝到buff中。<br>运行程序，结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0123456789</span><br><span class="line">*** stack smashing detected ***: ./buff terminated</span><br><span class="line">已放弃 (核心已转储)</span><br></pre></td></tr></table></figure></p>
<p>可以看到，由于p所指向的字符串长度大于buff的长度，拷贝时由于缓冲区溢出而破坏了栈中的内容而导致程序终止。</p>
<p>实际上，有时候缓冲区溢出导致程序马上运行出错是幸运的，因为我们至少能够知道这里出错了。而不幸的情况是，如果超出buff的部分存储在了栈帧不属于它自己的位置，即覆盖了栈帧上存储的其他信息，就有可能导致程序在其他位置出错，造成问题难以定位。</p>
<p>当然也有很幸运的时候，那就是超出buff的部分存储在了未被使用的栈空间上。但是我们绝对不可以对此抱有侥幸心理。</p>
<h2 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h2><p>对于前面所示的例子中，我们可以很明显地看到要拷贝的字符串长度大于buff的长度，我们可以选择将buff的长度增大。但是实际编程中，我们经常难以察觉是否会超过缓冲区大小。<br>比如，对于gets函数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char buff[255];</span><br><span class="line">gets(buff);</span><br></pre></td></tr></table></figure></p>
<p>我们不会知道用户在控制台会输入多少字符，但是可以肯定的是，输入字符很有可能会超过255，甚至字符中包含了可以执行代码的字节编码（当然，编译器和操作系统有很多机制，例如栈随机化，栈破坏检测，限制可执行代码区域等来对抗缓冲区溢出攻击），这个时候，灾难就会发生了。</p>
<p>因此我们不应该使用像gets这样不安全的函数，而选择fgets这样的可替代函数。查看gets函数的手册发现，手册中甚至直言不讳地说道：Never use gets()。</p>
<p>同样的，库函数中还有一些也可能造成缓冲区溢出，我们应该尽量避免使用它们，而选择使用更加安全的版本。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>作用</th>
<th>不推荐使用函数</th>
<th>推荐使用函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>拷贝字符串</td>
<td>strcpy</td>
<td>strncpy</td>
</tr>
<tr>
<td>字符串比较</td>
<td>strcmp</td>
<td>strncmp</td>
</tr>
<tr>
<td>字符串连接</td>
<td>strcat</td>
<td>strncat</td>
</tr>
<tr>
<td>格式化字符串并存入缓冲区</td>
<td>sprintf</td>
<td>snprintf</td>
</tr>
<tr>
<td>读取字符串</td>
<td>gets</td>
<td>fgets</td>
</tr>
<tr>
<td>复制字符串</td>
<td>strdup</td>
<td>strndup</td>
</tr>
<tr>
<td>字符串比较忽略大小写</td>
<td>strcasecmp</td>
<td>strncasecmp</td>
</tr>
</tbody>
</table>
</div>
<p>其中推荐使用的函数特点是，限定了操作内容的大小，从而避免了缓冲区溢出。当然，可能也会带来另外一个问题，就是截断。<br>我们修改一下前面的程序：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="string">"01234567890123"</span>;</span><br><span class="line">    <span class="built_in">strncpy</span>(buff,p,<span class="keyword">sizeof</span>(buff));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buff);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01234567</span><br></pre></td></tr></table></figure></p>
<p>可以看到，虽然部分字符串没有被拷贝，但是避免了缓冲区溢出,程序不再异常终止。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>缓冲区溢出造成的危害非常大，可能导致程序运行终止或程序运行异常且难以定位问题。当然有时候，也能够正常运行，但我们不能够抱有侥幸心理。因此在实际编程中，尽量选择那些更加安全的函数来避免缓冲区溢出。而有些时候并不一定有更加安全的函数可替代，这种时候，我们需要自己特别关注。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>以下代码有什么问题：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> buff[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(buff,<span class="string">"0123456789"</span>);</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之旅-string</title>
    <url>/2018/11/01/53461.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>标准库类型string表示可变长字符序列，使用之前需要包含string头文件，它定义在命名空间std中。<br><a id="more"></a></p>
<h2 id="string初始化"><a href="#string初始化" class="headerlink" title="string初始化"></a>string初始化</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1   <span class="comment">//默认初始化，s1是一个空串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span>    <span class="comment">//S2是s1的副本</span></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> s2 </span>= s1    、、等价于s2(s1)</span><br><span class="line"><span class="built_in">string</span> s3 = (<span class="string">"hello"</span>) <span class="comment">//s3是“hello”的副本，但不包含最后的空字符 </span></span><br><span class="line"><span class="built_in">string</span> s3(<span class="string">"hello"</span>)   <span class="comment">//等价于s3 = ("hello")</span></span><br><span class="line"><span class="built_in">string</span> s4(n,<span class="string">'c'</span>)    <span class="comment">//s4初始化为连续n个c字符组成的串</span></span><br></pre></td></tr></table></figure>
<p>其中string s4的初始化等价于下面的语句：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string temp(8,&apos;a&apos;);</span><br><span class="line">string s5 = temp;</span><br></pre></td></tr></table></figure></p>
<p>如果使用=初始化一个变量，执行的是<strong>拷贝初始化</strong>编译器把等号右边的初始值拷贝到新创建的对象中，否则为<strong>直接初始化</strong>。</p>
<h2 id="string操作"><a href="#string操作" class="headerlink" title="string操作"></a>string操作</h2><h4 id="读写string"><a href="#读写string" class="headerlink" title="读写string"></a>读写string</h4><p>可以使用标准库中的iostream来读写string对象。<br>例如：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行程序，在控制台输入： Hello world。<br>输入和输出结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> Hello world</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure></p>
<p>可以看到，string对象会自动<strong>忽略开头的空白</strong>（空格符，换行符，制表符等）并从第一个真正的字符开始读起，直到遇到下一处空白。<br>注意，string对象的输入输出操作会返回运算符左侧运算对象，并将其作为结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cin &gt;&gt; s1 &gt;&gt; s2;</span><br></pre></td></tr></table></figure></p>
<p>也就是说，对于上面的表达式，在运算cin &gt;&gt; s1之后，返回cin，继续运算cin &gt;&gt; s2。最终会将第一个输入读到s1，第二个输入读到s2中。</p>
<h4 id="读取整行"><a href="#读取整行" class="headerlink" title="读取整行"></a>读取整行</h4><p>整行读取可以使用getline函数，getline的读取会<strong>保留输入时的空白</strong>，遇到换行符才结束（换行符也被读取进来了）。遇到空行时，读取到的是空串。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> line;</span><br><span class="line">    <span class="keyword">if</span>(getline(<span class="built_in">cin</span>,line))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; line;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; line;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输入输出结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HELLO                                                                              </span><br><span class="line">HELLO    HELLO</span><br></pre></td></tr></table></figure></p>
<p>可以看到：</p>
<ul>
<li>空字符也被读取进来了</li>
<li>换行符没有存储在string中，line两次打印被打印在了同一行</li>
</ul>
<h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><p>比较s1和s2所含的字符是否完全一样，可以使用下面的方式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s1 == s2</span><br></pre></td></tr></table></figure></p>
<p>string的大小比较是利用字符在字典序比较：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s1 &gt; s2</span><br><span class="line">s1 &lt;= s2</span><br></pre></td></tr></table></figure></p>
<h4 id="判断string对象是否为空串"><a href="#判断string对象是否为空串" class="headerlink" title="判断string对象是否为空串"></a>判断string对象是否为空串</h4><p>例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s.empty()  //返回布尔类型值</span><br></pre></td></tr></table></figure></p>
<h4 id="获取string对象长度"><a href="#获取string对象长度" class="headerlink" title="获取string对象长度"></a>获取string对象长度</h4><p>例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s.size()</span><br></pre></td></tr></table></figure></p>
<p>注意：这个表达式的返回值类型为string::size_type，它是一个<strong>无符号类型</strong>，因此避免用有符号类型，例如int来存储或者比较其长度。一个无符号数和一个负的有符号数比较大小时，有符号数会被转换为很大的无符号数，因此常常得到的结果就是这个无符号数小于这个负的有符号数。（可参考<a href="https://www.yanbinghu.com/2018/10/28/27555.html">C语言入坑指南-整型的隐式转换和溢出</a>）</p>
<h4 id="字符串相加"><a href="#字符串相加" class="headerlink" title="字符串相加"></a>字符串相加</h4><p>有以下几种方式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s1 + s2  //返回s1和s2的内容</span><br><span class="line">s1 + “world”  //返回s1和world的内容</span><br></pre></td></tr></table></figure></p>
<p>注意：字符字面值和string对象使用+运算符时，<strong>两侧运算对象至少一个是string</strong>。<br>下面的操作是<strong>非法</strong>的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strings s = &quot;hello&quot; + &quot;world&quot;;</span><br></pre></td></tr></table></figure></p>
<h4 id="字符串访问"><a href="#字符串访问" class="headerlink" title="字符串访问"></a>字符串访问</h4><p>要访问字符串中的字符，可直接使用下表运算符[]，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s[0]   //访问s的第一个字符</span><br><span class="line">s[s.size()-1] //访问s的最后一个字符</span><br></pre></td></tr></table></figure></p>
<p>遍历字符串，可使用for each：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(auto c : s)     //遍历s中的字符，每个字符赋给c遍历</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;  //打印c的值</span><br></pre></td></tr></table></figure></p>
<p>同样也可以使用常规方式<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">unsignen <span class="keyword">int</span> loop ;</span><br><span class="line"><span class="keyword">for</span>(loop = <span class="number">0</span>; loop &lt; s.size();loop++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s[loop] &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>C++中的string是一个对象，但字符串字面值并不是一个string对象</li>
<li>string的size函数返回值为无符号类型</li>
<li>string对象的比较可用==等操作符，比较的是字符串内容是否相同</li>
<li>两个字符串字面值不能直接使用+操作符</li>
</ul>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言入坑指南-整型的隐式转换与溢出</title>
    <url>/2018/10/28/27555.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们知道整型有无符号数和有符号数之分。如果我们对无符号数和有符号数处理不当，就可能造成难以预测的结果，尤其是在作为循环条件的时候，可能导致死循环。整型之间的运算还可能导致出现另外一个问题－溢出。本文将分别介绍它们。<br><a id="more"></a></p>
<h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>我们看一下下面的程序：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/*比较字符串的长度和a的大小*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(p) &gt; a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"len &gt; a\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"len &lt; a\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">strlen</span>(p));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序中，将字符“hello”的长度与-1进行比较，按照我们平常的认识，长度5肯定大于-1，最后应该会打印len &gt; a。但是事实是，最后的输出结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">len &lt; a</span><br><span class="line">5</span><br></pre></td></tr></table></figure></p>
<p>最后的结果出乎我们的意料，为什么结果会是len &lt; a？5明明大于-1啊！</p>
<p>原因在于<strong>有符号数与无符号数进行运算时，会发生隐式类型转换，有符号数会转换为无符号数</strong>。<br>我们查看strlen的手册可以知道，它的返回值为size_t类型，虽然我们不能确定它到底是long unsigned int（64位程序）还是unsigned int（32位程序），但可以确定的是，它是一个无符号数。因此作为一个有符号数的-1和一个无符号数len进行比较时，-1会被转换为无符号数。<br>而负数是以补码的形式存储的，-1在内存中存储的是11111111 11111111 11111111 11111111，而它转换为无符号数，就变得很大了，即4294967295。因此，最后比较的结果必然是 len &lt; a。</p>
<h2 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h2><p>溢出指的是计算产生的结果很大，超出了该类型所能表示的范围。例如，int所能表示的最大值为2147483647，如果两个数相加的结果大于它，那么就会发生溢出。我们想当然的可以用这种巧妙的办法来判断是否溢出：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d,%d"</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="keyword">if</span>(a+b &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"overflow\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,a+b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假如a和b的值都是正整数，按照我们前面的认识，如果发生了溢出，那么它是一个很大的数，而作为有符号数时，就是一个负数。既然如此，检测它们相加是否小于0不就可以知道是否溢出了吗？</p>
<p>虽然这个方法很多时候都能奏效，但不幸的是，溢出的结果是未定义的。也就是说，任何对于溢出后的假设都是不明智的。有些机器它的结果是可能是一个负数，但有的结果可能是一个代表溢出的特殊值，这个时候，这种检测方式就不再奏效了。</p>
<h2 id="溢出检测"><a href="#溢出检测" class="headerlink" title="溢出检测"></a>溢出检测</h2><p>我们可以通过下面的方式来检测溢出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(a &gt; INT_MAX - b)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;overflow\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们利用整型的最大值减去其中一个数，然后与另一个数进行比较。其中INT_MAX定义在limit.h头文件中，它表示整数的最大值。<br>当然，我们还可以通过下面的方式来检测：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if((unsigned int)a + (unsigned int)b &gt; INT_MAX)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;overflow\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将两个数都先转换成无符号数进行计算，运算后的结果与INT_MAX进行比较。</p>
<h2 id="尽量避免"><a href="#尽量避免" class="headerlink" title="尽量避免"></a>尽量避免</h2><p>虽然我们有方法来检测溢出，但是我们建议的是尽量去避免溢出的发生。可以通过下面的方式来避免：</p>
<ul>
<li>选择合适的数据类型，当你的数据较大可能会超出short int的范围时，你就不该选择short int，而应该选择int等所表示范围更大的类型。</li>
<li>在设计上尽量回避溢出。例如，要计算两个整数的平均值，我们想到的方法可能是(a+b)/2，但是这样却有溢出的风险，我们可以换一种方式：a-(a-b)/2，这种方式就回避了溢出的问题。</li>
</ul>
<p>当然对于不可避免的可能发生溢出的情况，我们需要进行检测并进行后处理，而非忽略。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于整型隐式转换和溢出相关内容，我们做一个总结：</p>
<ul>
<li>避免有符号数和无符号数直接进行算术运算。</li>
<li>一个很小的负数被转换成有符号数时，将会变得很大。因此一个无符号数和一个有符号负数的比较结果几乎是显而易见的。</li>
<li>溢出的结果是未定义的，不要期望对它做任何假设。</li>
<li>尽量避免溢出问题。</li>
<li>java中没有无符号数。</li>
</ul>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>基于第一个示例程序，有如下操作：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p[0] = &apos;H&apos;;  //操作1</span><br><span class="line">sizeof(p);   //操作2</span><br></pre></td></tr></table></figure></p>
<ul>
<li>操作1合法吗？为什么？</li>
<li>操作2的值是多少？</li>
<li>为什么-1在内存中的存储为全1？</li>
</ul>
<p>第一个问题的答案可以在<a href="https://www.yanbinghu.com/2018/10/23/2660.html">C语言入坑指南-数组</a>之谜中找到哦。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>如何理解Linux shell中“2&gt;&amp;1”</title>
    <url>/2018/10/26/9186.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有时候我们常看到类似这样的脚本调用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./test.sh  &gt; log.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure></p>
<p>这里的2&gt;&amp;1是什么意思？该如何理解？<br>先说结论：上面的调用表明将./test.sh的输出重定向到log.txt文件中，同时将标准错误也重定向到log.txt文件中。<br><a id="more"></a></p>
<h2 id="有何妙用"><a href="#有何妙用" class="headerlink" title="有何妙用"></a>有何妙用</h2><p>（如果已经明白是什么作用，可跳过此小节）<br>上面到底是什么意思呢？我们来看下面的例子，假如有脚本test.sh：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">date         #打印当前时间</span><br><span class="line">while true   #死循环</span><br><span class="line">do</span><br><span class="line">    #每隔2秒打印一次</span><br><span class="line">	sleep 2</span><br><span class="line">	whatthis    #不存在的命令</span><br><span class="line">	echo -e &quot;std output&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>脚本中先打印当前日期，然后每隔2秒执行whatthis并打印一段字符。由于系统中不存在whatthis命令，因此执行会报错。<br>假如我们想保存该脚本的打印结果，只需将test.sh的结果重定向到log.txt中即可：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./test.sh &gt; log.txt</span><br></pre></td></tr></table></figure></p>
<p>执行结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ubuntu$ ./test.sh &gt;log.txt</span><br><span class="line">./test.sh: 行 7: whatthis: 未找到命令</span><br></pre></td></tr></table></figure></p>
<p>我们明明将打印内容重定向到log.txt中了，但是这条错误信息却没有重定向到log.txt中。如果你是使用程序调用该脚本，当查看脚本日志的时候，将会<strong>完全看不到这条错误信息</strong>。而使用下面的方式则会将出错信息也重定向到log.txt中：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./test.sh  &gt; log.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure></p>
<p>以这样的方式调用脚本，可以很好的将错误信息保存，<strong>帮助我们定位问题</strong>。</p>
<h2 id="如何理解"><a href="#如何理解" class="headerlink" title="如何理解"></a>如何理解</h2><p>每个程序在运行后，都会至少打开三个文件描述符，分别是0：标准输入；1：标准输出；2：标准错误。<br>例如，对于前面的test.sh脚本，我们通过下面的步骤看到它至少打开了三个文件描述符：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./test.sh    #运行脚本</span><br><span class="line">ps -ef|grep test.sh  #重新打开命令串口，使用ps命令找到test.sh的pid</span><br><span class="line">hyb       5270  4514  0 19:20 pts/7    00:00:00 /bin/bash ./test.sh</span><br><span class="line">hyb       5315  5282  0 19:20 pts/11   00:00:00 grep --color=auto test.sh</span><br></pre></td></tr></table></figure></p>
<p>可以看到test.sh的pid为5270，进入到相关fd目录：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /proc/5270/fd   #进程5270所有打开的文件描述符信息都在此</span><br><span class="line">ls -l              #列出目录下的内容</span><br><span class="line">lrwx------ 1 hyb hyb 64 10月 26 19:23 0 -&gt; /dev/pts/7</span><br><span class="line">lrwx------ 1 hyb hyb 64 10月 26 19:23 1 -&gt; /dev/pts/7</span><br><span class="line">lrwx------ 1 hyb hyb 64 10月 26 19:20 2 -&gt; /dev/pts/7</span><br><span class="line">lr-x------ 1 hyb hyb 64 10月 26 19:23 255 -&gt; /home/hyb/workspaces/shell/test.sh</span><br></pre></td></tr></table></figure></p>
<p>可以看到，test.sh打开了0，1，2三个文件描述符。同样的，如果有兴趣，也可以查看其他运行进程的文件描述符打开情况，除非关闭了否则都会有这三个文件描述符。</p>
<p>那么现在就容易理解前面的疑问了，2&gt;&amp;1表明将文件描述2（标准错误输出）的内容重定向到文件描述符1（标准输出），为什么1前面需要&amp;？当没有&amp;时，1会被认为是一个普通的文件，有&amp;表示重定向的目标不是一个文件，而是一个文件描述符。在前面我们知道，test.sh &gt;log.txt又将文件描述符1的内容重定向到了文件log.txt，那么最终标准错误也会重定向到log.txt。我们同样通过前面的方法，可以看到test.sh进程的文件描述符情况如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lrwx------ 1 hyb hyb 64 10月 26 19:35 0 -&gt; /dev/pts/7</span><br><span class="line">l-wx------ 1 hyb hyb 64 10月 26 19:35 1 -&gt; /home/hyb/workspaces/shell/log.txt</span><br><span class="line">l-wx------ 1 hyb hyb 64 10月 26 19:35 2 -&gt; /home/hyb/workspaces/shell/log.txt</span><br><span class="line">lr-x------ 1 hyb hyb 64 10月 26 19:35 255 -&gt; /home/hyb/workspaces/shell/test.sh</span><br></pre></td></tr></table></figure></p>
<p>我们可以很明显地看到，<strong>文件描述符1和2都指向了log.txt文件</strong>，也就得到了我们最终想要的效果：<strong>将标准错误输出重定向到文件中</strong>。<br>它们还有两种等价写法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./test.sh  &gt;&amp; log.txt</span><br><span class="line">./test.sh  &amp;&gt; log.txt</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们总结一下前面的内容：</p>
<ul>
<li>程序运行后会打开三个文件描述符，分别是标准输入，标准输出和标准错误输出。</li>
<li>在调用脚本时，可使用2&gt;&amp;1来将标准错误输出重定向。</li>
<li>只需要查看脚本的错误时，可将标准输出重定向到文件，而标准错误会打印在控制台，便于查看</li>
<li><blockquote>
<blockquote>
<p>log.txt会将重定向内容追加到log.txt文件末尾。</p>
</blockquote>
</blockquote>
</li>
<li>通过查看/proc/进程id/fd下的内容，可了解进程打开的文件描述符信息。</li>
</ul>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>下面的调用会将标准错误输出重定向到文件中吗？为什么？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./test.sh 2&gt;&amp;1 &gt;log.txt</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言入坑指南-数组之谜</title>
    <url>/2018/10/23/2660.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在C语言中，数组和指针似乎总是“暧昧不清”，有时候很容易把它们混淆。本文就来理一理数组和指针之间到底有哪些异同。<br><a id="more"></a></p>
<h2 id="数组回顾"><a href="#数组回顾" class="headerlink" title="数组回顾"></a>数组回顾</h2><p>在分析之前，我们不妨回顾一下数组的知识。数组是可以存储一个固定大小的相同类型元素的顺序集合。为了便于我们说明，假设有以下数组声明：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a[5];</span><br><span class="line">char b[] = &quot;hello&quot;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>数组大小必须在编译期就作为一个常数确定下来。</li>
<li>但C99中引入了变长数组，允许数组的维度是表达式 ，但在数组分配内存时，其表达式的值可以被求出。</li>
<li>数组下标运算实际上都是通过指针进行的，也就是说a[4]与*(a+4)是等价的，甚至你会发现和4[a]也是一样的。</li>
<li>数组名一般代表了指向该数组下标为0的元素的指针，并且printf(“%s\n”,hello)与printf(“%s\n”,&amp;hello[0])等效。</li>
</ul>
<h2 id="数组和指针不相等"><a href="#数组和指针不相等" class="headerlink" title="数组和指针不相等"></a>数组和指针不相等</h2><p>考虑下面的声明：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int c[4]；//假设int占4字节</span><br><span class="line">int *d;</span><br></pre></td></tr></table></figure></p>
<p>对于上面的声明，编译器会给c预留内存空间4*4字节，并且数组名代表着指向数组第一个元素的指针。但对于d，却只为指针本身保留了内存空间。<br>所以此时有下面的操作：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c[3];        //合法</span><br><span class="line">*(c+3);      //合法</span><br><span class="line">*d;          //不合法，d指向了内存中不确定位置</span><br><span class="line">c++；        //不合法，一维数组名是指针常量，常量不可修改</span><br><span class="line">d++；        //可通过编译</span><br></pre></td></tr></table></figure></p>
<p>另外，下面的两种情况也是不一样的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char c[] = &quot;hello&quot;;</span><br><span class="line">char *d = &quot;hello&quot;;</span><br></pre></td></tr></table></figure></p>
<p>前者对字符数组a进行了初始化，后者将d指向了字符串常量。字符串常量存储在只读区，因此有下面的操作：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c[0] = &apos;H&apos;;  //合法，可修改数组内容</span><br><span class="line">*d = &apos;H&apos;;    //不合法，字符串常量内容不可更改</span><br><span class="line">d[0] = &apos;H&apos;   //不合法</span><br></pre></td></tr></table></figure></p>
<h2 id="数组名的含义"><a href="#数组名的含义" class="headerlink" title="数组名的含义"></a>数组名的含义</h2><p>绝大多数情况，数组名都代表着指向该数组中下标为0的元素的指针，但是有例外：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int e[4];//假设int为4字节</span><br><span class="line">sizeof(e);</span><br></pre></td></tr></table></figure></p>
<p>上面的sizeof(e)的值并非4或8（指针占用空间），而是4*4 = 16。也就是说，当数组名被用作运算符sizeof的参数时，它的计算结果是<strong>整个数组的大小</strong>，而非第一个元素的指针大小。<br>再来看下面这种情况：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int temp[5];</span><br><span class="line">&amp;temp + 1;</span><br><span class="line">temp + 1;</span><br></pre></td></tr></table></figure></p>
<p>在这里，&amp;temp指向整个数组，因此+1后指向了数组末尾，而temp指向数组第一个元素，+1后指向第二个元素。</p>
<h2 id="数组长度计算"><a href="#数组长度计算" class="headerlink" title="数组长度计算"></a>数组长度计算</h2><p>如何计算数组长度？考虑下面的代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int f[] = &#123;1,2,3,4,5,6&#125;;</span><br><span class="line">int *g = f;</span><br><span class="line">size_t len_f = sizeof(f)/sizeof(int)//正确计算方法</span><br><span class="line">size_t len_g = sizeof(g)/sizeof(int)</span><br></pre></td></tr></table></figure></p>
<p>上面的len_f和len_g的值相等吗？显然并不相等。事实上，只有len_f到了数组f的长度，而len_g的值并没有任何实际意义。</p>
<h2 id="不能作为参数的数组"><a href="#不能作为参数的数组" class="headerlink" title="不能作为参数的数组"></a>不能作为参数的数组</h2><p>所谓的数组不能作为参数，并不是指声明的数组不能作为参数传递，而是指当数组名作为参数时，数组名会被转换为指向该数组下标为0的元素的指针。<br>而下面的两种声明，其实也是等效的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size_t arrayLen(const int *arr);</span><br><span class="line">size_t arrayLen(const int arr[]);</span><br></pre></td></tr></table></figure></p>
<p>我们来看一个例子，说明数组作为参数的情况：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int arraySum(const int arr[])</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int loop = 0;</span><br><span class="line">    /*循环前计算好长度，提高性能*/</span><br><span class="line">    unsigned int len = sizeof(arr)/sizeof(int);</span><br><span class="line">    int sum = 0;</span><br><span class="line">    if(NULL == arr)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for(loop = 0; loop &lt; len; loop++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=arr[loop];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;   </span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a[] = &#123;1,2,3,4,5,6&#125;;</span><br><span class="line">    int sum = arraySum(a);</span><br><span class="line">    printf(&quot;arr sum is %d&quot;,sum);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们运行上面的程序，发现最终结果并不是我们预期的21，而是3。问题在于，a作为参数传入到arraySum中时，它是作为指针的，那么在函数内部计算sizeof(arr)自然只是得到了指针占用的内存大小。对于64位程序，这个大小是8，那么len的值为2，最终只计算了两个元素的和。</p>
<p>思考：该如何修改上面的程序才能得到正确的结果？</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们来总结一下前面的核心内容：</p>
<ul>
<li>数组下标运算实际上都是通过指针进行的。</li>
<li>数组名代表着指向该数组中下标为0的元素的指针，但有例外：sizeof(数组名)返回整个数组的大小，而非指针大小；&amp;数组名返回一个指向数组的指针，而不是指向该数组中下标为0的元素的指针的指针。</li>
<li>数组名作为参数时，数组名会被转换成指向该数组下标为0的元素的指针。</li>
<li>指针操作可能比下标操作效率高，但可维护性却不一定有下标操作好。</li>
<li>数组和指针不相等。</li>
</ul>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>下面的代码输出结果是什么？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    int a[5] = &#123;1,2,3,4,5&#125;;</span><br><span class="line">    int *p = (int*)(&amp;a+1);</span><br><span class="line">    printf(&quot;%d,%d&quot;,*(a+1),*(p-1));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>PC-lint-发现bugs</title>
    <url>/2018/10/21/37870.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>很多代码问题在编译阶段难以发现，只有在运行时才会暴露。即便是在运行时出现问题了，我们可能仍然需要费一番功夫才能最终找到代码的问题。幸运地是，我们可以利用一个工具在编译之前就可以发现这些问题。有了它，基本可以检查出代码中80%的非逻辑性错误。这就是本文要介绍的主角—PC-lint。<br><a id="more"></a></p>
<h3 id="PC-lint简介"><a href="#PC-lint简介" class="headerlink" title="PC-lint简介"></a>PC-lint简介</h3><p>PC-Lint 是GIMPEL SOFTWARE公司开发的C/C++软件代码静态分析工具。而所谓静态分析是指在不运行代码的方式下，通过词法分析、语法分析、控制流、数据流分析等技术对程序代码进行扫描，验证代码是否满足规范性、安全性、可靠性、可维护性等指标—摘自百科。也就是说，利用PC-lint对我们的代码进行扫描分析，在程序运行之前，就可以发现代码中隐藏的问题。PC-lint除了能够发现诸如未初始化变量、数组越界、内存泄漏等问题，还能提出许多对程序运行效率，空间等方面的改进点。下面就简单介绍一下如何使用PC-lint。</p>
<h3 id="如何使用PC-lint"><a href="#如何使用PC-lint" class="headerlink" title="如何使用PC-lint"></a>如何使用PC-lint</h3><p>PC-lint能够在Windows、MS-DOS和OS/2平台上使用，Linux平台可使用FlexeLint、Splint等替代工具。本文介绍仅PC-lint的使用。<br>注：PC-lint为商用软件。</p>
<p>安装方法不在此介绍，和其他普通软件的安装方式一样。安装完成后，在安装目录下会有lint-nt.exe程序。基本使用方法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lint-nt.exe -u files.lnt #执行之后扫描结果会显示在控制台</span><br></pre></td></tr></table></figure></p>
<p>其中files.lnt文件中的内容是需要扫描的源代码位置。<br>例如files.lnt文件内容如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:\pclint\lint\test\test.c</span><br><span class="line">D:\pclint\lint\test\main.c</span><br></pre></td></tr></table></figure></p>
<p>表明将会对main.c和test.c进行静态检查。<br>如果源文件比较多，那么将源文件添加带files.lnt中是一件很繁琐的事情，我们可以使用命令来得到我们的files.lnt文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir /S/B *.h *.c &gt; files.lnt</span><br></pre></td></tr></table></figure></p>
<h3 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h3><p>我们直接来看一个例子，看看PC-lint到底有哪些能耐。</p>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>); </span><br><span class="line">    <span class="keyword">int</span> loop;</span><br><span class="line">    <span class="keyword">for</span>(loop = <span class="number">0</span>;loop &lt;= len;loop++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += a[loop];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">15</span> == sum)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"sum = 15\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"sum != 15,sum=%d\n"</span>,sum);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码计算数组a的和，并且判断最后和是否等于15。</p>
<h4 id="lnt配置"><a href="#lnt配置" class="headerlink" title="lnt配置"></a>lnt配置</h4><p>我们的lnt文件files.lnt配置如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-wlib(0)     //对库文件不输出任何错误信息</span><br><span class="line">-iD:\pclint\include  //指定头文件路径</span><br><span class="line">D:\pclint\lint\test\main.c //我们的源代码文件</span><br></pre></td></tr></table></figure></p>
<p>由于我们的代码包含了stdio.h头文件，因此还需要stdio.h头文件，我把它放在了D:\pclint\include，并在lnt文件中指定了头文件的位置。另外，我们只需要扫描我们自己的源代码，因此使用了-wlib(0)来避免对库文件输出告警信息。</p>
<h4 id="扫描代码"><a href="#扫描代码" class="headerlink" title="扫描代码"></a>扫描代码</h4><p>执行命令:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:\pclint\lint&gt;lint-nt.exe -u .\test\files.lnt&gt;result.txt</span><br></pre></td></tr></table></figure></p>
<p>这里我们将结果重定向到了result.txt文件中，最后生成的result.txt内容如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--- Module:   D:\pclint\lint\test\main.c (C)</span><br><span class="line">                            _</span><br><span class="line">    for(loop = 0;loop &lt;= len;loop++)</span><br><span class="line">D:\pclint\lint\test\main.c  10  Warning 574: Signed-unsigned mix with</span><br><span class="line">    relational</span><br><span class="line">D:\pclint\lint\test\main.c  10  Info 737: Loss of sign in promotion from int to</span><br><span class="line">    unsigned int</span><br><span class="line">                      _</span><br><span class="line">        sum += a[loop];</span><br><span class="line">D:\pclint\lint\test\main.c  12  Warning 530: Symbol &apos;sum&apos; (line 7) not</span><br><span class="line">    initialized</span><br><span class="line">D:\pclint\lint\test\main.c  7  Info 830: Location cited in prior message</span><br><span class="line">                      _</span><br><span class="line">        sum += a[loop];</span><br><span class="line">D:\pclint\lint\test\main.c  12  Warning 661: Possible access of out-of-bounds</span><br><span class="line">    pointer (1 beyond end of data) by operator &apos;[&apos; [Reference: file</span><br><span class="line">    D:\pclint\lint\test\main.c: lines 8, 10, 12]</span><br><span class="line">D:\pclint\lint\test\main.c  8  Info 831: Reference cited in prior message</span><br><span class="line">D:\pclint\lint\test\main.c  10  Info 831: Reference cited in prior message</span><br><span class="line">D:\pclint\lint\test\main.c  12  Info 831: Reference cited in prior message</span><br><span class="line">                            _</span><br><span class="line">        printf(&quot;sum = 15\n&quot;);</span><br><span class="line">D:\pclint\lint\test\main.c  16  Warning 534: Ignoring return value of function</span><br><span class="line">    &apos;printf(const char *, ...)&apos; (compare with line 271, file</span><br><span class="line">    D:\pclint\include\stdio.h)</span><br><span class="line">D:\pclint\include\stdio.h  271  Info 830: Location cited in prior message</span><br><span class="line">                                        _</span><br><span class="line">        printf(&quot;sum != 15,sum=%d\n&quot;,sum);</span><br><span class="line">D:\pclint\lint\test\main.c  21  Warning 534: Ignoring return value of function</span><br><span class="line">    &apos;printf(const char *, ...)&apos; (compare with line 271, file</span><br><span class="line">    D:\pclint\include\stdio.h)</span><br><span class="line">D:\pclint\include\stdio.h  271  Info 830: Location cited in prior message</span><br></pre></td></tr></table></figure></p>
<h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>经过扫描之后，发现了代码中的很多问题。我们一一列举：</p>
<ul>
<li>第10行警告号574，提示有符号数和无符号数混用。我们确实将有符号数loop和无符号数len进行了比较。</li>
<li>第12行警告号530，sum未进行初始化。定义sum变量时，并未进行初始化。</li>
<li>第12行警告号661，提示可能出现数组越界。我们仔细审查代码就会发现，循环对a进行求值时，其循环条件应该是loop &lt; len而不是loop &lt;= len。</li>
<li>第16行，21行提示有返回值没有使用。我们调用printf函数之后，并没有必要使用其返回值，因此我们可以忽略这个警告。</li>
<li>第24行提示警告号527，return语句不可到达。由于前面的if-else结构，使得最后的return语句永远无法执行。<h4 id="问题修改"><a href="#问题修改" class="headerlink" title="问题修改"></a>问题修改</h4>前面这段代码是可以编译通过，并且运行的，但是经过PC-lint扫描之后却发现如此之多的问题。我们将发现的问题代码进行修改后如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/*lint -e&#123;534&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>); </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> loop;</span><br><span class="line">    <span class="keyword">for</span>(loop = <span class="number">0</span>;loop &lt; len;loop++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += a[loop];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">15</span> == sum)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"sum = 15\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"sum != 15,sum=%d\n"</span>,sum);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>最终PC-lint检查结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--- Module:   D:\pclint\lint\test\main.c (C)</span><br></pre></td></tr></table></figure></p>
<p>这里除了修改了我们确定的问题之外，还屏蔽了PC-lint的534号警告，因为我们确认这不会对我们的程序本意造成任何影响，因此使用/*lint -e{534}*/屏蔽了main函数的534号警告。PC-lint屏蔽警告的方法很多，这里不再详述。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过示例程序可以看出，PC-lint确实能够发现一些隐藏的问题，但实际上它的强大远不止我们前面所看到的那样，利用好PC-lint能够帮助我们在运行程序之前就发现很多难以察觉的问题。本文本意为介绍PC-lint的用途，因此对PC-lint的详细使用并没有做过多介绍，有兴趣的读者可以参考网上的资料进行配置学习，PC-lint所报的警告号都可以通过官方PC-lint错误码查看其含义，帮助修正我们的程序。</p>
<h3 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h3><ul>
<li>最原始的代码，运行结果是什么？为什么会出现这样的结果？</li>
<li>如果将sum定义为全局静态变量，并且将循环条件改为loop &lt; len，还会出现同样的结果吗？为什么？</li>
</ul>
<p>欢迎在留言区评论留言。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>PC-lint</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令-解压缩篇</title>
    <url>/2018/10/19/64149.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Linux常用命令中，有很多用于对文件的压缩或解压，本文将介绍这些解压缩命令中不常见却非常实用的用法。<br><a id="more"></a></p>
<h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p>tar是linux中最常用的解压缩命令。tar命令可用于处理后缀名为tar，tar.gz，tgz，.tar.Z，tar.bz2的文件。<br>涉及参数说明：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-c 建立新的压缩文件</span><br><span class="line">-r 添加文件到已经压缩的文件</span><br><span class="line">-u 添加改变了和现有的文件到已经存在的压缩文件</span><br><span class="line">-x 从压缩的文件中提取文件</span><br><span class="line">-t 显示压缩文件的内容</span><br><span class="line">-z 支持gzip解压文件</span><br><span class="line">-j 支持bzip2解压文件</span><br><span class="line">-v 显示操作过程</span><br><span class="line">-k 保留源有文件不覆盖</span><br><span class="line">-C 切换到指定目录</span><br><span class="line">-f 指定压缩文件</span><br><span class="line"></span><br><span class="line">--delete            删除包中文件</span><br><span class="line">--strip-components  去除目录</span><br><span class="line">--add-file          向包中添加文件</span><br></pre></td></tr></table></figure></p>
<h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><h4 id="归档tar包，不压缩"><a href="#归档tar包，不压缩" class="headerlink" title="归档tar包，不压缩"></a>归档tar包，不压缩</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -cvf test.tar test1.log test2.log #归档多个文件</span><br><span class="line">tar -cvf test.tar test/* 　#归档test目录下所有文件</span><br><span class="line">tar -cvf test.tar *.log 　#归档所有以.log结尾的文件</span><br></pre></td></tr></table></figure>
<p>由于这种方式不会进行压缩，仅做了归档，因此<strong>速度极快</strong>，同时占用空间也较大。</p>
<h4 id="归档并压缩为tar-gz或tar-bz2"><a href="#归档并压缩为tar-gz或tar-bz2" class="headerlink" title="归档并压缩为tar.gz或tar.bz2"></a>归档并压缩为tar.gz或tar.bz2</h4><p>这种方式打包对文件进行了压缩：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zcvf test.tar.gz file1 file2 #打包，并以gzip压缩</span><br><span class="line">tar -jcvf test.tar.bz2 file1 file2 #打包，并以bzip2压缩</span><br></pre></td></tr></table></figure></p>
<h4 id="查看压缩包中的文件"><a href="#查看压缩包中的文件" class="headerlink" title="查看压缩包中的文件"></a>查看压缩包中的文件</h4><p>如果不想解压，只是想查看压缩包中的文件内容，可以使用-t参数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -tvf test.tar #可查看test包中有哪些文件</span><br></pre></td></tr></table></figure></p>
<h4 id="打包后删除源文件"><a href="#打包后删除源文件" class="headerlink" title="打包后删除源文件"></a>打包后删除源文件</h4><p>有时候在打包后可能需要删除源文件，但一个个删除显得麻烦，我们可以使用—remove-files 选项：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zcvf test.tar.gz test.log --remove-files</span><br></pre></td></tr></table></figure></p>
<h6 id="打包除指定目录或文件以外的文件"><a href="#打包除指定目录或文件以外的文件" class="headerlink" title="打包除指定目录或文件以外的文件"></a>打包除指定目录或文件以外的文件</h6><p>对于某些目录下的文件，可能只需要打包部分文件，因此可以使用—exclude选项排除一些不需要打包的文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zcvf test.tar.gz --exclude=test/*.log test/* #打包test目录下所有文件，排除以.log结尾的文件</span><br></pre></td></tr></table></figure></p>
<p>这里用到了—exclude选项，支持通配符和正则表达式，因此也非常强大。</p>
<h4 id="向压缩包中更新文件"><a href="#向压缩包中更新文件" class="headerlink" title="向压缩包中更新文件"></a>向压缩包中更新文件</h4><p>例如，压缩包中已经打入了test以及其他文件，现在你只想更新压缩包中的test文件，那么你可以使用—add-file选项：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -tf test.tar --add-file=test #只针对tar包</span><br></pre></td></tr></table></figure></p>
<h4 id="向tar包中增加文件"><a href="#向tar包中增加文件" class="headerlink" title="向tar包中增加文件"></a>向tar包中增加文件</h4><p>向tar包中增加文件可使用-r参数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -rf test.tar testfile #在test.tar包中增加文件，只针对tar包</span><br></pre></td></tr></table></figure></p>
<h4 id="删除压缩包中的文件"><a href="#删除压缩包中的文件" class="headerlink" title="删除压缩包中的文件"></a>删除压缩包中的文件</h4><p>在不解压的情况下，可使用—delete选项删除包中的文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar --delete -f test.tar  test1 #从test.tar中删除test1文件</span><br></pre></td></tr></table></figure></p>
<h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><h4 id="解压tar-gz和tar包到当前目录"><a href="#解压tar-gz和tar包到当前目录" class="headerlink" title="解压tar.gz和tar包到当前目录"></a>解压tar.gz和tar包到当前目录</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xvf test.tar.gz</span><br><span class="line">tar -xvf test.tar</span><br></pre></td></tr></table></figure>
<h4 id="解压到指定目录"><a href="#解压到指定目录" class="headerlink" title="解压到指定目录"></a>解压到指定目录</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xvf test.tar.gz -C dir</span><br><span class="line">tar -xvf test.tar -C dir</span><br></pre></td></tr></table></figure>
<h4 id="解压包中指定的文件"><a href="#解压包中指定的文件" class="headerlink" title="解压包中指定的文件"></a>解压包中指定的文件</h4><p>例如test.tar.gz包中文件情况如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.txt</span><br><span class="line">log/</span><br><span class="line">log/1.log</span><br><span class="line">log/2.log</span><br><span class="line">log/2.log</span><br><span class="line">log/4.log</span><br><span class="line">log/5.log</span><br></pre></td></tr></table></figure></p>
<p>如果我们只需要解压出log目录下的1.log，只需要执行下面的命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xvf test.tar.gz log/1.log</span><br><span class="line">tar -xvf test.tar.gz log/1.log -C test #将1.log解压到test目录</span><br></pre></td></tr></table></figure></p>
<h4 id="解压时去掉目录结构"><a href="#解压时去掉目录结构" class="headerlink" title="解压时去掉目录结构"></a>解压时去掉目录结构</h4><p>压缩包中的文件可能存在多级目录，常规方式解压出来后，对应目录也会存在.如果只想要压缩包的文件，可以去掉目录结构（注意：同一文件夹下文件名不能重）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xvf test.tar.gz --strip-components=1 #去掉一层目录</span><br></pre></td></tr></table></figure></p>
<h4 id="解压时不覆盖原文件"><a href="#解压时不覆盖原文件" class="headerlink" title="解压时不覆盖原文件"></a>解压时不覆盖原文件</h4><p>当前目录可能已经存在包中的文件，如果不想解压出来的文件覆盖当前已存在的文件，可使用-k参数（会抛出错误信息）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xvkf test.tar.gz</span><br></pre></td></tr></table></figure></p>
<h4 id="特别提醒"><a href="#特别提醒" class="headerlink" title="特别提醒"></a>特别提醒</h4><p>前面所提到的解压或者压缩带的f参数需要放在最后，因为它指定了压缩包名字，否则会出现解压或压缩失败。</p>
<h2 id="zip-unzip"><a href="#zip-unzip" class="headerlink" title="zip/unzip"></a>zip/unzip</h2><p>zip和unzip命令主要用于处理zip包。</p>
<h3 id="压缩-1"><a href="#压缩-1" class="headerlink" title="压缩"></a>压缩</h3><p>涉及参数说明：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-d 从压缩文件内删除指定的文件。</span><br><span class="line">-f 此参数的效果和指定&quot;-u&quot;参数类似，但不仅更新既有文件，如果某些文件原本不存在于压缩文件内，使用本参数会一并将其加入压缩文件中。</span><br><span class="line">-j 只保存文件名称及其内容，而不存放任何目录名称。</span><br><span class="line">-r 递归处理，将指定目录下的所有文件和子目录一并处理。</span><br><span class="line">-u 更换较新的文件到压缩文件内。</span><br><span class="line">-v 显示指令执行过程或显示版本信息。</span><br><span class="line">-y 直接保存符号连接，而非该连接所指向的文件，本参数仅在UNIX之类的系统下有效。</span><br><span class="line">- &lt;压缩效率&gt; 压缩效率是一个介于1-9的数值。</span><br></pre></td></tr></table></figure></p>
<h4 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zip -r test.zip test/ #打包test目录下的文件</span><br><span class="line">zip -rj test.zip test/ #打包test目录下文件，且压缩包不带test目录</span><br></pre></td></tr></table></figure>
<h4 id="指定压缩率打包文件"><a href="#指定压缩率打包文件" class="headerlink" title="指定压缩率打包文件"></a>指定压缩率打包文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zip -r8 test.zip test/* #数值（1-9）越大，压缩率越高，耗时越长</span><br></pre></td></tr></table></figure>
<h4 id="打包符号链接文件"><a href="#打包符号链接文件" class="headerlink" title="打包符号链接文件"></a>打包符号链接文件</h4><p>前面的命令只能打包普通文件，如果想要打包符号链接文件，则需要使用参数-y：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zip  -ry test.zip test</span><br></pre></td></tr></table></figure></p>
<h4 id="向压缩包中增加或更新文件"><a href="#向压缩包中增加或更新文件" class="headerlink" title="向压缩包中增加或更新文件"></a>向压缩包中增加或更新文件</h4><p>有时候需要向压缩包中增加文件，但又不想重新解压打包，可以使用参数-u：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zip -u test.zip test2 #向test.zip 包中增加test2文件</span><br></pre></td></tr></table></figure></p>
<h6 id="压缩时加密"><a href="#压缩时加密" class="headerlink" title="压缩时加密"></a>压缩时加密</h6><p>压缩时如果需要对压缩包进行加密，可使用-P参数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zip -r test.zip test1 test -P 66666 #使用密码66666加密</span><br></pre></td></tr></table></figure></p>
<h4 id="删除压缩包的特定文件"><a href="#删除压缩包的特定文件" class="headerlink" title="删除压缩包的特定文件"></a>删除压缩包的特定文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zip -d test.zip test  #删除test.zip包中的test文件</span><br></pre></td></tr></table></figure>
<h3 id="解压-1"><a href="#解压-1" class="headerlink" title="解压"></a>解压</h3><p>涉及参数说明：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-l 显示压缩文件内所包含的文件</span><br><span class="line">-j 只保存文件名称及其内容，而不存放任何目录名称。</span><br><span class="line">-o 以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该</span><br><span class="line">-v 显示指令执行过程或显示版本信息。</span><br><span class="line">-d 指定解压目录，目录不存在会创建</span><br></pre></td></tr></table></figure></p>
<h4 id="查看压缩包中的文件信息"><a href="#查看压缩包中的文件信息" class="headerlink" title="查看压缩包中的文件信息"></a>查看压缩包中的文件信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unzip -l test.zip #可以看到压缩包中的文件名，日期等信息</span><br><span class="line">unzip -v test.zip #查看更多信息，例如crc校验信息等</span><br></pre></td></tr></table></figure>
<h4 id="解压压缩包"><a href="#解压压缩包" class="headerlink" title="解压压缩包"></a>解压压缩包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unzip -o test.zip -d dir #讲test.zip解压到dir目录</span><br></pre></td></tr></table></figure>
<h4 id="解压包中指定的文件-1"><a href="#解压包中指定的文件-1" class="headerlink" title="解压包中指定的文件"></a>解压包中指定的文件</h4><p>如果不知道需要解压的文件名，可先查看包中的文件，然后使用下面的方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unzip -o test.zip &quot;1.log&quot; -d dir #解压包中的1.log文件到dir目录</span><br><span class="line">unzip -o tet.zip &quot;*.log&quot; -d dir  #解压包中所有的log文件</span><br></pre></td></tr></table></figure></p>
<h4 id="解压时去掉目录结构-1"><a href="#解压时去掉目录结构-1" class="headerlink" title="解压时去掉目录结构"></a>解压时去掉目录结构</h4><p>压缩包中有多层目录结构，普通解压仍然会保留目录结构，如果只想要压缩包中的文件，可以使用-j参数:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zip -oj test.zip -d ./temp</span><br></pre></td></tr></table></figure></p>
<h4 id="解压jar包"><a href="#解压jar包" class="headerlink" title="解压jar包"></a>解压jar包</h4><p>jar包是java归档包，但同样可用unzip解压查看里面的文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unzip -o java.jar -d dir</span><br></pre></td></tr></table></figure></p>
<h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2><p>涉及参数说明：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-k 保留源文件</span><br><span class="line">-d 解开压缩文件</span><br><span class="line">-r 递归处理，将指定目录下的所有文件及子目录一并处理</span><br><span class="line">-v 显示指令执行过程</span><br></pre></td></tr></table></figure></p>
<p>tar命令带有-z参数，并且打包成tar.gz文件时，便调用gzip进行了压缩。gzip对文本的压缩率约有60%~70%，压缩包文件常以gz为后缀。使用-k参数保留源文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip -k ./* #当前目录下所有文件进行压缩，每个文件一个gz包</span><br><span class="line">gzip -rkv ./* 递归压缩</span><br></pre></td></tr></table></figure></p>
<p>解压也很简单：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip -dv test.gz</span><br></pre></td></tr></table></figure></p>
<h2 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h2><p>tar命令使用-j参数将文件打包为tar.bz2时，便调用了bzip2进行压缩。bzip2压缩或解压后，会将源文件删除。如果需要保留源文件，可使用-k参数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bzip2 -zk test  #压缩test文件</span><br><span class="line">bzip2 -dk test.bz2  #解压</span><br></pre></td></tr></table></figure>
<h2 id="rar-unrar"><a href="#rar-unrar" class="headerlink" title="rar/unrar"></a>rar/unrar</h2><p>rar和unrar命令并非linux发行版自带命令，需要另外安装。常见用法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rar a test.tar test  #将test文件压缩为test.tar</span><br><span class="line">rar e test.rar       #解压test.tar</span><br><span class="line">unrar x test.rar     #解压test.tar</span><br></pre></td></tr></table></figure></p>
<h2 id="压缩率比较"><a href="#压缩率比较" class="headerlink" title="压缩率比较"></a>压缩率比较</h2><p>压缩率一般来说：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar.bz2&gt;tar.gz&gt;zip&gt;tar</span><br></pre></td></tr></table></figure></p>
<p>压缩率越高，压缩以及解压的时间也就越长。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对文件进行压缩能够节省磁盘空间，进行网络传输时，也能节省带宽，但是需要注意的是，空间和时间是需要根据实际应用进行权衡的。解压缩命令较多，为避免在其他平台使用不便，可选择常用命令进行压缩文件。有任何补充或建议，欢迎留言。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言入坑指南-“悬挂”else</title>
    <url>/2018/10/16/23869.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>if语句在编程中常用于构成分支结构，是我们最熟悉的语句之一。但如果编程习惯不当，并且出现if嵌套时，就可能造成难以排查的问题。本文将介绍“悬挂”else问题。<br><a id="more"></a></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>我们来看一下下面的程序，程序本意为，如果a是-，并且b大于c，则计算e = b-c的值；如果a不是-，则计算e = b+c的值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="string">'+'</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> e = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">'-'</span> == a)</span><br><span class="line">        <span class="keyword">if</span>(b &gt; c)</span><br><span class="line">            e = b - c;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        e = b + c;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"e=%d\n"</span>,e);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照我们的预期，else应该与第一个if结合，其结果应该是计算了b+c的值,即打印e=3。但事实并非如此。C语言并不像Python那样靠缩进来分隔代码块，也就是说，缩进不影响代码结构。对于上面的代码，还可以排版如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="string">'+'</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> e = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">'-'</span> == a)</span><br><span class="line">        <span class="keyword">if</span>(b &gt; c)</span><br><span class="line">            e = b - c;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            e = b + c;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" e = %d\n"</span>,e);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">在这种情况下，意思似乎又大不相同了。由于a不等于-，因此既不会计算b - c，也不会计算b+c，最后e的值仍然为<span class="number">0</span>，也就是我们所运行的结果。</span><br><span class="line"></span><br><span class="line">## “悬挂”<span class="keyword">else</span></span><br><span class="line">这就是所谓的“悬挂”<span class="keyword">else</span>问题。**<span class="keyword">else</span>始终与同一对括号内最近的未匹配的<span class="keyword">if</span>结合**，因此在示例程序中，<span class="keyword">else</span>会与第二个<span class="keyword">if</span>结合，而由于不满足‘-’ == a的条件，因此最后e的值仍然为<span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">## 如何避免</span><br><span class="line">避免方法也相当简单，就是<span class="keyword">if</span>或<span class="keyword">else</span>条件后的语句块用大括号“封装”起来。按照该方法修改后的代码如下：</span><br><span class="line">```c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="string">'+'</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> e = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">'-'</span> == a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &gt; c)</span><br><span class="line">        &#123;</span><br><span class="line">            e = b - c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        e = b + c;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"e=%d\n"</span>,e);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>修改后的程序虽然变得稍长，但结构清晰，最重要的是，能够得到我们想要的结果。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>下面的代码运行结果是什么？为什么？欢迎留言评论。<br>代码一：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="string">'+'</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> e = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">'-'</span> == a);</span><br><span class="line">        <span class="keyword">if</span>(b &gt; c)</span><br><span class="line">            e = b - c;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            e = b + c;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" e = %d\n"</span>,e);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码二：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b )</span><br><span class="line">        retVal = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b = a + b;</span><br><span class="line">        retVal = b;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = test(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于代码比较简单，可能比较容易发现问题，但是当代码复杂时，这样的问题就不那么容易被发现了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>良好的编程习惯能够在编码阶段就避免一些不必要的问题。</p>
<p>参考书籍《C陷阱与缺陷》</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言的main函数到底该怎么写？</title>
    <url>/2018/10/13/3168.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>main函数是程序启动后执行的第一个自定义函数，从开始学习C语言到现在，我们似乎看到了很多个版本的main函数，那么哪一种才是正确的呢？我们先来看看目前有哪些版本。<br><a id="more"></a></p>
<h2 id="main函数版本"><a href="#main函数版本" class="headerlink" title="main函数版本"></a>main函数版本</h2><p>第一种，没有返回值，没有参数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main()</span><br></pre></td></tr></table></figure></p>
<p>在C89标准中，这种写法是可以接受的，而使用现在的编译器编译时，会报警告，并且会将其返回值默认为int。实际上，如果函数没有显式声明返回类型，那么编译器会将返回值默认为int。</p>
<p>第二种，返回值为void，没有参数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void main()</span><br></pre></td></tr></table></figure></p>
<p>查看了C89/C99/C11相关文档，并没有发现相关踪迹。但是为何这么多初学者使用？main函数的返回值最终会作为程序的退出状态，而一旦声明为void，在程序退出后，想要获取其退出状态也就不可以了。因此不建议其返回值为void。</p>
<p>第三种，返回值为int，没有参数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()</span><br></pre></td></tr></table></figure></p>
<p>这也是很常见的一种。虽然其声明没有入参，实际调用却可以传入参数，看下面的例子：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    test(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>test函数虽然声明为无入参，但调用时却是可以传入任何参数或不传参数的。</p>
<p>第四种，返回值为int，参数为void<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(void)</span><br></pre></td></tr></table></figure></p>
<p>这是常见的一种写法。形参为void，表明它在调用的时候不能传入任何参数，那么它也就不能获取命令行参数了。</p>
<p>第五种，返回值为int，有两个入参：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int argc,char *argv[])</span><br></pre></td></tr></table></figure></p>
<p>这也是最常见的一种写法。第一个入参为命令行参数个数，第二个入参为命令行参数数组。通常用于实现需要从命令行获取参数的功能。</p>
<p>第六种，返回值为int，有三个入参,分别为命令行参数个数，命令参数数组，环境变量数组：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int argc,char *argv[],char *envp[]</span><br></pre></td></tr></table></figure></p>
<p>这种和第五种相似，但多个一个参数，用于获取环境变量，这种形式多源于编译器的扩展。但全局变量environ可以代替envp的作用 ，获取或者设置环境变量可以使用getenv或putenv，因此也不建议使用该形式。</p>
<p>没想到吧，仔细数一数竟然有这么种写法？但是真相究竟如何？到底使用哪种呢？</p>
<h2 id="真相大白"><a href="#真相大白" class="headerlink" title="真相大白"></a>真相大白</h2><p>C89/C99/C11标准文档中只提供了两种main函数的写法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(void) &#123; /* ... */ &#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123; /* ... */ &#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是说，其他的写法都是不符合标准的，有些的是历史遗留问题，有的是部分编译器扩展。当然对于带参数的写法，其参数名可自定义。另外对于除标准提供的以外的写法，不同的编译器有不同的处理策略，有的可能编译不过，有的可能报警告，但一个“正经”的编译器是不会对标准提供的形式产生质疑的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们已经知道了c语言main函数的写法，我们来总结一下前面的内容：</p>
<ul>
<li>C标准只提供了两种main的形式，即前面提到的第四种和第五种。</li>
<li>为了代码的通用可移植性，建议采用标准提供的形式。</li>
<li>不需要命令行参数可采用第四种，需要命令行参数采用第五种。</li>
<li>如果一个函数确定无需传入任何参数，那么用void限定是一个不错的选择。</li>
<li>函数没有声明返回值时，编译器默认其返回值为int。</li>
</ul>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>hello程序是如何变成可执行文件的</title>
    <url>/2018/10/10/27133.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>hello程序几乎是我们每个人学习C语言写的第一个程序，但是它是如何从.c文本变成可以打印出”hello world“的可执行文件的呢？本文将简单介绍其过程。<br><a id="more"></a></p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>hello world程序我们再熟悉不过：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*include head file*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/*the main function*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译并运行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -o helloWorld helloWorld.c </span><br><span class="line">./helloWorld</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure></p>
<p>整个过程一气呵成，但是实际上上面的过程并非像看起来那么简单。它可以大体分为4个步骤：<strong>预处理，编译，汇编，链接</strong>。接下来我们一一简单介绍这四个步骤做了什么。</p>
<h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>预处理主要是处理源代码中以#开头的指令（#pragma 除外），例如本文hello world程序中的#include<stdio.h>，预处理之后会将stdio.h的内容插入到预处理指令的位置。<br>想要只生成预处理之后的内容，可以使用下面的方式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -E -o helloWorld.i helloWorld.c #-E参数表示只进行预处理</span><br></pre></td></tr></table></figure></stdio.h></p>
<p>生成的helloWorld.i即为预处理之后的内容，有兴趣的可以打开文件查看里面的内容，会发现stdio.h的位置被其实际内容所替代。预处理之后，注释内容也会被删除，宏定义会被展开。</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>预处理之后就需要对生成的预处理文件进行词法分析，语法分析，语义分析，最终产生<strong>汇编代码</strong>文件，说白点可以简单理解为将C代码“翻译”成汇编代码。该过程是核心同时也是较复杂的一个过程。我们可以通过命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -S -o helloWorld.s helloWorld.c #-S参数表示只到生成汇编为止</span><br><span class="line">cat helloWorld.s</span><br><span class="line">	.file	&quot;helloWorld.c&quot;</span><br><span class="line">	.section	.rodata</span><br><span class="line">.LC0:</span><br><span class="line">	.string	&quot;Hello World!&quot;</span><br><span class="line">	.text</span><br><span class="line">	.globl	main</span><br><span class="line">	.type	main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset 16</span><br><span class="line">	.cfi_offset 6, -16</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register 6</span><br><span class="line">	subq	$16, %rsp</span><br><span class="line">	movl	%edi, -4(%rbp)</span><br><span class="line">	movq	%rsi, -16(%rbp)</span><br><span class="line">	movl	$.LC0, %edi</span><br><span class="line">	call	puts</span><br><span class="line">	movl	$0, %eax</span><br><span class="line">	leave</span><br><span class="line">	.cfi_def_cfa 7, 8</span><br><span class="line">	ret</span><br><span class="line">	.cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">	.size	main, .-main</span><br><span class="line">	.ident	&quot;GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.10) 5.4.0 20160609&quot;</span><br><span class="line">	.section	.note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure></p>
<p>上面的内容即为编译之后得到的汇编代码。</p>
<h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>汇编是将汇编代码翻译成机器可执行的指令，生成目标文件。整个过程较为简单，几乎只是按照汇编指令和机器指令进行一一翻译。我们可以用下面的命令获得汇编后的内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc  -o  helloWorld.o   -c helloWorld.c</span><br><span class="line">od helloWorld.o  #查看二进制内容</span><br><span class="line">0000000 042577 043114 000402 000001 000000 000000 000000 000000</span><br><span class="line">0000020 000001 000076 000001 000000 000000 000000 000000 000000</span><br><span class="line">0000040 000000 000000 000000 000000 001260 000000 000000 000000</span><br><span class="line">0000060 000000 000000 000100 000000 000000 000100 000015 000012</span><br><span class="line">0000100 044125 162611 101510 010354 076611 044374 072611 137760</span><br><span class="line">（其他内容未显示）</span><br></pre></td></tr></table></figure></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>链接是以某种方式将各个目标文件整个在一起，生成最后的可执行文件。我们的hello程序中调用了printf函数，但是并不存在于helloWorld.o中，而是存在于libc.so或libc.a中。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -o helloWorld helloWorld.c</span><br></pre></td></tr></table></figure></p>
<p>执行上面的命令之后，就得到了我们的helloWorld程序了。<br>我们通过ldd命令看到helloWorld程序链接了系统的库：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ldd helloWorld</span><br><span class="line">	linux-vdso.so.1 =&gt;  (0x00007ffe9ef11000)</span><br><span class="line">	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f0d9f038000)</span><br><span class="line">	/lib64/ld-linux-x86-64.so.2 (0x00007f0d9f402000)</span><br></pre></td></tr></table></figure></p>
<p>有兴趣的也可以尝试一下，如果删除系统中的libc.so库（记得事先备份），发现能够编译过，却在最后链接失败。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>我们大致总结整个编译过程如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st=&gt;start: .c源程序</span><br><span class="line">e=&gt;end</span><br><span class="line">op1=&gt;operation: 预处理将.c处理为.i（处理后的源程序）</span><br><span class="line">op2=&gt;operation: 编译器将.i编译为.s（汇编程序）</span><br><span class="line">op3=&gt;operation: 汇编器将.s汇编成.o（可重定位目标文件）</span><br><span class="line">op4=&gt;operation: 链接器将可重定位文件链接成可执行文件</span><br><span class="line">st-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>而正是由于整个编译过程分阶段进行，我们可以看到不同类型的问题在不同阶段出现并且有先后顺序。正因如此，链接问题在编译的最后阶段才会出现。</p>
<ul>
<li>gcc编译系统本身调用了很多其他相关工具，可以加上—verbose观察其详细编译过程，发现gcc命令调用了预处理器，编译器，汇编器，链接器等命令。</li>
</ul>
<p>本文只是粗略介绍其整个过程，更多地了解编译过程能够帮助我们优化代码、处理令人困扰的链接问题或避免安全漏洞，本文不展开介绍具体的编译过程。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>一个奇怪的链接问题</title>
    <url>/2018/10/06/46212.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>链接是代码生成可执行文件中一个非常重要的过程。我们在使用一些库函数时，有时候需要链接库，有时候又不需要，这是为什么呢？了解一些链接的基本过程，能够帮助我们在编译时解决一些奇怪的问题。比如，下面就有一种奇怪的现象。<br><a id="more"></a></p>
<h2 id="一个奇怪的链接问题"><a href="#一个奇怪的链接问题" class="headerlink" title="一个奇怪的链接问题"></a>一个奇怪的链接问题</h2><p>程序功能很简单，计算e的n次方。程序清单如下（代码一）：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> a = <span class="built_in">exp</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lf\n"</span>,a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -o expTest expTest.c</span><br><span class="line">./expTest</span><br><span class="line">7.389056</span><br></pre></td></tr></table></figure></p>
<p>一切似乎顺理成章，我们再来看下面这种情况（代码二）：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">double</span> a = <span class="built_in">exp</span>(b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lf\n"</span>,a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -o expTest expTest.c</span><br><span class="line">/tmp/ccx5lXbS.o：在函数‘main’中：</span><br><span class="line">expTest.c:(.text+0x20)：对‘exp’未定义的引用</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure></p>
<p>我们发现，同样的编译方法编译不过了，提示对‘exp’未定义的引用，并且抛出链接出错。</p>
<p>我们通过man命令查看exp函数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">man 3 exp</span><br><span class="line">NAME</span><br><span class="line">       exp, expf, expl - base-e exponential function</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">       double exp(double x);</span><br><span class="line">       float expf(float x);</span><br><span class="line">       long double expl(long double x);</span><br><span class="line"></span><br><span class="line">       Link with -lm.</span><br></pre></td></tr></table></figure></p>
<p>发现它除了需要包含头文件math.h外，编译时还需要使用-lm链接。<br>再次编译运行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -lm -o  expTest expTest.c </span><br><span class="line">/tmp/ccYT3E65.o：在函数‘main’中：</span><br><span class="line">expTest.c:(.text+0x20)：对‘exp’未定义的引用</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure></p>
<p>为什么还是不行呢？我们已经按照帮助手册的只是加了-lm了啊？难道是位置不对？我们换个位置试试：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -o  expTest expTest.c -lm </span><br><span class="line">./expTest</span><br><span class="line">7.389056</span><br></pre></td></tr></table></figure></p>
<p>现在终于成功编译并运行。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>虽然最后终于成功编译运行，但是不免产生了几个疑问：</p>
<ul>
<li>两段代码同样都调用了exp函数，为什么一个需要链接，一个不需要链接呢？</li>
<li>到底什么时候需要链接呢？</li>
<li>为什么链接的时候放在前面就不行呢？</li>
</ul>
<p>我们一一解答。<br>1.为什么一个需要链接，一个不需要？<br>我们可以观察到，代码一调用exp传入的参数是常量2，代码二调用exp传入的参数是变量b，那么对于代码一会不会在运行之前就计算好了呢？<br>我们来看一下它们的汇编代码。<br>代码一：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.LC1:</span><br><span class="line">        .string &quot;%lf\n&quot;</span><br><span class="line">main:</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        sub     rsp, 32</span><br><span class="line">        mov     DWORD PTR [rbp-20], edi</span><br><span class="line">        mov     QWORD PTR [rbp-32], rsi</span><br><span class="line">        movsd   xmm0, QWORD PTR .LC0[rip]</span><br><span class="line">        movsd   QWORD PTR [rbp-8], xmm0</span><br><span class="line">        movsd   xmm0, QWORD PTR [rbp-8]</span><br><span class="line">        mov     edi, OFFSET FLAT:.LC1</span><br><span class="line">        mov     eax, 1</span><br><span class="line">        call    printf</span><br><span class="line">        mov     eax, 0</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br><span class="line">.LC0:</span><br><span class="line">        .long   3100958126</span><br><span class="line">        .long   1075678820</span><br></pre></td></tr></table></figure></p>
<p>代码二：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.LC0:</span><br><span class="line">        .string &quot;%lf\n&quot;</span><br><span class="line">main:</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        sub     rsp, 32</span><br><span class="line">        mov     DWORD PTR [rbp-20], edi</span><br><span class="line">        mov     QWORD PTR [rbp-32], rsi</span><br><span class="line">        mov     DWORD PTR [rbp-4], 2</span><br><span class="line">        cvtsi2sd        xmm0, DWORD PTR [rbp-4]</span><br><span class="line">        call    exp</span><br><span class="line">        movq    rax, xmm0</span><br><span class="line">        mov     QWORD PTR [rbp-16], rax</span><br><span class="line">        movsd   xmm0, QWORD PTR [rbp-16]</span><br><span class="line">        mov     edi, OFFSET FLAT:.LC0</span><br><span class="line">        mov     eax, 1</span><br><span class="line">        call    printf</span><br><span class="line">        mov     eax, 0</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure></p>
<p>汇编的具体细节我们无需尽知，但是我们可以很明显地看到，第二段代码调用了exp函数（call exp指令），而第一段代码没有看到调用exp的身影。<br>实际上，通过汇编代码可以看到，当传入参数为常量时，就已经计算好了值（emm0寄存器为浮点运算相关寄存器），最后根本不需要调用exp函数。而对于变量型的参数，其值在运行时确定，因此需要调用。我们还可以通过ldd命令来看它们链接的库有什么不同。<br>对于代码一：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ldd expTest</span><br><span class="line">	linux-vdso.so.1 =&gt;  (0x00007ffec079d000)</span><br><span class="line">	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fd327744000)</span><br><span class="line">	/lib64/ld-linux-x86-64.so.2 (0x00007fd327b0e000)</span><br></pre></td></tr></table></figure></p>
<p>对于代码二：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ldd expTest</span><br><span class="line">	linux-vdso.so.1 =&gt;  (0x00007ffefdfc9000)</span><br><span class="line">	libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f9afcccb000)</span><br><span class="line">	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f9afc901000)</span><br><span class="line">	/lib64/ld-linux-x86-64.so.2 (0x00007f9afcfd4000)</span><br></pre></td></tr></table></figure></p>
<p>可以看到，第二段代码编译出来的可执行文件，多依赖了libm.so.6，也就是exp函数所在的库。</p>
<p>2.什么时候需要链接？<br>事实上，C编译器总是主动传送libc.a或libc.so给链接器，也就是说，对于使用包含在libc.a或libc.so库中的函数，是不需要在编译时手动链接的。而调用函数是否需要链接，可以使用命令“man 3 函数名“查看，如果需要链接库，最后都有说明。</p>
<p>3.为什么链接的时候放在前面就不行呢？<br>这个就涉及到链接器的工作原理了，在此只简单说明一下：链接过程中，需要进行符号解析，并且是按照顺序解析；如果库链接在前，就可能出现库中的符号不会被需要，链接器不会把它加到未解析的符号集合中，那么后面引用这个符号的目标文件就不能解析该引用，导致最后链接失败。因此<strong>链接库的一般准则是将它们放在命令行的结尾</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过前面的实例和分析，我们总结出以下几点：</p>
<ul>
<li>调用包含于libc库中的函数不需要链接。</li>
<li>对于传参为常量的数学函数调用，生成可执行文件过程中可能将其优化，而无需调用该函数。</li>
<li>库链接一般放在命令行结尾。</li>
<li>通过man命令查看在调用某个函数时是否需要链接。</li>
</ul>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>开发学习相关网站汇总</title>
    <url>/2018/10/05/59080.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文收录一些开发学习相关网站。<br><a id="more"></a></p>
<h2 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h2><p>搜索引擎大家最熟悉不过，本没有必要列出，但由于其重要性，不得不放在最前面。</p>
<p><a href="https://www.google.com/" target="_blank" rel="noopener"><strong>Google</strong></a>—全球最大搜索引擎</p>
<p>其他：百度，必应，雅虎 ，duckduckgo。</p>
<h2 id="在线课程"><a href="#在线课程" class="headerlink" title="在线课程"></a>在线课程</h2><p>1.国内平台</p>
<p><a href="https://study.163.com/" target="_blank" rel="noopener">网易云课堂</a>—涵盖各领域的在线课程</p>
<p><a href="https://www.imooc.com/" target="_blank" rel="noopener">中国大学慕课</a>—国内IT技能学习平台</p>
<p><a href="http://www.xuetangx.com/" target="_blank" rel="noopener">学堂在线</a>—国家精品课程在线学习平台</p>
<p><a href="https://www.shiyanlou.com/" target="_blank" rel="noopener">实验楼</a>—做实验，学编程</p>
<p>2.国外平台</p>
<p><a href="https://zh.coursera.org/" target="_blank" rel="noopener">coursera</a>—一流大学在线课程</p>
<p><a href="https://cn.udacity.com/" target="_blank" rel="noopener">优达学城</a>—传授硅谷的官方课程</p>
<p><a href="https://www.edx.org/" target="_blank" rel="noopener">edx</a>—大规模开放在线课堂平台</p>
<p><a href="https://www.codecademy.com/zh/" target="_blank" rel="noopener">codecademy</a>—在线编程学习</p>
<p><a href="https://www.ibm.com/developerworks/cn/" target="_blank" rel="noopener">IBM developerWorks</a>—IT教程，工具，社区</p>
<h2 id="在线练习"><a href="#在线练习" class="headerlink" title="在线练习"></a>在线练习</h2><p>1.国内平台<br><a href="https://www.nowcoder.com/" target="_blank" rel="noopener">牛客网</a>-专业IT笔试面试备考平台</p>
<p><a href="http://www.acmcoder.com/index" target="_blank" rel="noopener">赛码</a>·IT面试笔试平台</p>
<p>2.国外平台<br><a href="http://leetcode.com/" target="_blank" rel="noopener">leetCode</a></p>
<p><a href="https://www.lintcode.com/" target="_blank" rel="noopener">lintcode</a></p>
<p><a href="https://www.topcoder.com/" target="_blank" rel="noopener">topcoder</a></p>
<p><a href="https://www.hackerrank.com/" target="_blank" rel="noopener">HackerRank</a></p>
<h2 id="在线工具箱"><a href="#在线工具箱" class="headerlink" title="在线工具箱"></a>在线工具箱</h2><p><a href="https://tool.lu/" target="_blank" rel="noopener">程序员的工具箱</a></p>
<p><a href="http://tool.oschina.net/" target="_blank" rel="noopener">开源中国的在线工具箱</a></p>
<h2 id="在线编译器"><a href="#在线编译器" class="headerlink" title="在线编译器"></a>在线编译器</h2><p><a href="https://godbolt.org/" target="_blank" rel="noopener">Compiler Explorer</a>—在线汇编查看<br><a href="https://www.onlinegdb.com/" target="_blank" rel="noopener">C/C++在线编译调试器</a>—支持在线GDB调试<br><a href="https://wandbox.org/" target="_blank" rel="noopener">wandbox</a>—支持多语言，多编译器版本的在线编译器<br><a href="https://www.codechef.com/ide" target="_blank" rel="noopener">codechef</a>—支持多语言，在线编译器</p>
<h2 id="技术论坛或社区"><a href="#技术论坛或社区" class="headerlink" title="技术论坛或社区"></a>技术论坛或社区</h2><p><a href="http://www.stackoverflow.com/" target="_blank" rel="noopener"><strong>stackoverflow</strong></a>—全球最大IT技术问答网站</p>
<p><a href="https://github.com/" target="_blank" rel="noopener"><strong>github</strong></a>—代码托管平台和开发者社区</p>
<p><a href="https://www.quora.com/" target="_blank" rel="noopener">Quora</a>—国外在线问答网站，不限于IT</p>
<p><a href="https://segmentfault.com/" target="_blank" rel="noopener">segmentfault</a>—国内IT技术问答网站</p>
<p><a href="https://www.cnblogs.com/" target="_blank" rel="noopener">博客园</a>—开发者的网上家园</p>
<p><a href="https://www.csdn.net/" target="_blank" rel="noopener">CSDN</a>—IT技术社区</p>
<p><a href="https://www.oschina.net/" target="_blank" rel="noopener">开源中国</a>—开源技术社区<br>地址：</p>
<h2 id="放松一下"><a href="#放松一下" class="headerlink" title="放松一下"></a>放松一下</h2><p>听些纯净的声音，放松一下。<br><a href="https://asoftmurmur.com" target="_blank" rel="noopener">https://asoftmurmur.com</a><br><a href="http://www.rainymood.com/" target="_blank" rel="noopener">http://www.rainymood.com/</a><br><a href="https://www.noisli.com/" target="_blank" rel="noopener">https://www.noisli.com/</a></p>
<h2 id="最后说两句"><a href="#最后说两句" class="headerlink" title="最后说两句"></a>最后说两句</h2><p>网站很多，首要的恐怕就是利用好搜索引擎 了吧。对于同类型的网站，择其一二即可。欢迎留言补充或更正。</p>
]]></content>
      <categories>
        <category>resource</category>
      </categories>
      <tags>
        <tag>resource</tag>
      </tags>
  </entry>
  <entry>
    <title>linux常用命令--文本查看篇</title>
    <url>/2018/10/05/61779.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Linux常用命令中，除了cat还有很多其他用于文本查看的命令。本文将简单介绍一下这些文本查看的命令。<br><a id="more"></a></p>
<h2 id="全文本显示—cat"><a href="#全文本显示—cat" class="headerlink" title="全文本显示—cat"></a>全文本显示—cat</h2><p>cat可能是常用的一个文本查看命令了，使用方法也很简单：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat file  #全文本显示在终端</span><br><span class="line">cat -n file #显示全文本，并显示行号</span><br></pre></td></tr></table></figure></p>
<p>另外，cat也可用作合并文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat file1 file2 &gt;file3</span><br></pre></td></tr></table></figure></p>
<p>该命令将file1 file2的内容合并写到file3中。</p>
<h2 id="倒序显示全文本—tac"><a href="#倒序显示全文本—tac" class="headerlink" title="倒序显示全文本—tac"></a>倒序显示全文本—tac</h2><p>tac是cat倒过来的写法，tac以行为单位，倒序显示全文本内容。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tac file</span><br></pre></td></tr></table></figure></p>
<h2 id="分页显示文本—more"><a href="#分页显示文本—more" class="headerlink" title="分页显示文本—more"></a>分页显示文本—more</h2><p>cat将整个文本内容输出到终端。那么也就带来一个问题，如果文本内容较多，前面的内容查看将十分不便。而more命令可以分页显示。<br>1.显示内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">more file</span><br></pre></td></tr></table></figure></p>
<p>之后，就可以使用按键来查看文本。常用按键如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">回车    #向下n行，默认为1行</span><br><span class="line">空格    #向下滚动一屏</span><br><span class="line">b      #向上滚动一屏</span><br><span class="line">=      #输出当前行号</span><br><span class="line">:f     #输出当前文件名和当前行号</span><br><span class="line">q      #退出</span><br></pre></td></tr></table></figure></p>
<p>2.从指定行开始显示<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">more +10 file</span><br></pre></td></tr></table></figure></p>
<p>该命令从第10行开始显示file的内容。</p>
<p>3.从匹配的字符串行开始显示<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">more +/string file</span><br></pre></td></tr></table></figure></p>
<p>该命令从有string的行的前两行开始file的内容。</p>
<h2 id="任意浏览搜索文本—less"><a href="#任意浏览搜索文本—less" class="headerlink" title="任意浏览搜索文本—less"></a>任意浏览搜索文本—less</h2><p>less命令的基本功能和more没有太大差别，但是<strong>less命令可以向前浏览文件，而more只能向后浏览文件</strong>，同时less还拥有更多的搜索功能。<br>常见使用方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">less file     #浏览file</span><br><span class="line">less -N file  #浏览file，并且显示每行的行号</span><br><span class="line">less -m file  #浏览file，并显示百分比</span><br></pre></td></tr></table></figure></p>
<p>常用按键如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f        #向前滚动一屏</span><br><span class="line">b        #向后滚动一屏</span><br><span class="line">回车或j   #向前移动一行</span><br><span class="line">k        #向后移动一行</span><br><span class="line">G        #移动到最后一行</span><br><span class="line">g        #移动到第一行</span><br><span class="line">/string  #向下搜索string，n查看下一个，N查看上一个结果</span><br><span class="line">？string #向上搜索string，n查看下一个，N查看上一个结果</span><br><span class="line">q    #退出</span><br></pre></td></tr></table></figure></p>
<p>相比more命令，less命令能够搜索匹配需要的字符串。<br>另外，less还能在多个文件间切换浏览：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">less file1 file2 file3</span><br><span class="line">:n     #切换到下一个文件</span><br><span class="line">:p     #切换到上一个文件</span><br><span class="line">:x     #切换到第一个文件</span><br><span class="line">:d     #从当前列表移除文件</span><br></pre></td></tr></table></figure></p>
<h2 id="显示文本头部内容—head"><a href="#显示文本头部内容—head" class="headerlink" title="显示文本头部内容—head"></a>显示文本头部内容—head</h2><p>head命令的作用就像它的名字一样，用于显示文件的开头部分文本。<br>常见用法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">head -n 100 file #显示file的前100行</span><br><span class="line">head -n -100 file #显示file的除最后100行以外的内容。</span><br></pre></td></tr></table></figure></p>
<h2 id="显示文本尾部内容—tail"><a href="#显示文本尾部内容—tail" class="headerlink" title="显示文本尾部内容—tail"></a>显示文本尾部内容—tail</h2><p>和head命令类似，只不过tail命令用于读取文本尾部部分内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail -100 file  #显示file最后100行内容</span><br><span class="line">tail -n +100 file  #从第100行开始显示file内容</span><br></pre></td></tr></table></figure></p>
<p>tail还有一个比较实用的用法，用于实时文本更新内容。比如说，有一个日志文件正在写，并且实时在更新，就可以用命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail -f logFile</span><br></pre></td></tr></table></figure></p>
<p>对于更新的日志内容，会实时打印到终端上，方面查看实时日志。</p>
<h2 id="指定顺序显示文本—sort"><a href="#指定顺序显示文本—sort" class="headerlink" title="指定顺序显示文本—sort"></a>指定顺序显示文本—sort</h2><p>sort可用于对文本进行排序并显示，默认为字典升序。<br>例如有一段文本test.txt内容如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim</span><br><span class="line">count</span><br><span class="line">fail</span><br><span class="line">help</span><br><span class="line">help</span><br><span class="line">dead</span><br><span class="line">apple</span><br></pre></td></tr></table></figure></p>
<p>1.升序显示文本<br>使用命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort test.txt</span><br><span class="line">apple</span><br><span class="line">count</span><br><span class="line">dead</span><br><span class="line">fail</span><br><span class="line">help</span><br><span class="line">help</span><br><span class="line">vim</span><br></pre></td></tr></table></figure></p>
<p>文本内容将以升序显示。<br>2.降序显示<br>相关参数-r:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort -r test.txt</span><br><span class="line">vim</span><br><span class="line">help</span><br><span class="line">help</span><br><span class="line">fail</span><br><span class="line">dead</span><br><span class="line">count</span><br><span class="line">apple</span><br></pre></td></tr></table></figure></p>
<p>3.去掉重复的行<br>我们可以观察到，前面的help有两行，如果我们不想看到重复的行呢？可以使用参数-u，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort -u test.txt</span><br><span class="line">apple</span><br><span class="line">count</span><br><span class="line">dead</span><br><span class="line">fail</span><br><span class="line">help</span><br><span class="line">vim</span><br></pre></td></tr></table></figure></p>
<p>可以看到help行不再重复显示。</p>
<p>4.按照数字排序<br>如果按照字典排序，10将会在2的前面，因此我们需要按照数字大小排序：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort -n file</span><br></pre></td></tr></table></figure></p>
<p>由于本文篇幅有限，不在本文展开介绍，后续将单独介绍sort命令的妙用。</p>
<h2 id="过滤显示文本—sed"><a href="#过滤显示文本—sed" class="headerlink" title="过滤显示文本—sed"></a>过滤显示文本—sed</h2><p>sed是一个流编辑器，功能非常强大，但本文只介绍文本查看相关功能。<br>1.显示匹配关键字行<br>有时候查看日志，可能只需要查看包含某些关键字的日志行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -n &quot;/string/p&quot; logFile</span><br></pre></td></tr></table></figure></p>
<p>上面的命令表示打印包含string的行。</p>
<p>2.打印指定行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -n &quot;1,5p&quot; logFile #打印第1到5行</span><br><span class="line">sed -n &apos;3,5&#123;=;p&#125;&apos; logFile #打印3到5行，并且打印行号</span><br><span class="line">sed -n &quot;10p&quot; logFIle  #打印第10行</span><br></pre></td></tr></table></figure></p>
<h2 id="去重显示文本—uniq"><a href="#去重显示文本—uniq" class="headerlink" title="去重显示文本—uniq"></a>去重显示文本—uniq</h2><p>常见用法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uniq file  #去除重复的行</span><br><span class="line">uniq -c file #去除重复的行，并显示重复次数</span><br><span class="line">uniq -d file #只显示重复的行</span><br><span class="line">uniq -u file #只显示出现一次的行</span><br><span class="line">uniq -i file #忽略大小写，去除重复的行</span><br><span class="line">uniqe -w 10 file #认为前10个字符相同，即为重复</span><br></pre></td></tr></table></figure></p>
<h2 id="文本编辑查看—vi"><a href="#文本编辑查看—vi" class="headerlink" title="文本编辑查看—vi"></a>文本编辑查看—vi</h2><p>查看文件也很简单：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi file</span><br></pre></td></tr></table></figure></p>
<p>而从vi发展出来的被誉为编辑器之神的vim有着更加强大的功能，这里不作展开。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文本查看命令较多，可根据使用场景不同选择使用不同的命令。有些命令的用法较多，本文仅介绍经典用法，更多用法可使用man命令查看。很多命令可以结合其他命令使用，例如ps -elf|more，分页显示进程信息等等，更多用法可自行探索。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>谈一谈字节序的问题</title>
    <url>/2018/10/02/25450.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>字节序关系到我们的网络数据能否被正确地解析或使用。那么什么是字节序？又怎么处理字节序的问题呢？本文就来谈一谈字节序的问题。<br><a id="more"></a></p>
<h2 id="什么是字节序"><a href="#什么是字节序" class="headerlink" title="什么是字节序"></a>什么是字节序</h2><p>字节序指的是多字节的数据各字节的存储顺序。在几乎所有计算机中，多字节数据被存储为连续的字节序列。例如，一个4字节的int类型变量a，其存储的起始地址为0x804900，那么a的四个字节将被分别存在0x804900，0x804901，0x804902，0x804903的位置。但是问题来了，a的最低有效位可以存储在最前面，也可以存储在高最后面，就有两种不同的存储顺序。这就引出了大端序和小端序。</p>
<h2 id="大端序和小端序"><a href="#大端序和小端序" class="headerlink" title="大端序和小端序"></a>大端序和小端序</h2><p>实际上，如果最低有效位在最高有效位的前面，则该存储规则为小端序；反之，如果最低有效位在最高有效的后面，则该存储规则为大端序。不同的处理器体系，采用的字节序可能是不同的。例如，x86采用小端序，而PowerPc 970等采用大端序。那么如此一来，不同机器之间的数据传输是不是会出问题呢？</p>
<h2 id="本地序和网络序"><a href="#本地序和网络序" class="headerlink" title="本地序和网络序"></a>本地序和网络序</h2><p>本地序（也称主机序）即指前面处理器本身所采用的字节序，因此有的大端序，有的小端序。而网络序，是指网络传输采用的字节序。所幸，网络序是标准化的，即一般统一采用大端序。因此，<strong>发送网络数据之前需要将数据转换为网络序</strong>，从而避免了前面所担心的问题。而C语言也针对整型数据提供了一组接口，htonl、htons用于本地序转网络序，以及ntohl、ntohs用于网络序转本地序。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>我们通过一个例子来观察大端序和小端序，本地序和网络序的不同。示例程序做的事情很简单，定义整型变量a，将a的每一个字节的地址和值打印出来，将其转换为网络序之后，再打印观察。程序清单如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*================================================================</span></span><br><span class="line"><span class="comment">*   Copyright (C) 2018  Ltd. All rights reserved.</span></span><br><span class="line"><span class="comment">*   </span></span><br><span class="line"><span class="comment">*   文件名称：endian.c</span></span><br><span class="line"><span class="comment">*   创 建 者：shouwang</span></span><br><span class="line"><span class="comment">*   创建日期：2018年10月02日</span></span><br><span class="line"><span class="comment">*   描    述：</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">/**将char类型逐个打印成十六进制形式**/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stringToHex</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">string</span>,<span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> loop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *temp = <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == temp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"input para is NULL\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(loop = <span class="number">0</span>; loop &lt; len; loop++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%p:0x%2x\n"</span>,temp,*(temp));</span><br><span class="line">        temp++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/**x86为小端序**/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"转换之前\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>,a);</span><br><span class="line">    stringToHex((<span class="keyword">char</span>*)&amp;a,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="comment">/*转为网络字节序之后再打印*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"转换之后\n"</span>);</span><br><span class="line">    a = htonl(a);<span class="comment">/*转换为网络序*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>,a);</span><br><span class="line">    stringToHex((<span class="keyword">char</span>*)&amp;a,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译并运行:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -o endian endian.c </span><br><span class="line">./endian</span><br><span class="line">转换之前</span><br><span class="line">a = 305419896</span><br><span class="line">0x7ffc2018d844:0x78</span><br><span class="line">0x7ffc2018d845:0x56</span><br><span class="line">0x7ffc2018d846:0x34</span><br><span class="line">0x7ffc2018d847:0x12</span><br><span class="line">转换之后</span><br><span class="line">a = 2018915346</span><br><span class="line">0x7ffc2018d844:0x12</span><br><span class="line">0x7ffc2018d845:0x34</span><br><span class="line">0x7ffc2018d846:0x56</span><br><span class="line">0x7ffc2018d847:0x78</span><br></pre></td></tr></table></figure></p>
<p>由于本人使用的是x86系列处理器，且编译时未使用交叉编译，因此本地序为小端序。我们可以通过readelf -h endian看到：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">readelf -h endian</span><br><span class="line">ELF 头：</span><br><span class="line">  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  类别:                              ELF64</span><br><span class="line">  数据:                              2 补码，小端序 (little endian)</span><br><span class="line">  版本:                              1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI 版本:                          0</span><br><span class="line">  类型:                              EXEC (可执行文件)</span><br><span class="line">  系统架构:                          Advanced Micro Devices X86-64</span><br><span class="line">（其他内容未显示...）</span><br></pre></td></tr></table></figure></p>
<p>观察运行结果，我们可以发现以下几件事情：</p>
<ul>
<li>小端序a低位的0x78存储在低地址，而高位的12存储在高地址，也就是说对于小端序，其低位存储在高位之前。</li>
<li>使用htonl宏将a转为网络序（大端序）之后，a的低位存储在高位之后。</li>
<li>转换前后，打印a的数值大小截然不同。</li>
</ul>
<h2 id="为什么不统一字节序"><a href="#为什么不统一字节序" class="headerlink" title="为什么不统一字节序"></a>为什么不统一字节序</h2><p>既然每次都发送网络数据之前都要转换，为什么不统一字节序呢？实际上，大小端各有优劣：</p>
<ul>
<li>计算都是从低位开始的，因此计算机内部处理采用小端序，效率较高。</li>
<li>而大端序存储的时候，由于符号位在高位，因此对于数据征服或大小的判断也就方便许多。另外，大端序也更符合人类的阅读习惯。</li>
</ul>
<p>再由于各个芯片厂商的坚持，字节序的问题也就一直没有统一。大小端争端起源于吃鸡蛋时先打破大端还是小端，有兴趣的读者可以搜索一下。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在网络应用中，字节序的问题不可忽略，否则可能出现无法预知的问题（如果两台机器本地序相同，且都不做字节序转换，那么侥幸不会出现什么问题）。通过前面的介绍和分析，我们总结出以下几点：</p>
<ul>
<li>不同处理器之间采用的字节序可能不同。</li>
<li>有些处理器的字节序是确定的，有些处理器的字节序是可配置的。</li>
<li>网络序一般统一为大端序。</li>
<li>数据从本地传输到网络，需要转换为网络序，接收到的网络数据需要转换为本地序后使用。</li>
<li>C提供了一组接口用于整型数据在本地序和网络序之间的转换。</li>
<li>多字节数据对象才需要转字节序，例如int，short等，而char不需要。</li>
<li>由于处理器是按照IEEE标准处理float和double的（参考：<a href="https://www.yanbinghu.com/2018/09/05/65196.html">对浮点数的一些理解</a>），因此也不需要转字节序。</li>
<li>由于Java虚拟机的存在，Java不需要考虑大小端的问题。</li>
</ul>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>字节序</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令--系统状态篇</title>
    <url>/2018/10/01/26218.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Linux常用命令中，有些命令可以用于查看系统的状态，通过了解系统当前的状态，能够帮助我们更好地维护系统或定位问题。本文就简单介绍一下这些命令。<br><a id="more"></a></p>
<h2 id="查看系统运行时间—uptime"><a href="#查看系统运行时间—uptime" class="headerlink" title="查看系统运行时间—uptime"></a>查看系统运行时间—uptime</h2><p>有时候我们想知道系统上一次复位是在什么时候或者系统已经运行了多长时间，我们可以通过uptime命令获取这些信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uptime</span><br><span class="line">20:47:06 up 50 min,  1 user,  load average: 0.75, 0.84, 0.93</span><br></pre></td></tr></table></figure></p>
<p>从左往右显示的信息依次为：当前时间、已运行时间、用户登录数、1分钟、5分钟和15分钟内系统的平均负载。</p>
<h2 id="查看系统已登录用户—who"><a href="#查看系统已登录用户—who" class="headerlink" title="查看系统已登录用户—who"></a>查看系统已登录用户—who</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">who -a</span><br><span class="line">hyb      tty7         2018-09-30 19:57 (:0)</span><br></pre></td></tr></table></figure>
<p>通过who命令可以查看到哪些用户通过哪个ip登录到了这台主机。</p>
<h2 id="查看系统版本相关信息—uname"><a href="#查看系统版本相关信息—uname" class="headerlink" title="查看系统版本相关信息—uname"></a>查看系统版本相关信息—uname</h2><p>例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uname -a</span><br><span class="line">Linux ubuntu16.04 4.15.0-34-generic #37~16.04.1-Ubuntu SMP Tue Aug 28 10:44:06 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure></p>
<p>从结果可以看到操作系统版本（ubuntu16.04），CPU类型（x86_64）等信息</p>
<h2 id="查看当前环境变量—export"><a href="#查看当前环境变量—export" class="headerlink" title="查看当前环境变量—export"></a>查看当前环境变量—export</h2><p>环境变量影响着程序的运行，因此有时候需要查看当前环境的环境变量：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export</span><br></pre></td></tr></table></figure></p>
<h2 id="查看目录和文件占用空间—du"><a href="#查看目录和文件占用空间—du" class="headerlink" title="查看目录和文件占用空间—du"></a>查看目录和文件占用空间—du</h2><p>du命令直接显示当前目录下每个目录及其文件占用空间。结合—max-depth参数可以指定显示的目录层级。<br>例如，如果只想显示当前目录下各个目录所占总空间，可以使用:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">du -h --max-depth=1 </span><br><span class="line">19M	    ./python</span><br><span class="line">9.0M	    ./git</span><br><span class="line">321M	    ./hexo</span><br><span class="line">17M	    ./lua</span><br><span class="line">28K	    ./vim</span><br><span class="line">1.4M	    ./shell</span><br><span class="line">81M	    ./redis</span><br><span class="line">316M	    ./books</span><br><span class="line">48M	    ./c</span><br><span class="line">810M	    .</span><br><span class="line">du -sh     #仅统计当前目录总大小</span><br><span class="line">810M</span><br></pre></td></tr></table></figure></p>
<p>其中-h表示以易读的单位显示大小，即M，—max-depth=1表明目录层级。通过命令结果，我们可以看到当前目录下各个子目录占用空间大小，以及总空间大小。</p>
<h2 id="显示各挂载点空间—df"><a href="#显示各挂载点空间—df" class="headerlink" title="显示各挂载点空间—df"></a>显示各挂载点空间—df</h2><p>例如:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df -h</span><br><span class="line">文件系统        容量  已用  可用 已用% 挂载点</span><br><span class="line">udev            3.9G     0  3.9G    0% /dev</span><br><span class="line">tmpfs           786M  9.5M  776M    2% /run</span><br><span class="line">/dev/sda10       24G  9.8G   13G   45% /</span><br><span class="line">tmpfs           3.9G   43M  3.8G    2% /dev/shm</span><br><span class="line">tmpfs           5.0M  4.0K  5.0M    1% /run/lock</span><br><span class="line">tmpfs           3.9G     0  3.9G    0% /sys/fs/cgroup</span><br><span class="line">/dev/sda11      454M  274M  153M   65% /boot</span><br><span class="line">/dev/sda15       55G  5.2G   47G   10% /home</span><br><span class="line">/dev/sda1       256M   31M  226M   12% /boot/efi</span><br><span class="line">/dev/sda14      4.6G  9.9M  4.4G    1% /tmp</span><br><span class="line">tmpfs           786M   60K  786M    1% /run/user/1000</span><br></pre></td></tr></table></figure></p>
<p>从结果中，我们可以看到各个挂载点总空间以及可用空间。当磁盘文件占用空间较大时，可能导致系统运行缓慢，因此，可根据该结果进行相应的磁盘清理。</p>
<h2 id="显示内存可用情况—free"><a href="#显示内存可用情况—free" class="headerlink" title="显示内存可用情况—free"></a>显示内存可用情况—free</h2><p>free命令可用于显示系统中可用的物理内存，交换区内存以及内核使用的buffer：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           7.7G        2.3G        2.6G        268M        2.8G        4.7G</span><br><span class="line">Swap:          7.6G          0B        7.6G</span><br></pre></td></tr></table></figure></p>
<p>从执行结果可以看到已用内存和空闲内存的情况。同样地，当内存不足时，可能导致程序运行异常或系统卡顿。</p>
<h2 id="查看进程的内存使用情况—pmap"><a href="#查看进程的内存使用情况—pmap" class="headerlink" title="查看进程的内存使用情况—pmap"></a>查看进程的内存使用情况—pmap</h2><p>pmap命令用于查看进程内存相关信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pmap pid    #pid为进程id，可通过ps命令获取</span><br><span class="line">6030:   ./main</span><br><span class="line">0000000000400000      4K r-x-- main</span><br><span class="line">0000000000600000      4K r---- main</span><br><span class="line">0000000000601000      4K rw--- main</span><br><span class="line">00000000017d2000    132K rw---   [ anon ]</span><br><span class="line">00007fc3843e8000   1792K r-x-- libc-2.23.so</span><br><span class="line">00007fc3845a8000   2048K ----- libc-2.23.so</span><br><span class="line">00007fc3847a8000     16K r---- libc-2.23.so</span><br><span class="line">00007fc3847ac000      8K rw--- libc-2.23.so</span><br><span class="line">00007fc3847ae000     16K rw---   [ anon ]</span><br><span class="line">00007fc3847b2000    152K r-x-- ld-2.23.so</span><br><span class="line">00007fc3849b9000     12K rw---   [ anon ]</span><br><span class="line">00007fc3849d7000      4K r---- ld-2.23.so</span><br><span class="line">00007fc3849d8000      4K rw--- ld-2.23.so</span><br><span class="line">00007fc3849d9000      4K rw---   [ anon ]</span><br><span class="line">00007ffcf2018000    132K rw---   [ stack ]</span><br><span class="line">00007ffcf2175000     12K r----   [ anon ]</span><br><span class="line">00007ffcf2178000      8K r-x--   [ anon ]</span><br><span class="line">ffffffffff600000      4K r-x--   [ anon ]</span><br><span class="line"> total             4356K</span><br></pre></td></tr></table></figure></p>
<p>我们可以根据进程各部分占用空间情况，来不断优化我们的程序。</p>
<h2 id="查看虚拟内存统计信息—vmstat"><a href="#查看虚拟内存统计信息—vmstat" class="headerlink" title="查看虚拟内存统计信息—vmstat"></a>查看虚拟内存统计信息—vmstat</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vmstat</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 1  0      0 2214960 407828 2572148    0    0   126    57  377 1006  8  2 88  2  0</span><br></pre></td></tr></table></figure>
<p>vmstat的输出值能够帮助我们了解当前系统的性能。比如说，如果si（每秒从交换区写到内存的大小）和so（每秒写入交换区的内存大小）的值经常大于0，说明内存可能不够用，因此才需要用到交换空间。再比如说，us（用户进程执行时间百分比）的值比较高时，说明用户进程消耗的CPU资源较多。而wa（IO等待时间百分比）值较高时，说明IO等待情况严重。</p>
<h2 id="查看ip地址—ip"><a href="#查看ip地址—ip" class="headerlink" title="查看ip地址—ip"></a>查看ip地址—ip</h2><p>有时候使用ifconfig命令并不一定能够看到所有的ip地址，因此可以使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure></p>
<h2 id="查看网络连接状态—netstat"><a href="#查看网络连接状态—netstat" class="headerlink" title="查看网络连接状态—netstat"></a>查看网络连接状态—netstat</h2><p>netstat命令可以查看网络连接状态，通常用于诊断网络相关问题。例如查看端口是否被占用，连接是否已经释放，服务是否在监听等等。</p>
<h2 id="查看进程间关系—pstree"><a href="#查看进程间关系—pstree" class="headerlink" title="查看进程间关系—pstree"></a>查看进程间关系—pstree</h2><p>通过pstree命令可以看到进程间的父子关系，它以树形结构显示这些信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pstree</span><br><span class="line">systemd─┬─ModemManager─┬─&#123;gdbus&#125;</span><br><span class="line">        │              └─&#123;gmain&#125;</span><br><span class="line">        ├─NetworkManager─┬─dhclient</span><br><span class="line">        │                ├─dnsmasq</span><br><span class="line">        │                ├─&#123;gdbus&#125;</span><br><span class="line">        │                └─&#123;gmain&#125;</span><br><span class="line">        ├─accounts-daemon─┬─&#123;gdbus&#125;</span><br><span class="line">        │                 └─&#123;gmain&#125;</span><br><span class="line">        ├─acpid</span><br><span class="line">        ├─atd</span><br><span class="line">        ├─avahi-daemon───avahi-daemon</span><br><span class="line">        ├─bluetoothd</span><br><span class="line">        ├─colord─┬─&#123;gdbus&#125;</span><br><span class="line">        │        └─&#123;gmain&#125;</span><br><span class="line">        ├─cron</span><br><span class="line">        ├─cups-browsed─┬─&#123;gdbus&#125;</span><br><span class="line">        │              └─&#123;gmain&#125;</span><br><span class="line">        ├─cupsd───3*[dbus]</span><br><span class="line">        ├─dbus-daemon</span><br><span class="line">        ├─gnome-keyring-d─┬─&#123;gdbus&#125;</span><br><span class="line">        │                 ├─&#123;gmain&#125;</span><br><span class="line">        │                 └─&#123;timer&#125;</span><br><span class="line">(仅显示部分内容)</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际上，前面所提到的很多相关命令信息都是从系统文件中获取的，例如/proc/meminfo保存了内存相关信息，/proc/net/dev保存网络流量相关信息。只是，它们都是静态数值，但是我们可以结合watch命令来动态地观察这些信息，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watch -n 1 cat /proc/meminfo </span><br><span class="line"></span><br><span class="line">watch -n 1 cat /proc/net/dev</span><br></pre></td></tr></table></figure></p>
<p>上面的命令表示，每隔一秒执行一次cat /proc/meminfo或cat /proc/net/dev，因此我们可以看到内存信息或网卡流量信息在实时刷新。</p>
<p>本文仅介绍这些命令的经典使用，更多使用可通过man 命令查看。通过前面这些系统自带命令，我们可以比较方便地监控系统状态，从而帮助我们维护系统或定位问题。欢迎留言补充或更正。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux常用命令--开发调试篇</title>
    <url>/2018/09/26/61877.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Linux常用命令中有一些命令可以在开发或调试过程中起到很好的帮助作用，有些可以帮助了解或优化我们的程序，有些可以帮我们定位疑难问题。本文将简单介绍一下这些命令。<br><a id="more"></a></p>
<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>我们用一个小程序，来帮助后面我们对这些命令的描述，程序清单cmdTest.c如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int test(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a/b;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc,char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    int b = 0;</span><br><span class="line">    printf(&quot;a=%d,b=%d\n&quot;,a,b);</span><br><span class="line">    test(a,b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译获得elf文件cmdTest并运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -g -o cmdTest cmdTest.c</span><br><span class="line">./cmdTest</span><br><span class="line">a=10,b=0</span><br><span class="line">Floating point exception (core dumped)</span><br></pre></td></tr></table></figure>
<p>程序内容是在main函数中调用test，计算a/b的值，其中b的值为0，因此程序由于除0错误异常终止。</p>
<h2 id="查看文件基本信息—file"><a href="#查看文件基本信息—file" class="headerlink" title="查看文件基本信息—file"></a>查看文件基本信息—file</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file cmdTest</span><br><span class="line">cmdTest: ELF 64-bit LSB  executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=448e1c34b4c548120e2c04f6a2bfce4e6d2281a3, not stripped</span><br></pre></td></tr></table></figure>
<p>通过file命令可以看到cmdTest的类型为elf，是64位、运行于x86-64的程序，not striped表明elf文件中还保留着符号信息以及调试信息等不影响程序运行的内容。</p>
<h2 id="查看程序依赖库—ldd"><a href="#查看程序依赖库—ldd" class="headerlink" title="查看程序依赖库—ldd"></a>查看程序依赖库—ldd</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ldd cmdTest</span><br><span class="line">       linux-vdso.so.1 =&gt;  (0x00007ffc8e548000)</span><br><span class="line">       libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f0621931000)</span><br><span class="line">       /lib64/ld-linux-x86-64.so.2 (0x00007f0621cf6000)</span><br></pre></td></tr></table></figure>
<p>我们可以看到cmdTest依赖了libc.so等库。</p>
<h2 id="查看函数或者全局变量是否存在于elf文件中—nm"><a href="#查看函数或者全局变量是否存在于elf文件中—nm" class="headerlink" title="查看函数或者全局变量是否存在于elf文件中—nm"></a>查看函数或者全局变量是否存在于elf文件中—nm</h2><p>nm命令用于查看elf文件的符号信息。文件编译出来之后，我们可能不知道新增加的函数或者全局变量是否已经成功编译进去。这时候，我们可以使用nm命令来查看。<br>例如，查看前面所提到的elf文件有没有test函数，可以用命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nm cmdTest|grep test</span><br><span class="line">000000000040052d T test  #打印结果</span><br></pre></td></tr></table></figure></p>
<p>按照地址顺序列出符号信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nm -n cmdTest</span><br><span class="line">                 w _ITM_deregisterTMCloneTable</span><br><span class="line">                 w _ITM_registerTMCloneTable</span><br><span class="line">                 w _Jv_RegisterClasses</span><br><span class="line">                 w __gmon_start__</span><br><span class="line">                 U __libc_start_main@@GLIBC_2.2.5</span><br><span class="line">                 U printf@@GLIBC_2.2.5</span><br><span class="line">00000000004003e0 T _init</span><br><span class="line">0000000000400440 T _start</span><br><span class="line">0000000000400470 t deregister_tm_clones</span><br><span class="line">00000000004004a0 t register_tm_clones</span><br><span class="line">00000000004004e0 t __do_global_dtors_aux</span><br><span class="line">0000000000400500 t frame_dummy</span><br><span class="line">000000000040052d T test</span><br><span class="line">0000000000400540 T main</span><br><span class="line">0000000000400590 T __libc_csu_init</span><br><span class="line">0000000000400600 T __libc_csu_fini</span><br><span class="line">(列出部分内容)</span><br></pre></td></tr></table></figure></p>
<p>可以看到test函数的开始地址为0x000000000040052d，结束地址为0x0000000000400540。</p>
<h2 id="打印elf文件中的可打印字符串—strings"><a href="#打印elf文件中的可打印字符串—strings" class="headerlink" title="打印elf文件中的可打印字符串—strings"></a>打印elf文件中的可打印字符串—strings</h2><p>例如你在代码中存储了一个版本号信息，那么即使编译成elf文件后，仍然可以通过strings搜索其中的字符串甚至可以搜索某个.c文件是否编译在其中：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strings elfFile| grep &quot;someString&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="查看文件段大小—size"><a href="#查看文件段大小—size" class="headerlink" title="查看文件段大小—size"></a>查看文件段大小—size</h2><p>可以通过size命令查看各段大小：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size cmdTest</span><br><span class="line">   text       data      bss      dec      hex  filename</span><br><span class="line">   1319      560        8     1887      75f   cmdTest</span><br></pre></td></tr></table></figure></p>
<p>text段：正文段字节数大小<br>data段:包含静态变量和已经初始化的全局变量的数据段字节数大小<br>bss段：存放程序中未初始化的全局变量的字节数大小<br>当我们知道各个段的大小之后，如果有减小程序大小的需求，就可以有针对性的对elf文件进行优化处理。</p>
<h2 id="为elf文件”瘦身“—strip"><a href="#为elf文件”瘦身“—strip" class="headerlink" title="为elf文件”瘦身“—strip"></a>为elf文件”瘦身“—strip</h2><p>strip用于去掉elf文件中所有的符号信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -al cmdTest</span><br><span class="line">-rwxr-xr-x 1 hyb root 9792 Sep 25 20:30 cmdTest #总大小为9792字节</span><br><span class="line">strip cmdTest</span><br><span class="line">ls -al cmdTest</span><br><span class="line">-rwxr-xr-x 1 hyb root 6248 Sep 25 20:35 cmdTest#strip之后大小为6248字节</span><br></pre></td></tr></table></figure></p>
<p>可以看到，“瘦身”之后，<strong>大小减少将近三分之一</strong>。但是要特别注意的是，“瘦身”之后的elf文件由于没有了符号信息，许多调试命令将无法正常使用，出现core dump时，问题也较难定位，因此只建议在正式发布时对其进行“瘦身”。</p>
<h2 id="查看elf文件信息—readelf"><a href="#查看elf文件信息—readelf" class="headerlink" title="查看elf文件信息—readelf"></a>查看elf文件信息—readelf</h2><p>readelf用于查看elf文件信息，它可以查看各段信息，符号信息等，下面的例子是查看elf文件头信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">readelf -h cmdTest</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00  #elf文件魔数字</span><br><span class="line">  Class:                             ELF64  #64位 elf文件</span><br><span class="line">  Data:                              2&apos;s complement, little endian#字节序为小端序</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V #</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              EXEC (Executable file)#目标文件类型</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64 #目标处理器体系</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x400440  #入口地址</span><br><span class="line">  Start of program headers:          64 (bytes into file)</span><br><span class="line">  Start of section headers:          4456 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         9</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         28</span><br><span class="line">  Section header string table index: 27</span><br></pre></td></tr></table></figure></p>
<p>从elf头信息中，我们可以知道该elf是64位可执行文件，运行在x86-64中，且字节序为小端序。另外，我们还注意到它的入口地址是0x400440(_start)，而不是400540(main)。也就是说，<strong>我们的程序运行并非从main开始</strong>。</p>
<h2 id="反汇编指定函数—objdump"><a href="#反汇编指定函数—objdump" class="headerlink" title="反汇编指定函数—objdump"></a>反汇编指定函数—objdump</h2><p>objdump用于展示elf文件信息，功能较多，在此不逐一介绍。有时候我们需要反汇编来定位一些问题，可以使用命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objdump -d cmdTest #反汇编整个cmdTest程序</span><br></pre></td></tr></table></figure></p>
<p>但是如果程序较大，那么反汇编时间将会变长，而且反汇编文件也会很大。如果我们已经知道了问题在某个函数，只想反汇编某一个函数，怎么处理呢？<br>我们可以利用前面介绍的nm命令获取到函数test的地址，然后使用下面的方式反汇编：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objdump -d cmdTest --start-address=0x40052d --stop-address=0x400540 ##反汇编指定地址区间</span><br></pre></td></tr></table></figure></p>
<h2 id="端口占用情况查看—netstat"><a href="#端口占用情况查看—netstat" class="headerlink" title="端口占用情况查看—netstat"></a>端口占用情况查看—netstat</h2><p>我们可能常常会遇到进程第一次启动后，再次启动会出现端口绑定失败的问题，我们可以通过netstat命令查看端口占用情况：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -anp|grep 端口号</span><br></pre></td></tr></table></figure></p>
<h2 id="进程状态查看—ps-amp-top"><a href="#进程状态查看—ps-amp-top" class="headerlink" title="进程状态查看—ps&amp;top"></a>进程状态查看—ps&amp;top</h2><p>ps命令的用法可以参考<a href="https://www.yanbinghu.com/2018/04/06/53515.html">常见linux命令介绍－ps</a><br>top命令实时显示当前进程状态，最活跃的进程显示在最顶部。</p>
<h2 id="core-dump文件生成配置—ulimit-c"><a href="#core-dump文件生成配置—ulimit-c" class="headerlink" title="core dump文件生成配置—ulimit -c"></a>core dump文件生成配置—ulimit -c</h2><p>有时候我们的程序core dump了却没有生成core文件，很可能是我们设置的问题：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ulimit -c #查看core文件配置，如果结果为0，程序core dump时将不会生成core文件</span><br><span class="line">ulimit -c unlimited #不限制core文件生成大小</span><br><span class="line">ulimit -c 10 #设置最大生成大小为10kb</span><br></pre></td></tr></table></figure></p>
<h2 id="调试神器—gdb"><a href="#调试神器—gdb" class="headerlink" title="调试神器—gdb"></a>调试神器—gdb</h2><p>gdb是一个强大的调试工具，但这里仅介绍两个简单使用示例。<br>有时候程序可能已经正在运行，但是又不能终止它，这时候仍然可以使用<strong>gdb调试正在运行的进程</strong>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb processFile PID #processFile为进程文件，pid为进程id，可通过ps命令查找到</span><br></pre></td></tr></table></figure></p>
<p>有时候程序可能core dump了，但是系统还留给了我们一个礼物—core文件。<br>在core文件生成配置完成之后，运行cmdTest程序，产生core文件。我们可以用下面的方法通过core文件<strong>定位出错位置</strong>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb cmdTest core #processFile为进程文件，core为生成的core文件</span><br><span class="line">Core was generated by `./cmdTest&apos;.</span><br><span class="line">Program terminated with signal SIGFPE, Arithmetic exception.</span><br><span class="line">#0  0x00000000004004fb in test (a=10, b=0) at cmdTest.c:4</span><br><span class="line">4         return a/b;</span><br><span class="line">(gdb)bt</span><br><span class="line">#0  0x00000000004004fb in test (a=10, b=0) at cmdTest.c:4</span><br><span class="line">#1  0x000000000040052c in main (argc=1, argv=0x7ffca9536d38) at cmdTest.c:10</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>输入bt后，就可以看到调用栈了,出错位置在test函数，cmdTest.c的第4行。</p>
<h2 id="定位crash问题—addr2line"><a href="#定位crash问题—addr2line" class="headerlink" title="定位crash问题—addr2line"></a>定位crash问题—addr2line</h2><p>有时候程序崩溃了但不幸没有生成core文件，是不是就完全没有办法了呢？还是cmdTest的例子。运行完cmdTest之后，我们通过dmesg命令可以获取到以下内容<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[27153070.538380] traps: cmdTest[2836] trap divide error ip:40053b sp:7ffc230d9280 error:0 in cmdTest[400000+1000]</span><br></pre></td></tr></table></figure></p>
<p>该信息记录了cmdTest运行出错的基本原因（divide error）和出错位置（40053b）,我们使用addr2line命令获取出错具体行号：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addr2line -e cmdTest 40053b</span><br><span class="line">/home/hyb/practice/cmdTest.c:4</span><br></pre></td></tr></table></figure></p>
<p>可以看到addr2line命令将地址(40053b)翻译成了文件名(cmdTest.c)和行号(4)，确定了出错位置。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对以上命令仅介绍其经典使用，这些命令都还有其他一些有帮助的用法，但由于篇幅有限，不在此介绍，更多使用方法可以通过man 命令名的方式去了解。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>变长参数深度探究</title>
    <url>/2018/09/22/24370.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>变长参数，指的是函数参数数量可变，或者说函数接受参数的数量可以不固定。实际上，我们最开始学C语言的时候，就用到了这样的函数:printf，它接受任意数量的参数，向终端格式化输出字符串。本文就来探究一下，变长参数函数的实现机制是怎样的，以及我们自己如何实现一个变长参数函数。在此之前，我们先来了解一下参数入栈顺序是怎样的。<br><a id="more"></a></p>
<h2 id="函数参数入栈顺序"><a href="#函数参数入栈顺序" class="headerlink" title="函数参数入栈顺序"></a>函数参数入栈顺序</h2><p>我们可能知道，参数入栈顺序是从右至左，是不是这样的呢？我们可以通过一个小程序验证一下。小程序做的事情很简单，main函数调用了传入８个参数的test函数，test函数打印每个参数的地址。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d,<span class="keyword">int</span> e,<span class="keyword">int</span> f,<span class="keyword">int</span> g,<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n"</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e,&amp;f,&amp;g,&amp;h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">int</span> d = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">int</span> e = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">int</span> f = <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">int</span> g = <span class="number">7</span>;</span><br><span class="line">	<span class="keyword">int</span> h = <span class="number">8</span>;</span><br><span class="line">	test(a,b,c,d,e,f,g,h);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译成32位程序<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -m32 -o paraTest paraTest.c</span><br></pre></td></tr></table></figure></p>
<p>运行（不同的机器运行结果不同，且每次运行结果也不一定相同）:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0xffdadff0</span><br><span class="line">0xffdadff4</span><br><span class="line">0xffdadff8</span><br><span class="line">0xffdadffc</span><br><span class="line">0xffdae000</span><br><span class="line">0xffdae004</span><br><span class="line">0xffdae008</span><br><span class="line">0xffdae00c</span><br></pre></td></tr></table></figure></p>
<p>观察打印出来的地址，可以发现，从ａ到ｈ地址值依次增加４.我们知道，栈是从高地址向低地址增长的，从地址值可以推测ｈ是最先入栈，ａ是最后入栈的，也就是说，<strong>参数是从右往左入栈的</strong>（注:并非所有语言都是如此）。</p>
<p>但是如果将函数test参数ｂ改为char 型呢？运行结果如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0xffb29500</span><br><span class="line">0xffb294ec  </span><br><span class="line">0xffb29508</span><br><span class="line">0xffb2950c</span><br><span class="line">0xffb29510</span><br><span class="line">0xffb29514</span><br><span class="line">0xffb29518</span><br><span class="line">0xffb2951c</span><br></pre></td></tr></table></figure></p>
<p>观察结果可以发现，ｂ的地址并非是ａ的地址值加４，也不是在ａ和ｃ的地址值之间，这是为何？这是编译器出于对空间，压栈速度等因素的考虑对其进行了优化，但这并不影响变长参数的实现。</p>
<p>对于上面的情况，如果我们编译成64位程序又是什么样的情况呢？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -o paraTest paraTest.c</span><br><span class="line">./paraTest</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x7fff4b83cbcc</span><br><span class="line">0x7fff4b83cbc8</span><br><span class="line">0x7fff4b83cbc4</span><br><span class="line">0x7fff4b83cbc0</span><br><span class="line">0x7fff4b83cbbc</span><br><span class="line">0x7fff4b83cbb8</span><br><span class="line">0x7fff4b83cbe0</span><br><span class="line">0x7fff4b83cbe8</span><br></pre></td></tr></table></figure></p>
<p>通过观察可以发现，从参数ａ到ｆ，其地址似乎是递减的，而从ｇ到ｈ地址又变成递增的了，这是为什么呢？事实上，对于x86-64，当参数个数超过６时，前６个参数可以通过寄存器传递，而第７～n个参数则会通过栈传递，并且数据大小都向８的倍数对齐，也就是说，对于７～ｎ个参数，依然满足从右往左入栈，只是对于前６个参数，它们是通过寄存器来传递的，另外，寄存器的访问速度相对于内存来说要快得多，因此为了提高空间和时间效率，实际中其实不建议参数超过６个。</p>
<p>对于函数参数入栈顺序我们就了解到这里，但是参数入栈顺序和变长参数又有什么关系呢？</p>
<h2 id="变长参数实现分析"><a href="#变长参数实现分析" class="headerlink" title="变长参数实现分析"></a>变长参数实现分析</h2><p>通过前面的例子，我们了解到，函数参数是从右往左依次入栈的，而且第一个参数位于栈顶。那么，我们就可以通过第一个参数进行地址偏移，来得到第二个，第三个参数的地址，是不是可以实现呢？我们来看一个32位程序的例子。例子同样很简单，我们通过ａ的地址来获取其他参数的地址：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">( <span class="keyword">int</span> a, <span class="keyword">char</span> b,  <span class="keyword">int</span> c, <span class="keyword">int</span> d, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n%d\n%d\n%d\n%d\n\n"</span>,a,*(&amp;a+<span class="number">1</span>),*(&amp;a+<span class="number">2</span>),*(&amp;a+<span class="number">3</span>),*(&amp;a+<span class="number">4</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> b = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">int</span> d = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">int</span> e = <span class="number">5</span>;</span><br><span class="line">	test(a,b,c,d,e);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译为32位程序运行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -m32 -o paraTest paraTest.c </span><br><span class="line">./paraTest</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure></p>
<p>通过运行结果我们可以发现，即使只有ａ的地址也可以访问到其他参数。也就是说，即便传入的参数是多个，只要我们知道每个参数的类型，只需通过第一个参数就能够通过地址偏移正确访问到其他参数。另外我们也注意到，即便ｂ是char类型，访问ｃ的值也是偏移４的倍数地址，这是因为字节对齐的缘故，有兴趣的可以阅读<a href="https://www.yanbinghu.com/2018/09/15/43741.html#more">理一理字节对齐的那些事</a>。</p>
<h2 id="变长参数实现"><a href="#变长参数实现" class="headerlink" title="变长参数实现"></a>变长参数实现</h2><p>经过前面的理解分析，我们知道，正是由于参数从右往左入栈（但是要注意的是，对于ｘ86-64，它的参数不是完全从右往左入栈，且参数可能不在一个连续的区域中，它的变长参数实现也更为复杂，我们这里不展开。），可以实现变长参数。当然了，这一切，Ｃ已经有现成可用的一些东西来帮我们实现变长参数。<br>它主要通过一个类型（va_list）和三个宏（va_start、va_arg、va_end）来实现<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">va_list ：存储参数的类型信息，32位和64位实现不一样。</span><br><span class="line">void va_start ( va_list ap, paramN );</span><br><span class="line">参数：</span><br><span class="line">ap: 可变参数列表地址 </span><br><span class="line">paramN: 确定的参数</span><br><span class="line">功能：初始化可变参数列表，会把paraN之后的参数放入ap中</span><br><span class="line"></span><br><span class="line">type va_arg ( va_list ap, type );</span><br><span class="line">功能：返回下一个参数的值。</span><br><span class="line"></span><br><span class="line">void va_end ( va_list ap );</span><br><span class="line">功能：完成清理工作。</span><br></pre></td></tr></table></figure></p>
<p>可变参数函数实现的步骤如下:</p>
<ul>
<li>１.在函数中创建一个va_list类型变量</li>
<li>２.使用va_start对其进行初始化</li>
<li>３.使用va_arg访问参数值</li>
<li>４.使用va_end完成清理工作</li>
</ul>
<p>接下来我们来实现一个变长参数函数,对给定的一组整数进行求和。程序清单如下:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/*要使用变长参数的宏，需要包含下面的头文件*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * getSum：用于计算一组整数的和</span></span><br><span class="line"><span class="comment"> * num：整数的数量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> num,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	va_list ap;<span class="comment">//定义参数列表变量</span></span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> loop = <span class="number">0</span>;</span><br><span class="line">	va_start(ap,num);</span><br><span class="line">	<span class="comment">/*遍历参数值*/</span></span><br><span class="line">	<span class="keyword">for</span>(;loop &lt; num ; loop++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*取出并加上下一个参数值*/</span></span><br><span class="line">		sum += va_arg(ap,<span class="keyword">int</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	va_end(ap);</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	sum = getSum(<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的小程序接受变长参数，第一个参数表明将要计算和的整数个数，后面的参数是要计算的值。<br>编译运行可得结果:15。</p>
<p>但是我们要注意的是，这个小程序不像printf那样，对传入的参数做了校验，因此一但传入的参数num和实际参数不匹配，或者传入类型与要计算的int类型不匹配，将会出现不可预知的错误。我们举一个简单的例子,如果第二个参数传入一个浮点数，程序清单如下:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/*要使用变长参数的宏，需要包含下面的头文件*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * getSum：用于计算一组整数的和</span></span><br><span class="line"><span class="comment"> * num：整数的数量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> num,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	va_list ap;<span class="comment">//定义参数列表变量</span></span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> loop = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">	va_start(ap,num);</span><br><span class="line">	<span class="keyword">for</span>(;loop &lt; num ; loop++)</span><br><span class="line">	&#123;</span><br><span class="line">		value = va_arg(ap,<span class="keyword">int</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"the %d value is %d\n"</span>,loop.value);</span><br><span class="line">		sum += value;</span><br><span class="line">	&#125;</span><br><span class="line">	va_end(ap);</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">float</span> a = <span class="number">8.25f</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"a to int=%d\n"</span>,*(<span class="keyword">int</span>*)&amp;a);</span><br><span class="line">	sum = getSum(<span class="number">5</span>,a,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -m32 -o multiPara multiPara.c</span><br><span class="line">./multiPara</span><br><span class="line">a to int=1090781184</span><br><span class="line">the 0 loop value is 0</span><br><span class="line">the 1 loop value is 1075871744</span><br><span class="line">the 2 loop value is 2</span><br><span class="line">the 3 loop value is 3</span><br><span class="line">the 4 loop value is 4</span><br><span class="line">the sum is1075871753</span><br></pre></td></tr></table></figure></p>
<p>观察上面的运行结果，发现结果与我们所预期大相径庭，我们可能会有以下几个疑问:</p>
<ul>
<li>１．把a的地址上的值转换为int，为什么会是1090781184?</li>
<li>２．getSum函数中，为什么第一个值是0？</li>
<li>３．getSum函数中，为什么第二个值是1075871744？</li>
<li>４．getSum函数中，为什么没有获取到5？</li>
<li>５．为什么最后的结果不是我们预期的值?</li>
</ul>
<p>我们逐一解答</p>
<ul>
<li>第一个问题，我们不在本文解释，但可以通过<a href="https://www.yanbinghu.com/2018/09/05/65196.html">对浮点数的理解</a>来找到答案。</li>
<li>对于第二个、第三个问题以及第四个问题，涉及到类型提升。也就是说，在C语言中，调用一个不带原型声明的函数时，<br>调用者会对每个参数执行“默认实际参数提升”，提升规则如下:<br>——float将提升到double<br>——char、short和相应的signed、unsigned类型将提升到int<br>——如果int不能存储原值，则提升到unsigned int<br>那么也就可以理解了，调用者会将提升之后的参数传给被调用者。也就是说a被提升为了8字节的double类型，自然而然，而我们取值是按int４字节取值，第一次取值取的double的前４字节，第二次取的后４字节，而由于总共取数５次，因此最后的５也就不会被取到</li>
<li>了解了前面几个问题的答案，那么最后一个问题的答案也就随之而出了。前面取值已经不对了，最后的结果自然不是我们想要的。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过前面的分析和示例，我们来做一些总结</p>
<ul>
<li><p><strong>变长参数实现的基本原理</strong><br>对于x86来说，函数参数入栈顺序为从右往左。因此，在知道第一个参数地址之后，我们能够通过地址偏移获取其他参数，虽然x86-64在实现上略有不同，但`对于开发者使用来说，实现变长参数函数没有32位和64位的区别。</p>
</li>
<li><p><strong>变长参数实现注意事项</strong><br>  １．…前的参数可以有1个或多个，但前一个必须是确定类型。<br>  ２．传入参数会可能会出现类型提升。<br>  ３．va_arg的type类型不能是char,short int,float等类型，否则取值不正确，原因为第２点。<br>  ４．va_arg不能往回取参数，但可以使用va_copy拷贝va_list，以备后用。<br>  ５．变长参数类型注意做好检查，例如可以采用printf的占位符方式等等。<br>  ６．即便printf有类型检查，但也要注意参数匹配，例如，将int类型匹配%s打印，将会出现严重问题。<br>  ７．当传入参数个数少于使用的个数时，可能会出现严重问题，当传入参数大于使用的个数时，多出的参数不会被处理使用。<br>  ８．注意字节对齐问题。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>变长参数</tag>
      </tags>
  </entry>
  <entry>
    <title>ls命令常见实用用法</title>
    <url>/2018/09/16/51043.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ls（list directory contents，列出目录内容）命令是linux最常用的命令之一，通过man ls可以看到，ls的参数很多，但是本文不准备列出或者介绍这些参数的具体含义或用法，而是挑选一些实际应用中最常见的用法。<br><a id="more"></a></p>
<h2 id="介绍之前"><a href="#介绍之前" class="headerlink" title="介绍之前"></a>介绍之前</h2><p>在介绍之前，先说明以下几点：</p>
<ul>
<li>. 代表当前目录</li>
<li>..代表上一级目录，当前目录为根目录时，..与.相同</li>
<li>以.开头的文件为隐藏文件</li>
<li>有类似a-&gt;b的为链接文件，在文件权限列的开头是l</li>
<li>文件或目录名由除”/“和空字符“\0”之外的任意字符序列组成</li>
</ul>
<p>使用ls -l命令列出文件后，有9列，每一列含义如下:</p>
<ul>
<li>1.文件权限</li>
<li>2.连接数</li>
<li>3.文件所有者</li>
<li>4.文件所属组</li>
<li>5.文件大小</li>
<li>6.7.8列，文件最后修改时间</li>
<li>9.文件名</li>
</ul>
<p>下面开始介绍一些常见用法</p>
<h2 id="列出当前目录文件名"><a href="#列出当前目录文件名" class="headerlink" title="列出当前目录文件名"></a>列出当前目录文件名</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls   #列出当前目录文件名，不包括隐藏文件，且无法看到符号链接链向的文件</span><br><span class="line"></span><br><span class="line"># -a   ALL</span><br><span class="line">ls -a #列出当前目录下所有文件，包括隐藏文件，当前目录.以及上一级目录..</span><br><span class="line">ls -A #列出当前目录下所有文件，包括隐藏文件，不包括前目录.以及上一级目录..</span><br><span class="line"></span><br><span class="line">ls -al  # 列出当前目录所有文件，并且使用长格式显示所有信息，包括权限，大小，用户，时间等，与ll作用相同</span><br></pre></td></tr></table></figure>
<h2 id="以易读方式列出当前目录文件大小"><a href="#以易读方式列出当前目录文件大小" class="headerlink" title="以易读方式列出当前目录文件大小"></a>以易读方式列出当前目录文件大小</h2><p>相关参数-h（human-readable）,如下所示，文件大小不以初始字节显示，而是以k或者M为单位显示。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -lh   </span><br><span class="line">总用量 1.4M</span><br><span class="line">drwxrwxr-x 3 hyb  hyb  4.0K 10月 19  2017 Area3</span><br><span class="line">drwxrwxr-x 3 hyb  hyb  4.0K 10月 19  2017 home</span><br><span class="line">-rw-r--r-- 1 root root 1.3K 10月 19  2017 home.zip</span><br><span class="line">lrwxrwxrwx 1 hyb  hyb     8 9月  13 21:19 test -&gt; home.zip</span><br><span class="line">-rw-rw-r-- 1 hyb  hyb  1.3M 9月  16 15:30 test.zip</span><br><span class="line">drwxrwxr-x 2 hyb  hyb  4.0K 10月 19  2017 user</span><br></pre></td></tr></table></figure></p>
<h2 id="递归列出当前目录以及子目录的文件"><a href="#递归列出当前目录以及子目录的文件" class="headerlink" title="递归列出当前目录以及子目录的文件"></a>递归列出当前目录以及子目录的文件</h2><p>相关参数-R（recursive）。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -lR</span><br></pre></td></tr></table></figure></p>
<p>但是这样列出来的内容可读性较差，可参考后面的使用。</p>
<h2 id="列出特定目录下的文件"><a href="#列出特定目录下的文件" class="headerlink" title="列出特定目录下的文件"></a>列出特定目录下的文件</h2><p>参数与前面类似，最后再跟上目录名，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -a test</span><br><span class="line">lrwxrwxrwx 1 hyb hyb 8 9月  13 21:19 test -&gt; home.zip</span><br></pre></td></tr></table></figure></p>
<h2 id="列出符合条件的文件"><a href="#列出符合条件的文件" class="headerlink" title="列出符合条件的文件"></a>列出符合条件的文件</h2><p>参数与前面类似，最后跟上条件，例如列出所有以te开头的文件:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -al te*</span><br><span class="line">lrwxrwxrwx 1 hyb hyb       8 9月  13 21:19 test -&gt; home.zip</span><br><span class="line">-rw-rw-r-- 1 hyb hyb 1345047 9月  16 15:30 test.zip</span><br></pre></td></tr></table></figure></p>
<h2 id="按指定顺序列出文件"><a href="#按指定顺序列出文件" class="headerlink" title="按指定顺序列出文件"></a>按指定顺序列出文件</h2><p>列出时，也可以按照指定字段排序列出，同样还可以配合前面的参数一起使用，例如:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -lt  #按文件修改时间排序</span><br><span class="line">ls -alS  #按文件大小排序</span><br><span class="line">ls  -X   #按扩展名排序</span><br></pre></td></tr></table></figure></p>
<h2 id="计算目录下的文件或目录数量"><a href="#计算目录下的文件或目录数量" class="headerlink" title="计算目录下的文件或目录数量"></a>计算目录下的文件或目录数量</h2><p>先介绍以下文件权限列，文件权限列的开头代表了文件类型：</p>
<ul>
<li>l 链接文件</li>
<li>d 目录</li>
<li>- 普通文件<br>下面命令中^-的含义为，以-开头的字符，有兴趣的可以学习更多正则表达式的使用，这里不再赘述。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -l | grep &quot;^-&quot; | wc -l  #计算当前目录下文件数量</span><br><span class="line">ls -lR | grep &quot;^-&quot; | wc -l #包括子目录</span><br><span class="line">ls -lR | grep &quot;^d&quot; | wc -l #计算当前目录下的目录数量，且不包括.和..</span><br><span class="line">ls -lR | grep &quot;^l&quot; | wc -l  #计算当前目录下的链接数量</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="列出目录下部分文件"><a href="#列出目录下部分文件" class="headerlink" title="列出目录下部分文件"></a>列出目录下部分文件</h2><p>当目录下文件较多时，可以结合more命令，只显示部分，例如:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -al|more</span><br></pre></td></tr></table></figure></p>
<h2 id="列出目录下所有文件的完整路径"><a href="#列出目录下所有文件的完整路径" class="headerlink" title="列出目录下所有文件的完整路径"></a>列出目录下所有文件的完整路径</h2><p>例如，列出LTE目录下所有文件完整路径，$9代表第9列，即文件名，-R，递归子目录。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -lR |grep &apos;^-&apos; |awk &apos;&#123;print &quot;/LTE/&quot; $9&#125;&apos;</span><br><span class="line">/LTE/1.txt</span><br><span class="line">/LTE/home.zip</span><br><span class="line">/LTE/test.zip</span><br><span class="line">/LTE/qqq.txt</span><br><span class="line">/LTE/test.txt</span><br><span class="line">/LTE/qqq.txt</span><br><span class="line">ls -lR |grep &apos;^-&apos; |awk &apos;&#123;print &quot;/LTE/&quot; $1 &quot; &quot; $9 &#125;&apos; ##打印第一列和第九列</span><br></pre></td></tr></table></figure></p>
<p>^-也可以改为以下几种：</p>
<ul>
<li>^l 列出目录下所有链接</li>
<li>^[-l] 列出目录下所有文件和链接</li>
<li>^d 列出目录下所有目录</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ls命令是linux最常见的命令之一，以上用法在实际应用中基本能够满足日常需求，更多参数或使用方法可使用命令man ls查看。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ls</tag>
      </tags>
  </entry>
  <entry>
    <title>理一理字节对齐的那些事</title>
    <url>/2018/09/15/43741.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>字节对齐是我们初学C语言就会接触到的一个概念，但是到底什么是字节对齐？对齐准则又是什么？为什么要字节对齐呢？字节对齐对我们编程有什么启示？本文将简单理一理字节对齐的那些事。<br><a id="more"></a></p>
<h2 id="什么是字节对齐"><a href="#什么是字节对齐" class="headerlink" title="什么是字节对齐"></a>什么是字节对齐</h2><p>计算机中内存大小的基本单位是字节（byte），理论上来讲，可以从任意地址访问某种基本数据类型，但是实际上，计算机并非逐字节大小读写内存，而是以2,4,或8的 倍数的字节块来读写内存，如此以来就会对基本数据类型的合法地址作出一些限制，即它的地址必须是2，4或8的倍数。那么就要求各种数据类型按照一定的规则在空间上排列，这就是对齐。</p>
<h2 id="对齐准则是什么"><a href="#对齐准则是什么" class="headerlink" title="对齐准则是什么"></a>对齐准则是什么</h2><p>总的来说，字节对齐有以下准则：</p>
<ul>
<li><strong>结构体变量的首地址能够被其对齐字节数大小所整除</strong>。</li>
<li><strong>结构体每个成员相对结构体首地址的偏移都是成员大小的整数倍</strong>，如不满足，对前一个成员填充字节以满足。</li>
<li><strong>结构体的总大小为结构体对齐字节数大小的整数倍</strong>，如不满足，最后填充字节以满足。<br>我们通过一个小例子来说明是如何对齐的。<br>考虑下面的程序<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*================================================================</span></span><br><span class="line"><span class="comment">*   Copyright (C) 2018  Ltd. All rights reserved.</span></span><br><span class="line"><span class="comment">*   </span></span><br><span class="line"><span class="comment">*   文件名称：testByteAlign.c</span></span><br><span class="line"><span class="comment">*   创 建 者：shouwang</span></span><br><span class="line"><span class="comment">*   创建日期：2018年09月15日</span></span><br><span class="line"><span class="comment">*   描    述：</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">================================================================*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    short d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*在32位和64位的机器上，size_t的大小不同*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the size of struct test is %zu\n"</span>,<span class="keyword">sizeof</span>(struct test));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>编译成32位程序并运行（默认四字节自然对齐），可以看到，结构体test 的大小为16字节，而不是11字节（a占4字节，b占1字节，c占4字节，d占2字节）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#64位机器上编译32位程序可能需要安装一个库</span><br><span class="line">#sudo apt-get install gcc-multilib</span><br><span class="line">gcc -m32 -o testByteAlign testByteAlign.c #编译程序</span><br><span class="line">chmod +x testByteAlign  #赋执行权限</span><br><span class="line">./testByteAlign  #运行</span><br><span class="line">the size of struct test is 16</span><br></pre></td></tr></table></figure></p>
<p>实际上，结构体test的成员在内存中可能是像下面这样分布的（数值为偏移量）<br>未对齐时:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>0~3</th>
<th>4</th>
<th>5~9</th>
<th>10~11</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>b</td>
<td>c</td>
<td>d</td>
</tr>
</tbody>
</table>
</div>
<p>对齐时:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>0~3</th>
<th>4</th>
<th>5~7</th>
<th>8~11</th>
<th>12~13</th>
<th>14~15</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>b</td>
<td>填充内容</td>
<td>c</td>
<td>d</td>
<td>填充内容</td>
</tr>
</tbody>
</table>
</div>
<p>从上面可以看出，c的偏移为5，不满足对齐要求（它的偏移量应该能够被sizeof（int）大小整除），因此在b后面填充了3个字节，使得c的偏移为8。在b后面填充后，d已经满足对齐要求了，为什么最后还要填充字节呢？或者说，为什么需要满足第三条准则呢？<br>考虑下面的声明<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">teArray</span>[2];</span></span><br></pre></td></tr></table></figure></p>
<p>我们不难知道，teArray[0]的d如果不填充字节，那么teArray[1]的a偏移为14，不满足对齐要求，因此d后面也需要填充字节。</p>
<h2 id="为什么要字节对齐"><a href="#为什么要字节对齐" class="headerlink" title="为什么要字节对齐"></a>为什么要字节对齐</h2><p>无论数据是否对齐，大多数计算机还是能够正确工作，而且从前面可以看到，结构体test本来只需要11字节的空间，最后却占用了16字节，很明显<strong>浪费了空间</strong>，那么为什么还要进行字节对齐呢？最重要的考虑是<strong>提高内存系统性能</strong><br>    前面我们也说到，计算机每次读写一个字节块，例如，假设计算机总是从内存中取8个字节，如果一个double数据的地址对齐成8的倍数，那么一个内存操作就可以读或者写，但是如果这个double数据的地址没有对齐，数据就可能被放在两个8字节块中，那么我们可能需要执行两次内存访问，才能读写完成。显然在这样的情况下，是低效的。所以需要字节对齐来提高内存系统性能。<br>    在有些处理器中，如果需要未对齐的数据，可能不能够正确工作甚至crash，这里我们不多讨论。</p>
<h2 id="实际编程中的考虑"><a href="#实际编程中的考虑" class="headerlink" title="实际编程中的考虑"></a>实际编程中的考虑</h2><p>实际上，字节对齐的细节都由编译器来完成，我们不需要特意进行字节的对齐，但并不意味着我们不需要关注字节对齐的问题。</p>
<h4 id="空间存储"><a href="#空间存储" class="headerlink" title="空间存储"></a>空间存储</h4><p>还是考虑前面的结构体test，其占用空间大小为16字节，但是如果我们换一种声明方式，调整变量的顺序，重新运行程序，最后发现结构体test占用大小为<strong>12字节</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    short d;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>空间存储情况如下,b和d存储在了一个字节块中:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>0~3</th>
<th>4</th>
<th>5-6</th>
<th>7</th>
<th>8~11</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>b</td>
<td>d</td>
<td>填充内容</td>
<td>c</td>
</tr>
</tbody>
</table>
</div>
<p>也就是说，如果我们在设计结构的时候，合理调整成员的位置，可以大大节省存储空间。</p>
<h4 id="跨平台通信"><a href="#跨平台通信" class="headerlink" title="跨平台通信"></a>跨平台通信</h4><p>由于不同平台对齐方式可能不同，如此一来，同样的结构在不同的平台其大小可能不同，在无意识的情况下，互相发送的数据可能出现错乱，甚至引发严重的问题。因此，为了不同处理器之间能够正确的处理消息，我们有两种可选的处理方法。</p>
<ul>
<li>1字节对齐 </li>
<li>自己对结构进行字节填充</li>
</ul>
<p>我们可以使用伪指令#pragma pack(n)（n为字节对齐数）来使得结构间一字节对齐。<br>同样是前面的程序，如果在结构体test的前面加上伪指令，即如下:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1) <span class="comment">/*1字节对齐*/</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    short d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()<span class="comment">/*还原默认对齐*/</span></span></span><br></pre></td></tr></table></figure></p>
<p>在这样的声明下，任何平台结构体test的大小都为11字节，这样做能够保证跨平台的结构大小一致，同时还节省了空间，但不幸的是，降低了效率。</p>
<p>当然了对于单个结构体，gcc还有如下的用法，使其1字节对齐<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    short d;</span><br><span class="line">&#125;__attribute__ ((packed));</span><br></pre></td></tr></table></figure></p>
<p>注:</p>
<ul>
<li>_<em>attribute_</em>((aligned (n)))，让所作用的结构成员对齐在n字节自然边界上。如果结构中有成员的长度大于n，则按照最大成员的长度来对齐。</li>
<li>_<em>attribute_</em> ((packed))，取消结构在编译过程中的优化对齐，也可以认为是1字节对齐。<br>除了前面的1字节对齐，还可以进行人为的填充，即test结构体声明如下:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct test</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    char b;</span><br><span class="line">    char reserve[3];</span><br><span class="line">    int c;</span><br><span class="line">    short d;</span><br><span class="line">    char reserve1[2];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>访问效率高，但并不节省空间，同时扩展性不是很好，例如，当字节对齐有变化时，需要填充的字节数可能就会发生变化。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然我们不需要具体关心字节对齐的细节，但是如果不关注字节对齐的问题，可能会在编程中遇到难以理解或解决的问题。因此针对字节对齐，总结了以下处理建议：</p>
<ul>
<li>结构体成员合理安排位置，以节省空间</li>
<li>跨平台数据结构可考虑1字节对齐，节省空间但影响访问效率</li>
<li>跨平台数据结构人为进行字节填充，提高访问效率但不节省空间</li>
<li>本地数据采用默认对齐，以提高访问效率</li>
</ul>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>字节对齐</tag>
      </tags>
  </entry>
  <entry>
    <title>对进程和线程的一些总结</title>
    <url>/2018/09/07/47517.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>进程（Process）和线程（Thread）都是操作系统中的基本概念，它们之间有一些优劣和差异。<br><a id="more"></a></p>
<h2 id="进程基本介绍"><a href="#进程基本介绍" class="headerlink" title="进程基本介绍"></a>进程基本介绍</h2><p>进程是程序执行时的一个实例，是系统进行资源分配和调度的基本单位。所有与该进程有关的资源，都被记录在进程控制块(PCB)中。以表示该进程拥有这些资源或正在使用它们。另外，进程也是抢占处理机的调度单位，它拥有一个完整的虚拟地址空间。当进程发生调度时，不同的进程拥有不同的虚拟地址空间，而同一进程内的不同线程共享同一地址空间。</p>
<h2 id="线程基本介绍"><a href="#线程基本介绍" class="headerlink" title="线程基本介绍"></a>线程基本介绍</h2><p>线程，有时也被称为轻量级进程，是程序执行流的最小单元，是进程中的一个实体，是被系统独立调度和分派的基本单位。与进程不同，线程与资源分配无关，线程自己不拥有系统资源，它属于某一个进程，并与进程内的其他线程一起共享进程的资源。线程只由相关堆栈（系统栈或用户栈）寄存器和线程控制表TCB组成。</p>
<h2 id="进程和线程的关系"><a href="#进程和线程的关系" class="headerlink" title="进程和线程的关系"></a>进程和线程的关系</h2><p>通常在一个进程中可以包含若干个线程，它们可以利用进程所拥有的资源。但是，一个线程只属于一个进程。进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。而且需要注意的是，线程不是一个可执行的实体。</p>
<h2 id="进程和线程的比较"><a href="#进程和线程的比较" class="headerlink" title="进程和线程的比较"></a>进程和线程的比较</h2><p>进行和线程之间的差异可以从下面几个方面来阐述：</p>
<ul>
<li><p>调度 ：在引入线程的操作系统中，线程是调度和分配的基本单位 ，进程是资源拥有的基本单位 。把传统进程的两个属性分开，线程便能轻装运行，从而可 <strong>显著地提高系统的并发程度</strong> 。 在同一进程中，线程的切换不会引起进程的切换；在由一个进程中的线程切换到另一个进程中的线程时，才会引起进程的切换。</p>
</li>
<li><p>并发性 ：在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可并发执行，因而使操作系统具有更好的并发性，从而能 <strong>更有效地使用系统资源和提高系统吞吐量</strong>。</p>
</li>
<li><p>拥有资源 ：不论是传统的操作系统，还是设有线程的操作系统，进程都是拥有资源的一个独立 单位，它可以拥有自己的资源。 一般地说，<strong>线程自己不拥有系统资源（只有一些必不可少的资源</strong>，但它可以访问其隶属进程的资源。</p>
</li>
<li><p>系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。<strong>进程切换的开销也远大于线程切换的开销。</strong></p>
</li>
<li>通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性，因此共享简单。但是线程的数据同步要比进程略复杂。</li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>从上面的分析可以看到，似乎线程有很多优势，比如，数据共享效率高，可应对并发操作，有效利用等待时间等等，但是多线程的编程要比多进程要简单，同时，多进程的可靠性较好，因为进程间不会相互影响。实际情况还是需要自己分析拿捏的。但是一般来说，实际应用中都是采用“进程+线程”结合的方式，而不是非此即彼。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>进程</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>对浮点数的一些理解</title>
    <url>/2018/09/05/65196.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相比int等整型，float等浮点类型的表示和存储较为复杂，但它又是一个无法回避的话题，那么就有必要对浮点一探究竟了。在计算机中，一般用IEEE浮点近似表示任意一个实数，那么它实际上又是如何表示的呢？<br><a id="more"></a></p>
<h2 id="IEEE浮点表示"><a href="#IEEE浮点表示" class="headerlink" title="IEEE浮点表示"></a>IEEE浮点表示</h2><p>IEEE浮点标准用V=(-1)^s   *  M  *  2^E<br>的形式近似表示一个数。并且将浮点数的位表示划分为三个字段：</p>
<ul>
<li><p>符号（sign）s决定这个数是负数（s=1）还是正数（s=0）。可以用一个单独的符号s直接编码符号s。</p>
</li>
<li><p>尾数（signficand）M是一个二进制小数，它的范围是1～2-ξ或者是0～1-ξ。<br>n位小数字段frac=fn-1……f0编码尾数M。</p>
</li>
</ul>
<ul>
<li>阶码（exponent）E的作用是对浮点数加权，这个权重是2的E次幂（可能是负数）。k位的阶码字段 exp=ek-1……e0编码阶码E。</li>
</ul>
<p>在单精度浮点格式（c语言的float）中，s，exp和frac字段分别为1位，8位和23位,而双精度浮点格式（c语言中的double）中，s，exp和frac字段分别为1位，11位和52位。<br>一个浮点数的常见比特位表示如下:</p>
<ul>
<li>单精度</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>s（31）</th>
<th>exp（30~23）</th>
<th>frac（22~0)</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>双精度</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>s（63）</th>
<th>exp（62~52）</th>
<th>frac（51~0）</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>而根据exp的值，被编码的值可以分为三大类不同的情况。下面进行一一解释。</p>
<h4 id="情况1：规格化的值"><a href="#情况1：规格化的值" class="headerlink" title="情况1：规格化的值"></a>情况1：规格化的值</h4><p>即最普遍的情况，当exp，即阶码域既不为全0，也不为全1的情况。在这种情况下，阶码字段解释为以偏置（biased）形式表示有符号整数，即<strong>E=exp-Bias</strong>,exp是无符号数（1~254）。Bias是一个等于(2^(k-1))-1的偏置值，对于单精度来说，k=23，Bias=127，因此E的范围是-126~+127。</p>
<p>frac被描述为小数值，且0&le;frac&lt;1,其二进制表示为0.frac。尾数定义为 <strong>M=1+frac</strong> ，则M=1.frac。那么就有1&le;M&lt;2,由于总是能够调整阶码E，使得M在范围1&le;M&lt;2,所以不需要显示的表示它，这样还能获得一个额外的精度位。也就是说，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的frac部分,等到读取的时候，再把第一位的1加上去。</p>
<h4 id="情况2：非规格化的值"><a href="#情况2：非规格化的值" class="headerlink" title="情况2：非规格化的值"></a>情况2：非规格化的值</h4><p>当exp，即阶码域为全0时，所表示的数便为非规格化的值，该情况下的阶码值<strong>E=1-Bias</strong>（注:为从非格式化值转换到格式化值提供了一种方法）。尾数<strong>M=frac</strong></p>
<p>非规格化的数有两个作用。</p>
<ul>
<li>表示数值0。格式化数中，我们总使得M&ge;1，因此就无法表示0。而阶码全0时，且尾数也全0时，就可以表示0了。</li>
<li>表示接近0.0的数。它所表示的值分布地接近于0.0，该属性成为逐渐溢出。</li>
</ul>
<h4 id="情况3：特殊值"><a href="#情况3：特殊值" class="headerlink" title="情况3：特殊值"></a>情况3：特殊值</h4><p>有两种</p>
<ul>
<li>阶码全为1，小数域全为0。它得到值为 +∞(s=0)或-∞（s=1），它在计算机中可以表示溢出的结果，例如两个非常大的数相乘。</li>
<li>阶码全为1，小数域不全为0。它得到值为NaN（Note a Number）。它在计算机中可以表示非法的数，例如计算根号-1时的值。</li>
</ul>
<h2 id="浮点数的范围和有效位"><a href="#浮点数的范围和有效位" class="headerlink" title="浮点数的范围和有效位"></a>浮点数的范围和有效位</h2><p>对于浮点数，其能表示的数值范围和其有效位如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>比特位</th>
<th>数值范围</th>
<th>有效位</th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td>32</td>
<td>-3.4<em>10^38～+3.4</em>10^38</td>
<td>6~7位</td>
</tr>
<tr>
<td>double</td>
<td>64</td>
<td>-1.7<em>10^-308~1.7</em>10^308</td>
<td>15~16位</td>
</tr>
<tr>
<td>long double</td>
<td>128</td>
<td>-1.2<em>10^-4932~1.2</em>10^4932</td>
<td>18~19位</td>
</tr>
</tbody>
</table>
</div>
<p>可见同比特位数的整型（例如int）要比浮点数（例如float）能表示的数值范围要小很多，但是需要注意的，虽然浮点数能表示的范围大，但是 它却不能精确表示在其范围内的所有实数，也就是说，它只能保证有效位的值是精确的，当表示的数值（小数部分）超过有效位时，所表示的数是无法保证精确的，甚至可以说是错误的。<br>那么浮点数的数值范围和有效位是如何得到的呢？</p>
<h4 id="浮点数的数值范围计算"><a href="#浮点数的数值范围计算" class="headerlink" title="浮点数的数值范围计算"></a>浮点数的数值范围计算</h4><p>有了前面了基础，我们就可以来计算浮点数的数值范围了。以单精度（float）为例，我们知道它的指数范围（即E）为-126~+127，而M的范围为1&le;M&lt;2，实际上，对于单精度，1&le;M&le;2-2^（-23）（注:23为frac字段所占的比特位）。那么我们就可以得到单精度的最大值为:<br><img src="/images/float_max.png" alt="float_max"><br>同理，我们可以得到单精度的最小值为：</p>
<p><img src="/images/float_min.png" alt="float_max"></p>
<p>我们仅仅以单精度为例，用同样的方法可以计算其他精度的浮点数数值范围，在此不再赘述。</p>
<h4 id="浮点数的有效位"><a href="#浮点数的有效位" class="headerlink" title="浮点数的有效位"></a>浮点数的有效位</h4><p>有效位也可以理解为我们常说的精度。浮点数的精度是由尾数的位数来决定的。<br>对于单精度（float），它的尾数为23位，而2^23=8388608，共7位，也就是说最多能有7位有效数字，但至少能保证6位，因此其有效位为6~7位。当然我们可以通过下面的内容进一步理解。以下计算结果保留10位小数。<br>a=2^(-23)=0.0000001192<br>b=2^(-22)=0.0000002384<br>c=2^(-21)=0.0000004768<br>观察a和b的结果可以发现，0.0000001和0.0000002之间的其他数是没有办法通过单精度浮点数来精确表示的，也就是说，只有到小数点后面7位的值才是精确的，同理，观察b和c的结果，0.0000002到0.0000004之间的其他数也是不能通过单精度浮点数精确表示的，更不幸地是，这之间的数，甚至只能精确到第6位。</p>
<p>这也就有了<strong>单精度浮点数的有效位为6~7位</strong>的结论。根据相似的方法，我们同样可以得到<strong>双精度浮点数的有效位为15~16位</strong>的结论，这里不再赘述。</p>
<h2 id="浮点数在内存中的存储"><a href="#浮点数在内存中的存储" class="headerlink" title="浮点数在内存中的存储"></a>浮点数在内存中的存储</h2><p>了解了这么多，我们来看一下一个小数究竟是如何在内存中存储的。以float f = 8.25f为例。其二进制表示为1000.1=1.0001*2^3,可见指数实际值为3，则根据E=exp-Bias，可知exp=E+Bias=3+127=130，根据M=1+frac,可知，frac=M-1=0.0001（二进制）而<br>130(10)=10000010(2)<br>因此不难得到，8.25的在内存中的存储情况为：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>s</th>
<th>exp</th>
<th>frac</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1000 0010</td>
<td>0001 0000 0000 0000 0000 000</td>
</tr>
</tbody>
</table>
</div>
<p><strong>如果这个时候把这个值作为整型使用，是多少呢？没错，是1090781184</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main(int argc,char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	float f=8.25f;</span><br><span class="line">	int *i = (int*)&amp;f;</span><br><span class="line">	printf(&quot;%d\n&quot;,*i);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="再说几句"><a href="#再说几句" class="headerlink" title="再说几句"></a>再说几句</h2><p>关于浮点数，需要再说几句：</p>
<ul>
<li>在二进制，第一个有效数字必定是“1”，因此这个“1”并不会存储。</li>
<li>浮点数不能精确表示其范围内的所有数。</li>
<li>可精确表示的数不是均匀分布的，越靠近0越稠密。</li>
<li>默认舍入方式为向偶舍入，也被称为最接近的值舍入。</li>
<li>不遵守普遍的算术属性，比如结合律。</li>
</ul>
<p>参考文献：<br><a href="https://zh.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/IEEE_754</a><br><a href="http://csapp.cs.cmu.edu/" target="_blank" rel="noopener">http://csapp.cs.cmu.edu/</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>浮点数</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>系统调用和库函数的区别</title>
    <url>/2018/05/28/26708.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从用户的角度来看，系统调用和库函数似乎没有什么区别，它们都是以C函数的形式出现，并且两者都为应用程序提供服务。但从实现者角度来看，它们之间是有根本的区别。那么，它们之间到底有哪些不同呢？在说明之前，先简单了解以下系统调用和库函数。<br><a id="more"></a></p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用指运行在用户空间的程序向操作系统内核请求需要更高权限运行的服务。它通过软中断向内核态发出一个明确的请求。系统调用实现了用户态进程和硬件设备之间的大部分接口。</p>
<h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><p>库函数用于提供用户态服务。它可能调用封装了一个或几个不同的系统调用（printf调用write），也可能直接提供用户态服务（atoi不调用任何系统调用）。</p>
<h2 id="常见系统调用和库函数"><a href="#常见系统调用和库函数" class="headerlink" title="常见系统调用和库函数"></a>常见系统调用和库函数</h2><ul>
<li><strong>常见系统调用</strong><br>open, close, read, write, ioctl，fork，clone，exit，getpid，access，chdir，chmod，stat，brk，mmap等，需要包含unistd.h等头文件。</li>
<li><strong>常见库函数</strong><br>printf，scanf，fopen，fclose，fgetc，fgets，fprintf，fsacnf，fputc，calloc，free，malloc，realloc，strcat，strchr，strcmp，strcpy，strlen，strstr等，需要包含stdio.h，string.h，alloc.h，stdlib.h等头文件。<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2></li>
<li><p><strong>系统调用通常不可替换，而库函数通常可替换</strong><br>普通的库函数调用由函数库或用户自己提供，因此库函数是可以替换的。例如，对于存储空间分配函数malloc，如果不习惯它的操作方式，我们完全可以定义自己的malloc函数。</p>
</li>
<li><p><strong>系统调用通常提供最小接口，而库函数通常提供较复杂功能</strong><br>例如sbrk系统调用分配一块空间给进程，而malloc则在用户层次对这以空间进行管理。</p>
</li>
<li><p><strong>系统调用运行在内核空间，而库函数运行在用户空间</strong><br>因为系统调用属于内核，和库函数不属于内核。因此，如果当用户态进程调用一个系统调用时，CPU需要将其切换到内核态，并执行一个内核函数。</p>
</li>
<li><p><strong>内核调用都返回一个整数值，而库函数并非一定如此</strong><br>在内核中，整数或0表示系统调用成功结束，而负数表示一个出错条件。而出错时，内核不会将其设置在errno，而是由库函数从系统调用返回后对其进行设置或使用。</p>
</li>
<li><strong>POSIX 标准针对库函数而不是系统调用</strong><br>判断一个系统是否与POSIX需要看它是否提供一组合适的应用程序接口，而不管其对应的函数是如何实现的。因此<strong>从移值性来讲，使用库函数的移植性较系统调用更好。</strong></li>
<li><strong>系统调用运行时间属于系统时间，库函数运行时间属于用户时间</strong></li>
<li><strong>调用系统调用开销相对库函数来说更大</strong><br>很多库函数本身都调用了系统调用，那为什么直接调用系统调用的开销较大呢？这得益于双缓冲的实现，在用户态和内核态，都应用了缓冲技术，对于文件读写来说，调用库函数，可以大大减少调用系统调用的次数。而用户进程调用系统调用需要在用户空间和内核空间进行上下文切换，开销较大。如此以来，库函数的开销也就会比直接调用系统调用小了。另外一方面，库函数同样会对系统调用的性能进行优化。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>系统调用与库函数有联系也有区别，但是通常情况下，会建议使用库函数，主要出于以下几个方面的考虑：</p>
<ul>
<li>双缓冲技术</li>
<li>移植性</li>
<li>系统调用本身性能缺陷</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>C</tag>
        <tag>系统调用</tag>
        <tag>库函数</tag>
      </tags>
  </entry>
  <entry>
    <title>常见linux命令介绍－sed</title>
    <url>/2018/05/27/19567.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>sed(Stream EDitor，流编辑器)是文本处理中常用的工具，能够使用正则表达式，功能不可小觑。<br><a id="more"></a></p>
<h2 id="命令基本介绍"><a href="#命令基本介绍" class="headerlink" title="命令基本介绍"></a>命令基本介绍</h2><p>sed的命令格式： sed [option] 　‘sed command’　filename<br>执行sed处理命令<br>sed的脚本格式：sed [option] -f 　‘sed script’　filename<br>执行脚本中的sed处理命令</p>
<h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><p>-n ：只打印模式匹配的行</p>
<p>-e ：直接在命令行模式上进行sed动作编辑，此为默认选项</p>
<p>-f ：将sed的动作写在一个文件内，用–f filename 执行filename内的sed动作</p>
<p>-r ：    在脚本中使用扩展正则表达式。</p>
<p>-i ：直接修改文件内容<br>-s：将输入文件视为各个独立的文件而不是一个长的连续输入。</p>
<h3 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h3><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>a\</td>
<td>在当前行下面插入文本。</td>
</tr>
<tr>
<td>i\</td>
<td>在当前行上面插入文本。</td>
</tr>
<tr>
<td>c\</td>
<td>把选定的行改为新的文本。</td>
</tr>
<tr>
<td>d</td>
<td>删除，删除选择的行。</td>
</tr>
<tr>
<td>D</td>
<td>删除模板块的第一行。</td>
</tr>
<tr>
<td>s</td>
<td>替换指定字符</td>
</tr>
<tr>
<td>h</td>
<td>拷贝模板块的内容到内存中的缓冲区。</td>
</tr>
<tr>
<td>H</td>
<td>追加模板块的内容到内存中的缓冲区。</td>
</tr>
<tr>
<td>g</td>
<td>获得内存缓冲区的内容，并替代当前模板块中的文本。</td>
</tr>
<tr>
<td>G</td>
<td>获得内存缓冲区的内容，并追加到当前模板块文本的后面。</td>
</tr>
<tr>
<td>l</td>
<td>列表不能打印字符的清单。</td>
</tr>
<tr>
<td>n</td>
<td>读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。</td>
</tr>
<tr>
<td>N</td>
<td>追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。</td>
</tr>
<tr>
<td>p</td>
<td>打印模板块的行。</td>
</tr>
<tr>
<td>P(大写)</td>
<td>打印模板块的第一行。</td>
</tr>
<tr>
<td>q</td>
<td>退出Sed。</td>
</tr>
<tr>
<td>b lable</td>
<td>分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。</td>
</tr>
<tr>
<td>r file</td>
<td>从file中读行。</td>
</tr>
<tr>
<td>t label</td>
<td>if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。</td>
</tr>
<tr>
<td>T label</td>
<td>错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。</td>
</tr>
<tr>
<td>w</td>
<td>file 写并追加模板块到file末尾。</td>
</tr>
<tr>
<td>W</td>
<td>file 写并追加模板块的第一行到file末尾。</td>
</tr>
<tr>
<td>!</td>
<td>表示后面的命令对所有没有被选定的行发生作用。</td>
</tr>
<tr>
<td>=</td>
<td>打印当前行号码。</td>
</tr>
<tr>
<td>#</td>
<td>把注释扩展到下一个换行符以前。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="sed替换标记"><a href="#sed替换标记" class="headerlink" title="sed替换标记"></a>sed替换标记</h3><div class="table-container">
<table>
<thead>
<tr>
<th>标记</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>g</td>
<td>表示行内全面替换。</td>
</tr>
<tr>
<td>p</td>
<td>表示打印行。</td>
</tr>
<tr>
<td>w</td>
<td>表示把行写入一个文件。</td>
</tr>
<tr>
<td>x</td>
<td>表示互换模板块中的文本和缓冲区中的文本。</td>
</tr>
<tr>
<td>y</td>
<td>表示把一个字符翻译为另外的字符（但是不用于正则表达式）</td>
</tr>
<tr>
<td>\1</td>
<td>子串匹配标记</td>
</tr>
<tr>
<td>&amp;</td>
<td>已匹配字符串标记</td>
</tr>
</tbody>
</table>
</div>
<h3 id="sed元字符集"><a href="#sed元字符集" class="headerlink" title="sed元字符集"></a>sed元字符集</h3><div class="table-container">
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>匹配行开始，如：/^sed/匹配所有以sed开头的行。</td>
</tr>
<tr>
<td>$</td>
<td>匹配行结束，如：/sed$/匹配所有以sed结尾的行。</td>
</tr>
<tr>
<td>.</td>
<td>匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。</td>
</tr>
<tr>
<td>*</td>
<td>匹配0个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。</td>
</tr>
<tr>
<td>[]</td>
<td>匹配一个指定范围内的字符，如/[ss]ed/匹配sed和Sed。</td>
</tr>
<tr>
<td>[^]</td>
<td>匹配一个不在指定范围内的字符，如：/<sup><a href="#fn_A-RT-Z" id="reffn_A-RT-Z">A-RT-Z</a></sup>ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。</td>
</tr>
<tr>
<td>(..)</td>
<td>匹配子串，保存匹配的字符，如s/(love)able/\1rs，loveable被替换成lovers。</td>
</tr>
<tr>
<td>&amp;</td>
<td>保存搜索字符用来替换其他字符，如s/love/**&amp;**/，love这成**love**。</td>
</tr>
<tr>
<td>\&lt;</td>
<td>匹配单词的开始，如:/\&amp;ltlove/匹配包含以love开头的单词的行。</td>
</tr>
<tr>
<td>\&gt;</td>
<td>匹配单词的结束，如/love\&gt;/匹配包含以love结尾的单词的行。</td>
</tr>
<tr>
<td>x\{m\}</td>
<td>重复字符x，m次，如：/0\{5\}/匹配包含5个0的行。</td>
</tr>
<tr>
<td>x\{m,\}</td>
<td>重复字符x，至少m次，如：/0\{5,\}/匹配至少有5个0的行。</td>
</tr>
<tr>
<td>x\{m,n\}</td>
<td>重复字符x，至少m次，不多于n次，如：/0\{5,10\}/匹配5~10个0的行。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="文本查找"><a href="#文本查找" class="headerlink" title="文本查找"></a>文本查找</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sed  ‘2p’  filename <span class="comment">#打印第二行（第二行会打印两遍），并且会打印文本全部内容</span></span><br><span class="line"></span><br><span class="line">sed -n ‘2p’ filename <span class="comment">#只打印第二行</span></span><br><span class="line"></span><br><span class="line">sed -n <span class="string">'3.5p'</span> filename <span class="comment">#打印3到5行</span></span><br><span class="line"></span><br><span class="line">sed -n <span class="string">'/findstr/p'</span> filename <span class="comment">#打印匹配到findstr的行</span></span><br><span class="line"></span><br><span class="line">sed -n <span class="string">'/findstr1/,findstr2/p'</span> <span class="comment">#打印匹配分的findstr1和findstr2的行</span></span><br><span class="line"></span><br><span class="line">sed -n <span class="string">'3,5&#123;=;p&#125;'</span> filaname <span class="comment">#打印3到5行，并且打印行号</span></span><br><span class="line"></span><br><span class="line">sed -n <span class="string">'3.5!(=;p)'</span> filename <span class="comment">#打印除了3到5行的其他行 !表示对条件取反，其他情况也适用。</span></span><br><span class="line"></span><br><span class="line">sed -n <span class="string">'/pattern/p'</span> filename <span class="comment">#打印符合正则表达式pattern的行，正则表达式不在此介绍</span></span><br></pre></td></tr></table></figure>
<h3 id="文本删除"><a href="#文本删除" class="headerlink" title="文本删除"></a>文本删除</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sed -e <span class="string">'1d'</span> filename  <span class="comment">#删除第一行，但是不修改原文件。实际上把查找中的p换成d,即由打印变成删除动作。而-e 选项更换为-i选项，表明直接修改原文件</span></span><br></pre></td></tr></table></figure>
<h3 id="文本编辑"><a href="#文本编辑" class="headerlink" title="文本编辑"></a>文本编辑</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -i表明直接修改源文件，注意。</span></span><br><span class="line">sed -i <span class="string">'/str1/s/^/str2/'</span> filename <span class="comment">#在有str1的行首增加str2字符</span></span><br><span class="line"></span><br><span class="line">sed -i <span class="string">'s/str1/str2&amp;/'</span> filename  <span class="comment">#在str1前增加str2字符串</span></span><br><span class="line"></span><br><span class="line">sed -i <span class="string">'s/str1/&amp;str2/'</span> filename  <span class="comment">#在str1后增加str2字符串</span></span><br><span class="line"></span><br><span class="line">sed -i <span class="string">'/str1/s/$/str2/'</span> filename <span class="comment">#在有str1的行尾加上str2字符串</span></span><br><span class="line"></span><br><span class="line">sed -i <span class="string">'/str1/i\str2/'</span> filename <span class="comment">#在有str1的前一行增加一行，内容为str2</span></span><br><span class="line"></span><br><span class="line">sed -i <span class="string">'/str1/a\str2/'</span> filename <span class="comment">#在有str1的后一行增加一行，内容为str2，如果要添加多行，需要添加\n转义符，例如 '/str1/astr2\nstr3'</span></span><br><span class="line"></span><br><span class="line">sed -i <span class="string">'s/^/str/'</span> filename <span class="comment">#每行开头添加str字符串</span></span><br><span class="line"></span><br><span class="line">sed -i <span class="string">'s/$/str/'</span> filename <span class="comment">#每行结尾添加str字符串</span></span><br><span class="line"></span><br><span class="line">sed -i <span class="string">'1,3s/^/str/'</span> filename <span class="comment">#1到3行行首添加str字符串</span></span><br><span class="line"></span><br><span class="line">sed -i <span class="string">'/str1/s@/str2@str3@'</span> filename <span class="comment">#将有str1的行中的str2替换为str3，但是只修改一次</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sed -i <span class="string">'/str1/s@/str2@str3@/ng'</span> filename  <span class="comment">#与上一条作用类似，但是是修改n次，如果不带n，则表示修改全文</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>sed是一个非常有用且重要的文本处理工具之一，以上就是sed命令的一些常见操作介绍。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>sed</tag>
      </tags>
  </entry>
  <entry>
    <title>常见linux命令介绍－ps</title>
    <url>/2018/04/06/53515.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ps（Process Status）命令是linux中最常见的命令之一，它用来列出当前系统运行中的进程的状态信息。当然了，它只显示命令<strong>执行时</strong>的进程状态，如果想要动态列出状态信息，可以选择使用top命令。那么通过ps命令我们能够知道进程的哪些信息呢？下面进行介绍。<br><a id="more"></a></p>
<h2 id="命令基本介绍"><a href="#命令基本介绍" class="headerlink" title="命令基本介绍"></a>命令基本介绍</h2><h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>ps命令基本格式为:<br>ps [options]</p>
<h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-A    显示所有进程（同-e）</span><br><span class="line">-a    显示当前终端的所有进程</span><br><span class="line">-u    显示进程的用户信息</span><br><span class="line">-o    以用户自定义形式显示进程信息</span><br><span class="line">-f    显示程序间的关系</span><br></pre></td></tr></table></figure>
<p>对于更多参数的介绍，可使用命令man ps查看，这里不再赘述。</p>
<h2 id="字段含义"><a href="#字段含义" class="headerlink" title="字段含义"></a>字段含义</h2><p>在介绍实例之前，需要先了解一下ps命令输出各字段的含义，这样我们才能更好地理解所展示的信息。常见字段的基本含义如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USER          进程所有者的用户名</span><br><span class="line">PID           进程号</span><br><span class="line">START         进程激活时间</span><br><span class="line">%CPU          进程自最近一次刷新以来所占用的CPU时间和总时间的百分比</span><br><span class="line">%MEM          进程使用内存的百分比</span><br><span class="line">VSZ           进程使用的虚拟内存大小，以K为单位</span><br><span class="line">RSS           驻留空间的大小。显示当前常驻内存的程序的K字节数。</span><br><span class="line">TTY           进程相关的终端</span><br><span class="line">STAT          进程状态，包括下面的状态： </span><br><span class="line">                     D    不可中断     Uninterruptible sleep (usually IO)</span><br><span class="line">                     R    正在运行，或在队列中的进程</span><br><span class="line">                     S    处于休眠状态</span><br><span class="line">                     T    停止或被追踪</span><br><span class="line">                     Z    僵尸进程</span><br><span class="line">                     W    进入内存交换（从内核2.6开始无效）</span><br><span class="line">                     X    死掉的进程</span><br><span class="line">                     &lt;    高优先级</span><br><span class="line">                     N    低优先级</span><br><span class="line">                     L    有些页被锁进内存</span><br><span class="line">                     s    包含子进程</span><br><span class="line">                     \+   位于后台的进程组；</span><br><span class="line">                     l    多线程，克隆线程</span><br><span class="line"></span><br><span class="line">TIME          进程使用的总CPU时间</span><br><span class="line">COMMAND       被执行的命令行</span><br><span class="line">NI            进程的优先级值，较小的数字意味着占用较少的CPU时间</span><br><span class="line">PRI           进程优先级。</span><br><span class="line">PPID          父进程ID</span><br><span class="line">WCHAN         进程等待的内核事件名</span><br></pre></td></tr></table></figure></p>
<h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h2><p>下面来看看一些常见用法。</p>
<h4 id="显示所有进程信息"><a href="#显示所有进程信息" class="headerlink" title="显示所有进程信息"></a>显示所有进程信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps　-A</span><br><span class="line"> PID TTY          TIME CMD</span><br><span class="line">    1 ?        00:00:03 systemd</span><br><span class="line">    2 ?        00:00:00 kthreadd</span><br><span class="line">    4 ?        00:00:00 kworker/0:0H</span><br><span class="line">    6 ?        00:00:00 mm_percpu_wq</span><br><span class="line">    7 ?        00:00:00 ksoftirqd/0</span><br><span class="line">    8 ?        00:00:02 rcu_sched</span><br><span class="line">    9 ?        00:00:00 rcu_bh</span><br><span class="line">   10 ?        00:00:00 migration/0</span><br><span class="line">   11 ?        00:00:00 watchdog/0</span><br><span class="line">（内容较多，其他部分略过。）</span><br></pre></td></tr></table></figure>
<p>虽然能显示所有进程，但是显示的信息却不多，基本只显示了进程id和进程名，有时候并不实用。</p>
<h4 id="显示所有进程基本信息"><a href="#显示所有进程基本信息" class="headerlink" title="显示所有进程基本信息"></a>显示所有进程基本信息</h4><p>相关参数　-e<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         1     0  0 10:52 ?        00:00:03 /sbin/init splash</span><br><span class="line">root         2     0  0 10:52 ?        00:00:00 [kthreadd]</span><br><span class="line">root         4     2  0 10:52 ?        00:00:00 [kworker/0:0H]</span><br><span class="line">root         6     2  0 10:52 ?        00:00:00 [mm_percpu_wq]</span><br><span class="line">root         7     2  0 10:52 ?        00:00:00 [ksoftirqd/0]</span><br><span class="line">root         8     2  0 10:52 ?        00:00:02 [rcu_sched]</span><br><span class="line">root         9     2  0 10:52 ?        00:00:00 [rcu_bh]</span><br><span class="line">root        10     2  0 10:52 ?        00:00:00 [migration/0]</span><br><span class="line">（内容较多，其他部分略过。）</span><br></pre></td></tr></table></figure></p>
<p>这个时候已经显示较多信息了。</p>
<h4 id="显示指定用户的进程"><a href="#显示指定用户的进程" class="headerlink" title="显示指定用户的进程"></a>显示指定用户的进程</h4><p>相关参数-u<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -u root</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    1 ?        00:00:03 systemd</span><br><span class="line">    2 ?        00:00:00 kthreadd</span><br><span class="line">    4 ?        00:00:00 kworker/0:0H</span><br><span class="line">    6 ?        00:00:00 mm_percpu_wq</span><br><span class="line">    7 ?        00:00:00 ksoftirqd/0</span><br><span class="line">    8 ?        00:00:03 rcu_sched</span><br><span class="line">    9 ?        00:00:00 rcu_bh</span><br></pre></td></tr></table></figure></p>
<h4 id="查看指定进程名相关信息"><a href="#查看指定进程名相关信息" class="headerlink" title="查看指定进程名相关信息"></a>查看指定进程名相关信息</h4><p>这个时候就需要配合grep使用了。<br>例如，查看”java“相关进程：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef|grep java</span><br><span class="line">root       2685  2684  2 10:55 pts/0    00:01:19 java -jar ./software/finalspeed/finalspeed_client.jar</span><br><span class="line">root       5423  4487  0 11:55 pts/20   00:00:00 grep --color=auto java</span><br></pre></td></tr></table></figure></p>
<h4 id="查看进程占用内存，cpu利用率等信息"><a href="#查看进程占用内存，cpu利用率等信息" class="headerlink" title="查看进程占用内存，cpu利用率等信息"></a>查看进程占用内存，cpu利用率等信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -aux</span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.0  0.0 185488  6188 ?        Ss   10:52   0:03 /sbin/init splash</span><br><span class="line">root         2  0.0  0.0      0     0 ?        S    10:52   0:00 [kthreadd]</span><br><span class="line">root         4  0.0  0.0      0     0 ?        S&lt;   10:52   0:00 [kworker/0:0H]</span><br><span class="line">root         6  0.0  0.0      0     0 ?        S&lt;   10:52   0:00 [mm_percpu_wq]</span><br></pre></td></tr></table></figure>
<p>从上面的信息，可以看到进程的所有者、cpu占用率、内存占用率等较为详细的信息。</p>
<h4 id="显示线程相关信息"><a href="#显示线程相关信息" class="headerlink" title="显示线程相关信息"></a>显示线程相关信息</h4><p>相关参数-l<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -elf</span><br></pre></td></tr></table></figure></p>
<h4 id="查看进程间的关系"><a href="#查看进程间的关系" class="headerlink" title="查看进程间的关系"></a>查看进程间的关系</h4><p>相关参数-H，进程间关系以树形图的方式展示:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ejH</span><br></pre></td></tr></table></figure></p>
<h4 id="查看进程的指定字段信息"><a href="#查看进程的指定字段信息" class="headerlink" title="查看进程的指定字段信息"></a>查看进程的指定字段信息</h4><p>有时候可能比较关注某些进程信息，ps -o可以指定要显示的列<br>例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -eo %cpu,%mem,vsz,rsz,start,stat,pid,sid,ni,uid,user,rss,time,command</span><br><span class="line">.0  0.0      0     0 10:52:51 S      365     0   -     0 root         0 00:00:00 [irq/47-mei_me]</span><br><span class="line"> 0.0  0.0      0     0 10:52:51 S&lt;     373     0 -20     0 root         0 00:00:00 [cfg80211]</span><br><span class="line"> 0.0  0.0      0     0 10:52:52 S&lt;     402     0 -20     0 root         0 00:00:00 [ktpacpid]</span><br><span class="line"> 0.0  0.0      0     0 10:52:56 S      669     0   0     0 root         0 00:00:00 [jbd2/sda15-8]</span><br><span class="line"> 0.0  0.0      0     0 10:52:56 S&lt;     670     0 -20     0 root         0 00:00:00 [ext4-rsv-conver]</span><br><span class="line"> 0.0  0.0      0     0 10:52:57 S      676     0   0     0 root         0 00:00:00 [jbd2/sda11-8]</span><br><span class="line"> 0.0  0.0      0     0 10:52:57 S&lt;     677     0 -20     0 root         0 00:00:00 [ext4-rsv-conver]</span><br><span class="line"> 0.0  0.0      0     0 10:52:58 S      683     0   0     0 root         0 00:00:00 [jbd2/sda14-8]</span><br><span class="line"> 0.0  0.0      0     0 10:52:58 S&lt;     684     0 -20     0 root         0 00:00:00 [ext4-rsv-conver]</span><br></pre></td></tr></table></figure>
<h4 id="查看指定进程指定信息"><a href="#查看指定进程指定信息" class="headerlink" title="查看指定进程指定信息"></a>查看指定进程指定信息</h4><p>只需要在最后指定—pid参数即可。<br>例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -o %cpu,%mem,vsz,rsz,start,stat,pid,sid,ni,uid,user,rss,time,command --pid 2685</span><br><span class="line"></span><br><span class="line">%CPU %MEM    VSZ   RSZ  STARTED STAT   PID   SID  NI   UID USER       RSS     TIME COMMAND</span><br><span class="line"> 2.0  1.9 5740448 159796 10:55:24 Sl+ 2685  2583   0  1000 hyb      159796 00:01:46 java -jar ./software/finalspeed/finalspeed_client.jar</span><br></pre></td></tr></table></figure>
<h4 id="进程太多时分页显示"><a href="#进程太多时分页显示" class="headerlink" title="进程太多时分页显示"></a>进程太多时分页显示</h4><p>如果进程信息较多，可能一页无法完成显示，这时可以配合使用more命令<br>例如:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -aux|more</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ps命令也是在linux下常用命令之一，通过它我们可以了解更多进程的相关信息。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ps</tag>
      </tags>
  </entry>
  <entry>
    <title>vim使用技巧(二)-移动跳转</title>
    <url>/2018/01/08/12743.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在VIM中经常需要定位到特定的行或者列，单纯的使用方向键来定位位置，实在显得有些笨拙，下面介绍VIM中的跳转。<br><a id="more"></a></p>
<h2 id="行跳转"><a href="#行跳转" class="headerlink" title="行跳转"></a>行跳转</h2><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>:行号</td>
<td>跳转到指定行</td>
</tr>
<tr>
<td>G</td>
<td>跳转到文件末尾</td>
</tr>
<tr>
<td>ｗ</td>
<td>跳转到下一个单词的开始</td>
</tr>
<tr>
<td>ｂ</td>
<td>跳转到上一个单词的开始</td>
</tr>
<tr>
<td>ｅ</td>
<td>跳转到当前单词的末尾</td>
</tr>
<tr>
<td>gg</td>
<td>跳转到文件的开始</td>
</tr>
<tr>
<td>$</td>
<td>跳转到行尾</td>
</tr>
<tr>
<td>^</td>
<td>跳转到行首</td>
</tr>
<tr>
<td>数字+方向键</td>
<td>向特定方向移动指定行数或者字符数</td>
</tr>
<tr>
<td>Ｈ</td>
<td>跳转到屏幕顶部</td>
</tr>
<tr>
<td>Ｍ</td>
<td>跳转到屏幕中间</td>
</tr>
<tr>
<td>Ｌ</td>
<td>跳转到屏幕底部</td>
</tr>
<tr>
<td>h, j, k, l</td>
<td>分别代表方向键左下上右</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>vim</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言学习之共享内存</title>
    <url>/2018/01/07/26657.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>共享内存是可被多个进程读取的内存。用特殊的系统调用分配和释放内存并设置权限；通过一般的读写操作读写内存段中的数据。使用共享内存是进程间进行本地通信的方法之一。最重要的是，它能够较少由于Ｉ/Ｏ操作带来的开销。<br><a id="more"></a></p>
<h4 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h4><p>它适用于任何类型的协作，尤其适合需要安全性的情况。</p>
<h4 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h4><p>共享内存并非从某一个进程中划分出来的，进程的内存总是私有的，而共享内存是从系统的空闲内存池中分配的，希望访问它的每个进程连接它。这个连接过程称为映射，它给共享内存段分配每个进程的地址空间中的本地地址。</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>有两套共享内存 API：POSIX API 和比较老（但是仍然有效）的 System V API。下面做了一个简单的对比。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>POSIX API</th>
<th>system V API</th>
</tr>
</thead>
<tbody>
<tr>
<td>获取共享内存ID</td>
<td>int shm_open(const char *name, int oflag, mode_t mode);</td>
<td>int shmget(key_t key, size_t size, int shmflg);</td>
</tr>
<tr>
<td>映射内存</td>
<td>void <em>mmap(void </em>addr, size_t length, int prot, int flags, int fd, off_t offset);</td>
<td>void <em>shmat(int shmid, const void </em>shmaddr, int shmflg);</td>
</tr>
<tr>
<td>解除映射</td>
<td>int munmap(void *addr, size_t length);</td>
<td>void <em>shmat(int shmid, const void </em>shmaddr, int shmflg);</td>
</tr>
</tbody>
</table>
</div>
<p>因为 POSIX 是 UNIX 和 Linux® 及其衍生系统上的公认标准，所以下面介绍POSIX API。</p>
<p>POSIX 为创建、映射、同步和取消共享内存段提供五个入口点：</p>
<ul>
<li>int shm_open(const char *name, int oflag, mode_t mode);<br> 功能描述：创建或者打开已经存在的共享内存块<br> 返回值：成功返回文件描述符，失败返回-1<br> name：共享内存区的名称<br> oflag：标志位，可选择读，写等<br> mode：权限位</li>
<li><p>int shm_unlink(const char *name);<br>功能描述：<br>根据（shm_open() 返回的）文件描述符，删除共享内存段。实际上，这个内存段直到访问它的所有进程都退出时才会删除，这与在 UNIX 中删除文件很相似。但是，调用 shm_unlink() （通常由原来创建共享内存段的进程调用）之后，其他进程就无法访问这个内存段了。<br>返回值：失败返回-1<br>name：共享内存区名称</p>
</li>
<li><p>void <em>mmap(void </em>addr, size_t length, int prot, int flags,int fd, off_t offset);<br>功能描述：把共享内存段映射到进程的内存。这个系统调用需要 shm_open() 返回的文件描述符，它返回指向内存的指针。在某些情况下，还可以把一般文件或另一个设备的文件描述符映射到内存。<br>返回值：成功返回映射区地址，失败返回-1<br>addr：映射区的开始地址，设置为0时表示由系统决定映射区的起始地址<br>length：映射区的长度，以字节为单位。<br>prot：内存保护标志<br>flags：标志位<br>fd：文件描述符<br>offset：被映射对象内容的起点。</p>
</li>
<li><p>void <em>mmap(void </em>addr, size_t length, int prot, int flags, int fd, off_t offset);<br>功能描述：作用与 mmap() 相反。<br>返回值：成功返回0，失败返回-1</p>
</li>
<li>int msync(void *addr, size_t length, int flags);<br>功能描述：用来让共享内存段与文件系统同步 — 当把文件映射到内存时，这种技术有用。<br>返回值：成功返回0，失败返回-1<br>addr：文件映射到进程空间的地址；<br>length：映射空间的大小；<br>flags：刷新的参数设置，可以取值MS_ASYNC/ MS_SYNC/ MS_INVALIDATE<br>fd：文件描述符<br>offset：被映射对象内容的起点<h2 id="使用过程"><a href="#使用过程" class="headerlink" title="使用过程"></a>使用过程</h2>1.创建内存段（shm_open）<br>2.映射内存段（mmap）<br>3.使用<br>4.删除（munmap()，shm_unlink）</li>
</ul>
<h2 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h2><p>下面的程序简单说明了共享内存的使用方法。在开辟一片共享内存区域后，子进程写入数据，而父进程在子进程写入数据后，将数据读出，并打印。具体代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*================================================================</span></span><br><span class="line"><span class="comment">*   Copyright (C) 2018  Ltd. All rights reserved.</span></span><br><span class="line"><span class="comment">*   </span></span><br><span class="line"><span class="comment">*   文件名称：mmap.c</span></span><br><span class="line"><span class="comment">*   创 建 者：hyb</span></span><br><span class="line"><span class="comment">*   创建日期：2018年01月07日</span></span><br><span class="line"><span class="comment">*   描    述：</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">================================================================*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_and_die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	perror(msg);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *memname = <span class="string">"sample"</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">size_t</span> region_size=sysconf(_SC_PAGE_SIZE);</span><br><span class="line">	<span class="keyword">int</span> fd=shm_open(memname,O_CREAT|O_TRUNC|O_RDWR,<span class="number">0666</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">-1</span> == fd)</span><br><span class="line">	&#123;</span><br><span class="line">	    error_and_die(<span class="string">"shm_open"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//修改ｆｄ指针指向文件或者内存区的大小</span></span><br><span class="line">	r=ftruncate(fd,region_size);</span><br><span class="line">	<span class="keyword">if</span>(r!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	    error_and_die(<span class="string">"ftruncate"</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将ｐｔｒ指针指向共享内存区</span></span><br><span class="line">	<span class="keyword">void</span> *ptr = mmap(<span class="number">0</span>,region_size,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == ptr)</span><br><span class="line">	&#123;</span><br><span class="line">	    error_and_die(<span class="string">"mmap"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">pid_t</span> pid=fork();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="comment">//子进程写入数据</span></span><br><span class="line">	    <span class="keyword">char</span> *d=(<span class="keyword">char</span> *)ptr;</span><br><span class="line">	    <span class="built_in">snprintf</span>(d,region_size,<span class="string">"hello world"</span>);</span><br><span class="line">	    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="comment">//等待子进程退出后，读取共享内存数据</span></span><br><span class="line">	    <span class="keyword">int</span> status;</span><br><span class="line">	    waitpid(pid,&amp;status,<span class="number">0</span>);</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"child wrote %s\n"</span>,(<span class="keyword">char</span> *)ptr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//解除内存映射</span></span><br><span class="line">	r=munmap(ptr,region_size);</span><br><span class="line">	<span class="keyword">if</span>(r!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	    error_and_die(<span class="string">"munmap"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//删除共享内存</span></span><br><span class="line">	r=shm_unlink(memname);</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span>!=r)</span><br><span class="line">	&#123;</span><br><span class="line">	    error_and_die(<span class="string">"shm_unlink"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -g mmap.c -lrt -o mmap</span><br></pre></td></tr></table></figure></p>
<p>运行:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">child wrote hello world</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文简单介绍了共享内存以及简单使用。后面将会有更多的介绍。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>C</tag>
        <tag>笔记</tag>
        <tag>共享内存</tag>
      </tags>
  </entry>
  <entry>
    <title>《深入理解linux内核》摘要</title>
    <url>/2017/12/20/46657.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在阅读《深入理解linux内核》一书，颇有收益，因此记录书中重要内容，以备查看。<br><a id="more"></a></p>
<h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章-绪论"></a>第一章-绪论</h2><h4 id="linux与其他类unix内核的比较"><a href="#linux与其他类unix内核的比较" class="headerlink" title="linux与其他类unix内核的比较"></a>linux与其他类unix内核的比较</h4><p>与商业化的操作系统相比，linux有如下优势</p>
<ul>
<li>linux可运行在低档，便宜的硬件平台上。</li>
<li>linux是强大的。</li>
<li>linux的开发者都是非常出色的程序员。</li>
<li>linux内核非常小，而且紧凑。</li>
<li>linux与很多通用操作系统高度兼容。</li>
<li>linux有很好的技术支持。</li>
</ul>
<h4 id="linux版本"><a href="#linux版本" class="headerlink" title="linux版本"></a>linux版本</h4><p>linux通过简单的编号来区分内核的稳定版和开发版。每个版本号用三个数字描述，由圆点分隔。前两个数字用来表示版本号，第三个数字表示发布号。第二位版本号表示内核的类型，如果为偶数，表示稳定的内核，否则，表示开发中的内核。</p>
<h4 id="操作系统的基本概念"><a href="#操作系统的基本概念" class="headerlink" title="操作系统的基本概念"></a>操作系统的基本概念</h4><p>操作系统必须完成两个主要目标</p>
<ul>
<li>与硬件部分交互，为包含在硬件平台上的所有底层可编程部件提供服务。</li>
<li>为运行在计算机系统上的应用程序提供执行环境</li>
</ul>
<h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>一个进程可以定义为：“程序执行的一个实例”，或者一个运行程序的“执行上下文”。</p>
<p>允许进程并发活动的系统成为多道程序系统或者多处理系统。</p>
<p>unix是具有抢占式进程的多处理操作系统。</p>
<h4 id="unix文件系统概述"><a href="#unix文件系统概述" class="headerlink" title="unix文件系统概述"></a>unix文件系统概述</h4><p>文件或目录名由除“/”和空字符“\0”之外的任意ASCII字符序列组成。（一些操作系统允许一多种字符表示文件名，例如Unicode）</p>
<p>当标识文件名时，也用符号“.”和“..”。它们分辨标识当前工作目录和父目录。如果当前工作目录是根目录，那么它们是一致的。</p>
<p>包含在目录中的文件名就是一个文件的硬链接。在同一个目录或者不同的目录中，同一文件可以有几个链接。</p>
<p>硬链接有两个方面的限制：</p>
<ul>
<li>不允许用户给目录创建硬链接。因为这可能把目录树变成环形树，从而就不可能通过名字定位一个文件。</li>
<li>只有在同一个文件系统中的文件才能创建链接。</li>
</ul>
<p>但是软链接没有文件系统的限制。</p>
<h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><p>unix文件可以是下列类型之一：</p>
<ul>
<li>普通文件</li>
<li>目录</li>
<li>符号链接</li>
<li>面向块的设备文件</li>
<li>面向字符的设备文件</li>
<li>管道和命名管道</li>
<li>套接字</li>
</ul>
<h4 id="文件操作的系统调用"><a href="#文件操作的系统调用" class="headerlink" title="文件操作的系统调用"></a>文件操作的系统调用</h4><p>对于普通unix文件，可以顺序地访问，也可以随机地访问，而对设备文件和命名管道文件，通常只能顺序地访问。</p>
<p>当一个进程终止时，内核会关闭其所有仍然打开着的文件。</p>
<h4 id="信号和进程间通信"><a href="#信号和进程间通信" class="headerlink" title="信号和进程间通信"></a>信号和进程间通信</h4><p>进程可以以两种方式对收到的信号作出反应：</p>
<ul>
<li>忽略该信号</li>
<li>异步地执行一个制定的过程（信号处理程序）</li>
</ul>
<p>如果进程不指定选择何种方式，内核就根据信号的编号执行一个默认操作。五种可能的默认操作是：</p>
<ul>
<li>终止进程</li>
<li>将执行上下文和进程地址空间的内容写入一个文件（核心转储，core dump），然后终止进程</li>
<li>忽略该信号</li>
<li>挂起进程</li>
<li>如果进程曾被暂停，则恢复它的执行</li>
</ul>
<p>共享内存是进程之间交换和共享数据的最快的方式。</p>
<p>_exit()系统调用：内核对这个系统调用的处理是通过释放进程所拥有的资源，并向父进程发送SIGCHLD信号来实现的。</p>
<h4 id="随机访问存储器（RAM）的使用"><a href="#随机访问存储器（RAM）的使用" class="headerlink" title="随机访问存储器（ＲＡＭ）的使用"></a>随机访问存储器（ＲＡＭ）的使用</h4><p>所有的unix操作系统都将ＲＡＭ毫无疑义的划分为两部分。其中若干千兆字节专门或用于存放内核映像。其余部分通常由虚拟内存系统来处理。并且用在一下三种可能的方面。</p>
<ul>
<li>满足内核对缓冲区，描述符会议及其他动态内存数据结构的请求</li>
<li>满足进程对一般内存区的请求以及对文件内存映射的请求</li>
<li>借助于高速缓存从磁盘以及其他缓冲设备获得较好的性能</li>
</ul>
<p>虚拟内存系统必须解决的一个主要问题是内存碎片。理想情况下，只有当空闲页框数太少时，内存请求才失败。然而，通常需求内核使用物理上连续的内存区域。因此，及时有足够的可用内存，但它不能作为一个连续的大块使用时，内存的请求也会失败。</p>
<p>内核通过设备驱动程序与I/O设备交互。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>C</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>vim使用技巧(一)-查找替换</title>
    <url>/2017/11/05/31814.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>vim是一个强大的文本编辑器，简单记录一些常用技巧，以备后续查看。<br>本文主要记录vim的查找技巧。<br><a id="more"></a></p>
<h2 id="基本查找"><a href="#基本查找" class="headerlink" title="基本查找"></a>基本查找</h2><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>f</td>
<td>向后查找字符</td>
</tr>
<tr>
<td>F</td>
<td>向前查找字符</td>
</tr>
<tr>
<td>t</td>
<td>向后查找字符，光标停留在前一个字符</td>
</tr>
<tr>
<td>T</td>
<td>向前查找字符，光标停留在前一个字符</td>
</tr>
<tr>
<td>/</td>
<td>向后查找字符串</td>
</tr>
<tr>
<td>？</td>
<td>向前查找字符串</td>
</tr>
<tr>
<td>#</td>
<td>向后查找当前光标下的字符串</td>
</tr>
<tr>
<td>×</td>
<td>向前查找当前光标下的字符串</td>
</tr>
<tr>
<td>n</td>
<td>下一个查找结果</td>
</tr>
<tr>
<td>N</td>
<td>上一个查找结果</td>
</tr>
<tr>
<td>/words\c</td>
<td>大小写不敏感查找</td>
</tr>
</tbody>
</table>
</div>
<h2 id="多文件搜索查找"><a href="#多文件搜索查找" class="headerlink" title="多文件搜索查找"></a>多文件搜索查找</h2><h4 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h4><p>vim[grep][!] /{pattern}/[g][j] {file} …</p>
<h4 id="释义"><a href="#释义" class="headerlink" title="释义"></a>释义</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">！ #强制执行命令</span><br><span class="line"></span><br><span class="line">pattern  #需要搜索的内容，支持正则表达式</span><br><span class="line"></span><br><span class="line">g #显示重复的行</span><br><span class="line"></span><br><span class="line">j #跳转到结果的第一个匹配行</span><br><span class="line"></span><br><span class="line">file #要搜索的文件</span><br></pre></td></tr></table></figure>
<p>例如：查找当前目录以及子目录的.h文件中的include关键字<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:vimgrep /include/ **/*.h</span><br></pre></td></tr></table></figure></p>
<p>其他命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">:cnext (:cn) #当前页下一个结果</span><br><span class="line">:cprevious (:cp) #当前页上一个结果</span><br><span class="line">:copen (:cope) #打开quickfix窗口</span><br><span class="line">:ccl[ose] #关闭 quickfix 窗口。</span><br><span class="line">ctrl + ww #切换窗口</span><br></pre></td></tr></table></figure></p>
<h2 id="字符替换"><a href="#字符替换" class="headerlink" title="字符替换"></a>字符替换</h2><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[addr]s/源字符串/目的字符串/[option]</span><br></pre></td></tr></table></figure>
<h4 id="释义-1"><a href="#释义-1" class="headerlink" title="释义"></a>释义</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addr #搜索范围，默认当前行，% 当前文件，.,$当前行到文件尾，n1，n2从n1行到n2行</span><br><span class="line">s  #表示替换操作</span><br><span class="line">option #操作类型 g全局替换，c表示确认后进行替换，p替换结果逐行显示，i大小写不敏感查找</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>vim</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>vim完整开发环境配置（taglist/cscope/nerdtree/ctrlp）</title>
    <url>/2017/10/22/5844.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为编辑器之神的vim，初安装时，就像十几岁的孩子，潜力无限但能力有限。所以当我们要充分开发它的潜能时，那么就不得不对vim进行扩展，也就是安装插件。(当然了,如果你不想定制自己所需要的插件，只是想一键安装，然后满足你几乎所有对vim的需求，那么你可以尝试spf13-vim<br>github地址:<a href="https://github.com/spf13/spf13-vim" target="_blank" rel="noopener">https://github.com/spf13/spf13-vim</a>)<br>下面介绍部分插件的安装，以满足基本的代码阅读或者项目开发的需求。<br><a id="more"></a></p>
<h2 id="安装前说明"><a href="#安装前说明" class="headerlink" title="安装前说明"></a>安装前说明</h2><p>本文介绍的vim配置的核心是以Vundle为管理器，在此基础上，进行其他插件的安装和管理。</p>
<h2 id="安装Vundle"><a href="#安装Vundle" class="headerlink" title="安装Vundle"></a>安装Vundle</h2><p>由于后续可能安装的插件越来越多，因此在安装其他插件之前先安装一个插件管理器Vundle，它可以更新，安装或者卸载我们的插件，十分方便。<br>1.git clone<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim</span><br></pre></td></tr></table></figure></p>
<p>2.修改vim配置文件/home/username/.vimrc（注:username指你的用户名）<br>tips:如果你要修改全局的配置，对所有用户生效，可以修改系统配置，打开vim，<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:version</span><br></pre></td></tr></table></figure></p>
<p>可以看到不同位置的vimrc<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     系统 vimrc 文件: &quot;$VIM/vimrc&quot;</span><br><span class="line">     用户 vimrc 文件: &quot;$HOME/.vimrc&quot;</span><br><span class="line"> 第二用户 vimrc 文件: &quot;~/.vim/vimrc&quot;</span><br><span class="line">      用户 exrc 文件: &quot;$HOME/.exrc&quot;</span><br><span class="line">    系统 gvimrc 文件: &quot;$VIM/gvimrc&quot;</span><br><span class="line">    用户 gvimrc 文件: &quot;$HOME/.gvimrc&quot;</span><br><span class="line">第二用户 gvimrc 文件: &quot;~/.vim/gvimrc&quot;</span><br><span class="line">        系统菜单文件: &quot;$VIMRUNTIME/menu.vim&quot;</span><br><span class="line">         $VIM 预设值: &quot;/usr/share/vim&quot;</span><br></pre></td></tr></table></figure></p>
<p>修改不同位置的vimrc，产生不同范围的影响。</p>
<p>在.vimrc中添加以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set nocompatible              &quot; be iMproved, required</span><br><span class="line">filetype off                  &quot; required</span><br><span class="line"></span><br><span class="line">&quot; set the runtime path to include Vundle and initialize</span><br><span class="line">set rtp+=~/.vim/bundle/Vundle.vim</span><br><span class="line">call vundle#begin()</span><br><span class="line">&quot; alternatively, pass a path where Vundle should install plugins</span><br><span class="line">&quot;call vundle#begin(&apos;~/some/path/here&apos;)</span><br><span class="line"></span><br><span class="line">&quot; let Vundle manage Vundle, required</span><br><span class="line">Plugin &apos;VundleVim/Vundle.vim&apos;</span><br><span class="line">&quot;下面是三种实例方式安装插件</span><br><span class="line"></span><br><span class="line">&quot;从github安装，作者名/插件名称</span><br><span class="line">&quot;Plugin &apos;tpope/vim-fugitive&apos;</span><br><span class="line"></span><br><span class="line">&quot;从vim-scripts安装的，直接使用插件名</span><br><span class="line">&quot; Plugin &apos;L9&apos;</span><br><span class="line">&quot;没有托管在github的插件，使用git全地址</span><br><span class="line">&quot;Plugin &apos;git://git.wincent.com/command-t.git&apos;</span><br><span class="line"></span><br><span class="line">&quot;本地插件，比如自己编写的插件</span><br><span class="line">&quot;Plugin &apos;file:///home/gmarik/path/to/plugin&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot; All of your Plugins must be added before the following line</span><br><span class="line">call vundle#end()            &quot; required</span><br><span class="line">filetype plugin indent on    &quot; required</span><br></pre></td></tr></table></figure>
<p>添加完成后，打开vim，输入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:PluginInstall</span><br></pre></td></tr></table></figure></p>
<p>安装Vundle，等待安装完成<br>Vundle基本命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:BundleUpdate &quot;更新插件</span><br><span class="line">:BundleList &quot;列出所有插件</span><br><span class="line">:BundleSearch &quot;查找插件</span><br><span class="line">:BundleInstall &quot;安装插件</span><br><span class="line">:BundleClean &quot;清除插件</span><br></pre></td></tr></table></figure></p>
<p>接下来就是安装我们需要的插件了。</p>
<h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><p>安装之前，先简单介绍一下下面的插件</p>
<ul>
<li>taglist 在vim代码窗口旁以分割窗口形式显示当前的代码结构概览</li>
<li>nerdtree 显示文件的树形目录</li>
<li>ctags 用于定位标记对象，如结构，枚举，变量等</li>
<li>ctrlp 文件搜索</li>
<li>cscope 方便地找到某个函数或变量的定义位置、被调用的位置等信息</li>
</ul>
<p>有了以上这些插件，vim就如虎添翼了。</p>
<h4 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h4><p>在前面的vimrc文件中，添加下面内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot; All of your Plugins must be added before the following line</span><br></pre></td></tr></table></figure>
<p>之前，添加要安装的插件（未一一列举，可根据自己的需要添加或减少）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;taglist start</span><br><span class="line">Plugin &apos;taglist.vim&apos;</span><br><span class="line"></span><br><span class="line">&quot;taglist end</span><br><span class="line"></span><br><span class="line">&quot;ctags start</span><br><span class="line">Plugin &apos;https://github.com/universal-ctags/ctags.git&apos;</span><br><span class="line">&quot;ctags end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;nerdtree start,file tree</span><br><span class="line">Plugin &apos;https://github.com/scrooloose/nerdtree.git&apos;</span><br><span class="line">&quot;nerdtree end</span><br><span class="line">&quot;youcompleteme start</span><br><span class="line">&quot;Plugin &apos;https://github.com/Valloric/YouCompleteMe.git&apos;</span><br><span class="line">&quot;youcompleteme end</span><br><span class="line"></span><br><span class="line">&quot;ctrlp start,find file</span><br><span class="line">Plugin &apos;https://github.com/kien/ctrlp.vim&apos;</span><br><span class="line">&quot;ctrlp end</span><br><span class="line">&quot;NerdCommenter start</span><br><span class="line">Plugin &apos;https://github.com/scrooloose/nerdcommenter.git&apos;</span><br><span class="line">&quot;NerdCommenter end</span><br></pre></td></tr></table></figure></p>
<p>添加完成后保存。</p>
<p>打开vim,执行命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:BundleInstall</span><br></pre></td></tr></table></figure></p>
<p>等待自动安装完成。<br>当然你也可以通过apt-get的方式安装插件，例如<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install cscope</span><br><span class="line">sudo apt-get install ctags</span><br></pre></td></tr></table></figure></p>
<p>但是这样的安装方式是不在vundle的管理范围的。</p>
<p>经过以上步骤，我们需要的插件就已经安装上了。</p>
<h4 id="vim基本配置"><a href="#vim基本配置" class="headerlink" title="vim基本配置"></a>vim基本配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set nu &quot;显示行号</span><br><span class="line">set showcmd &quot;显示输入命令</span><br><span class="line">set tabstop=4 &quot;设置tab键缩进</span><br><span class="line">&quot;set autoindent &quot;设置自动缩进</span><br><span class="line">set cindent  &quot;c/c++缩进</span><br><span class="line">set clipboard+=unnamed &quot;共享剪切板</span><br><span class="line">set mouse=a &quot;设置鼠标可用</span><br></pre></td></tr></table></figure>
<p>另外：如果vim无法复制粘贴剪切板内容，使用命令查看<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim --version | grep &quot;clipboard&quot;</span><br></pre></td></tr></table></figure></p>
<p>出现 -clipboard表明不支持剪切板复制，需要安装图形化vim，并且修改vim配置，使得set mouse=v<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vim-gnom #安装图形化vim</span><br></pre></td></tr></table></figure></p>
<h4 id="taglist基本配置"><a href="#taglist基本配置" class="headerlink" title="taglist基本配置"></a>taglist基本配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let Tlist_Ctags_Cmd=&apos;ctags&apos;</span><br><span class="line">let Tlist_Show_One_File=1               &quot;不同时显示多个文件的tag，只显示当前文件的</span><br><span class="line">let Tlist_WinWidt =28                   &quot;设置taglist的宽度</span><br><span class="line">let Tlist_Exit_OnlyWindow=1             &quot;如果taglist窗口是最后一个窗口，则退出vim</span><br><span class="line">&quot;let Tlist_Use_Right_Window=1           &quot;在右侧窗口中显示taglist窗口</span><br><span class="line">let Tlist_Use_Left_Windo =1             &quot;在左侧窗口中显示taglist窗口</span><br><span class="line">let Tlist_Auto_Open=1</span><br></pre></td></tr></table></figure>
<h4 id="cscope基本配置"><a href="#cscope基本配置" class="headerlink" title="cscope基本配置"></a>cscope基本配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if has(&quot;cscope&quot;)</span><br><span class="line">  set csprg=/usr/bin/cscope</span><br><span class="line">  set csto=1</span><br><span class="line">  set cst</span><br><span class="line">  set nocsverb</span><br><span class="line">  &quot; add any database in current directory</span><br><span class="line">  if filereadable(&quot;cscope.out&quot;)</span><br><span class="line">      cs add cscope.out</span><br><span class="line">  endif</span><br><span class="line">  set csverb</span><br><span class="line">endif</span><br><span class="line">“设置快捷键</span><br><span class="line">nmap &lt;C-/&gt;s :cs find s &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;</span><br><span class="line">nmap &lt;C-/&gt;g :cs find g &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;</span><br><span class="line">nmap &lt;C-/&gt;c :cs find c &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;</span><br><span class="line">nmap &lt;C-/&gt;t :cs find t &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;</span><br><span class="line">nmap &lt;C-/&gt;e :cs find e &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;</span><br><span class="line">nmap &lt;C-/&gt;f :cs find f &lt;C-R&gt;=expand(&quot;&lt;cfile&gt;&quot;)&lt;CR&gt;&lt;CR&gt;</span><br><span class="line">nmap &lt;C-/&gt;i :cs find i ^&lt;C-R&gt;=expand(&quot;&lt;cfile&gt;&quot;)&lt;CR&gt;$&lt;CR&gt;</span><br><span class="line">nmap &lt;C-/&gt;d :cs find d &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;</span><br></pre></td></tr></table></figure>
<h4 id="nerdtree基本配置"><a href="#nerdtree基本配置" class="headerlink" title="nerdtree基本配置"></a>nerdtree基本配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let NERDTreeQuitOnOpen=1 &quot;打开文件时，关闭树</span><br><span class="line">nnoremap &lt;silent&gt; &lt;F2&gt; :NERDTree&lt;CR&gt; &quot;配置快捷键</span><br><span class="line">let NERDTreeShowBookmarks=1</span><br></pre></td></tr></table></figure>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>安装完成后，效果图如下：<br><img src="/images/vim_config_result.png" alt="结果图"></p>
<p>图的左上方是树形目录，中间是文件函数，宏等内容，右边是源文件，最下方则是通过cscope查找找的函数调用结果。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>以上内容仅对vim的基本安装和配置做简单说明，对于新安装其他插件，可以参照前面所提到的方法。以上配置对于基本的开发，阅读源码来说，已经足够了。</p>
]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>vundle</tag>
        <tag>cscope</tag>
        <tag>源码阅读</tag>
        <tag>开发环境</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 博客next主题集成gitment或者gitalk评论系统</title>
    <url>/2017/10/20/46383.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前使用多说，多说挂了，用网易跟帖代替，网易跟帖又没了。前段时间用来必力，感觉还行，但总归不踏实。后面发现有gitment，用github的issue作为评论载体，感觉靠谱许多。下面介绍一下hexo 的naxt主题中如何集成<a href="https://github.com/imsun/gitment" target="_blank" rel="noopener">gitment</a>以及<a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">gitalk</a>评论系统。注：next主题版本为5.1.3,其他版本可能略有差异。<br><a id="more"></a></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>在使用以上两个评论系统之前，都需要在<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">github</a>注册新的应用</p>
<p>参数说明：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Application name：   #应用名称</span><br><span class="line">Homepage URL：  #网站URL</span><br><span class="line">Application description #描述</span><br><span class="line">Authorization callback URL：#网站URL</span><br></pre></td></tr></table></figure></p>
<p>填写完成后，点击register application。</p>
<p>最后会生成Client ID以及Client Secret，后面需要用到。</p>
<p>完成之后需要创建一个仓库，仓库的名称为刚才应用的名称。</p>
<h2 id="next主题集成gitment"><a href="#next主题集成gitment" class="headerlink" title="next主题集成gitment"></a>next主题集成gitment</h2><h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><h4 id="修改主题配置文件next-config-yml"><a href="#修改主题配置文件next-config-yml" class="headerlink" title="修改主题配置文件next/_config.yml"></a>修改主题配置文件next/_config.yml</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"># Gitment</span><br><span class="line"># Introduction: https://imsun.net/posts/gitment-introduction/</span><br><span class="line">gitment:</span><br><span class="line">  enable: true</span><br><span class="line">  githubID: github帐号</span><br><span class="line">  repo: 仓库名  #例如：BlogComments</span><br><span class="line">  ClientID: Client ID</span><br><span class="line">  ClientSecret: Client Secret</span><br><span class="line">  lazy: flase  #false显示github评论框</span><br></pre></td></tr></table></figure>
<h4 id="修改next-languages-zh-Hans-yml"><a href="#修改next-languages-zh-Hans-yml" class="headerlink" title="修改next/languages/zh-Hans.yml"></a>修改next/languages/zh-Hans.yml</h4><p>在zh-Hans.yml中增加一行，当然来如果你的主题语言是英语，就修改<br>en.yml<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitmentbutton: 显示评论</span><br></pre></td></tr></table></figure></p>
<h4 id="修改-layout-partials-comments-swig"><a href="#修改-layout-partials-comments-swig" class="headerlink" title="修改/layout/_partials/comments.swig"></a>修改/layout/_partials/comments.swig</h4><p>在文件的最后一个<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>后面再插入一个else if 分支<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% elseif theme.gitment.enable %&#125;</span><br><span class="line">       &#123;% if theme.gitment.lazy %&#125;</span><br><span class="line">         &lt;div onclick=&quot;ShowGitment()&quot; id=&quot;gitment-display-button&quot;&gt;&#123;&#123;  __(&apos;gitmentbutton&apos;) &#125;&#125;&lt;/div&gt;</span><br><span class="line">         &lt;div id=&quot;gitment-container&quot; style=&quot;display:none&quot;&gt;&lt;/div&gt;</span><br><span class="line">       &#123;% else %&#125;</span><br><span class="line">         &lt;div id=&quot;gitment-container&quot;&gt;&lt;/div&gt;</span><br><span class="line">       &#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="修改layout-third-party-comments-index-swig"><a href="#修改layout-third-party-comments-index-swig" class="headerlink" title="修改layout/_third-party/comments/index.swig"></a>修改layout/_third-party/comments/index.swig</h4><p>在最后增加一行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include &apos;gitment.swig&apos; %&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="在-layout-third-party-comments-目录下增加gitment-swig"><a href="#在-layout-third-party-comments-目录下增加gitment-swig" class="headerlink" title="在/layout/_third-party/comments/目录下增加gitment.swig"></a>在/layout/_third-party/comments/目录下增加gitment.swig</h4><p>内容如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.gitment.enable %&#125;</span><br><span class="line">   &#123;% set owner = theme.gitment.githubID %&#125;</span><br><span class="line">   &#123;% set repo = theme.gitment.repo %&#125;</span><br><span class="line">   &#123;% set cid = theme.gitment.ClientID %&#125;</span><br><span class="line">   &#123;% set cs = theme.gitment.ClientSecret %&#125;</span><br><span class="line">   &lt;link rel=&quot;stylesheet&quot; href=&quot;https://imsun.github.io/gitment/style/default.css&quot;&gt;</span><br><span class="line">   &lt;script src=&quot;https://imsun.github.io/gitment/dist/gitment.browser.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">   &#123;% if not theme.gitment.lazy %&#125;</span><br><span class="line">       &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">           var gitment = new Gitment(&#123;</span><br><span class="line">              id: window.location.pathname, </span><br><span class="line">               owner: &apos;&#123;&#123;owner&#125;&#125;&apos;,</span><br><span class="line">               repo: &apos;&#123;&#123;repo&#125;&#125;&apos;,</span><br><span class="line">               oauth: &#123;</span><br><span class="line">                   client_id: &apos;&#123;&#123;cid&#125;&#125;&apos;,</span><br><span class="line">                   client_secret: &apos;&#123;&#123;cs&#125;&#125;&apos;,</span><br><span class="line">               &#125;&#125;);</span><br><span class="line">           gitment.render(&apos;gitment-container&apos;);</span><br><span class="line">       &lt;/script&gt;</span><br><span class="line">   &#123;% else %&#125;</span><br><span class="line">       &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">           function ShowGitment()&#123;</span><br><span class="line">               document.getElementById(&quot;gitment-display-button&quot;).style.display = &quot;none&quot;;</span><br><span class="line">               document.getElementById(&quot;gitment-container&quot;).style.display = &quot;block&quot;;</span><br><span class="line">               var gitment = new Gitment(&#123;</span><br><span class="line">                   id: document.location.href, </span><br><span class="line">                   owner: &apos;&#123;&#123;owner&#125;&#125;&apos;,</span><br><span class="line">                   repo: &apos;&#123;&#123;repo&#125;&#125;&apos;,</span><br><span class="line">                   oauth: &#123;</span><br><span class="line">                       client_id: &apos;&#123;&#123;cid&#125;&#125;&apos;,</span><br><span class="line">                       client_secret: &apos;&#123;&#123;cs&#125;&#125;&apos;,</span><br><span class="line">                   &#125;&#125;);</span><br><span class="line">               gitment.render(&apos;gitment-container&apos;);</span><br><span class="line">           &#125;</span><br><span class="line">       &lt;/script&gt;</span><br><span class="line">   &#123;% endif %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="增加gitment-styl"><a href="#增加gitment-styl" class="headerlink" title="增加gitment.styl"></a>增加gitment.styl</h4><p>在./source/css/_common/components/third-party/下增加gitment.styl<br>内容如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#gitment-display-button&#123;</span><br><span class="line">     display: inline-block;</span><br><span class="line">     padding: 0 15px;</span><br><span class="line">     color: #0a9caf;</span><br><span class="line">     cursor: pointer;</span><br><span class="line">     font-size: 14px;</span><br><span class="line">     border: 1px solid #0a9caf;</span><br><span class="line">     border-radius: 4px;</span><br><span class="line"> &#125;</span><br><span class="line"> #gitment-display-button:hover&#123;</span><br><span class="line">     color: #fff;</span><br><span class="line">     background: #0a9caf;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="修改third-party-styl"><a href="#修改third-party-styl" class="headerlink" title="修改third-party.styl"></a>修改third-party.styl</h4><p>修改/source/css/_common/components/third-party/third-party.styl，<br>在最后增加一行，引入样式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@import &quot;gitment&quot;;</span><br></pre></td></tr></table></figure></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h4 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h4><p>1.页面提示ERROR NOT FOUND<br>解决：一般是由于你的repo填写错误，repo纯粹指的是的你的仓库名称。</p>
<p>2.每篇文章都需要初始化<br>next主题版本过低，建议更新到5.1.1及以上版本，可全部自动初始化每篇文章的评论。</p>
<p>3.在上面说到的路径找不到对应文件时，建议使用find 命令查找，因为next主题的目录结构可能会变化。</p>
<p>4.在本地查看时，建议打开浏览器的调试模式，可以查看控制台是否有错。</p>
<h4 id="特点总结"><a href="#特点总结" class="headerlink" title="特点总结"></a>特点总结</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>样式比较还可以，并且支持markdown语法，能够预览，相对于其他评论系统应该是比较稳定可靠来。</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>1.移动端不支持<br>2.只能使用github登录，不过github应该已经够了。</p>
<h2 id="next主题集成gitalk"><a href="#next主题集成gitalk" class="headerlink" title="next主题集成gitalk"></a>next主题集成gitalk</h2><p>在集成gitalk之前，同样需要建立应用，操作步骤已经在准备章节中说明了。<br><a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">gitalk</a></p>
<h3 id="主题配置-1"><a href="#主题配置-1" class="headerlink" title="主题配置"></a>主题配置</h3><h4 id="修改主题配置文件next-config-yml-1"><a href="#修改主题配置文件next-config-yml-1" class="headerlink" title="修改主题配置文件next/_config.yml"></a>修改主题配置文件next/_config.yml</h4><p>在修改主题配置文件next/_config.yml中增加以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitalk:</span><br><span class="line">  enable: true</span><br><span class="line">  githubID: github帐号	 </span><br><span class="line">  repo: 仓库名称</span><br><span class="line">  ClientID: Client ID</span><br><span class="line">  ClientSecret: Client Secret</span><br><span class="line">  adminUser: github帐号#指定可初始化评论账户</span><br><span class="line">  distractionFreeMode: true</span><br></pre></td></tr></table></figure>
<h4 id="增加-layout-third-party-comments-gitalk-swig"><a href="#增加-layout-third-party-comments-gitalk-swig" class="headerlink" title="增加/layout/_third-party/comments/gitalk.swig"></a>增加/layout/_third-party/comments/gitalk.swig</h4><p>增加gitalk.swig，内容如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">		var gitalk = new Gitalk(&#123;</span><br><span class="line">		  clientID: &apos;&#123;&#123; theme.gitalk.ClientID &#125;&#125;&apos;,</span><br><span class="line">		  clientSecret: &apos;&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;&apos;,</span><br><span class="line">		  repo: &apos;&#123;&#123; theme.gitalk.repo &#125;&#125;&apos;,</span><br><span class="line">		  owner: &apos;&#123;&#123; theme.gitalk.githubID &#125;&#125;&apos;,</span><br><span class="line">		  admin: [&apos;&#123;&#123; theme.gitalk.adminUser &#125;&#125;&apos;], </span><br><span class="line">		  id: location.pathname,</span><br><span class="line">		  distractionFreeMode: &apos;&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;&apos;</span><br><span class="line">		&#125;)</span><br><span class="line">		gitalk.render(&apos;gitalk-container&apos;)           </span><br><span class="line">       &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id><a href="#" class="headerlink" title=" "></a> </h4><h4 id="修改-layout-partials-comments-swig-1"><a href="#修改-layout-partials-comments-swig-1" class="headerlink" title="修改/layout/_partials/comments.swig"></a>修改/layout/_partials/comments.swig</h4><p>在最后一个div增加内容<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% elseif theme.gitalk.enable %&#125;</span><br><span class="line"> &lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="修改layout-third-party-comments-index-swig-1"><a href="#修改layout-third-party-comments-index-swig-1" class="headerlink" title="修改layout/_third-party/comments/index.swig"></a>修改layout/_third-party/comments/index.swig</h4><p>在最后增加一行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include &apos;gitalk.swig&apos; %&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="增加gitment-styl-1"><a href="#增加gitment-styl-1" class="headerlink" title="增加gitment.styl"></a>增加gitment.styl</h4><p>在./source/css/_common/components/third-party/下增加gitalk.styl<br>内容如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.gt-header a, .gt-comments a, .gt-popup a</span><br><span class="line">  border-bottom: none;</span><br><span class="line">.gt-container .gt-popup .gt-action.is--active:before</span><br><span class="line">  top: 0.7em;</span><br></pre></td></tr></table></figure></p>
<h4 id="修改third-party-styl-1"><a href="#修改third-party-styl-1" class="headerlink" title="修改third-party.styl"></a>修改third-party.styl</h4><p>修改/source/css/_common/components/third-party/third-party.styl，<br>在最后增加一行，引入样式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@import &quot;gitalk&quot;;</span><br></pre></td></tr></table></figure></p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><h4 id="可能遇到的问题-1"><a href="#可能遇到的问题-1" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h4><p>1.页面提示ERROR NOT FOUND<br>解决：可能是仓库未创建或者仓库名填写错误。</p>
<p>2.每篇文章都需要初始化<br>next主题版本过低，建议更新到5.1.1及以上版本.</p>
<p>3.在上面说到的路径找不到对应文件时，建议使用find 命令查找，因为next主题的目录结构可能会变化。</p>
<p>4.在本地查看时，建议打开浏览器的调试模式，可以查看控制台是否有错。</p>
<h4 id="特点总结-1"><a href="#特点总结-1" class="headerlink" title="特点总结"></a>特点总结</h4><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>支持移动端</p>
<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p>缺点：不支持markdown在线预览</p>
<h5 id="提高加载速度"><a href="#提高加载速度" class="headerlink" title="提高加载速度"></a>提高加载速度</h5><p>为了提高加载速度，可以将gitalk.swig的<a href="https://unpkg.com/gitalk/dist/gitalk.css和https://unpkg.com/gitalk/dist/gitalk.min.js替换加载本地文件。" target="_blank" rel="noopener">https://unpkg.com/gitalk/dist/gitalk.css和https://unpkg.com/gitalk/dist/gitalk.min.js替换加载本地文件。</a></p>
<p>比如，在next/source/lib下新建gitalk文件夹，里面放置gitalk.css和gitalk.min.js文件。<br>引用方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/lib/gitalk/gitalk.css</span><br><span class="line">/lib/gitalk/gitalk.min.js</span><br></pre></td></tr></table></figure></p>
<p>上面两个文件可以在github上的<a href="https://github.com/gitalk/gitalk/tree/master/dist" target="_blank" rel="noopener">gitalk dist</a>中下载</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h4 id="提示Error-Cannot-read-property-‘avatarUrl’-of-null"><a href="#提示Error-Cannot-read-property-‘avatarUrl’-of-null" class="headerlink" title="提示Error: Cannot read property ‘avatarUrl’ of null"></a>提示Error: Cannot read property ‘avatarUrl’ of null</h4><p>原因：评论中的github用户已经被注销了，需要到你的评论仓库删除该用户的评论。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>配置好的next主题可以在<a href="https://github.com/yanbinghu/next" target="_blank" rel="noopener">next</a>中下载使用<br>以上两种方式私以为都是比较稳定的方式，还是值得一试。另外写这篇文章时，这两种评论系统的一些特点，可能到最新版本已经没有了，因此需要自己去尝试。</p>
<p>欢迎提出意见或者建议。<br>参考文章：<a href="https://newdee.cf/posts/4da30c7/" target="_blank" rel="noopener">Next主题的Gitalk移植</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>gitment</tag>
        <tag>gitalk</tag>
        <tag>next主题</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言操作redis数据库</title>
    <url>/2017/10/07/48917.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>redis（Remote Dictionary Server）是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库—来自维基百科。由于其读写性能高、数据结构丰富、支持主从复制、支持持久化等其他特性，使得redis成为当前最流行的key-value型数据库。本文将简单介绍c语言中如何操作redis数据库。</p>
<a id="more"></a>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h2 id="hiredis安装"><a href="#hiredis安装" class="headerlink" title="hiredis安装"></a>hiredis安装</h2><p>hiredis是redis官方推荐的基于C接口的客户端组件，它提供接口，供c语言调用以操作数据库。我们需要将hiredis安装到我们的系统中，在redis的源码包的deps/hiredis下就有它的源码,也可以另行<a href="https://github.com/redis/hiredis" target="_blank" rel="noopener">下载hiredis</a><br> 安装方法，进入deps/hiredis目录，执行命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br><span class="line">ldconfig   #使动态库在系统中更新生效</span><br></pre></td></tr></table></figure></p>
<h4 id="接口介绍"><a href="#接口介绍" class="headerlink" title="接口介绍"></a>接口介绍</h4><ul>
<li><p>函数原型：redisContext <em>redisConnect(const char </em>ip, int port);<br>说明：该函数用来连接redis数据库，参数为数据库的ip地址和端口，通常默认端口为6379。该函数返回一个redisContext对象。</p>
</li>
<li><p>函数原型：void <em>redisCommand(redisContext </em>c, const char *format, …);<br>说明：该函数执行redis命令，当然也包括由lua脚本组成的命令，返回redisReply对象。</p>
<ul>
<li><p>函数原型void freeReplyObject(void *reply);<br>说明：释放redisCommand执行后返回的redisReply所占用的内存。</p>
</li>
<li><p>函数原型：void redisFree(redisContext *c);<br>说明：释放redisConnect()所产生的连接。</p>
</li>
</ul>
</li>
</ul>
<p>后面的示例操作基本都是基于以上函数。</p>
<ul>
<li>redis reply对象:<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This is the reply object returned by redisCommand() */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisReply</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> type; <span class="comment">/* 返回结果类型* */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> integer; <span class="comment">/* 返回类型为整型的时候的返回值 */</span></span><br><span class="line">    <span class="keyword">size_t</span> len; <span class="comment">/* 字符串长度 */</span></span><br><span class="line">    <span class="keyword">char</span> *str; <span class="comment">/* 返回错误类型或者字符类型的字符串 */</span></span><br><span class="line">    <span class="keyword">size_t</span> elements; <span class="comment">/* 返回数组类型时，元素的数量*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisReply</span> **<span class="title">element</span>;</span> <span class="comment">/* 元素结果集合，redisReply对象 */</span></span><br><span class="line">&#125; redisReply;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>其中，返回类型有以下几种：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REDIS_REPLY_STRING 1 //字符串</span><br><span class="line">REDIS_REPLY_ARRAY 2    //数组，多个reply，通过element数组以及elements数组大小访问</span><br><span class="line">REDIS_REPLY_INTEGER 3    //整型</span><br><span class="line">REDIS_REPLY_NIL 4    //空，没有数据</span><br><span class="line">REDIS_REPLY_STATUS 5    //状态，str字符串以及len</span><br><span class="line">REDIS_REPLY_ERROR 6    //错误，同STATUS</span><br></pre></td></tr></table></figure></p>
<p>其他的我们暂时不过多介绍，下面通过一个简单的实例来看看这些接口的基本使用。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>实例通过redis数据库的hash表存储以下学生信息：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>sid</td>
<td>学号</td>
</tr>
<tr>
<td>name</td>
<td>学生姓名</td>
</tr>
<tr>
<td>gender</td>
<td>学生性别</td>
</tr>
<tr>
<td>major</td>
<td>专业</td>
</tr>
</tbody>
</table>
</div>
<p>c语言描述如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SID_MAX_LENGHT 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME_MAX_LENGHT 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAJOR_MAX_LENGHT 64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stu_Info_Struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> sid[SID_MAX_LENGHT];</span><br><span class="line">	<span class="keyword">char</span> name[NAME_MAX_LENGHT];</span><br><span class="line">	<span class="keyword">int</span> gender;<span class="comment">//0 male,1 female</span></span><br><span class="line">	<span class="keyword">char</span> major[MAJOR_MAX_LENGHT];</span><br><span class="line">&#125;Stu_Info_Struct;</span><br></pre></td></tr></table></figure></p>
<p>程序清单stu_manager.c如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/***************************************************************</span></span><br><span class="line"><span class="comment">*   Copyright (C) 2017 All rights reserved.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   文件名称：stu_manager.c</span></span><br><span class="line"><span class="comment">*   创 建 者：hyb</span></span><br><span class="line"><span class="comment">*   创建日期：2017年10月07日</span></span><br><span class="line"><span class="comment">*   描    述：</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">***************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;hiredis/hiredis.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*宏定义*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SID_MAX_LENGHT 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME_MAX_LENGHT 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAJOR_MAX_LENGHT 64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMD_MAX_LENGHT  256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_SERVER_IP <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_SERVER_PORT 6379</span></span><br><span class="line"><span class="comment">/*结构体定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stu_Info_Struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> sid[SID_MAX_LENGHT];</span><br><span class="line">	<span class="keyword">char</span> name[NAME_MAX_LENGHT];</span><br><span class="line">	<span class="keyword">int</span> gender;<span class="comment">//0 male,1 female</span></span><br><span class="line">	<span class="keyword">char</span> major[MAJOR_MAX_LENGHT];</span><br><span class="line">&#125;Stu_Info_Struct;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> STU_RESULT</span><br><span class="line">&#123;</span><br><span class="line">    SUCCESS=<span class="number">0</span>,</span><br><span class="line">    FAILURE=<span class="number">1</span></span><br><span class="line">&#125;STU_RESULT;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数*/</span></span><br><span class="line"><span class="function">STU_RESULT <span class="title">addStu</span><span class="params">(Stu_Info_Struct *stu)</span></span>;<span class="comment">/*添加信息*/</span></span><br><span class="line"><span class="comment">/*执行命令*/</span></span><br><span class="line"><span class="function">STU_RESULT <span class="title">exeRedisIntCmd</span><span class="params">(<span class="keyword">char</span> *cmd)</span></span>;</span><br><span class="line"><span class="function">STU_RESULT <span class="title">quryStuBySid</span><span class="params">(<span class="keyword">char</span> *sid)</span></span>;</span><br><span class="line"><span class="function">STU_RESULT <span class="title">exeRedisStrCmd</span><span class="params">(<span class="keyword">char</span> *cmd)</span></span>;</span><br><span class="line"><span class="comment">/**************************************</span></span><br><span class="line"><span class="comment">函数名:addStu</span></span><br><span class="line"><span class="comment">函数功能:添加学生信息</span></span><br><span class="line"><span class="comment">输入参数:stu 学生信息结构指针</span></span><br><span class="line"><span class="comment">输出参数:</span></span><br><span class="line"><span class="comment">返回值:STU_RESULT  成功或失败</span></span><br><span class="line"><span class="comment">************************************/</span></span><br><span class="line"><span class="function">STU_RESULT <span class="title">addStu</span><span class="params">(Stu_Info_Struct *stu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> cmd[CMD_MAX_LENGHT] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">/*检查入参*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == stu)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NULL pointer"</span>);</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*组装redis命令*/</span></span><br><span class="line">    <span class="built_in">snprintf</span>(cmd,CMD_MAX_LENGHT,<span class="string">"hset stu:%s name %s gender %d major %s"</span>,</span><br><span class="line">            stu-&gt;sid,stu-&gt;name,stu-&gt;gender,stu-&gt;major);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*执行redis命令*/</span></span><br><span class="line">    <span class="keyword">if</span>(FAILURE == exeRedisIntCmd(cmd))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"add student %s,%s,%d,%s failure\n"</span>,stu-&gt;sid,stu-&gt;name,stu-&gt;gender,stu-&gt;major);</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"add student %s,%s,%d,%s success\n"</span>,stu-&gt;sid,stu-&gt;name,stu-&gt;gender,stu-&gt;major);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**************************************</span></span><br><span class="line"><span class="comment">函数名:exeRedisIntCmd</span></span><br><span class="line"><span class="comment">函数功能:执行redis 返回值为int类型命令</span></span><br><span class="line"><span class="comment">输入参数:cmd  redis命令</span></span><br><span class="line"><span class="comment">输出参数:redis 返回结构</span></span><br><span class="line"><span class="comment">返回值:STU_RESULT</span></span><br><span class="line"><span class="comment">*************************************/</span></span><br><span class="line"><span class="function">STU_RESULT <span class="title">exeRedisIntCmd</span><span class="params">(<span class="keyword">char</span> *cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*检查入参*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == cmd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NULL pointer"</span>);</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*连接redis*/</span></span><br><span class="line">    redisContext *context = redisConnect(REDIS_SERVER_IP,REDIS_SERVER_PORT);</span><br><span class="line">    <span class="keyword">if</span>(context-&gt;err)</span><br><span class="line">    &#123;</span><br><span class="line">        redisFree(context);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d connect redis server failure:%s\n"</span>,__LINE__, context-&gt;errstr);</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"connect redis server success\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*执行redis命令*/</span></span><br><span class="line">    redisReply *reply = (redisReply *)redisCommand(context, cmd);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == reply)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d execute command:%s failure\n"</span>,__LINE__,cmd);</span><br><span class="line">        redisFree(context);</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//返回执行结果为整型的命令,只有状态为REDIS_REPLY_INTEGER,并且INTEGER是大于0时,才表示这种类型的命令执行成功</span></span><br><span class="line">    <span class="keyword">if</span>(!(reply-&gt;type == REDIS_REPLY_INTEGER &amp;&amp; reply-&gt;integer &gt; <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d execute command:%s failure\n"</span>,__LINE__, cmd);</span><br><span class="line">        freeReplyObject(reply);</span><br><span class="line">        redisFree(context);</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    freeReplyObject(reply);</span><br><span class="line">    redisFree(context);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d execute command:%s success\n"</span>,__LINE__,cmd);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**************************************</span></span><br><span class="line"><span class="comment">函数名:quryStuBySid</span></span><br><span class="line"><span class="comment">函数功能:通过sid查询学生信息</span></span><br><span class="line"><span class="comment">输入参数:cmd  redis命令</span></span><br><span class="line"><span class="comment">输出参数:redis 返回结构</span></span><br><span class="line"><span class="comment">返回值:STU_RESULT</span></span><br><span class="line"><span class="comment">*************************************/</span></span><br><span class="line"><span class="function">STU_RESULT <span class="title">queryStuBySid</span><span class="params">(<span class="keyword">char</span> *sid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> cmd[CMD_MAX_LENGHT] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">/*入参检查*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == sid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d NULL pointer\n"</span>,__LINE__);</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*组装执行命令*/</span></span><br><span class="line">    <span class="built_in">snprintf</span>(cmd,CMD_MAX_LENGHT,<span class="string">"HGETALL stu:%s"</span>,sid);</span><br><span class="line">    <span class="keyword">if</span>(FAILURE == exeRedisStrCmd(cmd))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d query stu failue"</span>,__LINE__);</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">STU_RESULT <span class="title">exeRedisStrCmd</span><span class="params">(<span class="keyword">char</span> *cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*检查入参*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == cmd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NULL pointer"</span>);</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*连接redis*/</span></span><br><span class="line">    redisContext *context = redisConnect(REDIS_SERVER_IP,REDIS_SERVER_PORT);</span><br><span class="line">    <span class="keyword">if</span>(context-&gt;err)</span><br><span class="line">    &#123;</span><br><span class="line">        redisFree(context);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d connect redis server failure:%s\n"</span>,__LINE__, context-&gt;errstr);</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"connect redis server success\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*执行redis命令*/</span></span><br><span class="line">    redisReply *reply = (redisReply *)redisCommand(context, cmd);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == reply)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d execute command:%s failure\n"</span>,__LINE__,cmd);</span><br><span class="line">        redisFree(context);</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//返回执行结果为整型的命令,只有状态为REDIS_REPLY_INTEGER,并且INTEGER是大于0时,才表示这种类型的命令执行成功</span></span><br><span class="line">    <span class="keyword">if</span>(!(reply-&gt;type == REDIS_REPLY_ARRAY &amp;&amp; reply-&gt;elements &gt; <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d execute command:%s failure\n"</span>,__LINE__, cmd);</span><br><span class="line">        freeReplyObject(reply);</span><br><span class="line">        redisFree(context);</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%lu\n"</span>,reply-&gt;type,reply-&gt;elements);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i &lt; reply-&gt;elements;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span> ==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s:"</span>,reply-&gt;element[i]-&gt;str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,reply-&gt;element[i]-&gt;str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    freeReplyObject(reply);</span><br><span class="line">    redisFree(context);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stu_Info_Struct stu =</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="string">"01"</span>,</span><br><span class="line">     <span class="string">"hu"</span>,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="string">"CS"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    addStu(&amp;stu);</span><br><span class="line">    queryStuBySid(<span class="string">"01"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="编译代码"><a href="#编译代码" class="headerlink" title="编译代码"></a>编译代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -g stu_manager.c -o stu -lhiredis</span><br></pre></td></tr></table></figure>
<p>可能遇到问题:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">libhiredis.so.0.10: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure></p>
<p>/usr/lib/hiredis目录下没有hiredis库,将编译链接好的hiredis库拷贝到/usr/lib/hiredis目录下，并且执行命令重新加载配置:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ldconfig</span><br></pre></td></tr></table></figure></p>
<h4 id="启动redis服务器"><a href="#启动redis服务器" class="headerlink" title="启动redis服务器"></a>启动redis服务器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./stu</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hyb@ubuntu-16:redis# ./stu</span><br><span class="line">connect redis server success</span><br><span class="line">116 execute command:hset stu:01 name hu gender 1 major CS success</span><br><span class="line">add student 01,hu,1,CS success</span><br><span class="line">connect redis server success</span><br><span class="line">2,6</span><br><span class="line">name:hu</span><br><span class="line">gender:1</span><br><span class="line">major:CS</span><br></pre></td></tr></table></figure></p>
<p>程序首先将学生信息添加到数据库中，然后通过id将其结果查询出来。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对hiredis的接口进行了简单的介绍，并通过一个小实例说明了这些接口在c中的使用。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>redis</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>lua脚本操作redis数据库介绍</title>
    <url>/2017/10/07/44845.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 为什么要用lua脚本操作redis数据库?<br>1.减少开销—减少向redis服务器的请求次数<br>2.原子操作—redis将lua脚本作为一个原子执行<br>3.可复用—其他客户端可以使用已经执行过的lua脚本<br>4.增加redis灵活性—lua脚本可以帮助redis做更多的事情</p>
<p>lua脚本本身体积小,启动速度快.</p>
<p>因此,从redis 2.6.0开始,redis在服务器端内置lua解释器<br><a id="more"></a></p>
<h2 id="EVAL命令语法"><a href="#EVAL命令语法" class="headerlink" title="EVAL命令语法"></a>EVAL命令语法</h2><p>EVAL script numkeys key [key …] arg [arg …]</p>
<p>EVAL  —-lua程序的运行环境上下文<br>script   —-lua脚本<br>numkeys —-参数的个数(key的个数)<br>key  —-redis键   访问下标从1开始,例如:KEYS[1]<br>arg  —-redis键的附加参数</p>
<h3 id="lua脚本"><a href="#lua脚本" class="headerlink" title="lua脚本"></a>lua脚本</h3><p>EVAL和EVALSHA用redis内置的lua编译器执行脚本<br>举例说明:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; eval &quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot; 2 username password test 123456</span><br><span class="line">1) &quot;username&quot;</span><br><span class="line">2) &quot;password&quot;</span><br><span class="line">3) &quot;test&quot;</span><br><span class="line">4) &quot;123456&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure></p>
<p>上面lua脚本的意思是返回以lua数组的形式返回key1,key2和value1,value2,2是key的个数.</p>
<h3 id="lua函数"><a href="#lua函数" class="headerlink" title="lua函数"></a>lua函数</h3><p>主要有两个函数来执行redis命令<br>redis.call()   —  出错时返回具体错误信息,并且终止脚本执行<br>redis.pcall()  —出错时返回lua  table的包装错误,但不引发错误<br>举例说明:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; eval &quot;return redis.call(&apos;set&apos;,KEYS[1],ARGV[1])&quot; 1 name  redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>
<p>该脚本中的函数作用是类似于执行  set  name redis   的redis命令.并返回执行结果,ok</p>
<p>redis.call()出错时:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; eval &quot;return redis.call(&apos;get&apos;,KEYS[1],ARGV[1])&quot; 1 name  redis</span><br><span class="line">(error) ERR Error running script (call to f_b943d620b079a29d99eccaaa7317e05f8eb8ce88): @user_script:1: @user_script: 1: Wrong number of args calling Redis command From Lua script </span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure></p>
<p>redis.pcall()出错时:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; eval &quot;return redis.pcall(&apos;get&apos;,KEYS[1],ARGV[1])&quot; 1 name  redis</span><br><span class="line">(error) @user_script: 1: Wrong number of args calling Redis command From Lua script</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="lua与redis数据类型转换"><a href="#lua与redis数据类型转换" class="headerlink" title="lua与redis数据类型转换"></a>lua与redis数据类型转换</h2><p>lua通过redis.call()或者redis.pcall()函数执行redis命令的返回值被转换成了lua数据结构,当然了,当lua脚本在redis的内置解释器里运行时,lua脚本的返回值也会被转换成redis数据结构,然后由EVAL将值返回给客户端.</p>
<p>那么lua和redis数据类型之间时如何转换的呢?对应关系又是怎样的呢?</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>redis数据类型</th>
<th>lua数据类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>integer</td>
<td>number</td>
</tr>
<tr>
<td>bulk</td>
<td>string</td>
</tr>
<tr>
<td>multi bulk</td>
<td>table</td>
</tr>
<tr>
<td>status</td>
<td>包含ok域的table</td>
</tr>
<tr>
<td>error</td>
<td>包含err域的table</td>
</tr>
<tr>
<td>nil bulk</td>
<td>false</td>
</tr>
</tbody>
</table>
</div>
<p>从redis数据类型到lua数据类型或者从lua数据类型到redis数据类型,都有以上对应规则,但是从</p>
<p><em>从lua转换到redis有一条额外的对应规则</em></p>
<ul>
<li>lua boolean  true   —&gt;   redis   1<br>即,lua的true对应redis 的整型1.</li>
</ul>
<h2 id="EVAL和EVALSHA"><a href="#EVAL和EVALSHA" class="headerlink" title="EVAL和EVALSHA"></a>EVAL和EVALSHA</h2><p>EVAL命令在每次执行脚本时,都发送一次脚本主体,而EVALSHA并非如此,它的第一个参数时脚本的sha1校验和.</p>
<p>EVALSHA命令的机制如下:</p>
<ul>
<li>如果服务器记得SHA1校验和指定的脚本,那么执行该脚本</li>
<li>如果服务器不记得SHA1校验和指定的脚本,那么它返回一个错误,提醒用户使用EVAl代替EVALSHA</li>
</ul>
<p>因此在脚本主体不变的情况下使用EVALSHA,可以使脚本复用,而<strong>节省带宽</strong></p>
<h2 id="lua脚本要求"><a href="#lua脚本要求" class="headerlink" title="lua脚本要求"></a>lua脚本要求</h2><p><strong>脚本需要被写成纯函数</strong></p>
<p> 对于同样的数据输入,给定相同的参数,脚本执行的redis写命令的结果总是相同的.<br>为此,redis做了以下事情:</p>
<ul>
<li>lua没有访问系统时间或者其他内部状态的命令</li>
<li>redis阻止上面所提到的脚本执行</li>
<li>lua脚本调用返回序命令的返回数据会被排序(字典序.)</li>
<li>对 Lua 的伪随机数生成函数 math.random 和 math.randomseed 进行修改，使得每次在运行新脚本的时候，总是拥有同样的 seed 值.</li>
</ul>
<p><strong>不允许创建全局变量</strong></p>
<p>为了防止数据泄露进lua环境,redis脚本不循序创建全局变量.</p>
<p>访问一个全局变量(无论是否存在)都会引起脚本停止</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用lua操作redis数据库能够带来很多便利,后续将提供实例展示lua脚本是如何操作redis数据库的.</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>数据库</tag>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>redis-阅读笔记</title>
    <url>/2017/10/05/10234.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>1.支持持久化<br>2.支持list，set，zset，hash等结构存储<br>3.支持主从模式的数据备份</p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>1.性能高<br>2.数据类型丰富<br>3.原子性<br>4.特定丰富</p>
<h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE<br><a id="more"></a></p>
<h2 id="redis数据类型"><a href="#redis数据类型" class="headerlink" title="redis数据类型"></a>redis数据类型</h2><h3 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h3><p>实例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set name &quot;hyb&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;hyb&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="Hash-哈希-—适合存储对象"><a href="#Hash-哈希-—适合存储对象" class="headerlink" title="Hash(哈希)—适合存储对象"></a>Hash(哈希)—适合存储对象</h3><p>redis hash 是一个键值对集合。<br>实例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset student:1 stuName hyb sex male</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hgetall student:1</span><br><span class="line">1) &quot;stuName&quot;</span><br><span class="line">2) &quot;hyb&quot;</span><br><span class="line">3) &quot;sex&quot;</span><br><span class="line">4) &quot;male&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="list（列表）"><a href="#list（列表）" class="headerlink" title="list（列表）"></a>list（列表）</h3><p>按照插入顺序排序的元素集合。集合内元素可以不唯一<br>lpush key member<br>实例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush testList a</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush testList b</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; lpush testList b</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange testList 0 2</span><br><span class="line">1) &quot;b&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;a&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="set（集合）-无序集合"><a href="#set（集合）-无序集合" class="headerlink" title="set（集合）-无序集合"></a>set（集合）-无序集合</h3><p>集合内元素唯一<br>sadd key member<br>实例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd  testSet a</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd  testSet b</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd  testSet b</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; smembers testSet</span><br><span class="line">1) &quot;b&quot;</span><br><span class="line">2) &quot;a&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="zset-有序集合"><a href="#zset-有序集合" class="headerlink" title="zset -有序集合"></a>zset -有序集合</h3><p>每个元素都会关联一个double类型的分数。redis通过分数来进行排序<br>zadd  key  score  member<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd testZset 1 aa</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd testZset 2 bb</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd testZset 3 bb</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; zadd testZset 4 qw</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE testZset 0 5</span><br><span class="line">1) &quot;aa&quot;</span><br><span class="line">2) &quot;bb&quot;</span><br><span class="line">3) &quot;qw&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="redis-命令"><a href="#redis-命令" class="headerlink" title="redis 命令"></a>redis 命令</h2><h3 id="连接远程redis服务器"><a href="#连接远程redis服务器" class="headerlink" title="连接远程redis服务器"></a>连接远程redis服务器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli  -h host -p port -a password</span><br></pre></td></tr></table></figure>
<h3 id="keys-命令"><a href="#keys-命令" class="headerlink" title="keys 命令"></a>keys 命令</h3><h5 id="del-key"><a href="#del-key" class="headerlink" title="del key"></a>del key</h5><p>key存在是删除key</p>
<h5 id="DUMP-KEY"><a href="#DUMP-KEY" class="headerlink" title="DUMP KEY"></a>DUMP KEY</h5><p>序列化给定key，并返回被序列化的值</p>
<h5 id="EXISTS-KEY"><a href="#EXISTS-KEY" class="headerlink" title="EXISTS KEY"></a>EXISTS KEY</h5><p>检查给定key 是否存在</p>
<h5 id="EXPIRE-KEY-SECONDS"><a href="#EXPIRE-KEY-SECONDS" class="headerlink" title="EXPIRE KEY SECONDS"></a>EXPIRE KEY SECONDS</h5><p>为key设置过期时间</p>
<h5 id="EXPIREAT-KEY-TIMESTAMP"><a href="#EXPIREAT-KEY-TIMESTAMP" class="headerlink" title="EXPIREAT KEY  TIMESTAMP"></a>EXPIREAT KEY  TIMESTAMP</h5><pre><code>时间参数为unix时间戳
</code></pre><h5 id="EXPIRE-KEY-MILLISECONDS"><a href="#EXPIRE-KEY-MILLISECONDS" class="headerlink" title="EXPIRE KEY MILLISECONDS"></a>EXPIRE KEY MILLISECONDS</h5><p>设置key的过期时间，以毫秒计</p>
<h5 id="KEYS-pattern"><a href="#KEYS-pattern" class="headerlink" title="KEYS pattern"></a>KEYS pattern</h5><p>查找所有符合给定模式（pattern）的key</p>
<h5 id="MOVE-KEY-DB"><a href="#MOVE-KEY-DB" class="headerlink" title="MOVE KEY  DB"></a>MOVE KEY  DB</h5><p>将当前数据库的key移动到给定的数据录db当中</p>
<h5 id="PERSIST-KEY"><a href="#PERSIST-KEY" class="headerlink" title="PERSIST KEY"></a>PERSIST KEY</h5><p>移除key的过期时间</p>
<h5 id="PTTL-KEY"><a href="#PTTL-KEY" class="headerlink" title="PTTL KEY"></a>PTTL KEY</h5><p>返回key的剩余过期时间，毫秒为单位</p>
<h5 id="TTL-key"><a href="#TTL-key" class="headerlink" title="TTL key"></a>TTL key</h5><p>返回key的剩余货期时间，秒为单位</p>
<h5 id="RANDOMKEY"><a href="#RANDOMKEY" class="headerlink" title="RANDOMKEY"></a>RANDOMKEY</h5><p>从当前数据库中随机返回一个key</p>
<h5 id="RENAME-KEY-NEWKEY"><a href="#RENAME-KEY-NEWKEY" class="headerlink" title="RENAME KEY NEWKEY"></a>RENAME KEY NEWKEY</h5><p>修改key的名称</p>
<h5 id="RENAMENX-KEY-NEWKEY"><a href="#RENAMENX-KEY-NEWKEY" class="headerlink" title="RENAMENX KEY NEWKEY"></a>RENAMENX KEY NEWKEY</h5><p>仅当newkey不存在时，将key改名为newkey</p>
<h5 id="TYPE-KEY"><a href="#TYPE-KEY" class="headerlink" title="TYPE KEY"></a>TYPE KEY</h5><p>返回key所存储的值的类型</p>
<h3 id="String-命令"><a href="#String-命令" class="headerlink" title="String 命令"></a>String 命令</h3><h5 id="SET-KEY-VALUE"><a href="#SET-KEY-VALUE" class="headerlink" title="SET KEY VALUE"></a>SET KEY VALUE</h5><p>设置指定key的值</p>
<h5 id="GET-KEY"><a href="#GET-KEY" class="headerlink" title="GET KEY"></a>GET KEY</h5><p>获取指定key的值</p>
<h5 id="GETRANGE-KEY-START-END"><a href="#GETRANGE-KEY-START-END" class="headerlink" title="GETRANGE KEY START END"></a>GETRANGE KEY START END</h5><p>返回key中字符串值的子字符</p>
<h5 id="GETSET-KEY-VALUE"><a href="#GETSET-KEY-VALUE" class="headerlink" title="GETSET KEY VALUE"></a>GETSET KEY VALUE</h5><p>将给定的key的值设为value，并返回key的旧值。</p>
<h5 id="MGET-KEY1-KEY2"><a href="#MGET-KEY1-KEY2" class="headerlink" title="MGET KEY1 KEY2"></a>MGET KEY1 KEY2</h5><p>获取所有给定key 的值</p>
<h5 id="SETEX-KEY-SECONDS-VALUE"><a href="#SETEX-KEY-SECONDS-VALUE" class="headerlink" title="SETEX KEY SECONDS VALUE"></a>SETEX KEY SECONDS VALUE</h5><p>将值value关联到key，并将key的过期时间设为seconds</p>
<h5 id="SETNX-KEY-VALUE"><a href="#SETNX-KEY-VALUE" class="headerlink" title="SETNX KEY VALUE"></a>SETNX KEY VALUE</h5><p>只有在key不存在时设置key的值</p>
<h5 id="SETRANGE-KEY-OFFSET-VALUE"><a href="#SETRANGE-KEY-OFFSET-VALUE" class="headerlink" title="SETRANGE KEY OFFSET VALUE"></a>SETRANGE KEY OFFSET VALUE</h5><p>用value 参数覆写给定key所存储的字符串值，从偏移量offset开始</p>
<h5 id="SETLEN-KEY"><a href="#SETLEN-KEY" class="headerlink" title="SETLEN KEY"></a>SETLEN KEY</h5><p>返回key所存储的字符串的长度</p>
<h5 id="MSET-KEY-VALUE-KEY-VALUE"><a href="#MSET-KEY-VALUE-KEY-VALUE" class="headerlink" title="MSET KEY VALUE[KEY VALUE]"></a>MSET KEY VALUE[KEY VALUE]</h5><p>同时设置一个或多个key-value对</p>
<h5 id="MSETNX-KEY-VALUE-KEY-VALUE"><a href="#MSETNX-KEY-VALUE-KEY-VALUE" class="headerlink" title="MSETNX KEY VALUE[KEY VALUE]"></a>MSETNX KEY VALUE[KEY VALUE]</h5><p>同时设置一个或多个key-value对，当且仅当所有给定key都不存在</p>
<h5 id="APPEND-KEY-VALUE"><a href="#APPEND-KEY-VALUE" class="headerlink" title="APPEND KEY VALUE"></a>APPEND KEY VALUE</h5><p>如果key已经存在并且是一个字符串，append命令将value添加到key原来值的末尾</p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><h5 id="HDEL-KEY-FIELD1-FIELD2"><a href="#HDEL-KEY-FIELD1-FIELD2" class="headerlink" title="HDEL KEY FIELD1 [FIELD2]"></a>HDEL KEY FIELD1 [FIELD2]</h5><p>删除一个或者多个hash表字段</p>
<h5 id="HEXISTS-KEY-FIELD"><a href="#HEXISTS-KEY-FIELD" class="headerlink" title="HEXISTS KEY FIELD"></a>HEXISTS KEY FIELD</h5><p>查看hash表中指定字段是否存在</p>
<h5 id="HGET-KEY-FIELD"><a href="#HGET-KEY-FIELD" class="headerlink" title="HGET KEY FIELD"></a>HGET KEY FIELD</h5><p>获取存储在hash中指定字段的值</p>
<h5 id="HGETALL-KEY"><a href="#HGETALL-KEY" class="headerlink" title="HGETALL KEY"></a>HGETALL KEY</h5><p>获取hash中指定key所有字段和值</p>
<h5 id="HKEYS-KEY"><a href="#HKEYS-KEY" class="headerlink" title="HKEYS KEY"></a>HKEYS KEY</h5><p>获取所有hash表中的字段</p>
<h5 id="HLEN-KEY"><a href="#HLEN-KEY" class="headerlink" title="HLEN KEY"></a>HLEN KEY</h5><p>获取hash表中字段的数量</p>
<h5 id="HMGET-KEY-FIELD1-FIELD2"><a href="#HMGET-KEY-FIELD1-FIELD2" class="headerlink" title="HMGET KEY FIELD1 [FIELD2]"></a>HMGET KEY FIELD1 [FIELD2]</h5><p>获取所有给定字段的值</p>
<h5 id="HMSET-KEY-FIELD1-VALUE1-FIELD2-VALUE2"><a href="#HMSET-KEY-FIELD1-VALUE1-FIELD2-VALUE2" class="headerlink" title="HMSET KEY FIELD1 VALUE1 [FIELD2 VALUE2]"></a>HMSET KEY FIELD1 VALUE1 [FIELD2 VALUE2]</h5><p>同时将多个field-value对设置到hash表key中</p>
<h5 id="HSET-KEY-FIELD-VALUE"><a href="#HSET-KEY-FIELD-VALUE" class="headerlink" title="HSET KEY FIELD VALUE"></a>HSET KEY FIELD VALUE</h5><p>将哈希表key中的字段field的值设为value</p>
<h5 id="HSETNX-KEY-FIELD-VALUE"><a href="#HSETNX-KEY-FIELD-VALUE" class="headerlink" title="HSETNX KEY FIELD VALUE"></a>HSETNX KEY FIELD VALUE</h5><p>只有在字段field不存在时，设置哈希表字段的值</p>
<h5 id="HVALS-KEY"><a href="#HVALS-KEY" class="headerlink" title="HVALS KEY"></a>HVALS KEY</h5><p>获取hash表中所有值</p>
<h3 id="LIST"><a href="#LIST" class="headerlink" title="LIST"></a>LIST</h3><h5 id="BLPOP-KEY1-KEY2-timeout"><a href="#BLPOP-KEY1-KEY2-timeout" class="headerlink" title="BLPOP KEY1 [KEY2] timeout"></a>BLPOP KEY1 [KEY2] timeout</h5><p>移出并获取列表的第一个元素，如果列表中没有元素会阻塞列表直到等待超时或者发现可弹出元素为止</p>
<h5 id><a href="#" class="headerlink" title=" "></a> </h5><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><h3 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NULTI</span><br><span class="line">redis command</span><br><span class="line">......</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure>
<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><h5 id="EVAL-script-numkeys-key-key-…-arg-arg-…"><a href="#EVAL-script-numkeys-key-key-…-arg-arg-…" class="headerlink" title="EVAL script numkeys key [key …] arg [arg …]"></a>EVAL script numkeys key [key …] arg [arg …]</h5><p>执行lua脚本</p>
<h5 id="EVALSHA-sha1-numkeys-key-key-…-arg-arg-…"><a href="#EVALSHA-sha1-numkeys-key-key-…-arg-arg-…" class="headerlink" title="EVALSHA sha1 numkeys key [key …] arg [arg …]"></a>EVALSHA sha1 numkeys key [key …] arg [arg …]</h5><p>执行lua脚本</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2>]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>redis</tag>
        <tag>数据库</tag>
        <tag>高性能</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫实战（一）--爬取知乎话题图片</title>
    <url>/2017/09/19/43578.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>什么是网络爬虫（也叫网络蜘蛛）？简单来说，是一种用来自动浏览万维网程序或脚本（网络爬虫的典型应用就是我们所熟知的搜索引擎）。既然如此，那么我们也可以写一个程序，用来自动浏览或者获取网页上的信息。本文将介绍利用python自带库编写一个简单的爬虫程序来获取网络信息。<br><a id="more"></a></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>本次爬取实例可能涉及以下知识：</p>
<ul>
<li>python基础知识</li>
<li>urllib库使用</li>
<li>http基本知识</li>
<li>html/js基本知识</li>
<li>正则表达式</li>
</ul>
<p>环境准备：</p>
<ul>
<li>linux(windows基本适用)</li>
<li>python3</li>
<li>chrome浏览器</li>
</ul>
<h2 id="爬取目标"><a href="#爬取目标" class="headerlink" title="爬取目标"></a>爬取目标</h2><p>本次爬取的目标是知乎话题下的图片。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>以知乎话题<a href="https://www.zhihu.com/question/48132860" target="_blank" rel="noopener">你有哪些压箱底的表情包？</a>为例。<br>用chrome浏览器打开该链接。鼠标右键-检查元素，在elements页移动鼠标，当鼠标移动到某元素时，页面会被选中，因此我们可以找到第一张图片的img标签，而在标签中，我们可以找到图片的url地址，复制url地址，在浏览器打开，我们就看到了需要下载的表情包了。<br>至此，整体思路就很简单了：访问话题页—找到img标签—获取图片url地址—下载图片。</p>
<p><img src="/images/zhihu_spider1.png" alt="查找链接"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> urllib.request <span class="keyword">as</span> request</span><br><span class="line"><span class="keyword">import</span> urllib.parse <span class="keyword">as</span> parse</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> urllib.error <span class="keyword">as</span> error</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">获取url中的图片</span></span><br><span class="line"><span class="string">url：链接地址</span></span><br><span class="line"><span class="string">dirpath：保存路径</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getUrlImage</span><span class="params">(url,dirpath)</span>:</span></span><br><span class="line"></span><br><span class="line">    dldNum=<span class="number">0</span></span><br><span class="line">    <span class="comment">#存储目录不存在时，创建目录</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(dirpath):</span><br><span class="line">        os.makedirs(dirpath)</span><br><span class="line">    </span><br><span class="line">    data = request.urlopen(url).read()</span><br><span class="line">    page_data = data.decode(<span class="string">'gbk'</span>,<span class="string">'ignore'</span>)</span><br><span class="line">    <span class="comment">#获取img标签数据</span></span><br><span class="line">    page_image = re.compile(<span class="string">'&lt;img src=\"(.+?)\"'</span>)</span><br><span class="line">    <span class="comment">#循环获取img标签中的图片</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> image <span class="keyword">in</span> page_image.findall(page_data):</span><br><span class="line">        <span class="comment">#匹配数据中的图片</span></span><br><span class="line">        pattern = re.compile(<span class="string">r'^https://.*.(jpg|png|gif|jpeg)$'</span>)</span><br><span class="line">        <span class="keyword">if</span>  pattern.match(image):</span><br><span class="line">            <span class="keyword">print</span> (image)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                extension =  GetFileNameAndExt(image)</span><br><span class="line">                <span class="comment">#读取图片内容</span></span><br><span class="line">                image_data = request.urlopen(image).read()</span><br><span class="line">                image_path = dirpath+<span class="string">'/'</span>+str(dldNum)+extension</span><br><span class="line">                dldNum += <span class="number">1</span></span><br><span class="line">                print(image_path)</span><br><span class="line">                <span class="comment">#保存图片</span></span><br><span class="line">                <span class="keyword">with</span> open(image_path, <span class="string">'wb'</span>) <span class="keyword">as</span> image_file:</span><br><span class="line">                    image_file.write(image_data)</span><br><span class="line">                    image_file.close()</span><br><span class="line">            <span class="keyword">except</span> error.URLError <span class="keyword">as</span> e:</span><br><span class="line">                print(<span class="string">'Download failed'</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">获取文件名中的扩展名</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetFileNameAndExt</span><span class="params">(filename)</span>:</span></span><br><span class="line">    (filepath,tempfilename) = os.path.split(filename);</span><br><span class="line">    (shotname,extension) = os.path.splitext(tempfilename);</span><br><span class="line">    <span class="keyword">return</span> extension</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">入口函数</span></span><br><span class="line"><span class="string">带两个参数</span></span><br><span class="line"><span class="string">参数1:话题链接地址</span></span><br><span class="line"><span class="string">参数2:图片保存路径</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">if</span>(len(sys.argv) &lt; <span class="number">2</span>):</span><br><span class="line">        print(<span class="string">"usage:./download_spider.py url  savePath"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"the url is "</span>+str(sys.argv[<span class="number">1</span>]))</span><br><span class="line">        print(<span class="string">"the save path is "</span>+str(sys.argv[<span class="number">2</span>]))</span><br><span class="line">        url = sys.argv[<span class="number">1</span>]</span><br><span class="line">        savePath = sys.argv[<span class="number">2</span>]</span><br><span class="line">        getUrlImage(url,savePath)</span><br></pre></td></tr></table></figure>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>有两个参数，第一个参数是url，即话题的链接，第二个参数是所要保存图片的路径。<br>在linux下运行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./getZhiHuImage.py  https://www.zhihu.com/question/48132860 ./test</span><br></pre></td></tr></table></figure></p>
<p>将会在目的目录下发现下载好的图片。</p>
<p><img src="/images/zhihu_spider_result.png" alt="下载结果"><br><img src="/images/zhihu_spider_result2.png" alt="下载结果2"></p>
<h2 id="最后说两句"><a href="#最后说两句" class="headerlink" title="最后说两句"></a>最后说两句</h2><p>本文仅简单利用了python自带urllib库完成了话题图片的获取工作，但更多时候，爬取网络资源要更困难得的多，要获取的内容也不像本文例子中那么明显易得到，比如可能需要模拟登录，验证码识别，伪装成浏览器，去重等等，这里不再展开。但是Python中自带urllib及urllib2库，基本上能满足一般的页面抓取了。</p>
<p>表情包地址:链接: <a href="https://pan.baidu.com/s/1Xp-QT5eAn_2TqGeJ3UxuiA" target="_blank" rel="noopener">https://pan.baidu.com/s/1Xp-QT5eAn_2TqGeJ3UxuiA</a> 密码: 3y9k</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title>《简明python教程》学习笔记</title>
    <url>/2017/09/17/8563.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录在阅读简明python教程中的一些关键内容。<br>私以为，该书适合有一定编程基础，并且有面向对象编程经验的人初学。<br><a id="more"></a></p>
<h2 id="数"><a href="#数" class="headerlink" title="数"></a>数</h2><p>在python中有四中类型的数—整数， 长整数，浮点数和复数</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h4 id="可以使用，单引号，双引号，三引号，三引号可以指示一个多行的字符串"><a href="#可以使用，单引号，双引号，三引号，三引号可以指示一个多行的字符串" class="headerlink" title="可以使用，单引号，双引号，三引号，三引号可以指示一个多行的字符串"></a>可以使用，单引号，双引号，三引号，三引号可以指示一个多行的字符串</h4><h4 id="字符串是不可变的"><a href="#字符串是不可变的" class="headerlink" title="字符串是不可变的"></a>字符串是不可变的</h4><h4 id="按字面意义级连字符串"><a href="#按字面意义级连字符串" class="headerlink" title="按字面意义级连字符串"></a>按字面意义级连字符串</h4><p>例如，‘are you ok’‘？’，会被自动转为‘are you ok？’</p>
<h4 id="python没有char类型数据"><a href="#python没有char类型数据" class="headerlink" title="python没有char类型数据"></a>python没有char类型数据</h4><h4 id="使用自然字符串处理正则表达式。"><a href="#使用自然字符串处理正则表达式。" class="headerlink" title="使用自然字符串处理正则表达式。"></a>使用自然字符串处理正则表达式。</h4><p>如果你想要指示某些不需要如转义符那样的特别处理的字符串，那么你需要指定一个自<br>然字符串。自然字符串通过给字符串加上前缀r或R来指定。</p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>以字母或者下划线开头，其他部分由字母，下划线或者数字组成。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>基本数据类型为数和字符串，当然可以用基本类型构造属于我们自己的类型。</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ 加</span><br><span class="line">- 减</span><br><span class="line">× 乘</span><br><span class="line">×× 幂</span><br><span class="line">/ 除</span><br><span class="line">//取整除 返回商的整数部分</span><br><span class="line">% 取模</span><br><span class="line">&lt;&lt; 左移</span><br><span class="line">&gt;&gt; 右移</span><br><span class="line">not 非</span><br><span class="line">and 与</span><br><span class="line">or 或</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h4 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h4><p>if expression：<br>elif expression<br>else：</p>
<h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p>while expression：</p>
<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p>for i in range（1,5）</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h4 id="函数形参"><a href="#函数形参" class="headerlink" title="函数形参"></a>函数形参</h4><p>def  printMax（a，b）：</p>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>global 关键字</p>
<h4 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h4><p>对于一些函数，你可能希望它的一些参数是 可选 的，如果用户不想要为这些参数提供值的<br>话，这些参数就使用默认值。<br>例如：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: func_default.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myprint</span><span class="params">(message, times = <span class="number">1</span>)</span>:</span></span><br><span class="line"> <span class="keyword">print</span> message * times</span><br><span class="line">myprint(<span class="string">'Hello'</span>)</span><br><span class="line">myprint(<span class="string">'World'</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure></p>
<p>只有在形参表末尾的那些参数可以有默认参数值</p>
<p>def func(a, b=5)有效，而def func(a=5, b)无效</p>
<h4 id="关键参数"><a href="#关键参数" class="headerlink" title="关键参数"></a>关键参数</h4><p>如果你的某个函数有许多参数，而你只想指定其中的一部分，那么你可以通过命名来为这些参<br>数赋值<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename: func_key.py</span><br><span class="line">def func(a, b=5, c=10):</span><br><span class="line"> print &apos;a is&apos;, a, &apos;and b is&apos;, b, &apos;and c is&apos;, c</span><br><span class="line">func(3, 7)</span><br><span class="line">func(25, c=24)</span><br><span class="line">func(c=50, a=100)</span><br></pre></td></tr></table></figure></p>
<p>输出<br>$ python func_key.py<br>a is 3 and b is 7 and c is 10<br>a is 25 and b is 5 and c is 24<br>a is 100 and b is 5 and c is 50 </p>
<h2 id="docstrings"><a href="#docstrings" class="headerlink" title="docstrings"></a>docstrings</h2><p>文档字符串的惯例是一个多行字符串，它的首行以大写字母开始，句号结尾。第二行是空行，<br>从第三行开始是详细的描述。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">def docStringTest(message):</span><br><span class="line">    &apos;&apos;&apos; Hello,this is the test function.</span><br><span class="line"></span><br><span class="line">        let us get start&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    print message</span><br><span class="line"></span><br><span class="line">docStringTest(&apos;test messge&apos;)</span><br><span class="line">print docStringTest.__doc__</span><br></pre></td></tr></table></figure></p>
<p>输出：<br>test messge<br> Hello,this is the test function.</p>
<p> let us get start</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><h4 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h4><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><h4 id="self"><a href="#self" class="headerlink" title="self"></a>self</h4><p>self等价于java中的this<br>你有一个不需要参数的对象方法，你还是得给这个方法定义一个self参数</p>
<h4 id="init"><a href="#init" class="headerlink" title="init"></a><strong>init</strong></h4><p>在创建对象的实例时，会把参数传给init方法</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>class Student（SchoolMember）：<br>—Python不会自动调用基本类的constructor，你得亲自专门调用它。<br>因此，在子类的init函数中，需要调用基类的init</p>
<h4 id="存储器-pickle"><a href="#存储器-pickle" class="headerlink" title="存储器 pickle"></a>存储器 pickle</h4><p>cPickle比pickle快1000倍<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shoplist = [<span class="string">'apple'</span>, <span class="string">'mango'</span>, <span class="string">'carrot'</span>]</span><br><span class="line"><span class="comment"># Write to the file</span></span><br><span class="line">f = file(shoplistfile, <span class="string">'w'</span>)</span><br><span class="line">p.dump(shoplist, f) <span class="comment"># dump the object to a file</span></span><br><span class="line">f.close()</span><br><span class="line"><span class="keyword">del</span> shoplist <span class="comment"># remove the shoplist</span></span><br><span class="line"><span class="comment"># Read back from the storage</span></span><br><span class="line">f = file(shoplistfile)</span><br><span class="line">storedlist = p.load(f)</span><br><span class="line"><span class="keyword">print</span> storedlist</span><br></pre></td></tr></table></figure></p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h4 id="捕捉异常"><a href="#捕捉异常" class="headerlink" title="捕捉异常"></a>捕捉异常</h4><p>try：<br>except：errortype<br>except：</p>
<h5 id="引发异常"><a href="#引发异常" class="headerlink" title="引发异常"></a>引发异常</h5><p>class MyException(Exception):<br> ‘’’A user-defined exception class.’’’<br> def <strong>init</strong>(self, length, atleast):<br> Exception.<strong>init</strong>(self)<br> self.length = length<br> self.atleast = atleast<br>raise MyException（3,3）</p>
<h3 id="try-finally"><a href="#try-finally" class="headerlink" title="try finally"></a>try finally</h3><p>try：<br>finally：<br>finally中的语句，无论异常发生与否都会执行</p>
<h2 id="python标准库"><a href="#python标准库" class="headerlink" title="python标准库"></a>python标准库</h2><h4 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h4><p>包含系统对应的功能</p>
<h4 id="os"><a href="#os" class="headerlink" title="os"></a>os</h4><p>包含普遍的操作系统功能</p>
<p>比如获取当前目录</p>
<h2 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h2><h4 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h4><p><strong>init</strong>(self,…)  新建对象要被返回使用之前被调用<br><strong>del</strong>（self）在对象要被删除之前调用<br><strong>str</strong>（self）在对对象使用print或是使用str（）的时候调用<br><strong>lt</strong>当使用小于运算符时调用，类似的，+，》等都有特殊的方法<br><strong>len</strong>（self）对序列对象使用内建的()函数时调用</p>
<h4 id="列表综合"><a href="#列表综合" class="headerlink" title="列表综合"></a>列表综合</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: list_comprehension.py</span></span><br><span class="line">listone = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">listtwo = [<span class="number">2</span>*i <span class="keyword">for</span> i <span class="keyword">in</span> listone <span class="keyword">if</span> i &gt; <span class="number">2</span>]</span><br><span class="line"><span class="keyword">print</span> listtwo</span><br></pre></td></tr></table></figure>
<p>输出：<br>[6, 8]<br>使其中所有大于2的数都是原来的2倍</p>
<h4 id="在函数中接收元组和列表"><a href="#在函数中接收元组和列表" class="headerlink" title="在函数中接收元组和列表"></a>在函数中接收元组和列表</h4><p>由于在args变量前有<em>前缀，所有多余的函数参数都会作为一个元组存储在args中。如果使用的<br>是*</em>前缀，多余的参数则会被认为是一个字典的键/值对。</p>
<h4 id="lambda-形式"><a href="#lambda-形式" class="headerlink" title="lambda 形式"></a>lambda 形式</h4><p>lambda语句被用来创建新的函数对象</p>
<p>注：是否类似c语言里的函数指针</p>
<h4 id="exec-和eval语句"><a href="#exec-和eval语句" class="headerlink" title="exec 和eval语句"></a>exec 和eval语句</h4><p>exec语句用来执行储存在字符串或文件中的Python语句。</p>
<p>eval语句用来计算存储在字符串中的有效Python表达式。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>python</tag>
        <tag>笔记</tag>
        <tag>简明python教程</tag>
      </tags>
  </entry>
  <entry>
    <title>父进程异常退出时，确保子进程退出</title>
    <url>/2017/09/10/9987.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>父进程异常退出时，如果子进程未退出，或者对于父进程的退出不知情，将会导致子进程变成孤儿进程，更严重的情况是，如果父进程需要使用端口，而父进程异常退出，父进程再次启动时，会发现其子进程占用其端口。原因是，子进程继承了原来父进程的端口。</p>
<p>因此必须保证，父进程异常退出是，子进程也能够退出。</p>
<a id="more"></a>
<p>如下面的程序，对系统的system函数进行了改写。<br>bakRun.sh<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">declare -i i=1</span><br><span class="line">until ((30&lt;i))</span><br><span class="line">    do </span><br><span class="line">	let i++</span><br><span class="line">	sleep 1</span><br><span class="line">	echo &quot;1&quot;</span><br><span class="line">done</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure></p>
<p>bakRun.c，编译：gcc -g bakRun.c -o bakRun<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mysystem</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">int</span> status;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>((pid=fork()) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		waitpid(pid,&amp;status,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"parent\n"</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"receive msg\n"</span>);</span><br><span class="line">		prctl(PR_SET_PDEATHSIG,SIGHUP);</span><br><span class="line">		execl(<span class="string">"/bin/sh"</span>,<span class="string">"sh"</span>,<span class="string">"-c"</span>,<span class="string">"./bakRun.sh"</span>,(<span class="keyword">char</span>*)<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"exec cmd\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc ,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mysystem(<span class="string">"./backRun.sh"</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的程序中，需要设置选项<br>prctl(PR_SET_PDEATHSIG,SIGHUP);</p>
<p>设置该选项，在父进程死后，子进程会收到SIGHUP信号，子进程因此也会退出，解决了，父进程异常退出，而子进程来不及回收资源的问题。</p>
<p>如果去掉了上面的设置，在杀死bakRun之后，会发现sh脚本还在运行。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>linux命令学习笔记</title>
    <url>/2017/09/10/52112.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录一些有用但不常见的linux命令用法<br><a id="more"></a></p>
<h4 id="iconv-—文件编码格式转码"><a href="#iconv-—文件编码格式转码" class="headerlink" title="iconv —文件编码格式转码"></a>iconv —文件编码格式转码</h4><p>场景：从windows上拷贝一个txt文件文件，在linux上打开全是乱码，可以使用下面的命令进行转换。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iconv -f gb18030  -t utf8 1.txt -o 2.txt</span><br></pre></td></tr></table></figure></p>
<p>其中，gb18030是windows上文件的编码，utf8是linux上文件的默认编码格式。1.txt是需要转换的文件，2.txt是转换后的结果</p>
<h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><h5 id="列出目录下所有文件名"><a href="#列出目录下所有文件名" class="headerlink" title="列出目录下所有文件名"></a>列出目录下所有文件名</h5><p>例如，列出/LTE目录下所有文件的文件名<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -lR |grep &apos;^-&apos; |awk &apos;&#123;print &quot;/LTE/&quot;$9&#125;&apos;</span><br></pre></td></tr></table></figure></p>
<p>-R   递归目录<br>^-   文件（文件以-开头）<br>$9  文件名</p>
<h5 id="计算目录下的文件数量"><a href="#计算目录下的文件数量" class="headerlink" title="计算目录下的文件数量"></a>计算目录下的文件数量</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -lR |grep &apos;^-&apos;|wc -l</span><br></pre></td></tr></table></figure>
<h4 id="at"><a href="#at" class="headerlink" title="at"></a>at</h4><p>让系统执行定时任务<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">at now &lt;&lt;&lt; &quot;ls&quot;</span><br><span class="line">at 17:50</span><br></pre></td></tr></table></figure></p>
<p>表示现在执行ls命令</p>
<h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><h5 id="删除带某个字符串以外的文件"><a href="#删除带某个字符串以外的文件" class="headerlink" title="删除带某个字符串以外的文件"></a>删除带某个字符串以外的文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -v !(*mts*)</span><br></pre></td></tr></table></figure>
<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><h5 id="找到某一文件的目录"><a href="#找到某一文件的目录" class="headerlink" title="找到某一文件的目录"></a>找到某一文件的目录</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find $PWD -name \&quot;build.sh\&quot;</span><br></pre></td></tr></table></figure>
<h4 id="du"><a href="#du" class="headerlink" title="du"></a>du</h4><h5 id="查看目录磁盘空间大小"><a href="#查看目录磁盘空间大小" class="headerlink" title="查看目录磁盘空间大小"></a>查看目录磁盘空间大小</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">du -h  --max-depth=1</span><br></pre></td></tr></table></figure>
<p>—max-depth  目录深度</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>笔记</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>linux调试或定位命令</title>
    <url>/2017/09/10/3456.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录一些在编程或者调试过程中用到的linux系统命令，这些命令在编码或者调试过程中，能够起到很好的帮助作用。<br><a id="more"></a></p>
<h4 id="tcpdump-抓包分析"><a href="#tcpdump-抓包分析" class="headerlink" title="tcpdump 抓包分析"></a>tcpdump 抓包分析</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcpdump -i any -w test.pcap</span><br></pre></td></tr></table></figure>
<p>对任何网卡的数据进行抓包并将抓包结果存储为test.pcap</p>
<h4 id="strings-搜索可执行文件中包含的字符"><a href="#strings-搜索可执行文件中包含的字符" class="headerlink" title="strings  搜索可执行文件中包含的字符"></a>strings  搜索可执行文件中包含的字符</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strings test | grep &quot;somestring&quot;</span><br></pre></td></tr></table></figure>
<h4 id="nm-查看某库是否包含某个接口"><a href="#nm-查看某库是否包含某个接口" class="headerlink" title="nm  查看某库是否包含某个接口"></a>nm  查看某库是否包含某个接口</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nm libtest_interface.a | grep test</span><br></pre></td></tr></table></figure>
<p>查看libtest_interface.a中是否包含test相关接口</p>
<h4 id="readelf-查看目标文件信息"><a href="#readelf-查看目标文件信息" class="headerlink" title="readelf  查看目标文件信息"></a>readelf  查看目标文件信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">readelf -h libdb.a</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">File: libgmock.a(gmock-all.o)</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&apos;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              REL (Relocatable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x0</span><br><span class="line">  Start of program headers:          0 (bytes into file)</span><br><span class="line">  Start of section headers:          1281856 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           0 (bytes)</span><br><span class="line">  Number of program headers:         0</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         2118</span><br><span class="line">  Section header string table index: 2115</span><br></pre></td></tr></table></figure>
<p>可以看到目标文件的一些信息</p>
<h4 id="addr2line-定位core-dump问题"><a href="#addr2line-定位core-dump问题" class="headerlink" title="addr2line  定位core dump问题"></a>addr2line  定位core dump问题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addr2line -e test test_add.so 0x0011d680 -f</span><br></pre></td></tr></table></figure>
<p>比如core dump的地址为0x0011d680，so文件为test_add.so，可以使用上面的命令知道哪一行出了问题<br>addr2line -e 进程  地址</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>笔记</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>使用gcov和lcov测试代码覆盖率</title>
    <url>/2017/08/06/13981.html</url>
    <content><![CDATA[<h2 id="gcov与-lcov简介"><a href="#gcov与-lcov简介" class="headerlink" title="gcov与 lcov简介"></a>gcov与 lcov简介</h2><p>通过gcov和lcov，可以很直观的看到代码的运行情况，同时也可以查看<br>代码的行覆盖率，函数覆盖率等等信息，为开发提供一个方便的测试手段。<br><a id="more"></a></p>
<h3 id="gcov"><a href="#gcov" class="headerlink" title="gcov"></a>gcov</h3><p>gcov是Linux下GCC自带的一个C/C++代码覆盖率分析工具,因此只要安装了gcc，就不需要再次安装了</p>
<h3 id="lcov"><a href="#lcov" class="headerlink" title="lcov"></a>lcov</h3><h4 id="lcov介绍"><a href="#lcov介绍" class="headerlink" title="lcov介绍"></a>lcov介绍</h4><p>gcov能够生成代码覆盖信息，但是不够直观，因此需要借助lcov直观展示覆盖率,主要特点有：</p>
<p>基于Html输出，并生成一棵完整的HTML树<br>输出包括概述、覆盖率百分比、图表，能快速浏览覆盖率数据<br>支持大项目，提供三个级别的视图：目录视图、文件视图、源码视图 </p>
<h4 id="lcov安装"><a href="#lcov安装" class="headerlink" title="lcov安装"></a>lcov安装</h4><p>下载地址：<a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_blank" rel="noopener">lcov</a><br>下载完成后解压，执行命令：make install即可。</p>
<p>下面简单介绍linux下，使用gcov和locov进行代码覆盖率的测试。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码:"></a>测试代码:</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***************************************************************</span></span><br><span class="line"><span class="comment">*   Copyright (C) 2017 All rights reserved.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   文件名称：test.c</span></span><br><span class="line"><span class="comment">*   创 建 者：hyb</span></span><br><span class="line"><span class="comment">*   创建日期：2017年08月06日</span></span><br><span class="line"><span class="comment">*   描    述：</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">***************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> loop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> inloop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>* result = <span class="literal">NULL</span>;</span><br><span class="line">    result =(<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">memset</span>(result,<span class="number">0</span>,<span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"numsSize=%d\n"</span>,numsSize);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == nums || numsSize==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(loop = <span class="number">0</span>;loop &lt; numsSize;loop++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(inloop = loop+<span class="number">1</span>;inloop &lt;numsSize;inloop++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(*(nums+loop)+*(nums+inloop) == target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">NULL</span> != result)</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    *result = loop;</span><br><span class="line">                    *(result+<span class="number">1</span>) = inloop;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> arg,<span class="keyword">char</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nums[<span class="number">4</span>]=&#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">int</span> numsSize = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span>* result = twoSum(nums,numsSize,target);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"index1:%d\nindex2:%d\n"</span>,*result,*(result+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">gcc -fprofile-arcs -ftest-coverage test.c -o test</span><br></pre></td></tr></table></figure>
<p>上面的参数-fprofile-arcs -ftest-coverage一定要带上，会生成gcno文件</p>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./test</span><br></pre></td></tr></table></figure>
<p>生成了gcda文件</p>
<h4 id="转换覆盖率信息"><a href="#转换覆盖率信息" class="headerlink" title="转换覆盖率信息"></a>转换覆盖率信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lcov -c -o test.info -d .</span><br></pre></td></tr></table></figure>
<p>-c 生成覆盖率信息<br>-o 生成目标文件<br>-d 目录<br>. 当前目录</p>
<p>可能出现的出错:可能会提示out of memory,原因是locv版本过低。</p>
<h4 id="生成html文件"><a href="#生成html文件" class="headerlink" title="生成html文件"></a>生成html文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">genhtml test.info -o ./output</span><br></pre></td></tr></table></figure>
<p>tst.info 需要生成覆盖率信息的源文件<br>-o 生成结果目录<br>最后会有提示如下：</p>
<p>Generating output.<br>Processing file gcov_lcov/test.c<br>Writing directory view page.<br>Overall coverage rate:<br>  lines……: 91.3% (21 of 23 lines)<br>  functions..: 100.0% (2 of 2 functions)<br>可以看到output目录下有index.html文件<br>使用浏览器打开html文件，即可查看覆盖率报告</p>
<h4 id="覆盖率报告分析"><a href="#覆盖率报告分析" class="headerlink" title="覆盖率报告分析"></a>覆盖率报告分析</h4><p><img src="/gcovreport.png" alt="gcov"></p>
<p>从上图可以看到<br>整个工程的代码行覆盖率和函数覆盖率，分支覆盖情况<br>继续点击test.c，可以看到具体每行是否有跑到。<br><img src="/ccov.png" alt="test.c"></p>
<p>褐色表示未跑到过的代码，左侧数字表示跑到的次数。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>结合使用gcov和locv,可以比较直观的观察到运行的程序是否按照自己的设计，<br>跑到了对应的代码中。</p>
]]></content>
      <categories>
        <category>单元测试</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>C</tag>
        <tag>单元测试</tag>
        <tag>gcov</tag>
        <tag>lcov</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下使用gtest框架进行c/c++测试(二)-gmock环境搭建</title>
    <url>/2017/08/06/13315.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>   google mock（以下简称gmock）也是google的开源项目，它能够在测试中起到“打桩”的作用。举个例子，有A模块需要调用B模块，需要对A模块进行测试，但是B模块没有实现，那么就可以利用gmock对B模块进行打桩，来模拟B接口的实现。本文主要介绍gmock环境的搭建，即简单使用。</p>
<a id="more"></a>
<h2 id="准备gtest框架"><a href="#准备gtest框架" class="headerlink" title="准备gtest框架"></a>准备gtest框架</h2><p>在github网站下载gtest框架<a href="https://github.com/google/googletest" target="_blank" rel="noopener">https://github.com/google/googletest</a></p>
<p>解压后，进入googletest目录，目录下有以下内容<br>├── build-aux<br>├── CHANGES<br>├── cmake<br>├── CMakeLists.txt<br>├── codegear<br>├── configure.ac<br>├── CONTRIBUTORS<br>├── docs<br>├── include<br>├── LICENSE<br>├── m4<br>├── make<br>├── Makefile.am<br>├── msvc<br>├── README.md<br>├── samples<br>├── scripts<br>├── src<br>├── test<br>└── xcode</p>
<p>现在我们需要获得gmock的.a文件<br>进入googlemock的make文件夹，执行make，再执行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ar -rv libgmock.a gtest-all.o gmock-all.o</span><br></pre></td></tr></table></figure></p>
<p>为确保成功，可以运行目录下生成的./gmock_test。<br>生成的libgmock.a以及该目录include下的头文件都是我们后面测试需要的。<br>gmock中已经包含了gtest的库，因此 <strong> 只需要gmock就可以使用gtest的所有测试功能。</strong></p>
<h2 id="新建测试项目"><a href="#新建测试项目" class="headerlink" title="新建测试项目"></a>新建测试项目</h2><p>新建项目目录，比如我创建了一个TestWithGtest目录。<br>同时，在该目录下创建以下三个目录<br>├── gmock   //存放gtest框架内容<br>├── leetcode  //存放项目源代码<br>├── testcase  //存放测试用例代码<br>└── Makefile</p>
<p>gmock目录下有刚才所说的include头文件，lib文件。另外，我们还需要一个main函数文件。放在gmock的main下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/*TestAll.cpp*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"googletest.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//testing::GTEST_FLAG(output) = "xml:"; //生成xml结果文件</span></span><br><span class="line">    testing::InitGoogleTest(&amp;argc,argv); <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">if</span>( RUN_ALL_TESTS())  <span class="comment">//跑单元测试</span></span><br><span class="line">	        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>leetcode目录下新建src目录和include目录，分别用于存放头文件和.c文件<br>我在include下放了两个头文件common.h 和leetcode_functions.h<br>内容分别如下：<br>common.h<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>leetcode_functions.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">//leetcode_functions.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LEETCODE_FUNCTIONS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _LEETCODE_FUNCTIONS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"common.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>src目录下为项目的.c文件<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Given an array of integers, return indices of the two numbers such that they add up to a specific target.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">You may assume that each input would have exactly one solution, and you may not use the same element twice.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Example:</span></span><br><span class="line"><span class="comment">Given nums = [2, 7, 11, 15], target = 9,</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Because nums[0] + nums[1] = 2 + 7 = 9,</span></span><br><span class="line"><span class="comment">return [0, 1].</span></span><br><span class="line"><span class="comment">  Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"leetcode_functions.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> loop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> inloop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>* result = <span class="literal">NULL</span>;</span><br><span class="line">    result =(<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">memset</span>(result,<span class="number">0</span>,<span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"numsSize=%d\n"</span>,numsSize);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == nums || numsSize==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(loop = <span class="number">0</span>;loop &lt; numsSize;loop++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(inloop = loop+<span class="number">1</span>;inloop &lt; numsSize;inloop++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(*(nums+loop)+*(nums+inloop) == target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">NULL</span> != result)</span><br><span class="line">                &#123;</span><br><span class="line">                    </span><br><span class="line">                    *result = loop;</span><br><span class="line">                    *(result+<span class="number">1</span>) = inloop;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>testcase下新建include和src目录<br>src目录下有测试用例文件leetcode_test.cpp<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	<span class="comment">//leetcode_test.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"googletest.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"leetcode_functions.h"</span></span></span><br><span class="line"></span><br><span class="line">TEST(two_sum_test,twoSum001)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> nums[<span class="number">4</span>]=&#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">int</span> numsSize = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span>* result = twoSum(nums,numsSize,target);</span><br><span class="line"></span><br><span class="line">       ASSERT_EQ(<span class="number">0</span>,*result);</span><br><span class="line">       ASSERT_EQ(<span class="number">1</span>,*(result+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>include下有头文件<br>googletest.h<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&quot;gmock/gmock.h&quot;</span><br><span class="line">#include&quot;gtest/gtest.h&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="编译链接"><a href="#编译链接" class="headerlink" title="编译链接"></a>编译链接</h2><p>测试之前，需要编译并链接我们得项目代码和测试框架。<br>编译<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">g++ -o 001_two_sum.o -c ./leetcode/src/001_Two_Sum.c  -I ./leetcode/include/</span><br><span class="line"></span><br><span class="line">g++ -o leetcode_test.o -c ./testcase/src/leetcode_test.cpp -I ./ -I ./leetcode/include/</span><br><span class="line"></span><br><span class="line">   g++ -o TestAll.o -c ./gmock/main/TestAll.cpp -I ./</span><br></pre></td></tr></table></figure></p>
<p>链接<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">g++ -o main *.o -I./include -L./gmock/lib -lgtest -lpthread</span><br></pre></td></tr></table></figure></p>
<p>最后生成main文件。</p>
<h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><p>运行生成的可执行文件main<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">./main</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：</p>
<p>[==========] Running 1 test from 1 test case.<br>[—————] Global test environment set-up.<br>[—————] 1 test from two_sum_test<br>[ RUN      ] two_sum_test.twoSum001<br>numsSize=4<br>[       OK ] two_sum_test.twoSum001 (0 ms)<br>[—————] 1 test from two_sum_test (0 ms total)</p>
<p>[—————] Global test environment tear-down<br>[==========] 1 test from 1 test case ran. (0 ms total)<br>[  PASSED  ] 1 test.</p>
<p>可以看到，共有一个用例，通过了一个用例</p>
<p>例子中，暂时未使用到gmock，只介绍了gmock的环境搭建。<br>代码可以在<a href="https://github.com/yanbinghu/TestWithGtest.git" target="_blank" rel="noopener">github下载</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用gmock可以很方便的对一些函数打桩，或者返回特定的返回值，以便测试继续进行。</p>
]]></content>
      <categories>
        <category>单元测试</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>C</tag>
        <tag>gtest</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题目解析</title>
    <url>/2017/08/04/64636.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文为<a href="https://leetcode.com" target="_blank" rel="noopener">leetcode</a>上的题目简单分析，仅作记录，欢迎提出建议，共同学习交流。题目的源代码和测试用例可以在<a href="https://github.com/yanbinghu/LeetCodeWithC" target="_blank" rel="noopener">leetcodeWithC</a>下载</p>
<a id="more"></a>
<h3 id="001-Two-Sum"><a href="#001-Two-Sum" class="headerlink" title="001  Two Sum"></a>001  Two Sum</h3><h5 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h5><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p>Example:<br>Given nums = [2, 7, 11, 15], target = 9,</p>
<p>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p>
<h5 id="释义："><a href="#释义：" class="headerlink" title="释义："></a>释义：</h5><p>给定整型数组，返回两个数的下标，使得这两个数相加得到特定的值。<br>假设每个给定的数组只能找到一组满足条件的结果，同时，不能使用同一个数两次。</p>
<h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><p>题大意为，在一组数组中，找到两个数，使得这两个数的和等于特定值，并返回下标。可以从第一个数开始，循环与后面的每一个相加，与结果比较，比较成功则返回。<br>例如，输入[1,7,11,15],目标值26，那么循环计算1+7,1+11,1+15，7+11,7+15……，直到得到目标值。</p>
<h5 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h5><p><a href="https://github.com/yanbinghu/LeetCodeWithC/blob/master/leetcode/src/001_Two_Sum.c" target="_blank" rel="noopener">001 two sum</a><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> loop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> inloop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>* result = <span class="literal">NULL</span>;</span><br><span class="line">    result =(<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">memset</span>(result,<span class="number">0</span>,<span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"numsSize=%d\n"</span>,numsSize);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == nums || numsSize==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(loop = <span class="number">0</span>;loop &lt; numsSize;loop++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(inloop = loop+<span class="number">1</span>;inloop &lt;numsSize;inloop++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(*(nums+loop)+*(nums+inloop) == target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">NULL</span> != result)</span><br><span class="line">                &#123;</span><br><span class="line">                    *result = loop;</span><br><span class="line">                    *(result+<span class="number">1</span>) = inloop;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="002-Add-Two-Numbers"><a href="#002-Add-Two-Numbers" class="headerlink" title="002 Add Two Numbers"></a>002 Add Two Numbers</h3><h5 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h5><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8</p>
<h5 id="释义：-1"><a href="#释义：-1" class="headerlink" title="释义："></a>释义：</h5><p>给定两个非空链表代表两个非负整数，整数的各位数以逆序存储在链表的每个节点中。将这两个数相加，并返回结果链表。</p>
<h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>题意较清晰，是将用链表形式的两个整数进行相加，并返回链表结果。<br>需要注意的主要有以下几点<br>1.加完之后需要给下一位子进位。<br>2.如果链表只有一位，直接计算结果，提高效率。<br>3.考虑两个链表长度不一样的场景</p>
<h5 id="代码如下：-1"><a href="#代码如下：-1" class="headerlink" title="代码如下："></a>代码如下：</h5><p><a href="https://github.com/yanbinghu/LeetCodeWithC/blob/master/leetcode/src/002_Add_Two_Numbers.c" target="_blank" rel="noopener">002 Add Two Numbers</a><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">addTwoNumbers</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(struct ListNode);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">head</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">temp</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">int</span> tempValue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	/×个位数相加的情况×/</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == l1-&gt;next||<span class="literal">NULL</span> == l2-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        head = (struct ListNode*)<span class="built_in">malloc</span>(len);</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">0</span>,len);</span><br><span class="line">        head-&gt;val = (l1-&gt;val + l2-&gt;val)%<span class="number">10</span>;</span><br><span class="line">       /×获取进位×/</span><br><span class="line">        flag = (l1-&gt;val + l2-&gt;val)/<span class="number">10</span>;</span><br><span class="line">        temp = head;</span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">        l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">	    /×非个位数计算×/</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">NULL</span> != l1&amp;&amp; <span class="literal">NULL</span> != l2)</span><br><span class="line">        &#123;</span><br><span class="line">            tempValue =  l2-&gt;val+l1-&gt;val;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">node</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">len</span>);</span></span><br><span class="line">            <span class="built_in">memset</span>(node,<span class="number">0</span>,len);</span><br><span class="line">            node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            node-&gt;val = (tempValue+flag)%<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">NULL</span> == head)</span><br><span class="line">            &#123;</span><br><span class="line">                head = node;</span><br><span class="line">                temp = head;</span><br><span class="line">            &#125;</span><br><span class="line">            &#123;</span><br><span class="line">                temp-&gt;next = node;</span><br><span class="line">                temp = temp-&gt;next;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            flag = (tempValue+flag)/<span class="number">10</span>;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	/×l1的位数大于l2×/</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != l1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">NULL</span> != l1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">node</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">len</span>);</span></span><br><span class="line">            <span class="built_in">memset</span>(node,<span class="number">0</span>,len);</span><br><span class="line">            node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            node-&gt;val = (l1-&gt;val+flag)%<span class="number">10</span>;</span><br><span class="line">            temp-&gt;next = node;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">            flag = (l1-&gt;val+flag)/<span class="number">10</span>;</span><br><span class="line">            l1=l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /×l2的位数大于l1×/</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="literal">NULL</span> != l2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">NULL</span> != l2)</span><br><span class="line">        &#123;</span><br><span class="line">            struct ListNode* node = (struct ListNode*)<span class="built_in">malloc</span>(len);</span><br><span class="line">            <span class="built_in">memset</span>(node,<span class="number">0</span>,len);</span><br><span class="line">            node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            node-&gt;val = (l2-&gt;val+flag)%<span class="number">10</span>;</span><br><span class="line">            temp-&gt;next = node;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">            flag =(l2-&gt;val+flag)/<span class="number">10</span>;</span><br><span class="line">            l2=l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>&#123;&#125;</span><br><span class="line">    /×如果前面有进位，记得加上×/</span><br><span class="line">    <span class="keyword">if</span>(flag != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp-&gt;next = (struct ListNode*)<span class="built_in">malloc</span>(len);</span><br><span class="line">        <span class="built_in">memset</span>(temp-&gt;next,<span class="number">0</span>,len);</span><br><span class="line">        temp-&gt;next-&gt;val = flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="258-Add-Digits"><a href="#258-Add-Digits" class="headerlink" title="258 Add Digits"></a>258 Add Digits</h3><h5 id="题目：-2"><a href="#题目：-2" class="headerlink" title="题目："></a>题目：</h5><p>Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.</p>
<p>For example:</p>
<p>Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.</p>
<h5 id="释义：-2"><a href="#释义：-2" class="headerlink" title="释义："></a>释义：</h5><p>计算各位数之和，直到最后只有一位。</p>
<h5 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h5><p>计算各位数之和，采用递归，计算一次后，再次调用，直到结果位各位数。</p>
<h5 id="代码如下：-2"><a href="#代码如下：-2" class="headerlink" title="代码如下："></a>代码如下：</h5><p><a href="https://github.com/yanbinghu/LeetCodeWithC/blob/master/leetcode/src/258_Add_Digits.c" target="_blank" rel="noopener">258 Add Digits</a><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = num;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == num/<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        num =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">0</span> != temp/<span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num +=temp%<span class="number">10</span>;</span><br><span class="line">            temp = temp/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num = num+temp;</span><br><span class="line">       <span class="keyword">return</span>  addDigits(num);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="344-Reverse-String"><a href="#344-Reverse-String" class="headerlink" title="344 Reverse String"></a>344 Reverse String</h3><h5 id="题目：-3"><a href="#题目：-3" class="headerlink" title="题目："></a>题目：</h5><p>Write a function that takes a string as input and returns the string reversed.</p>
<p>Example:<br>Given s = “hello”, return “olleh”.</p>
<h5 id="释义：-3"><a href="#释义：-3" class="headerlink" title="释义："></a>释义：</h5><p>字符串翻转</p>
<h5 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h5><p>头尾对应位置的字符位置调换</p>
<h5 id="代码如下：-3"><a href="#代码如下：-3" class="headerlink" title="代码如下："></a>代码如下：</h5><p><a href="https://github.com/yanbinghu/LeetCodeWithC/blob/master/leetcode/src/344_Reverse_String.c" target="_blank" rel="noopener">344 Reverse String</a><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>* s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span>  <span class="keyword">int</span> len = <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span>*)s);</span><br><span class="line">    <span class="keyword">char</span> result[len+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(result,<span class="number">0</span>,len);</span><br><span class="line">     <span class="keyword">int</span> loop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(loop = len<span class="number">-1</span>; loop &gt;= <span class="number">0</span>;loop--)</span><br><span class="line">    &#123;</span><br><span class="line">        *(result+(len-loop<span class="number">-1</span>)) = *(s+loop);</span><br><span class="line">    &#125;</span><br><span class="line">    result[len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(s,result,len);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="463-Hamming-Distance"><a href="#463-Hamming-Distance" class="headerlink" title="463 Hamming Distance"></a>463 Hamming Distance</h3><h5 id="题目：-4"><a href="#题目：-4" class="headerlink" title="题目："></a>题目：</h5><p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.</p>
<p>Given two integers x and y, calculate the Hamming distance.</p>
<p>Note:<br>0 ≤ x, y &lt; 231.</p>
<p>Example:</p>
<p>Input: x = 1, y = 4</p>
<p>Output: 2</p>
<p>Explanation:<br>1   (0 0 0 1)<br>4   (0 1 0 0)<br>       ?   ?</p>
<p>The above arrows point to positions where the corresponding bits are different.</p>
<h5 id="释义：-4"><a href="#释义：-4" class="headerlink" title="释义："></a>释义：</h5><h5 id="分析：-2"><a href="#分析：-2" class="headerlink" title="分析："></a>分析：</h5><p>两个数的汉明距离，可以理解为，二进制的情况下，两个数异或之后的数的1的个数。<br>比如例子中，1和4,0001与0100异或得：0101，而0101中1的个数，即为汉明距离，可以理解位，从0001，变成0100，需要改变的位数。</p>
<h5 id="代码如下：-4"><a href="#代码如下：-4" class="headerlink" title="代码如下："></a>代码如下：</h5><p><a href="https://github.com/yanbinghu/LeetCodeWithC/blob/master/leetcode/src/461_Hamming_Distance.c" target="_blank" rel="noopener">463 Hamming Distance</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int hammingDistance(int x, int y) &#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    /*get the temp result*/</span><br><span class="line">    int temp = x^y;</span><br><span class="line">    /*calc the 1 of temp result*/</span><br><span class="line">    while (temp != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        if (temp % 2 == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp &gt;&gt;1;</span><br><span class="line">    &#125;</span><br><span class="line">   return result;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="476-Number-Complement"><a href="#476-Number-Complement" class="headerlink" title="476 Number Complement"></a>476 Number Complement</h3><h5 id="题目：-5"><a href="#题目：-5" class="headerlink" title="题目："></a>题目：</h5><p>Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.</p>
<p>Note:<br>The given integer is guaranteed to fit within the range of a 32-bit signed integer.<br>You could assume no leading zero bit in the integer’s binary representation.<br>Input: 5<br>Output: 2<br>Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.</p>
<h5 id="释义：-5"><a href="#释义：-5" class="headerlink" title="释义："></a>释义：</h5><p>给定一个正整数，输出它的补全整数。补全策略是翻转它的每个比特位，得到补全整数。</p>
<h5 id="分析：-3"><a href="#分析：-3" class="headerlink" title="分析："></a>分析：</h5><p>对于补全，以5为例，101，每一位翻转得到，010，即结果为2，那么，010+101 = 111，2的3次方。再以35为例，10 0011，翻转得到011100，即有100011+011100=111111,2的6次方，那么不难得到，其实补全数，就是用2的n次方，减去该数，其中，n为该数二进制表示的位数。</p>
<h5 id="代码如下：-5"><a href="#代码如下：-5" class="headerlink" title="代码如下："></a>代码如下：</h5><p><a href="https://github.com/yanbinghu/LeetCodeWithC/blob/master/leetcode/src/476_Number_Complement.c" target="_blank" rel="noopener">476 Number Complement</a><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span> temp = num;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;temp!=<span class="number">0</span>;temp/=<span class="number">2</span>,i++)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    /×<span class="built_in">pow</span>，库函数×/</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>,i)-num<span class="number">-1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>C</tag>
        <tag>github</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习笔记</title>
    <url>/2017/07/29/14696.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。</p>
<p>因此，利用好git，可以很好的管理我们自己的项目。</p>
<a id="more"></a>
<h4 id="待补充……"><a href="#待补充……" class="headerlink" title="待补充……"></a>待补充……</h4>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下使用gtest框架进行c/c++测试(一)-gtest环境搭建</title>
    <url>/2017/07/27/51530.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  google test（以下简称gtest）是谷歌的开源C++单元测试框架，用来做c/c++的单元测试比较方便。下面对于它在linux下的使用环境搭建做简单介绍。<br><a id="more"></a></p>
<h2 id="准备gtest框架"><a href="#准备gtest框架" class="headerlink" title="准备gtest框架"></a>准备gtest框架</h2><p>在github网站下载gtest框架<a href="https://github.com/google/googletest" target="_blank" rel="noopener">https://github.com/google/googletest</a></p>
<p>解压后，进入googletest目录。目录下有以下内容<br>├── build-aux<br>├── CHANGES<br>├── cmake<br>├── CMakeLists.txt<br>├── codegear<br>├── configure.ac<br>├── CONTRIBUTORS<br>├── docs<br>├── include<br>├── LICENSE<br>├── m4<br>├── make<br>├── Makefile.am<br>├── msvc<br>├── README.md<br>├── samples<br>├── scripts<br>├── src<br>├── test<br>└── xcode</p>
<p>现在我们需要将其编译成.o文件<br>编译生成gtest.o文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ -o gtest.o -I./include -I./  -c ./src/gtest-all.cc</span><br></pre></td></tr></table></figure></p>
<p>再生成.a静态库文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ar -rv libgtest.a gtest.o</span><br></pre></td></tr></table></figure></p>
<p>生成的libgtest.a以及该目录include下的头文件都是我们后面测试需要的。</p>
<h2 id="新建测试项目"><a href="#新建测试项目" class="headerlink" title="新建测试项目"></a>新建测试项目</h2><p>新建项目目录，比如我创建了一个LeetcodeWithC目录。<br>同时，在该目录下创建以下三个目录<br>├── gtest                           //存放gtest框架内容<br>├── leetcode                    //存放项目源代码<br>├── testcase                    //存放测试用例代码<br>└── Makefile</p>
<p>gtest目录下有刚才所说的include头文件，lib文件。另外，我们还需要一个main函数文件。放在getst的main下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/*TestAll.cpp*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"googletest.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	        <span class="comment">//testing::GTEST_FLAG(output) = "xml:"; //若要生成xml结果文件</span></span><br><span class="line">	        testing::InitGoogleTest(&amp;argc,argv); <span class="comment">//初始化</span></span><br><span class="line">	       <span class="keyword">if</span>( RUN_ALL_TESTS())                     <span class="comment">//跑单元测试</span></span><br><span class="line">	        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>leetcode目录下新建src目录和include目录，分别用于存放头文件和.c文件<br>我在include下放了两个头文件,common.h 和leetcode_functions.h<br>内容分别如下：<br>common.h<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>leetcode_functions.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">//leetcode_functions.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LEETCODE_FUNCTIONS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _LEETCODE_FUNCTIONS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"common.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>src目录下为项目的.c文件<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Given an array of integers, return indices of the two numbers such that they add up to a specific target.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">You may assume that each input would have exactly one solution, and you may not use the same element twice.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Example:</span></span><br><span class="line"><span class="comment">Given nums = [2, 7, 11, 15], target = 9,</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Because nums[0] + nums[1] = 2 + 7 = 9,</span></span><br><span class="line"><span class="comment">return [0, 1].</span></span><br><span class="line"><span class="comment">  Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"leetcode_functions.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> loop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> inloop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>* result = <span class="literal">NULL</span>;</span><br><span class="line">    result =(<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">memset</span>(result,<span class="number">0</span>,<span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"numsSize=%d\n"</span>,numsSize);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == nums || numsSize==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(loop = <span class="number">0</span>;loop &lt; numsSize;loop++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(inloop = loop+<span class="number">1</span>;inloop &lt; numsSize;inloop++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(*(nums+loop)+*(nums+inloop) == target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">NULL</span> != result)</span><br><span class="line">                &#123;</span><br><span class="line">                    </span><br><span class="line">                    *result = loop;</span><br><span class="line">                    *(result+<span class="number">1</span>) = inloop;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>testcase下新建include和src目录<br>src目录下有测试用例文件leetcode_test.cpp<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	<span class="comment">//leetcode_test.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"googletest.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"leetcode_functions.h"</span></span></span><br><span class="line"></span><br><span class="line">TEST(two_sum_test,twoSum001)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> nums[<span class="number">4</span>]=&#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">int</span> numsSize = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span>* result = twoSum(nums,numsSize,target);</span><br><span class="line"></span><br><span class="line">       ASSERT_EQ(<span class="number">0</span>,*result);</span><br><span class="line">       ASSERT_EQ(<span class="number">1</span>,*(result+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>include下有头文件<br>googletest.h<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&quot;gtest/gtest.h&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="编译链接"><a href="#编译链接" class="headerlink" title="编译链接"></a>编译链接</h2><p>测试之前，需要编译并链接我们得项目代码和测试框架。<br>编译<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">g++ -o <span class="number">001</span>_two_sum.o -c ./leetcode/src/<span class="number">001</span>_Two_Sum.c  -I ./leetcode/include/</span><br><span class="line"></span><br><span class="line">g++ -o leetcode_test.o -c ./testcase/src/leetcode_test.cpp -I ./ -I ./leetcode/include/</span><br><span class="line"></span><br><span class="line">   g++ -o TestAll.o -c ./gtest/main/TestAll.cpp -I ./</span><br></pre></td></tr></table></figure></p>
<p>链接<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">g++ -o main *.o -I./include -L./gtest/lib -lgtest -lpthread</span><br></pre></td></tr></table></figure></p>
<p>最后生成main文件。</p>
<h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><p>运行生成的可执行文件main<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">./main</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：</p>
<p>[==========] Running 1 test from 1 test case.<br>[—————] Global test environment set-up.<br>[—————] 1 test from two_sum_test<br>[ RUN      ] two_sum_test.twoSum001<br>numsSize=4<br>[       OK ] two_sum_test.twoSum001 (0 ms)<br>[—————] 1 test from two_sum_test (0 ms total)</p>
<p>[—————] Global test environment tear-down<br>[==========] 1 test from 1 test case ran. (0 ms total)<br>[  PASSED  ] 1 test.</p>
<p>可以看到，共有一个用例，通过了一个用例</p>
<p>项目代码可以在<a href="https://github.com/yanbinghu/TestWithGtest.git" target="_blank" rel="noopener">github下载</a>，节点：f727e04969ffad51a7dba4cd1227772413cbe7f1，<br>由于项目更新，可能与文章中的项目内容已经不一致了，具体使用方法可以查看项目的README文件。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用gtest框架进行单元测试还是比较方便的，有很多可用的测试方法，具体可以查看官网文档，另外它还有打桩功能，它能够完成其他较为复杂的测试功能，我们将在下一篇介绍gmock环境的搭建。</p>
<p>如果觉得测试结果不直观，还可以结合gcov进行代码覆盖率的测试，从测试报告中可以很清晰的看到用例跑到了哪些代码。再后续文章中将会介绍。<br>最后，欢迎交流讨论^_^</p>
]]></content>
      <categories>
        <category>单元测试</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>C</tag>
        <tag>gtest</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言调用脚本后台执行</title>
    <url>/2017/05/17/54928.html</url>
    <content><![CDATA[<h2 id="c语言调用脚本后台执行"><a href="#c语言调用脚本后台执行" class="headerlink" title="c语言调用脚本后台执行"></a>c语言调用脚本后台执行</h2><h4 id="可能实现方法"><a href="#可能实现方法" class="headerlink" title="可能实现方法"></a>可能实现方法</h4><p>c语言如何调用脚本，并让脚本后台执行？<br>c语言调用系统命令主要有三种方式，<br>1.popen(建立管道)<br>2.system()<br>3.使用vfork()新建子进程<br>4.使用at命令，交给系统执行<br><a id="more"></a></p>
<h5 id="1-popen的方式—-不可行"><a href="#1-popen的方式—-不可行" class="headerlink" title="1.popen的方式—-不可行"></a>1.popen的方式—-不可行</h5><p>c代码如下：<br>backExeShell.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//建立管道，并后台执行脚本</span></span><br><span class="line">   FILE *pp = popen(<span class="string">" sh ./backExeShell.sh &amp;"</span>,<span class="string">"r"</span>);</span><br><span class="line">   <span class="keyword">if</span>(!pp)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"pp"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   pclose(pp);</span><br><span class="line">   <span class="comment">//让程序休眠</span></span><br><span class="line">   sleep(<span class="number">10</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"good bye"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>脚本内容<br>backExeShell.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line">echo "shell start!"</span><br><span class="line">sleep 50</span><br><span class="line">echo "finished"</span><br></pre></td></tr></table></figure>
<p>编译代码<br>gcc -g backExeShell.c -o backExeShell<br>执行./backExeShell (注意，脚本和c程序在同一路径)</p>
<p>可以看到c程序暂停，新打开一个终端<br>执行命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef | grep backExeShell</span><br></pre></td></tr></table></figure></p>
<p>可以看到<br>此时脚本正在执行，这时候，终止c程序，再次执行上面的命令，发现，脚本也终止了。</p>
<p>结论：通过管道的方式调用shell脚本，一旦程序退出，脚本也不再执行，因此不能通过管道的方式通过c语言调用后台执行脚本。</p>
<h4 id="system-方式——可行"><a href="#system-方式——可行" class="headerlink" title="system()方式——可行"></a>system()方式——可行</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 system(<span class="string">"sh ./backExeShell.sh &amp;"</span>);</span><br><span class="line">	 sleep(<span class="number">10</span>);</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"good bye"</span>);</span><br><span class="line">	 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c代码如下：<br>backExeShell_1.c</p>
<p>脚本代码与前面一致。</p>
<p>编译，运行.<br>使用ps -ef | grep backExeShell命令查看脚本执行进程<br>发现进程存在，等c程序执行结束后，继续查看脚本执行进程，发现脚本仍然在执行。</p>
<p>结论：通过system方式可调用脚本后台执行。</p>
<p>但是存在一个问题，由于脚本是通过程序调用的，因此脚本会“继承”程序的端口，<br>也就是说，如果程序有使用端口，而通过这种方式，调用脚本后，杀死程序，<br>再次启动程序时，会出现端口占用。</p>
<h4 id="交给系统执行（at-命令）"><a href="#交给系统执行（at-命令）" class="headerlink" title="交给系统执行（at 命令）"></a>交给系统执行（at 命令）</h4><p>使用系统的at命令</p>
<p>例如：at now &lt;&lt;&lt; “./backExeShell”</p>
<p>但是这种方式又存在另外一个问题，因为该脚本是系统执行的，<br>也就是说，不存在任何用户，潜在的问题就是，有些命令如果依赖用户<br>的环境，那么该命令就会执行失败。</p>
<h4 id="结束语："><a href="#结束语：" class="headerlink" title="结束语："></a>结束语：</h4><p>其他方式不做说明，通过system，并且执行脚本时，使用后台启动，即sh ./shell.sh &amp;(甚至可以 nohup ./shell.sh &amp;)的方式可以实现后台启动。<br>(./shell.sh 的方式不可行)</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>C</tag>
        <tag>shell</tag>
        <tag>后台执行脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>github+hexo多终端同步</title>
    <url>/2017/03/31/36088.html</url>
    <content><![CDATA[<h2 id="hexo-github多终端同步管理"><a href="#hexo-github多终端同步管理" class="headerlink" title="hexo+github多终端同步管理"></a>hexo+github多终端同步管理</h2><p>前期用hexo+github搭建了一个个人主页，如果某一天，换了一台电脑，又没有备份，或者说，想用多台电脑来发布文章，要怎么处理呢？<br>本文提供一种多终端都可以发布文章的一种方法。<br><a id="more"></a></p>
<p>说明：部署得博客内容里只包含了生成后的文件，如何更换电脑，我们单是git clone到本地，并不能继续用以发布文章，所以我们需要创建一个仓库，用来存储发布文章用的工程，以便在任何终端都可以clone下来。</p>
<p>在你该电脑已经存在hexo的博客环境前提下，下面是具体操作步骤</p>
<h3 id="1-在github上新建一个仓库-仓库地址为××××-git"><a href="#1-在github上新建一个仓库-仓库地址为××××-git" class="headerlink" title="1.在github上新建一个仓库, 仓库地址为××××.git"></a>1.在github上新建一个仓库, 仓库地址为××××.git</h3><h3 id="2-设置所需要上传到库的关键文件"><a href="#2-设置所需要上传到库的关键文件" class="headerlink" title="2.设置所需要上传到库的关键文件"></a>2.设置所需要上传到库的关键文件</h3><p>修改博客根目录下的.gitignore文件，用来设置哪些文件夹不需要上传到库。<br>例如：我修改后的内容如下：<br><code><br>.DS_Store<br>Thumbs.db<br>db.json<br><em>.log<br>node_modules/<br>public/<br>.deploy</em>/<br>/.deploy_git<br>/public
</code><br>以上文件夹内容在进行hexo g的时候会重新生成，以及日志文件也是不需要的，因此不需要将以上内容上传到库（当然你自己如果需要也是可以留下的）。</p>
<h3 id="3-初始化仓库"><a href="#3-初始化仓库" class="headerlink" title="3.初始化仓库"></a>3.初始化仓库</h3><p>在博客的根目录下，依次执行以下命令：<br><code><br>git init<br>git remote add origin ××××.git
</code></p>
<h3 id="4-将本地内容同步到远程仓库"><a href="#4-将本地内容同步到远程仓库" class="headerlink" title="4.将本地内容同步到远程仓库"></a>4.将本地内容同步到远程仓库</h3><p>在博客根目录下执行以下命令：<br><code><br>git add . #添加目录下的文件<br>git commit -m “update info” #提交更新说明<br>git push -u origin master #推送到远程仓库
</code><br>执行过程中可能需要输入github的账号和密码之类的。<br>执行完成后，本地内容已经备份到远程仓库了。</p>
<h3 id="5-从远程仓库同步到另一个终端"><a href="#5-从远程仓库同步到另一个终端" class="headerlink" title="5.从远程仓库同步到另一个终端"></a>5.从远程仓库同步到另一个终端</h3><p>当然，同步之前，该终端需要搭建node.js,git,hexo等基本环境。接下来就是从远程仓库同步了。<br>进入在该终端创建好的hexo文件夹，执行命令<br><code><br>git init    #初始化本地仓库<br>git remote add origin ××××.git   #添加远程仓库地址<br> git fetch —all   #从远程仓库获取<br> git reset —hard origin/master   #
</code></p>
<p>到此，远程仓库得内容已经同步到该终端了，接下来就可以发表文章了。</p>
<h3 id="6-发布了新文章之后，将新增的内容同步到库上："><a href="#6-发布了新文章之后，将新增的内容同步到库上：" class="headerlink" title="6.发布了新文章之后，将新增的内容同步到库上："></a>6.发布了新文章之后，将新增的内容同步到库上：</h3><p><code><br>git add . #<br>git commit -m “update info”   #提交更新信息<br> git push -u origin master #第一次提交，后面提交可以直接git push
</code></p>
<p>注：在你更新文章之前，先git pull，将远程仓库在其他终端更新的内容同步到该终端，再进行提交。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
        <tag>博客</tag>
        <tag>多终端同步</tag>
      </tags>
  </entry>
  <entry>
    <title>解决ubuntu无法拨号上网的问题</title>
    <url>/2017/03/29/45308.html</url>
    <content><![CDATA[<h3 id="解决ubuntu-通过pppoe方式拨号上网无法连接得问题"><a href="#解决ubuntu-通过pppoe方式拨号上网无法连接得问题" class="headerlink" title="解决ubuntu 通过pppoe方式拨号上网无法连接得问题"></a>解决ubuntu 通过pppoe方式拨号上网无法连接得问题</h3><p>环境：ubuntu 15.10, 电信宽带。<br>上网方式：adsl拨号上网。<br>问题：通过pppoeconf命令配置拨号上网,配置均正确,ifconfig也可以查看到ppp0有ip.浏览器也可以进入192.168.1.1,但是就是无法上网。<br><a id="more"></a><br>解决:切换到root用户，修改interface文件<br>    <code><br>vi /etc/network/interfaces
</code><br>找到其中一行<br><code><br>iface enp0s25 inet manual
</code><br>有该行说明,ip是自动获取的,我们需要修改设置为静态ip，注释掉这一行，然后添加新得内容<br><code><br>iface ppp0 inet static  #静态ip<br> address 10.168.1.74   #根据实际情况填写,注意和网关同网段<br> netmask 255.255.255.0  #子网掩码<br>  geteway 10.168.1.1    #网关
</code><br>添加完成后,保存退出vi。</p>
<p>执行命令:<br><code><br>/etc/init.d/networking restart
</code><br>执行ok后，可ping一下<br> <code><br> ping www.baidu.com
</code><br>不出意外得话可以看到以下内容：<br><code><br>64 bytes from 58.217.200.113: icmp_seq=1 ttl=55 time=25.2 ms</code></p>
<p>&lt;/code&gt;<br>现在可以自由上网了。</p>
<p>注：下次电脑启动后，如果仍然无法联网，可以试着重启网卡。<br><code><br>ifconfig enp0s25 down  #enp0s25为你的网卡名<br>ifconfig enp0s25  up
</code></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>windows实用又干净简洁的电脑安全/管理软件</title>
    <url>/2016/11/13/16100.html</url>
    <content><![CDATA[<p>以下内容满足实用和简洁。</p>
<p>1.杀毒，Windows defender （同时打开防火墙）来源：Windows自带<br><img src="http://i.imgur.com/CVbid8e.png" alt></p>
<a id="more"></a>
<p>2.管理软件，控制面板 来源：Windows自带<br><img src="http://i.imgur.com/nzbr9L9.png" alt></p>
<p>3.清理垃圾，磁盘清理 来源；Windows自带<br><img src="http://i.imgur.com/fWlRIhk.png" alt></p>
<p>4.碎片整理，磁盘碎片整理 开源；Windows自带<br><img src="http://i.imgur.com/LVaD3kU.png" alt></p>
<p>5.自启动项管理 win+R，输入msconfig 来源；Windows自带</p>
<p>6.集软件管理，垃圾清理，启动项管理，注册表清理等功能于一身，且简洁实用，ccleaner 来源：第三方</p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>管理软件</tag>
        <tag>安全软件，简洁</tag>
      </tags>
  </entry>
  <entry>
    <title>利用github page＋hexo搭建个人博客</title>
    <url>/2016/11/13/4800.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>嗯，也不知道是出于什么原因，反正就是搭建了现在的这样一个博客，下面会简单记录一下搭建的过程。以下操作皆基于windows操作平台。</p>
<h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><p>一.配置github仓库</p>
<p>二.搭建环境</p>
<p>三.安装配置hexo</p>
<p>四.hexo配置以及主题配置</p>
<p>五.域名解析</p>
<p>六.常见问题<br><a id="more"></a></p>
<h1 id="一-配置github仓库"><a href="#一-配置github仓库" class="headerlink" title="一.配置github仓库"></a>一.配置github仓库</h1><h2 id="1-注册账号"><a href="#1-注册账号" class="headerlink" title="1.注册账号"></a>1.注册账号</h2><p>首先在<a href="http://github.com" title="github官网" target="_blank" rel="noopener">http://github.com</a>注册账号，这一步不在赘述。</p>
<h2 id="2-创建仓库"><a href="#2-创建仓库" class="headerlink" title="2.创建仓库"></a>2.创建仓库</h2><p>接下来创建一个仓库，进到如下图所示的页面<br><img src="http://i.imgur.com/8eHNByE.png" alt="创建仓库"></p>
<p>其中，repository name一栏填写仓库名，比如，我自己的就是<br>yanbinghu.github.io 注意，这个仓库名一定要是你的昵称+.github.io，否则的话，是不可以利用github创建博客的，每个人只有一个。</p>
<p>把initialize the respository with a README,这样的话你的仓库就有一个master分支了。<br>注意：一定要有master分支，否则 也无法完成博客的搭建。<br>创建好后，过一会就可以访问仓库名.github.io了，访问结果如下：<br><img src="http://i.imgur.com/V5CiTyx.png" alt="访问页面"></p>
<p>因为这个时候还没有部署hexo，所以是没有任何页面可以访问的。</p>
<h2 id="3-配置ssh"><a href="#3-配置ssh" class="headerlink" title="3.配置ssh"></a>3.配置ssh</h2><p>下载<a href="https://desktop.github.com/" title="github客户端" target="_blank" rel="noopener">https://desktop.github.com/</a>，安装好后，登陆你的账号，ssh key就自动添加了。在网页版github页面，点击setting-点击ssh and gpg keys，就可以看到已经有ssh key被添加了。<br><img src="http://i.imgur.com/FNsqco4.png" alt="setting"></p>
<p>当然也可以用命令行的方式添加，简单起见，这里不赘述。<br>判断ssh是否配置好，可在命令行输入：<br>    ssh -T git@github.com<br>看提示就知道成功与否啦</p>
<p>到此github部分已经配置好。</p>
<h1 id="二-搭建环境"><a href="#二-搭建环境" class="headerlink" title="二.搭建环境"></a>二.搭建环境</h1><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>昂，其实安装github客户端的时候，已经安装好了git<br><img src="http://i.imgur.com/MHJNesT.png" alt="git shell"></p>
<h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p>进入<a href="https://nodejs.org/en/" title="node.js官网" target="_blank" rel="noopener">https://nodejs.org/en/</a>，点击下载，普通程序一样安装即可。</p>
<h1 id="三、安装配置hexo"><a href="#三、安装配置hexo" class="headerlink" title="三、安装配置hexo"></a>三、安装配置hexo</h1><h2 id="1-使用npm安装hexo"><a href="#1-使用npm安装hexo" class="headerlink" title="1.使用npm安装hexo"></a>1.使用npm安装hexo</h2><pre><code>npm install -g hexo-cli
</code></pre><h2 id="2-初始化hexo"><a href="#2-初始化hexo" class="headerlink" title="2.初始化hexo"></a>2.初始化hexo</h2><p>在本地新建一个目录，比如hexo，然后cd到该目录下<br>执行下面的命令：<br>    hexo init<br>    npm install<br>没有什么明显错误就表示安装成功。</p>
<h2 id="3-启动服务器，进行预览"><a href="#3-启动服务器，进行预览" class="headerlink" title="3.启动服务器，进行预览"></a>3.启动服务器，进行预览</h2><pre><code>hexo server
</code></pre><p>可以看到<br><img src="http://i.imgur.com/uYjAwwA.png" alt="启动服务"></p>
<p>打开浏览器，访问<a href="localhost:4000" title="localhost:4000" target="_blank" rel="noopener">localhost:4000</a>.<br>这个时候就可以看到博客已经基本设置好啦（下图是我配置好之后的）<br><img src="http://i.imgur.com/LNOxbWt.png" alt="首页"></p>
<h2 id="4-hexo常用几个命令"><a href="#4-hexo常用几个命令" class="headerlink" title="4.hexo常用几个命令"></a>4.hexo常用几个命令</h2><pre><code>hexo clean #清除生成好的
hexo g     #生成
hexo d     #部署
hexo s     #启动本地服务
</code></pre><p>更多命令，请前往<a href="https://hexo.io/zh-cn/" title="hexo官网" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></p>
<h1 id="四-hexo配置以及主题配置"><a href="#四-hexo配置以及主题配置" class="headerlink" title="四.hexo配置以及主题配置"></a>四.hexo配置以及主题配置</h1><h2 id="1-hexo初步配置"><a href="#1-hexo初步配置" class="headerlink" title="1.hexo初步配置"></a>1.hexo初步配置</h2><p>打开hexo里博客目录下的_config.yml文件，找到如下位置</p>
<pre><code># Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:
type: git
repository: https://github.com/yanbinghu/yanbinghu.github.io.git
branch: master  
</code></pre><p>将昵称换成你自己的，其他的像上面一样设置即可。<br>在命令行输入<br>    hexo g<br>然后：<br>    hexo d<br>过一会，就将博客部署好了，访问以下你的地址，比如我的是yanbinghu.github.io，可以看到，博客已经部署好了。</p>
<p>当然你也可以通过另外一种方式：<br>将hexo目录下的public目录下的所有文件拷贝到yanbinghu.github.io项目clone的本地地址，然后再github客户端进行提交，也是可以的。</p>
<h2 id="2-配置hexo"><a href="#2-配置hexo" class="headerlink" title="2.配置hexo"></a>2.配置hexo</h2><p>虽然已经部署好了，但是你会发现博客标题，内容等东西依然是原始的，我们还需要进一步配置。我个人的配置文件如下，仅供参考：</p>
<pre><code># Hexo Configuration
## Docs: https://hexo.io/docs/configuration.html
## Source: https://github.com/hexojs/hexo/

# Site
title: Yanbing&#39;s blog  #博客标题
subtitle: a little coder&#39;s blog#博客子标题
description: a blog for huyanbing#描述
author: Yanbing #作者名称
language: zh-CN#语言
timezone:   #时区

# URL  
## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;
url: 
root: /
permalink: :year/:month/:day/:title/
permalink_defaults:

# Directory
source_dir: source
public_dir: public
tag_dir: tags
archive_dir: archives #归档目录
about_dir: about
category_dir: categories #分类目录
code_dir: downloads/code
i18n_dir: :lang
skip_render:

# Writing
new_post_name: :title.md # File name of new posts
default_layout: post
titlecase: false # Transform title into titlecase
external_link: true # Open external links in new tab
filename_case: 0
render_drafts: false
post_asset_folder: false
relative_link: false
future: true
highlight:
  enable: true
  line_number: true
  auto_detect: false
  tab_replace:

# Category &amp; Tag
default_category: uncategorized
category_map:
tag_map:

# Date / Time format
## Hexo uses Moment.js to parse and display date
## You can customize the date format as defined in
## http://momentjs.com/docs/#/displaying/format/
date_format: YYYY-MM-DD
time_format: HH:mm:ss

# Pagination
## Set per_page to 0 to disable pagination
per_page: 10
pagination_dir: page

# Extensions
## Plugins: https://hexo.io/plugins/
## Themes: https://hexo.io/themes/
theme: next  #主题，我用的是next主题

# Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:
  type: git
  repository: https://github.com/yanbinghu/yanbinghu.github.io.git
  branch: master

search:               #配置的站内搜索
  path: search.xml
  field: post
  format: html
  limit: 10000
</code></pre><h2 id="3-主题配置"><a href="#3-主题配置" class="headerlink" title="3.主题配置"></a>3.主题配置</h2><p>以next主题为例<br>github地址：<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/getting-started.html</a><br>clone或者下载解压到theme目录下后，修改主配置文件的theme为next<br>这里有很详细的配置部署，在此也不再赘述.</p>
<p>改好配置后，再清除，生成，部署，新的主题就好了。</p>
<h1 id="五-域名解析"><a href="#五-域名解析" class="headerlink" title="五.域名解析"></a>五.域名解析</h1><h2 id="1-在你申请的域名里添加一条CNAME记录如下："><a href="#1-在你申请的域名里添加一条CNAME记录如下：" class="headerlink" title="1.在你申请的域名里添加一条CNAME记录如下："></a>1.在你申请的域名里添加一条CNAME记录如下：</h2><p><img src="http://i.imgur.com/ItsrFF5.png" alt="cname"><br>你可以用www,也可以用子域名</p>
<h2 id="2-在你的项目目录下新建一个CNAME文件，文件内容为你映射的域名"><a href="#2-在你的项目目录下新建一个CNAME文件，文件内容为你映射的域名" class="headerlink" title="2.在你的项目目录下新建一个CNAME文件，文件内容为你映射的域名"></a>2.在你的项目目录下新建一个CNAME文件，文件内容为你映射的域名</h2><p><img src="http://i.imgur.com/fm7Rt1k.png" alt="cname映射"><br>好了，大功告成，可以用自己的域名访问了。</p>
<h1 id="六-常见问题"><a href="#六-常见问题" class="headerlink" title="六.常见问题"></a>六.常见问题</h1><h2 id="1-创建好仓库后，无法访问github-io页面"><a href="#1-创建好仓库后，无法访问github-io页面" class="headerlink" title="1.创建好仓库后，无法访问github.io页面"></a>1.创建好仓库后，无法访问github.io页面</h2><p>   原因：没有master分支<br>   解决：在仓库里创建一个文件，或者在本地创建文件后进行提交，总之达到有master分支的目的。</p>
<h2 id="2-虽然在配置文件里有分类，标签等新加的目录，但是点击访问却没有页面"><a href="#2-虽然在配置文件里有分类，标签等新加的目录，但是点击访问却没有页面" class="headerlink" title="2.虽然在配置文件里有分类，标签等新加的目录，但是点击访问却没有页面"></a>2.虽然在配置文件里有分类，标签等新加的目录，但是点击访问却没有页面</h2><p>   原因：source目录下没有相应文件<br>   解决：在博客的source目录下，新建相应目录，比如如下：<br><img src="http://i.imgur.com/l8BM9Tc.png" alt="目录"></p>
<p>新建的目录下再新建index.md文件，内容相似，可参考如下：</p>
<pre><code>---
title: categories
date: 2016-11-14 00:12:10
type: &quot;categories&quot;

---
</code></pre><h2 id="3-next主题本地能够预览，但是一旦部署到服务器，就一片空白"><a href="#3-next主题本地能够预览，但是一旦部署到服务器，就一片空白" class="headerlink" title="3.next主题本地能够预览，但是一旦部署到服务器，就一片空白"></a>3.next主题本地能够预览，但是一旦部署到服务器，就一片空白</h2><p>   原因：js库使用问题<br>   解决：打开next主题的配置文件_config.yml，找到配置js的位置，并配置成以下内容：<br>    vendors:</p>
<pre><code>  # Internal path prefix. Please do not edit it.
  _internal: vendors

  # Internal version: 2.1.3
  jquery: //cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js

  # Internal version: 2.1.5
  # http://fancyapps.com/fancybox/
  fancybox: //cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js
  fancybox_css: //cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.min.css

  # Internal version: 1.0.6
  # https://github.com/ftlabs/fastclick
  fastclick: //cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js

  # Internal version: 1.9.7
  # https://github.com/tuupola/jquery_lazyload
  lazyload: //cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js

  # Internal version: 1.2.1
  # http://VelocityJS.org
  velocity: //cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js

  # Internal version: 1.2.1
  # http://VelocityJS.org
  velocity_ui: //cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js

  # Internal version: 0.7.9
  # https://faisalman.github.io/ua-parser-js/
  ua_parser: //cdn.jsdelivr.net/ua-parser.js/0.7.10/ua-parser.min.js

  # Internal version: 4.4.0
  # http://fontawesome.io/
  fontawesome: //maxcdn.bootstrapcdn.com/font-awesome/4.6.2/css/font-awesome.min.css
</code></pre><h2 id="4-如何新建文章？"><a href="#4-如何新建文章？" class="headerlink" title="4.如何新建文章？"></a>4.如何新建文章？</h2><p>  解决：在_post目录下新建.md文件，文章内容按照<a href="http://wowubuntu.com/markdown/" title="markdown语法说明（简体中文版）" target="_blank" rel="noopener">http://wowubuntu.com/markdown/</a>编写<br>  写好后，重新生成，部署。</p>
<h2 id="5-在修改配置文件之后，会提示类似以下的错误"><a href="#5-在修改配置文件之后，会提示类似以下的错误" class="headerlink" title="5.在修改配置文件之后，会提示类似以下的错误"></a>5.在修改配置文件之后，会提示类似以下的错误</h2><p><img src="http://i.imgur.com/S8unL5b.png" alt="error"><br>原因：配置文件格式不对<br>解决：查看你配置项的冒号后是否有空格，每一项配置，冒号后都需要带空格<br>另外，并列的配置，需要对齐</p>
<h2 id="6-gitalt或者gitment无法登录或初始化"><a href="#6-gitalt或者gitment无法登录或初始化" class="headerlink" title="6.gitalt或者gitment无法登录或初始化"></a>6.gitalt或者gitment无法登录或初始化</h2><p>查看控制台日志，出现了类似gitment GET <a href="https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif?l=https://www.huyanbing.me/?error=redirect_uri_mismatch&amp;error_description=The+redirect_uri+MUST+match+the+registered+callback+URL+for+this+application.&amp;error_uri=https%3A%2F%2Fdeveloper.github.com%2Fapps%2Fmanaging-oauth-apps%2Ftroubleshooting-authorization-request-errors%2F%23redirect-uri-mismatch" target="_blank" rel="noopener">https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif?l=https://www.huyanbing.me/?error=redirect_uri_mismatch&amp;error_description=The+redirect_uri+MUST+match+the+registered+callback+URL+for+this+application.&amp;error_uri=https%3A%2F%2Fdeveloper.github.com%2Fapps%2Fmanaging-oauth-apps%2Ftroubleshooting-authorization-request-errors%2F%23redirect-uri-mismatch</a> net::ERR_BLOCKED_BY_CLIENT<br>或者<a href="https://api.github.com/user" target="_blank" rel="noopener">https://api.github.com/user</a> 401 (Unauthorized) 的情况</p>
<p>原因：github pages与gitalk comment的访问方式不一致。<br>解决：如果github pages强制https访问了，那么Authorization callback URL也要设置成https的访问地址</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>因为教程是在搭建完成之后写得，内容难免有疏漏或不妥之处，<br>有任何建议或疑问，欢迎在评论中提出^_^！</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
        <tag>github page</tag>
      </tags>
  </entry>
</search>
